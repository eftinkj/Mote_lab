/****************************************************************************
**
** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
**
** This file is part of the documentation of the UMR Mote Toolkit.
**
** This file may be used under the terms of the GNU General Public
** License version 2.0 as published by the Free Software Foundation
** and appearing in the file LICENSE.GPL included in the packaging of
** this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

#include "defs/esnl_pub.h"

#include "common.h"
#include "Application.h"
#include "FEAT_Queuing/Queuing.h"
#include "HW_LIB/RTC.h"
//#include "HW_LIB/adc_0.h"
//#include "HW_LIB/new_adc_0_pub.h"
#include "packet.h"
#include "FEAT_Scheduler/sch_basic_pub.h"

#include "FEAT_Routing/routing.h"
#ifdef _ENABLE_OEDSR_
	#include "FEAT_Routing/routing_OEDSR.h"
#endif
#ifdef _ARM_
	#include "FEAT_STM32W/STM32W_Radio.h"
#endif // _ARM_
#include "FEAT_Networking/Phy_layer.h"
#include "FEAT_XBee_API/AT_scripts.h"

//#define FEAT_XBee_API
#ifdef _ENABLE_APP_MOD_


#ifdef FEAT_ENABLE_CC
#include "congestionControl.h"
#endif


unsigned char XDATA app_tx_data_mode_ = APP_DEFAULT_TX_DATA_MODE;
//bit app_send_data = 0;
uint8_t app_generate_pkt_ = 0;
unsigned char XDATA n_samples_per_packet_ = SAMPLES_PER_PACKET;	// samples per packet
unsigned char XDATA last_config_rssi_rcv_;

unsigned int XDATA app_count_drop_pkts_;	// Dropped packets
unsigned int XDATA app_count_lost_pkts_;	// Lost during TX packets
unsigned int XDATA app_count_sent_pkts_;	// Sent out succesfully
unsigned int XDATA app_count_recv_pkts_;	// Received from other nodes
unsigned int XDATA app_count_gen_pkts_;	// Generated by this node

unsigned int XDATA app_beam_count_; // Count received beams
unsigned int XDATA app_beacon_count_;	// Received beacon messages

rtc_tick_t XDATA app_last_BS_contact_;
uint8_t app_repeat_beam;
uint16_t XDATA app_beam_seq;

/**
  * app_init() - resets app counters and variables
  */
void app_init()
{
	app_count_drop_pkts_ = 0;	// Dropped packets
	app_count_lost_pkts_ = 0;	// Lost during TX packets
	app_count_sent_pkts_ = 0;	// Sent out succesfully
	app_count_recv_pkts_ = 0;	// Received from other nodes
	app_count_gen_pkts_ = 0;	// Generated by this node
	app_beam_count_ 	= 0;	// Received beam messages
	app_beacon_count_ 	= 0;	// Received beacon messages

	app_last_BS_contact_ = 0;
	app_repeat_beam = BEAM_REPEAT_DEFAULT_ACTION;
	app_beam_seq = 0xFFFF; // first time always repeat and syncronize with BS

	// Disable data generation
//	app_send_data = 0;
	app_generate_pkt_ = 0;
	// reset counter
	sequence_no_ = 1;

	app_tx_data_mode_ = 3;//APP_DEFAULT_TX_DATA_MODE;
	n_samples_per_packet_ = SAMPLES_PER_PACKET;

#if defined (_ENABLE_ADC_MODULE_) //|| defined (_ENABLE_NEW_ADC_MODULE_)
	app_suspendADC();
#endif // _ENABLE_ADC_MODULE_

	sch_add_loop((sch_loop_func_t)app_loop);
}




/**
 *  app_loop() - executes main loop block (BUT DOES NOT LOOP ITSELF!!!)
 */
void app_loop( void )
{
#ifdef _ENABLE_APP_MOD_
		switch ( network_search_mode_ )
		{
			case SEARCH_OFF:
				break;
			case SEARCH_BEACON_BS_SWITCHING:
				// Do nothing since the BS is switching
				break;
			case SEARCH_BEACON_NODE_SWITCHING:
				// Switch to a new channel
				if ( rtc_get_ticks() > switch_timeout_ )
				{
					app_search_switch_channel();
				}
				break;
			case SEARCH_OEDSR_HELLO:
				if ( rtc_get_ticks() > switch_timeout_ )
				{
					app_search_switch_channel();
				}
				break;
			default:
				// ERROR
				break;
		}
#endif // _ENABLE_APP_MOD_

}



void app_recvStopData ( pkt_t *p )
{
#ifdef SOURCE
	// stop data transmission
	if ( ( 0xFFFF == p->mac_dst ) || ( MY_ADDR == p->mac_dst ) )
	{
//		app_send_data = 0;
		app_generate_pkt_ = 0;
		// reset counter
		sequence_no_ = 1;
#if defined (_ENABLE_ADC_MODULE_) //|| defined (_ENABLE_NEW_ADC_MODULE_)
		app_suspendADC();
#endif // _ENABLE_ADC_MODULE_
	}
#endif
#if defined(_ENABLE_SRC_DUMMY_) || defined (_ENABLE_SSN_8BIT_)
	ssn_stop_burst();
#endif // _ENABLE_SRC_DUMMY_
}



void app_recvStartData ( pkt_t *p )
{
#ifdef SOURCE
#if defined (_ENABLE_ADC_MODULE_) //|| defined (_ENABLE_NEW_ADC_MODULE_)
	// start data transmission
	if ( ( 0xFFFF == p->mac_dst ) || ( MY_ADDR == p->mac_dst ) )
	{
//		app_send_data = 1;
		app_generate_pkt_ = 1;
		// reset counter
		sequence_no_ = 1;
		app_resumeADC();
	}
#endif // #if defined (_ENABLE_ADC_MODULE_) || defined (_ENABLE_NEW_ADC_MODULE_)

#if defined(_ENABLE_SRC_DUMMY_) || defined (_ENABLE_SSN_8BIT_)
	ssn_start_burst(10000);
#endif // _ENABLE_SRC_DUMMY_
	
#endif
}

//#define MAX_CONFIG_PKT_SIZE 50


void app_sendConfigSensor()
{
//	uint8_t XDATA temp[MAX_CONFIG_PKT_SIZE];
	uint8_t XDATA temp[CONFIG_LEN];
	conpkt_t XDATA *pkt = (conpkt_t XDATA*)temp;
	//Refill the packet and send out the response
	pkt->start = START_BYTE;
	pkt->flags = FLAG_CONFIG_RESP;
	pkt->mac_dst = BS_ADDR;
	pkt->mac_src = MY_ADDR;
	pkt->length = 28;
	pkt->dst_id = BS_ADDR;
	pkt->src_id = MY_ADDR;


	//Section for Sampling Settings
	pkt->data_mode = app_tx_data_mode_;
#ifdef _ENABLE_ADC_MODULE_
	pkt->divider = adc_sample_rate_divider_;
	pkt->averager = adc_sample_averaging_;
	pkt->data_size = n_samples_per_packet_;
	pkt->num_adc_chan = number_of_channels_;
#else	// _ENABLE_ADC_MODULE_
	pkt->divider = 0xFF;
	pkt->averager = 0xFF;
	pkt->data_size = n_samples_per_packet_;
	pkt->num_adc_chan = 0x00;
#endif // else _ENABLE_ADC_MODULE_
	//Section for RF Settings
	pkt->current_RF_chan = my_rf_channel_;
	pkt->power_control_scheme = 0x00; //Hardcoded for future use, currenly no controller online
	pkt->power_level = my_tx_power_;
	pkt->RSSI_thresh = my_rssi_threshold_;

	//Settings for OEDSR
	pkt->distance = my_distance_;
	pkt->energy = my_energy_;
	pkt->RF_TX_retries = my_RF_retries_;

	//Settings for Protocol Selection
	pkt->protocol = my_protocol_;
	pkt->scheduling_protocol = my_scheduling_;

	//Section for Scheduling Settings
	pkt->src_weight = 0;//my_source_weight_;
	pkt->node_weight = 0;//my_weight_;

	//Clustering Settings
	pkt->current_CH = my_CH_;

	//For Recieved Config packet RSSI Feedback
	pkt->rssi = last_config_rssi_rcv_;

	//Place Stop Byte
	pkt->crc = STOP_BYTE;

	phy_set_power_level ( MAX_POWER_LEVEL );
#ifdef _ENABLE_XBEE_API_
	api_send_packet16 ( (char *)temp, CONFIG_LEN, BS_ADDR );
#endif // _ENABLE_XBEE_API_
	phy_set_power_level ( my_tx_power_ );

}

void app_recvConfigSensor ( pkt_t *p , unsigned char rssi )
{
//#ifdef SOURCE
#ifdef _ARM_
//	return; // Causes node to become disabled
//uint16_t temp_rate=500;
#endif // _ARM_
	//unsigned char offset = 0;
	uint32_t offset = 0;
	config_generic_t *cfg_gen = ( config_generic_t * ) ( ( ( char* ) p ) + ISN_APP_NEW_CONFIG_OFFSET_FROM_CUSTOM_HEADER );
	unsigned char flag = cfg_gen->config_flag;

	while ( ISN_APP_CONFIG_FLAG_END != flag )
	{
		switch ( flag )
		{
			case ISN_APP_CONFIG_FLAG_SAMPLING:
				{
					//config_sampling_t *cp = ( config_sampling_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_SAMPLING;
					// transmission mode
#if defined(_ARM_) && defined(_ENABLE_SRC_DUMMY_)
					temp_rate = 10000/(cp->adc_sample_rate_divider * cp->adc_sample_averaging);
					if (1>temp_rate) temp_rate=1;
					if (1000<temp_rate) temp_rate=1000;
					src_set_rate(temp_rate);
#else // _ARM_
#ifdef _ENABLE_ADC_MODULE_
					app_tx_data_mode_ = cp->tx_data_mode;
					// samples rate divider
					adc_sample_rate_divider_ = cp->adc_sample_rate_divider;
					// sample averaging over "N"
					adc_sample_averaging_ = cp->adc_sample_averaging;
					// No. of samples per packet
					// use max of dictated number and max SAMPLES PER PACKET
					if ( cp->n_samples_per_packet > SAMPLES_PER_PACKET )
					{
						n_samples_per_packet_ = SAMPLES_PER_PACKET;
					}
					else
					{
						n_samples_per_packet_ = cp->n_samples_per_packet;
					}
					set_number_of_channels ( cp->num_of_channels );
#endif // _ENABLE_ADC_MODULE_
#if defined (_ENABLE_NEW_ADC_MODULE_)
					app_tx_data_mode_ = cp->tx_data_mode;
					// samples rate divider
					adc_set_rate_divider(cp->adc_sample_rate_divider);
					// No. of samples per packet
					// use max of dictated number and max SAMPLES PER PACKET
					if ( cp->n_samples_per_packet > SAMPLES_PER_PACKET )
					{
						n_samples_per_packet_ = SAMPLES_PER_PACKET;
					}
					else
					{
						n_samples_per_packet_ = cp->n_samples_per_packet;
					}	
#endif // defined (_ENABLE_NEW_ADC_MODULE_)
#endif // else _ARM_
				}
				break;
			case ISN_APP_CONFIG_FLAG_SAMPLING_MAP:
				{
#ifdef _ENABLE_ADC_MODULE_
					config_sampling_map_t *cp = ( config_sampling_map_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_SAMPLING_MAP + cp->num_of_channels;
					// sets number of channels for ADC
					set_number_of_channels ( cp->num_of_channels );
#endif // _ENABLE_ADC_MODULE_
				}
				break;
			case ISN_APP_CONFIG_FLAG_RF:
				{
					config_rf_t *cp = ( config_rf_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_RF;
					// radio channel to be used (0 - 0xB, 1 - 0xC, ... 15 - 0x1A)
					phy_set_RF_channel ( cp->channel );
					// power control scheme
					// cp->power_control_scheme;
					// default TX power level to be used
#ifndef _ARM_
					my_tx_power_ = cp->default_power_level;
					phy_set_power_level ( cp->default_power_level );  //This line is error, see the phy_set_power_level for explanation
#endif // not _ARM_
					// set RSSI threshold for accepting incomming packets
					my_rssi_threshold_ = cp->rssi_threshold;

				}

				break;
			case ISN_APP_CONFIG_FLAG_OEDSR:
				{
					config_oedsr_t *cp = ( config_oedsr_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_OEDSR;
					// Set distance to BS
					my_distance_ = cp->distance;
					// Set battery energy
					if (ENERGY_IGNORE_VALUE != cp->energy)
					{
						my_energy_ = cp->energy;
					}
					// number of RF retries
					if ( NO_CHANGE_RF_RETRIES != cp->rf_retries )
					{
						my_RF_retries_ = cp->rf_retries;
#ifdef _ENABLE_XBEE_API_
						api_send_at ( "RR", ( char* ) &my_RF_retries_, 1 );
#endif // _ENABLE_XBEE_API_
					}
				}
				break;
			case ISN_APP_CONFIG_FLAG_MMCR:
				{
					config_mmcr_t *cp = ( config_mmcr_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_MMCR;
					
					// Set battery energy
					if (ENERGY_IGNORE_VALUE != cp->energy)
					{
						my_energy_ = cp->energy;
					}
					// number of RF retries
					if ( NO_CHANGE_RF_RETRIES != cp->rf_retries )
					{
						my_RF_retries_ = cp->rf_retries;
#ifdef _ENABLE_XBEE_API_
						api_send_at ( "RR", ( char* ) &my_RF_retries_, 1 );
#endif // _ENABLE_XBEE_API_
					}
				}
				break;
			case ISN_APP_CONFIG_FLAG_PROTOCOLS:
				{
					//config_protocols_t *cp = ( config_protocols_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_PROTOCOLS;
#ifndef _ARM_
					my_protocol_ = cp->routing;
					// = cp->scheduling;
					//Select the Correct Protocols that are availible
					routing_set_routing_protocol(); // my_protocol_ has correct value
					//Select the Correct Protocols that are availible
					switch ( cp->scheduling )
					{
							// Default (droptail + no_backoff)
						case PROTOCOL_SCHEDULING_NONE:
							my_scheduling_ = cp->scheduling;
							phy_change_backoff ( PHY_BACKOFF_DISABLE );
							que_switch_protocol ( QUEUE_DROPTAIL );
							break;
#ifdef FEAT_ENABLE_SFQ
						// ADFS (sfq) + no_backoff
						case PROTOCOL_SCHEDULING_ADFS:
							my_scheduling_ = cp->scheduling;
							phy_change_backoff ( PHY_BACKOFF_DISABLE );
							que_switch_protocol ( QUEUE_SFQ );
							Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
							break;
#endif // FEAT_ENABLE_SFQ

#ifdef FEAT_ENABLE_SFQ
						// DFS (sfq) + no_backoff
						case PROTOCOL_SCHEDULING_DFS:
							my_scheduling_ = cp->scheduling;
							phy_change_backoff (PHY_BACKOFF_DISABLE);
							que_switch_protocol(QUEUE_SFQ);
							// MZ_DFS begin
							Q_SFQ_set_version(SFQ_FIXED_WEIGHT_DFS);
							//OR!!!!!!!!!!!!!1111
							//Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
							// MZ_DFS end							
							
							break;
#endif // FEAT_ENABLE_SFQ

						// DROPTAIL (fifo) + BACKOFF
						case PROTOCOL_SCHEDULING_NONE_BO:
							my_scheduling_ = cp->scheduling;
							que_switch_protocol(QUEUE_DROPTAIL);
							phy_change_backoff (PHY_BACKOFF_EXPONENTIAL);
							break;
#ifdef FEAT_ENABLE_SFQ
							// ADFS with wieghted BACKOFF
						case PROTOCOL_SCHEDULING_ADFS_BO:
							my_scheduling_ = cp->scheduling;
							phy_change_backoff (PHY_BACKOFF_ADFS);
							que_switch_protocol(QUEUE_SFQ);
							// MZ_DFS begin
							//Q_SFQ_set_version(SFQ_FIXED_WEIGHT_DFS);
							//OR!!!!!!!!!!!!!1111
							Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
							// MZ_DFS end
							break;
#endif // FEAT_ENABLE_SFQ


#ifdef FEAT_ENABLE_SFQ
						// DFS with wieghted BACKOFF
						case PROTOCOL_SCHEDULING_DFS_BO:
							my_scheduling_ = cp->scheduling;
							phy_change_backoff (PHY_BACKOFF_ADFS);
							que_switch_protocol(QUEUE_SFQ);
							// MZ_DFS begin
							Q_SFQ_set_version(SFQ_FIXED_WEIGHT_DFS);
							//OR!!!!!!!!!!!!!1111
							//Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
							// MZ_DFS end
							break;
#endif // FEAT_ENABLE_SFQ


						// Default (droptail + no_backoff)
						default:
							my_scheduling_ = PROTOCOL_SCHEDULING_NONE;
							phy_change_backoff ( PHY_BACKOFF_DISABLE );
							// set Queuing scheme
							que_switch_protocol ( QUEUE_DROPTAIL );
					}
#endif // not _ARM_
				}
				break;
#ifdef ENABLE_ADFS
			case ISN_APP_CONFIG_FLAG_SCHEDULING:
				{
					config_scheduling_t *cp = ( config_scheduling_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_SCHEDULING;
					// Set distance to BS
					if ( SCHEDULING_WEIGHT_NO_CHANGE != cp->source_weight )
					{
						my_source_weight_ = cp->source_weight;
					}
					// Set battery energy
					if ( SCHEDULING_WEIGHT_NO_CHANGE != cp->node_weight )
					{
						my_weight_ = cp->node_weight;
					}
				}
#ifdef FEAT_ENABLE_SFQ
						Q_SFQ_set_weights (my_weight_, my_source_weight_);
#endif // FEAT_ENABLE_SFQ
				break;
#endif // ENABLE_ADFS
			case ISN_APP_CONFIG_FLAG_CLUSTERING:
				{
					config_clustering_t *cp = ( config_clustering_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
					offset = ISN_APP_CONFIG_LEN_CLUSTERING;
					// Cluster Head id
					if ( CLUSTERING_I_AM_CH == cp->CH )
					{
						// SET MYSELF AS CLUSTER HEAD
						// ?????
						my_CH_ = cp->CH;
					}
					else if ( CLUSTERING_NO_CHANGE != cp->CH )
					{
						// THE CHANGE of CH WAS REQUESTED
						my_CH_ = cp->CH;
						// TODO:
						// cluster_join( my_CH_ );
					}
				}

				break;

			default:
				return; // exit if the FLAG is unknown (possibly incorrect config packet)
				break;
		}
		// move the header to next option (or end of packet)
		cfg_gen = ( config_generic_t * ) ( ( ( char* ) cfg_gen ) + offset );
		offset = 0;
		flag = cfg_gen->config_flag;
	}

	//Update the Last RSSI recieved for a config
	last_config_rssi_rcv_ = rssi;
	// report what you have changed
//	app_sendConfigSensor();
//#endif
}





void app_recvBEAM ( sint8_t *pkt )
{
	bpkt_t *beam = ( bpkt_t * ) pkt;
	// Set time only once to avoid "backward time travels"
//	if (0 == app_beam_count_)
	{
		rtc_time_set ( beam->hour, beam->minute, beam->second, ENDIAN16(beam->msecond) );
	}
	if (1 == app_repeat_beam)
	{
		uint16_t bseq = beam->seq;
		if (app_beam_seq >= beam->seq) bseq+=256;
		if (app_beam_seq+APP_BEAM_WINDOW > bseq)
		{
			app_beam_seq = beam->seq;
			beam->mac_src = ENDIAN16((uint16_t)MY_ADDR);
			beam->hops_from_bs++;
#ifdef _ARM_
			sendPriorityPacket( BEAM_PACKET_LENGTH, (sint8_t*)pkt, MAC_BROADCAST);
#else // _ARM_
			api_send_packet16 ( pkt, BEAM_PACKET_LENGTH, MAC_BROADCAST);
#endif // else _ARM)
		}
	}
	app_last_BS_contact_ = rtc_get_ticks();
	app_beam_count_++;
}



#if defined (_ENABLE_ADC_MODULE_) || defined (_ENABLE_NEW_ADC_MODULE_)

void app_suspendADC()
{
#ifndef _ARM_
#ifdef _SFRPAGE_EXIST_
	SFRPAGE   = TMR2_PAGE;
#endif // _SFRPAGE_EXIST_
	//	TMR2CN = 0x05; // bit 2 - timer enable; bit 0 - capture mode
	TMR2CN &= 0xFB;//~0x04; // bit 2 - timer disabled(=0); bit 0 - capture mode
#else // _ARM_
        // stop ADC reading
#endif // _ARM_
}

void app_resumeADC()
{
#ifndef _ARM_
#ifdef _SFRPAGE_EXIST_
	SFRPAGE   = TMR2_PAGE;
#endif // _SFRPAGE_EXIST_
	TMR2CN |= 0x04; // bit 2 - timer enable; bit 0 - capture mode
	//	TMR2CN = 0x01; // bit 2 - timer disabled(=0); bit 0 - capture mode
#else // _ARM_
        // stop ADC reading
#endif // _ARM_
}


#endif // #if defined (_ENABLE_ADC_MODULE_) || defined (_ENABLE_NEW_ADC_MODULE_)



///////////////////////////////////////////////

void NodeConfigure ( char *p )
{
	unsigned char temp_power;
	conpkt_t *pkt = ( conpkt_t * ) p;
	//conpkt_t *pkt2 = ;

	//Assign the Global Variables to the Correct Variables
	my_energy_ = ENDIAN32(pkt->energy);
	my_distance_ = ENDIAN32(pkt->distance);
	my_protocol_ = pkt->protocol;
	my_rssi_threshold_ = pkt->rssi;

	phy_set_power_level ( pkt->power_level );

	//my_cost_fun_=pkt->cost_function;
	/*
		if (13 < pkt->length)
		{
			//unsigned char data_mode;
			adc_sample_rate_divider_ = pkt->divider;
			// Averaging samples over N readings
			adc_sample_averaging_ = pkt->averager;
			if ( pkt->data_size > SAMPLES_PER_PACKET )
			{
				n_samples_per_packet_ = SAMPLES_PER_PACKET;
			}
			else
			{
				n_samples_per_packet_ = pkt->data_size;
			}
		}
	*/

	//Select the Correct Protocols that are availible
	routing_set_routing_protocol(); // my_protocol_ has correct value


	//Refill the packet and send out the response
	pkt->start = START_BYTE;
	pkt->flags = FLAG_CONFIG_RESP;
	pkt->mac_dst = ENDIAN16(BS_ADDR);
	pkt->mac_src = ENDIAN16(MY_ADDR);
	//pkt->dst_id=BS_ADDR;
	//pkt->src_id=MY_ADDR;
	pkt->length = 17;
	pkt->protocol = my_protocol_;
	pkt->distance = ENDIAN32(my_distance_);
	pkt->energy = ENDIAN32(my_energy_);
	pkt->crc = STOP_BYTE;

	temp_power = my_tx_power_;
	phy_set_power_level ( MAX_POWER_LEVEL );
#ifdef _ARM_
	sendPriorityPacket( CONFIG_LEN, p, BS_ADDR);
#else // _ARM_
	#ifdef _ENABLE_XBEE_API_
		api_send_packet16 ( p, CONFIG_LEN, BS_ADDR );
	#endif // _ENABLE_XBEE_API_
#endif // else _ARM)
	phy_set_power_level ( temp_power );

}
///////////////////////////////////////////////


///////////////////////////////////////////////
void disable_node ( unsigned char address )
{
	gbpkt_t *gby = ( gbpkt_t * ) packet;
	//int result; // length of received result string
	//unsigned int uint_value = 0;
//	float f = 0.222;

//Set the Node Address
	//uint_value = address;

	if ( 1 == energy_depleted_control_ )
	{
		return;
	}


	//Assemble Routing Type Packet with the RREQ Flag
	gby->start = START_BYTE;
	gby->flags = FLAG_GOODBYE;
	gby->mac_dst = ENDIAN16(BS_ADDR); //MAC_BROADCAST;
	gby->mac_src = ENDIAN16(MY_ADDR);
	gby->crc = STOP_BYTE;
#ifdef _ARM_
	sendPriorityPacket(GOODBYE_LEN, packet, ENDIAN16(gby->mac_dst) );
#else // _ARM_
	#ifdef _ENABLE_XBEE_API_
		api_send_packet16 ( ( char* ) packet, GOODBYE_LEN, gby->mac_dst );
	#endif // _ENABLE_XBEE_API_
#endif // _ARM_
#ifdef FEAT_ENABLE_AODV
	if ( AODVcounter_update )
	{
		RREQ_counter++;
	}
	my_energy_ = my_energy_ -GOODBYE_LEN;
#endif // FEAT_ENABLE_AODV

#ifdef _ENABLE_XBEE_API_
	api_send_at ( "MY", ( char* ) &uint_value, 2 );
	for ( result = 0; result < 100; result++ )
	{
		f = 1.0 / f;
	}
#endif // _ENABLE_XBEE_API_
	energy_depleted_control_ = 1;
}
///////////////////////////////////////////////
///////////////////////////////////////////////
void enable_node ( char *p )
{
	enpkt_t *pkt = ( enpkt_t * ) p;


	//int result; // length of received result string
	unsigned int uint_value;
	//float f = 0.222;
//Set the Node Address
	uint_value = MY_ADDR;
#ifdef _ENABLE_XBEE_API_
	api_send_at ( "MY", ( char* ) &uint_value, 2 );
	for ( result = 0; result < 100; result++ )
	{
		f = 1.0 / f;
	}
	packet[0] = 'R';
	packet[1] = 'E';
	packet[2] = 'C';
	packet[3] = 'H';
	packet[4] = 'G';
	packet[5] = MY_ADDR;
	packet[6] = '\r';

	api_send_packet16 ( packet , 6, 0xFFFF );
	for ( result = 0; result < 1000; result++ )
	{
		f = 1.0 / f;
	}
#endif // _ENABLE_XBEE_API_
	energy_depleted_control_ = 0;
	my_energy_ = ENDIAN32(pkt->energy);

}
///////////////////////////////////////////////

/**
  * app_drop_pkt(base,module_name, reason, event) - handles packet dropping
  *     possible actions are - counting errors, rescheduling packet for retransmission
  */
void app_drop_pkt ( unsigned int base, module_t module, reason_t reason, event_t event )
{
	app_count_drop_pkts_++;

#ifdef FEAT_ENABLE_CC
	cc_drop_pkts_ ++;
#endif

	// app_count_drop_pkts_;	// Dropped packets
	// app_count_lost_pkts_;	// Lost during TX packets
//	unsigned int XDATA app_count_sent_pkts_;	// Sent out succesfully
//	unsigned int XDATA app_count_recv_pkts_;	// Received from other nodes
//	unsigned int XDATA app_count_gen_pkts_;	// Generated by this node
}




///////////////////////////////////////////////
unsigned char XDATA network_search_mode_ = SEARCH_OFF;
unsigned long XDATA switch_timeout_;
unsigned long XDATA switch_start_time_;


#define ROTATE_CHANNEL(c) (c>=MAX_RF_CHANNEL)?MIN_RF_CHANNEL:c+1

/**
  * app_start_search_channel(packet) - handles request for channel search
  *     it switches to particular (given in packet) channel in starts the search
  *		using one of the available methods (given in packet)
  */
void app_start_search_channel ( pkt_t * p )
{
	switchpkt_t *pkt = ( switchpkt_t* ) p;
	phy_set_RF_channel ( pkt->channel ); //  channel to be used as a starting point
	network_search_mode_ = pkt->search_mode;
	switch_start_time_ = rtc_get_ticks();

	if ( SEARCH_OEDSR_HELLO == network_search_mode_ )
	{
		switch_timeout_ = switch_start_time_ + SEARCH_OEDSR_HELLO_SWITCH_INTERVAL;
		// send HELLO!!
#ifdef _ENABLE_OEDSR_
		sendHELLO();
#endif
	}
	else if ( SEARCH_BEACON_NODE_SWITCHING == network_search_mode_ )
	{
		switch_timeout_ = switch_start_time_ + SEARCH_BEACON_SWITCH_INTERVAL;
	}
}


/**
  * app_search_switch_channel() - handles switching between channels while searching
  *     for the BS/network
  */
void app_search_switch_channel()
{
	phy_set_RF_channel ( ROTATE_CHANNEL ( my_rf_channel_ ) );

	if ( SEARCH_OEDSR_HELLO == network_search_mode_ )
	{
		switch_timeout_ = rtc_get_ticks() + SEARCH_OEDSR_HELLO_SWITCH_INTERVAL;
		// send HELLO!!
#ifdef _ENABLE_OEDSR_
		sendHELLO();
#endif //
	}
	else if ( SEARCH_BEACON_NODE_SWITCHING == network_search_mode_ )
	{
		switch_timeout_ = rtc_get_ticks() + SEARCH_BEACON_SWITCH_INTERVAL;
	}

}


/**
  * app_received_beacon(packet) - handles reception of beacon packet
  *     changes to the specified channel thus "joining" the network
  */
void app_received_beacon ( pkt_t * p )
{
	bcpkt_t *pkt = ( bcpkt_t * ) p;

	app_send_join ( pkt->dst_id, pkt->channel, network_search_mode_ );
	app_beacon_count_++;
}




/**
  * app_send_join(dst_id, channel, mode) - sends JOIN packet to agiven node (dst_id)
  *     additionally it stops the channel search and sets the particular channel
  */
void app_send_join ( unsigned char dst_id, unsigned char channel, unsigned char mode )
{
	unsigned char temp_power = my_tx_power_;
	char XDATA temp_pkt[JOIN_PKT_SIZE];
	jpkt_t XDATA *pkt = ( jpkt_t XDATA* ) temp_pkt;
	// Turn off the channel search
	network_search_mode_ = SEARCH_OFF;
	// switch to correct channel
	phy_set_RF_channel ( channel );
	// Make the JOIN packet
	pkt->start = START_BYTE;
	pkt->flags = FLAG_JOIN;
	pkt->mac_dst = ENDIAN16(( unsigned int ) dst_id);
	pkt->mac_src = ENDIAN16(MY_ADDR);
	pkt->length = JOIN_PKT_LENGTH; // of the packet'd data
	pkt->dst_id = dst_id; // part of DATA field (dest_id) - actual length depends on "length"
	pkt->src_id = MY_ADDR; // part of DATA field
	pkt->channel = channel; //  channel to be used as a starting point
	pkt->search_mode = mode; // search algorithm
	pkt->duration = ENDIAN32(rtc_get_ticks() - switch_start_time_); // search algorithm
	pkt->crc = STOP_BYTE;

	// Send the JOIN packet using MAX power
	phy_set_power_level ( MAX_POWER_LEVEL );
#ifdef _ARM_
	sendPriorityPacket ( JOIN_PKT_SIZE, temp_pkt, ENDIAN16 ((uint16_t)dst_id) );
#else // _ARM_
	#ifdef _ENABLE_XBEE_API_
		api_send_packet16 ( ( char* ) temp_pkt, JOIN_PKT_SIZE, ( unsigned int ) dst_id );
	#endif // _ENABLE_XBEE_API_
#endif // _ARM_
	phy_set_power_level ( temp_power );
}

#endif // _ENABLE_MAIN_
