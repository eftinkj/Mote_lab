###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:27:03
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\low_level_init.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\low_level_init.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"low_level_init.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\low_level_init.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\low_level_init.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\low_level_init.c
      1          /**
      2            ******************************************************************************
      3            * @file    low_level_init.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012
      7            * @brief   low_level_init functions
      8            * @verbatim
      9            *
     10           ===============================================================================
     11                            ##### low_level_init function describtion #####
     12           ===============================================================================
     13          
     14           * This module contains the function `__low_level_init', a function
     15           * that is called before the `main' function of the program.  Normally
     16           * low-level initializations - such as setting the prefered interrupt
     17           * level or setting the watchdog - can be performed here.
     18           *
     19           * Note that this function is called before the data segments are
     20           * initialized, this means that this function cannot rely on the
     21           * values of global or static variables.
     22           *
     23           * When this function returns zero, the startup code will inhibit the
     24           * initialization of the data segments. The result is faster startup,
     25           * the drawback is that neither global nor static data will be
     26           * initialized.
     27          
     28            @endverbatim
     29            ******************************************************************************
     30            * @attention
     31            *
     32            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     33            *
     34            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     35            * You may not use this file except in compliance with the License.
     36            * You may obtain a copy of the License at:
     37            *
     38            *        http://www.st.com/software_license_agreement_liberty_v2
     39            *
     40            * Unless required by applicable law or agreed to in writing, software 
     41            * distributed under the License is distributed on an "AS IS" BASIS, 
     42            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     43            * See the License for the specific language governing permissions and
     44            * limitations under the License.
     45            *
     46            ******************************************************************************
     47            */
     48          
     49          /* Includes ------------------------------------------------------------------*/
     50          #include PLATFORM_HEADER
     51          #include "memmap.h"
     52          
     53          #define IAP_BOOTLOADER_APP_SWITCH_SIGNATURE  0xb001204d
     54          #define IAP_BOOTLOADER_MODE_UART  0
     55          #define IAP_BOOTLOADER_MODE_OTA   1
     56          
     57          /** @addtogroup HAL
     58            * @{
     59            */
     60          
     61          /** @defgroup low_level_init
     62            * @brief low_level_init modules
     63            * @{
     64            */
     65          
     66          /* Private define ------------------------------------------------------------*/
     67          /* Private typedef -----------------------------------------------------------*/
     68            
     69          #ifdef __ICCARM__  
     70          #pragma language=extended
     71          #endif
     72            
     73          /* Private macros ------------------------------------------------------------*/
     74          /* Private variables ---------------------------------------------------------*/
     75          
     76          #if (defined (__ICCARM__) || defined (__GNUC__))

   \                                 In section FAT, align 4, root
     77          NO_STRIPPING(NO_INIT(VAR_AT_SEGMENT(const HalFixedAddressTableType halFixedAddressTable, __FAT__)));
   \                     halFixedAddressTable:
   \   00000000                      DS8 44
     78          #elif defined __CC_ARM 
     79          HalFixedAddressTableType halFixedAddressTable __attribute__((section("__FAT__"), zero_init));
     80          #endif
     81            
     82          /* extern const HalVectorTableType __vector_table[];*/
     83          #ifdef __ICCARM__
     84          extern const HalVectorTableType __vector_table[];
     85          #elif defined __CC_ARM
     86            extern const HalVectorTableType __Vectors[];
     87          #elif defined __GNUC__
     88            extern const HalVectorTableType g_pfnVectors[];
     89          #else 
     90             #error "Vector table expected"  
     91          #endif
     92          
     93          #ifdef __CC_ARM
     94          __asm void CPSID ()
     95          {
     96          	CPSID i
     97          	BX LR
     98             
     99          }
    100          __asm void CPSIE ()
    101          {
    102          	CPSIE i
    103            BX LR 
    104          }
    105          #endif
    106          
    107          /* Private function prototypes -----------------------------------------------*/
    108          static void low_level_init2(void);
    109          /* __interwork int __low_level_init(void);*/
    110          int __low_level_init(void);
    111          /* Private functions ---------------------------------------------------------*/
    112          
    113          /** @defgroup  micro_Private_Functions
    114            * @{
    115            */
    116          
    117          #ifdef CORTEXM3_STM32W108xB
    118          /**
    119            * @brief  Clock switching for bootloader software activation. 
    120            * @param  None
    121            * @retval None
    122            */
    123          static void switchClock(void)
    124          {
    125            /* Enable the accurate 24MHz clock. */
    126            CLK->HSECR2 = CLK_HSECR2_EN;
    127            /* Wait 3 milliseconds after enabling the crystal before switching to it. */
    128            /* When running on OSCHF the MAC timer tick is 2 microseconds. */
    129            MACTMR->CR |= MACTMR_CR_EN;
    130            uint32_t startTime = MACTMR->CNTR;
    131            /* Wrapping is handled by the mask. */
    132            while (((MACTMR->CNTR - startTime) & MACTMR_CNTR_CNT) < (3000 / 2)) {}
    133            MACTMR->CR = 0x00;
    134            CLK->HSECR2 |= CLK_HSECR2_SW1;
    135          }
    136          

   \                                 In section .text, align 4, keep-with-next
    137          static const uint16_t blOffset[] = {
   \                     blOffset:
   \   00000000   0x0300 0x0300      DC16 768, 768
    138            0x0715 - 0x03ad - 0x68,
    139            0x0719 - 0x03ad - 0x6C
    140          };
    141          #endif
    142          
    143          /**
    144            * @brief  Sets the Stack pointer. 
    145            * @param  Address
    146            * @retval None
    147            */

   \                                 In section .text, align 4, keep-with-next
    148          static void setStackPointer(uint32_t address)
    149          {
    150            #if (defined (__ICCARM__))
    151                asm("MOV SP, r0");
   \                     setStackPointer: (+1)
   \   00000000   0x4685             MOV SP, r0
    152            #elif (defined (__GNUC__) || defined (__CC_ARM))
    153                __set_MSP(address);
    154            #else 
    155             #error "Inline assembler syntax expected"  
    156            #endif
    157          }
   \   00000002   0x4770             BX       LR               ;; return
    158          
    159          /**
    160            * @brief  Configures interupts levels
    161            * @param  None
    162            * @retval Init value
    163            * @note Important note: This function is critical for waking up from deep sleep 
    164            * and it should not use more that 2 stack position
    165            * otherwise a stack corruption will occur when waking up from deep sleep.
    166            * All the steps not related to deep sleep have been moved to low_level_init2.
    167            * Perhaps this function should be rewritten in assembler to avoid stack usage 
    168            * all together when waking up from deep sleep.
    169            */

   \                                 In section .text, align 4, keep-with-next
    170          int __low_level_init(void)
    171          {
   \                     __low_level_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    172          #ifdef CORTEXM3_STM32W108xB
    173            /* Ensure there is enough margin on VREG_1V8 for stable RAM reads by */
    174            /* setting it to a code of 6.  VREG_1V2 can be left at its reset value. */
    175            PWR->VREGCR = 0x00000307;
   \   00000002   0x....             LDR.N    R0,??DataTable2  ;; 0x40000018
   \   00000004   0xF240 0x3107      MOVW     R1,#+775
   \   00000008   0x6001             STR      R1,[R0, #+0]
    176          #endif
    177            
    178            /* This code should be careful about the use of local variables in case the
    179               reset type happens to be a deep sleep reset.  If the reset is not from
    180              deep sleep, then locals can be freely used */
    181            
    182            /* When the Cortex-M3 exits reset, interrupts are enable.  Explicitely
    183               disable them immediately using the standard set PRIMASK instruction.
    184               Injecting an assembly instruction this early does not effect optimization. */
    185                
    186          /* asm("CPSID i"); */                                                              
    187           #if (defined (__ICCARM__) || defined (__GNUC__))  
    188          	asm("CPSID i");
   \   0000000A   0xB672             CPSID i
    189           #elif defined __CC_ARM
    190                  CPSID();
    191           #else 
    192             #error "Inline assembler syntax expected"  
    193           #endif
    194            
    195            /* It is quite possible that when the Cortex-M3 begins executing code the
    196               Core Reset Vector Catch is still left enabled.  Because this VC would
    197               cause us to halt at reset if another reset event tripped, we should
    198               clear it as soon as possible.  If a debugger wants to halt at reset,
    199               it will set this bit again. */
    200            CoreDebug->DEMCR &= ~CoreDebug_DEMCR_VC_CORERESET_Msk;
   \   0000000C   0x....             LDR.N    R1,??DataTable2_1  ;; 0xe000edfc
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0x0852             LSRS     R2,R2,#+1
   \   00000012   0x0052             LSLS     R2,R2,#+1
   \   00000014   0x600A             STR      R2,[R1, #+0]
    201            
    202            /* Configure flash access for optimal current consumption early
    203               during boot to save as much current as we can. */
    204            FLASH->ACR= (FLASH_ACR_PRFTBE | (1 << 0));
   \   00000016   0x2111             MOVS     R1,#+17
   \   00000018   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40008000
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \   0000001C   0x2380             MOVS     R3,#+128
    205            
    206            /*****---- Always remap the vector table ----*****/
    207            /* We might be coming from a bootloader at the base of flash, or even in the
    208               NULL_BTL case, the BAT/AAT will be at the beginning of the image */
    209          
    210          #ifdef __ICCARM__
    211            SCB->VTOR = (uint32_t)__vector_table;
   \   0000001E   0x....             LDR.N    R1,??DataTable2_3  ;; 0xe000ed04
   \   00000020   0x....             LDR.N    R2,??DataTable2_4
   \   00000022   0x604A             STR      R2,[R1, #+4]
    212          #elif defined __CC_ARM
    213            SCB->VTOR = (uint32_t)__Vectors;
    214          #elif __GNUC__
    215            SCB->VTOR = (uint32_t)g_pfnVectors;
    216          #else
    217            #error "Vector table expected"
    218          #endif
    219          
    220            /*****---- Always Configure Interrupt Priorities ----************************/
    221            /* The STM32W support 5 bits of priority configuration.
    222               The cortex allows this to be further divided into preemption and a
    223               "tie-breaker" sub-priority.
    224               We configure a scheme that allows for 3 bits (8 values) of preemption and
    225               2 bits (4 values) of tie-breaker by using the value 4 in PRIGROUP.
    226               The value 0x05FA0000 is a special key required to write to this register. */
    227            SCB->AIRCR = (0x05FA0000 | (4 <<8));
   \   00000024   0x....             LDR.N    R2,??DataTable2_5  ;; 0x5fa0400
   \   00000026   0x608A             STR      R2,[R1, #+8]
    228            
    229            /* A few macros to help with interrupt priority configuration.  Really only 
    230               uses 6 of the possible levels, and ignores the tie-breaker sub-priority
    231               for now.
    232               Don't forget that the priority level values need to be shifted into the
    233               top 5 bits of the 8 bit priority fields. (hence the <<3)
    234             
    235               NOTE: The ATOMIC and DISABLE_INTERRUPTS macros work by setting the 
    236                    current priority to a value of 12, which still allows CRITICAL and 
    237                    HIGH priority interrupts to fire, while blocking MED and LOW.
    238                    If a different value is desired, INTERRUPTS_DISABLED_PRIORITY will need
    239                    to be edited. */
    240          #define CRITICAL (0  <<3)
    241          #define HIGH     (8  <<3)
    242          #define MED      (16 <<3)
    243          #define LOW      (28 <<3)
    244          #define NONE     (31 <<3)
    245            
    246          /* With optimization turned on, the compiler will indentify all the values
    247             and variables used here as constants at compile time and will truncate
    248             this entire block of code to 98 bytes, comprised of 7 load-load-store
    249               operations. */
    250             /* vect00 is fixed                        Stack pointer */
    251             /* vect01 is fixed                        Reset Vector */
    252             /* vect02 is fixed                        NMI Handler */
    253             /* vect03 is fixed                        Hard Fault Handler */
    254          
    255            SCB->SHP[0] = CRITICAL;   /* Memory Fault Handler */ 
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x750A             STRB     R2,[R1, #+20]
    256            SCB->SHP[1] = CRITICAL;   /* Bus Fault Handler */
   \   0000002C   0x754A             STRB     R2,[R1, #+21]
    257            SCB->SHP[2] = CRITICAL;   /* Usage Fault Handler */
   \   0000002E   0x758A             STRB     R2,[R1, #+22]
    258            SCB->SHP[3] = NONE;       /* Reserved */
   \   00000030   0x22F8             MOVS     R2,#+248
   \   00000032   0x75CA             STRB     R2,[R1, #+23]
    259            
    260            SCB->SHP[4] = NONE;       /* Reserved */
   \   00000034   0x760A             STRB     R2,[R1, #+24]
    261            SCB->SHP[5] = NONE;       /* Reserved */
   \   00000036   0x764A             STRB     R2,[R1, #+25]
    262            SCB->SHP[6] = NONE;       /* Reserved */
   \   00000038   0x768A             STRB     R2,[R1, #+26]
    263            SCB->SHP[7] = HIGH;       /* SVCall Handler */
   \   0000003A   0x2240             MOVS     R2,#+64
   \   0000003C   0x76CA             STRB     R2,[R1, #+27]
    264            
    265            SCB->SHP[8] = MED;        /* Debug Monitor Handler */
   \   0000003E   0x2280             MOVS     R2,#+128
   \   00000040   0x770A             STRB     R2,[R1, #+28]
    266            SCB->SHP[9] = NONE;       /* Reserved */
   \   00000042   0x22F8             MOVS     R2,#+248
   \   00000044   0x774A             STRB     R2,[R1, #+29]
    267            SCB->SHP[10] = HIGH;      /* PendSV Handler */
   \   00000046   0x2240             MOVS     R2,#+64
   \   00000048   0x778A             STRB     R2,[R1, #+30]
    268            SCB->SHP[11] = HIGH;      /* halSysTickIsr */
   \   0000004A   0x77CA             STRB     R2,[R1, #+31]
    269          
    270            NVIC->IP[0] = MED;       /* Timer 1 Handler */
   \   0000004C   0x....             LDR.N    R2,??DataTable2_6  ;; 0xe000e400
   \   0000004E   0x7013             STRB     R3,[R2, #+0]
    271            NVIC->IP[1] = MED;       /* Timer 2 Handler */
   \   00000050   0x7053             STRB     R3,[R2, #+1]
    272            NVIC->IP[2] = HIGH;      /* Management Handler */
   \   00000052   0x2340             MOVS     R3,#+64
   \   00000054   0x7093             STRB     R3,[R2, #+2]
    273            NVIC->IP[3] = MED;       /* BaseBand Handler */
   \   00000056   0x2380             MOVS     R3,#+128
   \   00000058   0x70D3             STRB     R3,[R2, #+3]
    274            
    275            NVIC->IP[4] = MED;      /* Sleep Timer Handler */
   \   0000005A   0x7113             STRB     R3,[R2, #+4]
    276            NVIC->IP[5] = MED;      /* SC1 Handler */
   \   0000005C   0x7153             STRB     R3,[R2, #+5]
    277            NVIC->IP[6] = MED;      /* SC2 Handler */
   \   0000005E   0x7193             STRB     R3,[R2, #+6]
    278            NVIC->IP[7] = MED;      /* Security Handler */
   \   00000060   0x71D3             STRB     R3,[R2, #+7]
    279            
    280            NVIC->IP[8] = MED;      /* MAC Timer Handler */
   \   00000062   0x7213             STRB     R3,[R2, #+8]
    281            NVIC->IP[9] = MED;      /* MAC TX Handler */
   \   00000064   0x7253             STRB     R3,[R2, #+9]
    282            NVIC->IP[10] = MED;     /* MAC RX Handler */
   \   00000066   0x7293             STRB     R3,[R2, #+10]
    283            NVIC->IP[11] = MED;     /* ADC Handler */
   \   00000068   0x72D3             STRB     R3,[R2, #+11]
    284            
    285            NVIC->IP[12] = MED;     /* GPIO IRQA Handler */
   \   0000006A   0x7313             STRB     R3,[R2, #+12]
    286            NVIC->IP[13] = MED;     /* GPIO IRQB Handler */
   \   0000006C   0x7353             STRB     R3,[R2, #+13]
    287            NVIC->IP[14] = MED;     /* GPIO IRQC Handler */
   \   0000006E   0x7393             STRB     R3,[R2, #+14]
    288            NVIC->IP[15] = MED;     /* GPIO IRQD Handler */
   \   00000070   0x73D3             STRB     R3,[R2, #+15]
    289            NVIC->IP[16] = LOW;     /* Debug Handler */
   \   00000072   0x23E0             MOVS     R3,#+224
   \   00000074   0x7413             STRB     R3,[R2, #+16]
    290            /* vect33 not implemented */
    291            /* vect34 not implemented */
    292            /* vect35 not implemented */
    293            
    294            /*****---- Always Configure System Handlers Control and Configuration ----*****/
    295            SCB->CCR = SCB_CCR_DIV_0_TRP_Msk;
   \   00000076   0x2210             MOVS     R2,#+16
   \   00000078   0x610A             STR      R2,[R1, #+16]
    296            SCB->SHCSR = ( SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_BUSFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk);
   \   0000007A   0xF44F 0x22E0      MOV      R2,#+458752
   \   0000007E   0x620A             STR      R2,[R1, #+32]
    297            
    298            if((RST->SR&RST_SR_WKUP) == RST_SR_WKUP)
   \   00000080   0x6940             LDR      R0,[R0, #+20]
   \   00000082   0x0680             LSLS     R0,R0,#+26
   \   00000084   0xD509             BPL.N    ??__low_level_init_0
    299            {
    300              /* Since the 13 NVIC registers above are fixed values, they are restored
    301                 above (where they get set anyways during normal boot sequences) instead
    302                 of inside of the halInternalSleep code: */
    303              
    304              void halTriggerContextRestore(void);
    305              extern __IO boolean halPendSvSaveContext;
    306              halPendSvSaveContext = 0;       /* 0 means restore context */
   \   00000086   0x....             LDR.N    R2,??DataTable2_7
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x7010             STRB     R0,[R2, #+0]
    307              SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk; /* pend halPendSvIsr to enable later */
   \   0000008C   0x6808             LDR      R0,[R1, #+0]
   \   0000008E   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \   00000092   0x6008             STR      R0,[R1, #+0]
    308              halTriggerContextRestore();     /* sets MSP, enables interrupts */
   \   00000094   0x.... 0x....      BL       halTriggerContextRestore
    309              /* if the context restore worked properly, we should never return here */
    310              while(1) { ; }
   \                     ??__low_level_init_1: (+1)
   \   00000098   0xE7FE             B.N      ??__low_level_init_1
    311            }
    312            low_level_init2();
   \                     ??__low_level_init_0: (+1)
   \   0000009A   0x.... 0x....      BL       low_level_init2
    313            /*==========================================================================*/
    314            /*                     Choose if segment initialization                     */
    315            /*                        should be done or not.                            */
    316            /*                      Return: 0 to omit seg_init                          */
    317            /*                         1 to run seg_init                                */
    318            /*==========================================================================*/
    319            return 1;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xBD02             POP      {R1,PC}          ;; return
    320          }
    321          /* Second stage low level init to be executed under normal condition, but not when waking up from deep sleep */
    322          
    323          /**
    324            * @brief  Configures interrupt level
    325            * @param  None
    326            * @retval None
    327            */

   \                                 In section .text, align 4, keep-with-next
    328          static void low_level_init2(void)
    329          {
   \                     low_level_init2: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    330          #ifdef CORTEXM3_STM32W108xB
    331            /* USART bootloader software activation check */
    332            if ((*((uint32_t *)RAM_BOTTOM) == IAP_BOOTLOADER_APP_SWITCH_SIGNATURE) && (*((uint8_t *)(RAM_BOTTOM+4)) == IAP_BOOTLOADER_MODE_UART))
   \   00000002   0xF04F 0x5100      MOV      R1,#+536870912
   \   00000006   0x....             LDR.N    R2,??DataTable2_8  ;; 0xb001204d
   \   00000008   0x6808             LDR      R0,[R1, #+0]
   \   0000000A   0x4290             CMP      R0,R2
   \   0000000C   0xBF04             ITT      EQ 
   \   0000000E   0x7908             LDRBEQ   R0,[R1, #+4]
   \   00000010   0x2800             CMPEQ    R0,#+0
   \   00000012   0xD12D             BNE.N    ??low_level_init2_0
    333            {
    334              uint8_t cut = *(__IO uint8_t *) (FIB_BOTTOM + 0x0798);
   \   00000014   0x....             LDR.N    R0,??DataTable2_9  ;; 0x8040798
    335              uint16_t offset = 0;
    336              typedef void (*EntryPoint)(void);     
    337              offset = (halFixedAddressTable.baseTable.version == 3) ? blOffset[cut - 2] : 0;
   \   00000016   0x....             LDR.N    R3,??DataTable2_10
   \   00000018   0x7802             LDRB     R2,[R0, #+0]
   \   0000001A   0x8A5B             LDRH     R3,[R3, #+18]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x2B03             CMP      R3,#+3
   \   00000020   0xD105             BNE.N    ??low_level_init2_1
   \   00000022   0x.... 0x....      ADR.W    R0,blOffset
   \   00000026   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \   0000002A   0xF830 0x0C04      LDRH     R0,[R0, #-4]
    338              *((uint32_t *)RAM_BOTTOM) = 0;
   \                     ??low_level_init2_1: (+1)
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x600A             STR      R2,[R1, #+0]
    339              if (offset) 
   \   00000032   0xB1B0             CBZ.N    R0,??low_level_init2_2
    340              {
    341                switchClock();
   \   00000034   0x....             LDR.N    R1,??DataTable2_11  ;; 0x4000401c
   \   00000036   0x2202             MOVS     R2,#+2
   \   00000038   0x600A             STR      R2,[R1, #+0]
   \   0000003A   0xF240 0x55DC      MOVW     R5,#+1500
   \   0000003E   0x....             LDR.N    R2,??DataTable2_12  ;; 0x40002038
   \   00000040   0x6D53             LDR      R3,[R2, #+84]
   \   00000042   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000046   0x6553             STR      R3,[R2, #+84]
   \   00000048   0x6813             LDR      R3,[R2, #+0]
   \                     ??low_level_init2_3: (+1)
   \   0000004A   0x6814             LDR      R4,[R2, #+0]
   \   0000004C   0x1AE4             SUBS     R4,R4,R3
   \   0000004E   0x0324             LSLS     R4,R4,#+12
   \   00000050   0x0B24             LSRS     R4,R4,#+12
   \   00000052   0x42AC             CMP      R4,R5
   \   00000054   0xD3F9             BCC.N    ??low_level_init2_3
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0x6553             STR      R3,[R2, #+84]
   \   0000005A   0x680A             LDR      R2,[R1, #+0]
   \   0000005C   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000060   0x600A             STR      R2,[R1, #+0]
    342              }
    343              EntryPoint entryPoint = (EntryPoint)(*(uint32_t *)(FIB_BOTTOM+4) - offset);
   \                     ??low_level_init2_2: (+1)
   \   00000062   0x....             LDR.N    R1,??DataTable2_13  ;; 0x8040000
   \   00000064   0x684A             LDR      R2,[R1, #+4]
   \   00000066   0x1A14             SUBS     R4,R2,R0
    344              setStackPointer(*(uint32_t *)FIB_BOTTOM);
   \   00000068   0x6808             LDR      R0,[R1, #+0]
   \   0000006A   0x.... 0x....      BL       setStackPointer
    345              entryPoint();
   \   0000006E   0x47A0             BLX      R4
    346            }
    347          #elif defined (CORTEXM3_STM32W108CC)
    348            /* Embedeed USART or RF bootloader software activation check */
    349            if ((*((uint32_t *)RAM_BOTTOM) == IAP_BOOTLOADER_APP_SWITCH_SIGNATURE))
    350            {
    351              typedef void (*EntryPoint)(void);
    352              EntryPoint entryPoint;
    353              uint32_t bootAddress;
    354              *((uint32_t *)RAM_BOTTOM) = 0;
    355              if ((*((uint8_t *)(RAM_BOTTOM+4)) == IAP_BOOTLOADER_MODE_UART) || (*((uint8_t *)(RAM_BOTTOM+4)) == IAP_BOOTLOADER_MODE_OTA)) 
    356              {
    357                bootAddress = (*((uint8_t *)(RAM_BOTTOM+4)) == IAP_BOOTLOADER_MODE_UART) ? FIB_BOTTOM : (FIB1_BOTTOM + 0x800);
    358                entryPoint = (EntryPoint)(*(uint32_t *)(bootAddress+4));
    359                setStackPointer(*((uint32_t *)bootAddress));
    360                entryPoint();
    361              }
    362            }
    363          #endif
    364            
    365            INTERRUPTS_OFF();
   \                     ??low_level_init2_0: (+1)
   \   00000070   0x2060             MOVS     R0,#+96
   \   00000072   0xF380 0x8811      MSR      BASEPRI,R0
    366          
    367          #if (defined (__ICCARM__) || defined (__GNUC__)) 
    368          	asm("CPSIE i");
   \   00000076   0xB662             CPSIE i
    369          #elif defined __CC_ARM
    370              CPSIE();
    371          #else 
    372           #error "Inline assembler syntax expected"  
    373          #endif
    374            
    375          }
   \   00000078   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40000018         DC32     0x40000018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xE000EDFC         DC32     0xe000edfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     __vector_table

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x05FA0400         DC32     0x5fa0400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     halPendSvSaveContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0xB001204D         DC32     0xb001204d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x08040798         DC32     0x8040798

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x........         DC32     halFixedAddressTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x4000401C         DC32     0x4000401c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x40002038         DC32     0x40002038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x08040000         DC32     0x8040000
    376          /*#pragma language=default*/ 
    377          
    378          #ifdef __ICCARM__
    379          #pragma language=default
    380          #endif
    381          
    382          /**
    383            * @}
    384            */
    385          
    386          /**
    387            * @}
    388            */ 
    389          
    390          /**
    391            * @}
    392            */
    393          
    394          
    395          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   __low_level_init
         8   -> halTriggerContextRestore
         8   -> low_level_init2
      16   low_level_init2
        16   -- Indirect call
        16   -> setStackPointer
       0   setStackPointer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     162  __low_level_init
       4  blOffset
      44  halFixedAddressTable
     122  low_level_init2
       4  setStackPointer

 
 348 bytes in section .text
  44 bytes in section FAT
 
 348 bytes of CODE memory
  44 bytes of DATA memory

Errors: none
Warnings: none
