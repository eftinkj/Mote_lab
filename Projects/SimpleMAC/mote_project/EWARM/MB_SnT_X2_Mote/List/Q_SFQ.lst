###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:28:10
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Queuing\Q_SFQ.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Queuing\Q_SFQ.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"Q_SFQ.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Queuing\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\Q_SFQ.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\Q_SFQ.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Queuing\Q_SFQ.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          //SFQ source code
     17          
     18          #include "common.h"
     19          
     20          #ifdef FEAT_ENABLE_SFQ
     21          
     22          
     23          
     24          #include "RTC.h"
     25          #include "Q_SFQ.h"
     26          #include "Queuing.h"
     27          #include "packet.h"
     28          
     29          //Decleration Variables
     30          table_index_t	XDATA SFQ_head[NUMFLOWS];
     31          table_index_t	XDATA SFQ_tail[NUMFLOWS];
     32          table_size_t	XDATA SFQsize[NUMFLOWS];
     33          v_time_t	virt_tag = 0;
     34          v_time_t	XDATA Ftime_old[NUMFLOWS];
     35          v_time_t	XDATA Ftime[NUMFLOWS][NUMQBUFFS];
     36          v_time_t	XDATA Stime[NUMFLOWS][NUMQBUFFS];
     37          //pkt_index_t 	xdata pktindex[NUMFLOWS * NUMQBUFFS] _at_ PKT_INDEX_BEGIN;
     38          pkt_index_t 	XDATA pktindex[NUMFLOWS * NUMQBUFFS];
     39          //table_index_t Nextpkt[NUMFLOWS][NUMQBUFFS];
     40          weight_t XDATA flow_weights[NUMFLOWS];
     41          weight_t XDATA my_updated_weight_;
     42          uint8_t XDATA q_sfq_version_;
     43          
     44          //**********************
     45          
     46          #define PKTINDEX_ACCESS(f,i) pktindex[f*NUMQBUFFS+i]
     47          
     48          //SFQ Initialization
     49          void Q_SFQ_init()
     50          {
     51          	int k1, k2;
     52          	//Initialize the SFQ ID Table
     53          	for ( k1 = 0; k1 < NUMFLOWS; k1++ )
     54          	{
     55          		for ( k2 = 0; k2 < NUMQBUFFS; k2++ )
     56          		{
     57          			Ftime[k1][k2] = k1;
     58          			Stime[k1][k2] = k1;
     59          //		 	Nextpkt[k1][k2] = 0xFF;
     60          			PKTINDEX_ACCESS ( k1, k2 ) = 0xDD;
     61          
     62          		}
     63          		Ftime_old[k1] = 0;
     64          		SFQ_tail[k1] = 0;
     65          		SFQ_head[k1] = 0;
     66          		SFQsize[k1] = 0;
     67          
     68          		flow_weights[k1] = 0;
     69          	}
     70          	my_updated_weight_ = 0; // the original weight with update is empty
     71          	q_sfq_version_ = SFQ_WEIGHT_UPDATE_ADFS;
     72          }
     73          //**********************
     74          
     75          //Function to deQ an SFQ Packet
     76          pkt_index_t Q_SFQ_dequeue()
     77          {
     78          
     79          	pkt_index_t index_dequeu; // the result place
     80          	table_index_t f;
     81          	v_time_t S_temp = 0xFFFFFFFF; // the max value 0xFFFFFF
     82          	table_index_t f_temp = 0xFF;	
     83          
     84          	if ( 0 < Q_SFQ_utilization() )
     85          	{
     86          		
     87          		//find the queue with lowest Start Tag
     88          		for ( f = 0; f < NUMFLOWS; f++ )
     89          		{
     90          			if ( 0 < SFQsize[f] )
     91          			{
     92          				if ( S_temp > Stime[f][SFQ_tail[f]] )
     93          				{
     94          					S_temp = Stime[f][SFQ_tail[f]];
     95          					f_temp = f;
     96          				}
     97          			}
     98          			else
     99          			{
    100          				continue;
    101          			}
    102          		}
    103          		if ( 0xFF == f_temp )
    104          		{
    105          			return NO_PACKET_INDEX; // ERROR -> size not 0, but not found any packet)
    106          		}
    107          		// Take out the packet from the found queue
    108          		//index = pktindex[f_temp][SFQ_tail[f_temp]];
    109          		index_dequeu = PKTINDEX_ACCESS ( f_temp, SFQ_tail[f_temp] );
    110          		SFQ_tail[f_temp]++;
    111          		if ( NUMQBUFFS <= SFQ_tail[f_temp] )
    112          			SFQ_tail[f_temp] = 0;
    113          		SFQsize[f_temp]--;
    114          // MZ_DFS
    115          		// Update total weight
    116          		if (SFQ_WEIGHT_UPDATE_ADFS == q_sfq_version_)
    117          		{
    118          			pkt_t* xdata temp = ( pkt_t* ) & ( buffer0[QBUFF_BASE ( index_dequeu ) ] );
    119          			flow_id_t temp_f = temp->src_id - FLOW_ID_SHIFT;
    120          			weight_t temp_w = temp->weight;
    121          			my_updated_weight_ = my_updated_weight_ - flow_weights[temp_f] + temp_w;
    122          			flow_weights[temp_f] = temp_w;
    123          		}
    124          // MZ_DFS
    125          		return index_dequeu;
    126          	}
    127          	else
    128          	{
    129          		// no packets in the queue
    130          		return NO_PACKET_INDEX;
    131          	}
    132          }
    133          //**********************
    134          
    135          /**
    136            * Q_SFQ_enqueue_internal (int index,int flownum,int weight) - enqueues a packet in one of SFQ sub-queues
    137            *     //Function to enQ a SFQ packet
    138            */
    139          
    140          bit Q_SFQ_enqueue_internal ( pkt_index_t index, flow_id_t flownum, weight_t weight )
    141          {
    142          	table_index_t relindex;
    143          	if ( SFQsize[flownum] < NUMQBUFFS )
    144          	{
    145          		relindex = SFQ_head[flownum];
    146          		// Increase size and move head forward
    147          		SFQsize[flownum] = SFQsize[flownum] + 1;
    148          		SFQ_head[flownum] = SFQ_head[flownum] + 1;
    149          		if ( NUMQBUFFS <= SFQ_head[flownum] )
    150          		{
    151          			SFQ_head[flownum] = 0;
    152          		}
    153          		Stime[flownum][relindex] = START_TAG ( rtc_get_ticks(), Ftime_old[flownum] ); // start_tag(ticker, Ftime_old[flownum]);
    154          		Ftime[flownum][relindex] = FINISH_TAG ( Stime[flownum][relindex], weight ); //finish_tag(Stime[flownum][relindex],weight);
    155          		PKTINDEX_ACCESS ( flownum, relindex ) = index;
    156          		// update the flow info
    157          		Ftime_old[flownum] = Ftime[flownum][relindex];
    158          
    159          		return 1;
    160          	}
    161          	else
    162          	{
    163          		// Error due to buffer overflow
    164          		return 0;
    165          	}
    166          }
    167          
    168          
    169          // shift by 10 positions (11->1, ... , 19->9)
    170          // NO SHIFT -> SOURCES HAVE TO USE IDs BETWEEN flow_id_shift AND numflows
    171          #define FLOW_ID_SHIFT 0x00
    172          
    173          //Function to enQ a packet from index number
    174          bit Q_SFQ_enqueue ( unsigned char index )
    175          {
    176          	weight_t temp_w;
    177          	pkt_t* xdata temp = ( pkt_t* ) & ( buffer0[QBUFF_BASE ( index ) ] );
    178          	flow_id_t temp_f = temp->src_id - FLOW_ID_SHIFT;
    179          	if (SFQ_FIXED_WEIGHT_DFS != q_sfq_version_)
    180          	{
    181          		Q_SFQ_weight_update ( index );
    182          	}
    183          	temp_w = temp->weight;
    184          	// Update total weight
    185          	//my_updated_weight_ = my_updated_weight_ - flow_weights[temp_f] + temp_w;
    186          	//flow_weights[temp_f] = temp_w;
    187          
    188          	// Store packet
    189          	return Q_SFQ_enqueue_internal ( index, temp_f, temp_w );
    190          }
    191          
    192          
    193          
    194          //**********************
    195          
    196          //Function to check Q utilization
    197          pkt_index_t Q_SFQ_utilization()
    198          {
    199          	pkt_index_t ret = 0;
    200          	table_index_t i;
    201          	for ( i = 0; i < NUMFLOWS; i++ )
    202          	{
    203          		ret += SFQsize[i];
    204          	}
    205          	return ret;
    206          }
    207          //**********************
    208          
    209          
    210          
    211          //**********************
    212          /**
    213            * finish_tag(v_time_t start_tag, int weight) - calculates a FINISH TAG for a new packet
    214            *     //Function to Calculate the Finish Tag of a packet
    215            */
    216          /*
    217          v_time_t finish_tag(v_time_t start_tag, weight_t weight) {
    218          	return (start_tag + (PACKLEN/weight));
    219          }
    220          */
    221          //**********************
    222          
    223          /**
    224            * start_tag(v_time_t virt_time,v_time_t finish_tag) - calculates a START TAG for a new packet
    225            */
    226          /*
    227          v_time_t start_tag(v_time_t virt_time, v_time_t old_finish_tag) {
    228          	if (virt_time > old_finish_tag){
    229          		return virt_time;
    230          	}
    231          	else{
    232          		return old_finish_tag;
    233          	}
    234          }
    235          */
    236          //**********************
    237          
    238          #define QUEUE_ERROR_SCALING 10
    239          //#define DELAY_ERROR_SCALING 200
    240          #define DELAY_ERROR_SCALING 400
    241          
    242          /**
    243            * Q_SFQ_weight_update(int index) - updates weight of a packed in BIG buffer at position "index"
    244            *      //Function to Update the packet weight for an indexed packet
    245            */
    246          weight_t Q_SFQ_weight_update ( pkt_index_t index )
    247          {
    248          	int ret;
    249          	weight_t phi_last;
    250          	int E;
    251          	//int error_delay; //This was original
    252          	unsigned long int error_delay;
    253          
    254          	unsigned long int ticker_old;
    255          	unsigned long int delay;
    256          	//unsigned long int errorQ;  //This was original
    257          	int errorQ;
    258          
    259          	pkt_t* xdata temp = ( pkt_t* ) & ( buffer0[QBUFF_BASE ( index ) ] );//Fetch Packet pointer
    260          	ticker_old = temp -> ticker; //Point to Ticker value in packet
    261          	phi_last = temp-> weight;
    262          	delay = rtc_get_ticks() - ticker_old;
    263          	// @TODO: Verify that new resolution will not mess up the calculations
    264          	// Previously it used 1 tick = 50 ms, NEW: 1tick=1ms
    265          	errorQ = Q_SFQ_utilization() - EXPQ;
    266          //	error_delay = delay - EXPDELAY;
    267          	error_delay = EXPDELAY - delay;
    268          	//E = errorQ + ( 1 / error_delay );
    269          	E = QUEUE_ERROR_SCALING*errorQ + ( DELAY_ERROR_SCALING / error_delay );
    270          	ret = ALPHA * phi_last + BETA * E;
    271          
    272          	// store the new weight
    273          	temp-> weight = ret;
    274          
    275          	return ret;
    276          }
    277          //**********************
    278          
    279          
    280          
    281          /**
    282            * Q_SFQ_get_total_weight() - returns total weight ofor the node
    283            */
    284          weight_t Q_SFQ_get_total_weight()
    285          {
    286          	if (SFQ_FIXED_WEIGHT_DFS == q_sfq_version_)
    287          	{
    288          		return my_weight_;
    289          	}
    290          	else
    291          	{
    292          		// ADFS
    293          		if ( my_updated_weight_ < MIN_WEIGHT )
    294          		{ return MIN_WEIGHT; }
    295          		else { return my_updated_weight_; }
    296          	}
    297          }
    298          
    299          
    300          //**********************
    301          /**
    302            * Q_SFQ_get_total_weight() - returns total weight ofor the node
    303            */
    304          void Q_SFQ_set_version(uint8_t version)
    305          {
    306          	
    307          	switch (version)
    308          	{
    309          		case SFQ_FIXED_WEIGHT_DFS:
    310          			q_sfq_version_ = SFQ_FIXED_WEIGHT_DFS;
    311          			break;
    312          		case SFQ_WEIGHT_UPDATE_ADFS:
    313          			q_sfq_version_ = SFQ_WEIGHT_UPDATE_ADFS;
    314          			break;
    315          		default:
    316          			q_sfq_version_ = SFQ_WEIGHT_UPDATE_ADFS;
    317          	}
    318          }
    319          
    320          
    321          /**
    322            * Q_SFQ_set_weights() - sets weights for the node
    323            */
    324          void Q_SFQ_set_weights(weight_t total_weight, weight_t flow_weight)
    325          {
    326          	uint8_t k1;
    327          	for ( k1 = 0; k1 < NUMFLOWS; k1++ )
    328          	{
    329          		flow_weights[k1] = flow_weight;
    330          	}
    331          	my_updated_weight_ = total_weight;
    332          }
    333          
    334          
    335          #endif
    336          


 

 


Errors: none
Warnings: none
