###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:28:35
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_MMCR_MPR_select.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_MMCR_MPR_select.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"routing_MMCR_MPR_select.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\routing_MMCR_MPR_select.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\routing_MMCR_MPR_select.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_MMCR_MPR_select.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2009-2008 Maciej Zawodniok, Priya Kasirajan. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          
     17          #include "defs/esnl_pub.h"
     18          
     19          #ifdef FEAT_ENABLE_MMCR
     20          
     21          #include "routing.h"
     22          #include "routing_MMCR_MPR_select.h"
     23          #ifdef _ARM_
     24          	#include "FEAT_STM32W/STM32W_Radio.h"
     25          #endif // _ARM_
     26          
     27          #include "network_hardware_ADFS.h"
     28          #include "common.h"
     29          #include "FEAT_Xbee_API/AT_scripts.h"
     30          #include "FEAT_Queuing/Queuing.h"
     31          #include "FEAT_Networking/tsp_common_pub.h"
     32          #include "Application.h"
     33          #include "FEAT_Networking/Phy_layer.h"
     34          #include "packet.h"
     35          #include "FEAT_Scheduler/sch_basic_pub.h"
     36          
     37          ///////////////////////////////////////////////
     38          ///////////////////////////////////////////////
     39          //uint8_t	mmcr_pkt_id = 0xFF;
     40          

   \                                 In section .bss, align 1
     41          unsigned char XDATA mmcr_request_send_TC_ = 0 ; // request for sending Topology control
   \                     mmcr_request_send_TC_:
   \   00000000                      DS8 1
     42          //unsigned char XDATA mmcr_request_send_HELLO_ = 0; // request for sending HELLO
     43          
     44          // Variables to manage )periodic) timeout
     45          //uint8_t mmcr_hello_timeout_enabled_ = 0;
     46          //rtc_tick_t	mmcr_hello_timeout_ = RTC_OVERFLOW_TIMER_VALUE;
     47          uint8_t mmcr_hello_tidx = SCH_NO_TIMEOUT_ID; // Clear timeout's ID
     48          uint8_t mmcr_routeStart_tidx_ = SCH_NO_TIMEOUT_ID; // Clear timeout's ID
     49          

   \                                 In section .bss, align 4
     50          unsigned char mpr_idx[MMCR_MAX_MPRS];
     51          //unsigned char mpr_idx[MMCR_MAX_MPRS];
     52          uint8_t mpr_count_;
   \                     mpr_count_:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     mpr_idx:
   \   00000004                      DS8 12
     53          
     54          
     55          uint8_t mmcr_state_; // state of the routing agent (e.g. IDLE, routing in-progress)
     56          unsigned char XDATA mmcr_Hello_countdown_;	// ON - periodically send HELLO
     57          //int XDATA mmcr_route_search_BS_;	// address of the target node (BS)
     58          
     59          
     60          
     61          //Counters for the Routing Energy Analysis
     62          ///unsigned char XDATA mmcr_Hello_counter;
     63          ///unsigned char XDATA mmcr_ACK_MMCR_counter;
     64          ///unsigned char XDATA mmcr_DAT_MMCR_counter;
     65          
     66          

   \                                 In section .bss, align 2
     67          uint16_t mmcr_len_sample;
   \                     mmcr_len_sample:
   \   00000000                      DS8 2
     68          
     69          //unsigned char XDATA mmcr_ch_counter;
     70          
     71          //unsigned char XDATA mmcr_return_ch;
     72          
     73          //uint8_t ch_sw_TIDX; /// Timer ID for channel switching request
     74          
     75          
     76          

   \                                 In section .bss, align 4
     77          nhood_t	Neighborhood;
   \                     Neighborhood:
   \   00000000                      DS8 320

   \                                 In section .data, align 4
   \                     mmcr_hello_tidx:
   \   00000000   0xFF               DC8 255
   \                     mmcr_routeStart_tidx_:
   \   00000001   0xFF               DC8 255
   \                     mmcr_state_:
   \   00000002   0x00               DC8 0
   \                     mmcr_Hello_countdown_:
   \   00000003   0x00               DC8 0
     78          
     79          
     80          char str_MMCR_sendACK[] = "MMCR_sendACK";
     81          char str_MMCR_HELLO[] = "MMCR_HELLO";
   \                     str_MMCR_HELLO:
   \   00000004   0x4D 0x4D          DC8 "MMCR_HELLO"
   \              0x43 0x52    
   \              0x5F 0x48    
   \              0x45 0x4C    
   \              0x4C 0x4F    
   \              0x00         
   \   0000000F   0x00               DC8 0
     82          char str_MMCR_TC[] = "MMCR_TC";
   \                     str_MMCR_TC:
   \   00000010   0x4D 0x4D          DC8 "MMCR_TC"
   \              0x43 0x52    
   \              0x5F 0x54    
   \              0x43 0x00    
     83          char str_MMCR_startRT[] = "MMCR_startRT";
   \                     str_MMCR_startRT:
   \   00000018   0x4D 0x4D          DC8 "MMCR_startRT"
   \              0x43 0x52    
   \              0x5F 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x52 0x54    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     str_MMCR_sendACK:
   \   00000000   0x4D 0x4D          DC8 "MMCR_sendACK"
   \              0x43 0x52    
   \              0x5F 0x73    
   \              0x65 0x6E    
   \              0x64 0x41    
   \              0x43 0x4B    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     84          
     85          ///////////////////////////////////////////////
     86          /**
     87            * routing_init - performs initial setup of routing
     88            */

   \                                 In section .text, align 2, keep-with-next
     89          void routing_init_MPR_select()
     90          {
   \                     routing_init_MPR_select: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     91          	mmcr_state_=MMCR_STATE_IDLE;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7088             STRB     R0,[R1, #+2]
     92          
     93          	//mmcr_request_send_HELLO_ = 1; // request for sending HELLO
     94          	// Variables to manage (periodic) timeout
     95          //	mmcr_hello_timeout_ = RTC_OVERFLOW_TIMER_VALUE;
     96          
     97          	init_topology();
   \   0000000A   0x.... 0x....      BL       mmcr_neighbor_clear
     98          	// MZ: Why deleted? //	
     99          	mpr_select();
   \   0000000E   0x.... 0x....      BL       mpr_select
    100          
    101          	mmcr_startRouteSearch(0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE8BD 0x4002      POP      {R1,LR}
   \   00000018   0x....             B.N      mmcr_startRouteSearch
    102          }
    103          
    104          ///////////////////////////////////////////////
    105          /**
    106            * init_topology - performs initial setup of topology
    107            */

   \                                 In section .text, align 2, keep-with-next
    108          void init_topology()
    109          {
    110          	mmcr_neighbor_clear();
   \                     init_topology: (+1)
   \   00000000   0x....             B.N      mmcr_neighbor_clear
    111          	
    112          #ifdef NODE_1
    113          	Neighborhood.OneHopNodes = 3;
    114          	Neighborhood.TwoHopNodes = 1;
    115          	Neighborhood.OneHop[0].ID = 0x000C;
    116          	Neighborhood.OneHop[0].Links = 1;
    117          	Neighborhood.OneHop[0].Link[0] = 0x00FE;
    118          	Neighborhood.OneHop[1].ID = 0x000D;
    119          	Neighborhood.OneHop[1].Links = 1;
    120          	Neighborhood.OneHop[1].Link[0] = 0x00FE;
    121          	Neighborhood.OneHop[2].ID = 0x000B;
    122          	Neighborhood.OneHop[2].Links = 1;
    123          	Neighborhood.OneHop[2].Link[0] = 0x00FE;
    124          	Neighborhood.TwoHop[0].ID = 0x00FE;
    125          #endif
    126          #ifdef NODE_2
    127          	Neighborhood.OneHopNodes = 2;
    128          	Neighborhood.TwoHopNodes = 1;
    129          	Neighborhood.OneHop[0].ID = 0x000A;
    130          	Neighborhood.OneHop[0].Links = 1;
    131          	Neighborhood.OneHop[0].Link[0] = 0x00AA;
    132          	Neighborhood.OneHop[1].ID = 0x00FE;
    133          	Neighborhood.OneHop[1].Links = 0;
    134          	Neighborhood.TwoHop[0].ID = 0x00AA;
    135          #endif
    136          #ifdef NODE_3
    137          	Neighborhood.OneHopNodes = 2; //3
    138          	Neighborhood.TwoHopNodes = 0;
    139          	Neighborhood.OneHop[0].ID = 0x000F;
    140          	Neighborhood.OneHop[0].Links = 0;
    141          //	Neighborhood.OneHop[1].ID = 0x000F;
    142          //	Neighborhood.OneHop[1].Links = 0;
    143          	Neighborhood.OneHop[1].ID = 0x00FE;
    144          	Neighborhood.OneHop[1].Links = 0;
    145          #endif
    146          #ifdef NODE_4
    147          	Neighborhood.OneHopNodes = 2;
    148          	Neighborhood.TwoHopNodes = 0;
    149          	Neighborhood.OneHop[0].ID = 0x000E;
    150          	Neighborhood.OneHop[0].Links = 0;
    151          	Neighborhood.OneHop[1].ID = 0x00FE;
    152          	Neighborhood.OneHop[1].Links = 0;
    153          #endif
    154          #ifdef NODE_5
    155          //	Neighborhood.OneHopNodes = 1;
    156          //	Neighborhood.TwoHopNodes = 0;
    157          //	Neighborhood.OneHop[0].ID = 0x0A;
    158          //	Neighborhood.OneHop[0].Links = 0;
    159          	Neighborhood.OneHopNodes = 3;
    160          	Neighborhood.TwoHopNodes = 1;
    161          	Neighborhood.OneHop[0].ID = 0x000C;
    162          	Neighborhood.OneHop[0].Links = 1;
    163          	Neighborhood.OneHop[0].Link[0] = 0x00FE;
    164          	Neighborhood.OneHop[1].ID = 0x000D;
    165          	Neighborhood.OneHop[1].Links = 1;
    166          	Neighborhood.OneHop[1].Link[0] = 0x00FE;
    167          	Neighborhood.OneHop[2].ID = 0x000B;
    168          	Neighborhood.OneHop[2].Links = 1;
    169          	Neighborhood.OneHop[2].Link[0] = 0x00FE;
    170          	Neighborhood.TwoHop[0].ID = 0x00FE;
    171          #endif
    172          
    173          
    174          #ifdef NODE_6
    175          //	Neighborhood.OneHopNodes = 1;
    176          //	Neighborhood.TwoHopNodes = 0;
    177          //	Neighborhood.OneHop[0].ID = 0x000F;
    178          //	Neighborhood.OneHop[0].Links = 0;
    179          	Neighborhood.OneHopNodes = 3;
    180          	Neighborhood.TwoHopNodes = 1;
    181          	Neighborhood.OneHop[0].ID = 0x000C;
    182          	Neighborhood.OneHop[0].Links = 1;
    183          	Neighborhood.OneHop[0].Link[0] = 0x00FE;
    184          	Neighborhood.OneHop[1].ID = 0x000D;
    185          	Neighborhood.OneHop[1].Links = 1;
    186          	Neighborhood.OneHop[1].Link[0] = 0x00FE;
    187          	Neighborhood.OneHop[2].ID = 0x000B;
    188          	Neighborhood.OneHop[2].Links = 1;
    189          	Neighborhood.OneHop[2].Link[0] = 0x00FE;
    190          	Neighborhood.TwoHop[0].ID = 0x00FE;
    191          #endif
    192          
    193          #ifdef NODE_7
    194          //	Neighborhood.OneHopNodes = 1;
    195          //	Neighborhood.TwoHopNodes = 0;
    196          //	Neighborhood.OneHop[0].ID = 0x000F;
    197          //	Neighborhood.OneHop[0].Links = 0;
    198          	Neighborhood.OneHopNodes = 3;
    199          	Neighborhood.TwoHopNodes = 1;
    200          	Neighborhood.OneHop[0].ID = 0x000C;
    201          	Neighborhood.OneHop[0].Links = 1;
    202          	Neighborhood.OneHop[0].Link[0] = 0x00FE;
    203          	Neighborhood.OneHop[1].ID = 0x000D;
    204          	Neighborhood.OneHop[1].Links = 1;
    205          	Neighborhood.OneHop[1].Link[0] = 0x00FE;
    206          	Neighborhood.OneHop[2].ID = 0x000B;
    207          	Neighborhood.OneHop[2].Links = 1;
    208          	Neighborhood.OneHop[2].Link[0] = 0x00FE;
    209          	Neighborhood.TwoHop[0].ID = 0x00FE;
    210          #endif
    211          
    212          }
    213          
    214          #define ROUTE_COST_AGE_STEP	10000
    215          
    216          
    217          ///////////////////////////////////////////////
    218          /**
    219            * mpr_select - performs MPR selection
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          void mpr_select()
    222          {
   \                     mpr_select: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
    223          	int x = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    224          	int y = 0;
    225          	int z = 0;
    226          	unsigned char count[10];
    227          
    228          //	boolean uncovered;
    229          	int overcoverage;
    230          
    231          	for(x=0;x<MMCR_MAX_MPRS;x++)
   \   00000008   0xAD00             ADD      R5,SP,#+0
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable19_1
    232          	{
    233          		count[x]=0;
   \                     ??mpr_select_0: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x5541             STRB     R1,[R0, R5]
    234          		mpr_idx[x]=NO_NODE_IDX;
   \   00000012   0x1902             ADDS     R2,R0,R4
   \   00000014   0x21FF             MOVS     R1,#+255
    235          	}
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x280A             CMP      R0,#+10
   \   0000001A   0x7111             STRB     R1,[R2, #+4]
   \   0000001C   0xDBF7             BLT.N    ??mpr_select_0
    236          	for (x=0;x<MMCR_MAX_TWO_HOPS;x++)
   \   0000001E   0x.... 0x....      LDR.W    R8,??DataTable19_2
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x2100             MOVS     R1,#+0
    237          	{
    238          		Neighborhood.TwoHop[x].Covered=0;
   \                     ??mpr_select_1: (+1)
   \   00000026   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   0000002A   0x4442             ADD      R2,R2,R8
    239          	}
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x280A             CMP      R0,#+10
   \   00000030   0xF882 0x111A      STRB     R1,[R2, #+282]
   \   00000034   0xDBF7             BLT.N    ??mpr_select_1
    240          	/** MPR selection **/
    241          	// count coverage
    242          	for(x=0;x<Neighborhood.OneHopNodes;x++)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF04F 0x091C      MOV      R9,#+28
   \   0000003C   0xE000             B.N      ??mpr_select_2
   \                     ??mpr_select_3: (+1)
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \                     ??mpr_select_2: (+1)
   \   00000040   0xF8D8 0x1136      LDR      R1,[R8, #+310]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xDA1D             BGE.N    ??mpr_select_4
    243          	{
    244          		for(y=0;y<Neighborhood.OneHop[x].Links;y++)
   \   00000048   0x2700             MOVS     R7,#+0
   \   0000004A   0xFB09 0x8100      MLA      R1,R9,R0,R8
   \   0000004E   0xE014             B.N      ??mpr_select_5
    245          		{
    246          			for(z=0;z<Neighborhood.TwoHopNodes;z++)
    247          			{
    248          				if(Neighborhood.OneHop[x].Link[y] == Neighborhood.TwoHop[z].ID)
   \                     ??mpr_select_6: (+1)
   \   00000050   0xEB02 0x0C42      ADD      R12,R2,R2, LSL #+1
   \   00000054   0xEB01 0x0347      ADD      R3,R1,R7, LSL #+1
   \   00000058   0x44C4             ADD      R12,R12,R8
   \   0000005A   0xF8B3 0x3003      LDRH     R3,[R3, #+3]
   \   0000005E   0xF8BC 0x6118      LDRH     R6,[R12, #+280]
   \   00000062   0x42B3             CMP      R3,R6
   \   00000064   0xD102             BNE.N    ??mpr_select_7
    249          					count[x]++;
   \   00000066   0x5D43             LDRB     R3,[R0, R5]
   \   00000068   0x1C5B             ADDS     R3,R3,#+1
   \   0000006A   0x5543             STRB     R3,[R0, R5]
    250          			}
   \                     ??mpr_select_7: (+1)
   \   0000006C   0x1C52             ADDS     R2,R2,#+1
   \                     ??mpr_select_8: (+1)
   \   0000006E   0xF508 0x739B      ADD      R3,R8,#+310
   \   00000072   0x685B             LDR      R3,[R3, #+4]
   \   00000074   0x429A             CMP      R2,R3
   \   00000076   0xDBEB             BLT.N    ??mpr_select_6
   \   00000078   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mpr_select_5: (+1)
   \   0000007A   0x7DCA             LDRB     R2,[R1, #+23]
   \   0000007C   0x4297             CMP      R7,R2
   \   0000007E   0xDADE             BGE.N    ??mpr_select_3
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0xE7F4             B.N      ??mpr_select_8
    251          		}		
    252          	}
    253          
    254          	// 1. select singular neighbors
    255          	for(x=0;x<Neighborhood.OneHopNodes;x++)
   \                     ??mpr_select_4: (+1)
   \   00000084   0x2700             MOVS     R7,#+0
   \   00000086   0xE00C             B.N      ??mpr_select_9
    256          	{
    257          		if(count[x] == 0)
   \                     ??mpr_select_10: (+1)
   \   00000088   0x5D78             LDRB     R0,[R7, R5]
   \   0000008A   0xB948             CBNZ.N   R0,??CrossCallReturnLabel_2
    258          		{
    259          			Neighborhood.OneHop[x].flags.MPR = true;
   \   0000008C   0xFB09 0x8007      MLA      R0,R9,R7,R8
   \   00000090   0x7881             LDRB     R1,[R0, #+2]
   \   00000092   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000096   0x7081             STRB     R1,[R0, #+2]
    260          			//TODO: search for single link
    261          			Neighborhood.TwoHop[find_two_hop_node(Neighborhood.OneHop[x].Link[0])].Covered ++;
   \   00000098   0x.... 0x....      BL       ??Subroutine2_0
    262          		}
    263          	}
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000009C   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \   000000A0   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mpr_select_9: (+1)
   \   000000A2   0xF8D8 0x0136      LDR      R0,[R8, #+310]
   \   000000A6   0x4287             CMP      R7,R0
   \   000000A8   0xDBEE             BLT.N    ??mpr_select_10
    264          
    265          	// 2. selects as MPR neighbors with the largest count of uncovered twohop nodes
    266          	x=0;
   \   000000AA   0x2700             MOVS     R7,#+0
   \   000000AC   0xE012             B.N      ??mpr_select_11
    267          //	uncovered = true;
    268          	while(x<Neighborhood.OneHopNodes /*&& uncovered*/)
    269          	{
    270          		//TODO: sort high-low
    271          		if(count[x]>0)
   \                     ??mpr_select_12: (+1)
   \   000000AE   0x5D78             LDRB     R0,[R7, R5]
   \   000000B0   0xB178             CBZ.N    R0,??CrossCallReturnLabel_3
    272          		{
    273          			if(~Neighborhood.TwoHop[find_two_hop_node(Neighborhood.OneHop[x].Link[0])].Covered)
   \   000000B2   0xFB09 0x8607      MLA      R6,R9,R7,R8
   \   000000B6   0xF8B6 0x0003      LDRH     R0,[R6, #+3]
   \   000000BA   0x.... 0x....      BL       find_two_hop_node
    274          			{
    275          				Neighborhood.OneHop[x].flags.MPR = true;
   \   000000BE   0x78B0             LDRB     R0,[R6, #+2]
   \   000000C0   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000C4   0x70B0             STRB     R0,[R6, #+2]
    276          				Neighborhood.TwoHop[find_two_hop_node(Neighborhood.OneHop[x].Link[0])].Covered ++;
   \   000000C6   0xF8B6 0x0003      LDRH     R0,[R6, #+3]
   \   000000CA   0x.... 0x....      BL       find_two_hop_node
   \   000000CE   0x.... 0x....      BL       ?Subroutine1
    277          			}
    278          		}
    279          		x++;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000D2   0x1C7F             ADDS     R7,R7,#+1
    280          	}
   \                     ??mpr_select_11: (+1)
   \   000000D4   0xF8D8 0x0136      LDR      R0,[R8, #+310]
   \   000000D8   0x4287             CMP      R7,R0
   \   000000DA   0xDBE8             BLT.N    ??mpr_select_12
    281          
    282          	// 3. remove redundant nodes
    283          	for(x=0;x<Neighborhood.OneHopNodes;x++)
   \   000000DC   0x2500             MOVS     R5,#+0
   \   000000DE   0xE00E             B.N      ??mpr_select_13
    284          	{
    285          		overcoverage = 0;
    286          		for(y=0;y<Neighborhood.OneHop[x].Links;y++)
    287          		{
    288          			//for(z=0;z<10;z++)
    289          			{
    290          				if(Neighborhood.TwoHop[find_two_hop_node(Neighborhood.OneHop[x].Link[y])].Covered > 1)
    291          				{
    292          					overcoverage ++;
    293          				}
    294          			}
    295          		}
    296          		if(overcoverage == Neighborhood.OneHop[x].Links)
    297          		{
    298          			Neighborhood.OneHop[x].flags.MPR = false;
    299          			//TODO: reduce Covered
    300          			for(y=0;y<Neighborhood.OneHop[x].Links;y++)
    301          			{
    302          				Neighborhood.TwoHop[find_two_hop_node(Neighborhood.OneHop[x].Link[y])].Covered--;
   \                     ??mpr_select_14: (+1)
   \   000000E0   0x.... 0x....      BL       ?Subroutine2
    303          			}
   \                     ??CrossCallReturnLabel_6: (+1)
   \   000000E4   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   000000E8   0x4440             ADD      R0,R0,R8
   \   000000EA   0x1C7F             ADDS     R7,R7,#+1
   \   000000EC   0xF890 0x111A      LDRB     R1,[R0, #+282]
   \   000000F0   0x1E49             SUBS     R1,R1,#+1
   \   000000F2   0xF880 0x111A      STRB     R1,[R0, #+282]
   \                     ??mpr_select_15: (+1)
   \   000000F6   0x7DF0             LDRB     R0,[R6, #+23]
   \   000000F8   0x4287             CMP      R7,R0
   \   000000FA   0xDBF1             BLT.N    ??mpr_select_14
   \                     ??mpr_select_16: (+1)
   \   000000FC   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mpr_select_13: (+1)
   \   000000FE   0xF8D8 0x0136      LDR      R0,[R8, #+310]
   \   00000102   0x4285             CMP      R5,R0
   \   00000104   0xDA1C             BGE.N    ??mpr_select_17
   \   00000106   0xF04F 0x0A00      MOV      R10,#+0
   \   0000010A   0x2700             MOVS     R7,#+0
   \   0000010C   0xFB09 0x8605      MLA      R6,R9,R5,R8
   \   00000110   0xE00B             B.N      ??mpr_select_18
   \                     ??mpr_select_19: (+1)
   \   00000112   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000116   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   0000011A   0x4440             ADD      R0,R0,R8
   \   0000011C   0xF890 0x011A      LDRB     R0,[R0, #+282]
   \   00000120   0x2802             CMP      R0,#+2
   \   00000122   0xBFA8             IT       GE 
   \   00000124   0xF10A 0x0A01      ADDGE    R10,R10,#+1
   \   00000128   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mpr_select_18: (+1)
   \   0000012A   0x7DF0             LDRB     R0,[R6, #+23]
   \   0000012C   0x4287             CMP      R7,R0
   \   0000012E   0xDBF0             BLT.N    ??mpr_select_19
   \   00000130   0x4582             CMP      R10,R0
   \   00000132   0xD1E3             BNE.N    ??mpr_select_16
   \   00000134   0x78B0             LDRB     R0,[R6, #+2]
   \   00000136   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000013A   0x70B0             STRB     R0,[R6, #+2]
   \   0000013C   0x2700             MOVS     R7,#+0
   \   0000013E   0xE7DA             B.N      ??mpr_select_15
    304          		}
    305          	}
    306              mpr_count_ = 0;
   \                     ??mpr_select_17: (+1)
   \   00000140   0x2100             MOVS     R1,#+0
    307          	for(x=0;x<Neighborhood.OneHopNodes;x++)
   \   00000142   0x2200             MOVS     R2,#+0
   \   00000144   0xE009             B.N      ??mpr_select_20
    308          	{
    309          		if(Neighborhood.OneHop[x].flags.MPR)
   \                     ??mpr_select_21: (+1)
   \   00000146   0xFB09 0x8302      MLA      R3,R9,R2,R8
   \   0000014A   0x789B             LDRB     R3,[R3, #+2]
   \   0000014C   0x07DB             LSLS     R3,R3,#+31
   \   0000014E   0xD503             BPL.N    ??mpr_select_22
    310          		{
    311          			mpr_idx[mpr_count_++] = x; //Neighborhood.OneHop[x].ID;
   \   00000150   0xB2C9             UXTB     R1,R1
   \   00000152   0x190B             ADDS     R3,R1,R4
   \   00000154   0x1C49             ADDS     R1,R1,#+1
   \   00000156   0x711A             STRB     R2,[R3, #+4]
    312          		}
    313          	}
   \                     ??mpr_select_22: (+1)
   \   00000158   0x1C52             ADDS     R2,R2,#+1
   \                     ??mpr_select_20: (+1)
   \   0000015A   0x4282             CMP      R2,R0
   \   0000015C   0xDBF3             BLT.N    ??mpr_select_21
   \   0000015E   0x7021             STRB     R1,[R4, #+0]
    314          }
   \   00000160   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xEB06 0x0047      ADD      R0,R6,R7, LSL #+1
   \                     ??Subroutine2_0: (+1)
   \   00000004   0xF8B0 0x0003      LDRH     R0,[R0, #+3]
   \   00000008   0x....             B.N      find_two_hop_node

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   00000004   0x4440             ADD      R0,R0,R8
   \   00000006   0xF890 0x111A      LDRB     R1,[R0, #+282]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \   0000000C   0xF880 0x111A      STRB     R1,[R0, #+282]
   \   00000010   0x4770             BX       LR
    315          
    316          
    317          /**
    318            * neighbor_clear - setups up neighbor table
    319            */

   \                                 In section .text, align 2, keep-with-next
    320          void mmcr_neighbor_clear()
    321          {
   \                     mmcr_neighbor_clear: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    322          	int x,y;
    323          	Neighborhood.OneHopNodes = 0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable19_2
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8C4 0x0136      STR      R0,[R4, #+310]
    324          	Neighborhood.TwoHopNodes = 0;
   \   0000000C   0xF8C4 0x013A      STR      R0,[R4, #+314]
    325          	for (x=0;x<MMCR_MAX_ONE_HOPS;x++)
   \   00000010   0x2500             MOVS     R5,#+0
    326          	{
    327          		Neighborhood.OneHop[x].ID=0;
   \                     ??mmcr_neighbor_clear_0: (+1)
   \   00000012   0x201C             MOVS     R0,#+28
   \   00000014   0x4368             MULS     R0,R0,R5
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x5301             STRH     R1,[R0, R4]
    328          		Neighborhood.OneHop[x].flags_u8 = 0; // MPR=0; IAM_MPR=0; ...
   \   0000001A   0x1900             ADDS     R0,R0,R4
   \   0000001C   0x.... 0x....      BL       ?Subroutine0
    329          		Neighborhood.OneHop[x].Links=0;
    330          		Neighborhood.OneHop[x].LinkCost=0xFFFFFFFF;
    331          		for (y=0;y<MMCR_MAX_OH_LINKS;y++)
    332          			Neighborhood.OneHop[x].Link[y]=0;
    333          	}
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0x2D0A             CMP      R5,#+10
   \   00000024   0xDBF5             BLT.N    ??mmcr_neighbor_clear_0
    334          	for (x=0;x<MMCR_MAX_TWO_HOPS;x++)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x2200             MOVS     R2,#+0
    335          	{
    336          		Neighborhood.TwoHop[x].ID=0;
   \                     ??mmcr_neighbor_clear_1: (+1)
   \   0000002A   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000002E   0x1909             ADDS     R1,R1,R4
    337          		Neighborhood.TwoHop[x].Covered=0;
    338          	}
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0xF8A1 0x2118      STRH     R2,[R1, #+280]
   \   00000036   0x280A             CMP      R0,#+10
   \   00000038   0xF881 0x211A      STRB     R2,[R1, #+282]
   \   0000003C   0xDBF5             BLT.N    ??mmcr_neighbor_clear_1
    339          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x7081             STRB     R1,[R0, #+2]
   \   00000002   0x75C1             STRB     R1,[R0, #+23]
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x6181             STR      R1,[R0, #+24]
   \   0000000A   0x1CC0             ADDS     R0,R0,#+3
   \   0000000C   0x2114             MOVS     R1,#+20
   \   0000000E   0x.... 0x....      B.W      __aeabi_memclr
    340          
    341          
    342          #define ONEHOP_COST_AGE_STEP	0x10000000
    343          /**
    344            * mmcr_neighborhood_age - age the neighbor tables to remove stale ones
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          void mmcr_neighborhood_age()
    347          {
   \                     mmcr_neighborhood_age: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    348          	int x,y;
    349          //	Neighborhood.OneHopNodes = 0;
    350          //	Neighborhood.TwoHopNodes = 0;
    351          	for (x=0; x<Neighborhood.OneHopNodes; x++)
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable19_2
   \   00000008   0xE003             B.N      ??mmcr_neighborhood_age_0
    352          	{
    353          		if ( 0xFFFFFFFF - ONEHOP_COST_AGE_STEP > Neighborhood.OneHop[x].LinkCost )
    354          		{
    355          			Neighborhood.OneHop[x].LinkCost += ONEHOP_COST_AGE_STEP;
    356          		}
    357          		else
    358          		{
    359          			//Neighborhood.OneHop[x].ID=0;
    360          			Neighborhood.OneHop[x].flags_u8 = 0; // MPR=0; IAM_MPR=0; ...
   \                     ??mmcr_neighborhood_age_1: (+1)
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      BL       ?Subroutine0
    361          			Neighborhood.OneHop[x].Links=0;
    362          			Neighborhood.OneHop[x].LinkCost=0xFFFFFFFF;
    363          			for (y=0;y<10;y++)
    364          				Neighborhood.OneHop[x].Link[y]=0;
    365          		}
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mmcr_neighborhood_age_0: (+1)
   \   00000012   0xF8D4 0x0136      LDR      R0,[R4, #+310]
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xDA0B             BGE.N    ??mmcr_neighborhood_age_2
   \   0000001A   0x201C             MOVS     R0,#+28
   \   0000001C   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000020   0xF06F 0x5280      MVN      R2,#+268435456
   \   00000024   0x6981             LDR      R1,[R0, #+24]
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xD2EF             BCS.N    ??mmcr_neighborhood_age_1
   \   0000002A   0xF101 0x5180      ADD      R1,R1,#+268435456
   \   0000002E   0x6181             STR      R1,[R0, #+24]
   \   00000030   0xE7EE             B.N      ??CrossCallReturnLabel_0
    366          	}
    367          //	for (x=0;x<MMCR_MAX_TWO_HOPS;x++)
    368          //	{
    369          //		Neighborhood.TwoHop[x].ID=0;
    370          //		Neighborhood.TwoHop[x].Covered=0;
    371          //	}
    372          }
   \                     ??mmcr_neighborhood_age_2: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    373          
    374          

   \                                 In section .text, align 2, keep-with-next
    375          uint8_t find_one_hop_node(uint16_t ID)
    376          {
   \                     find_one_hop_node: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    377          	uint8_t x;
    378          	for (x=0;x<Neighborhood.OneHopNodes;x++)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable19_2
   \   00000008   0xE000             B.N      ??find_one_hop_node_0
   \                     ??find_one_hop_node_1: (+1)
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \                     ??find_one_hop_node_0: (+1)
   \   0000000C   0xB2C9             UXTB     R1,R1
   \   0000000E   0xF8D2 0x4136      LDR      R4,[R2, #+310]
   \   00000012   0x460B             MOV      R3,R1
   \   00000014   0x42A3             CMP      R3,R4
   \   00000016   0xDA07             BGE.N    ??find_one_hop_node_2
    379          	{
    380          		if(Neighborhood.OneHop[x].ID == ID)
   \   00000018   0x241C             MOVS     R4,#+28
   \   0000001A   0xFB04 0x2303      MLA      R3,R4,R3,R2
   \   0000001E   0x881B             LDRH     R3,[R3, #+0]
   \   00000020   0x4283             CMP      R3,R0
   \   00000022   0xD1F2             BNE.N    ??find_one_hop_node_1
    381          			return x;
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0xBD10             POP      {R4,PC}
    382          	}
    383          	return NO_NODE_IDX;
   \                     ??find_one_hop_node_2: (+1)
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    384          }
    385          

   \                                 In section .text, align 2, keep-with-next
    386          uint8_t find_two_hop_node(uint16_t ID)
    387          {
   \                     find_two_hop_node: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    388          	uint8_t x;
    389          	for (x=0;x<Neighborhood.TwoHopNodes;x++)
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable19_2
   \   00000008   0xE000             B.N      ??find_two_hop_node_0
   \                     ??find_two_hop_node_1: (+1)
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \                     ??find_two_hop_node_0: (+1)
   \   0000000C   0xF8D2 0x413A      LDR      R4,[R2, #+314]
   \   00000010   0xB2C9             UXTB     R1,R1
   \   00000012   0x42A1             CMP      R1,R4
   \   00000014   0xDA08             BGE.N    ??find_two_hop_node_2
    390          	{
    391          		if(Neighborhood.TwoHop[x].ID == ID)
   \   00000016   0xEB01 0x0341      ADD      R3,R1,R1, LSL #+1
   \   0000001A   0x189B             ADDS     R3,R3,R2
   \   0000001C   0xF8B3 0x3118      LDRH     R3,[R3, #+280]
   \   00000020   0x4283             CMP      R3,R0
   \   00000022   0xD1F2             BNE.N    ??find_two_hop_node_1
    392          			return x;
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0xBD10             POP      {R4,PC}
    393          	}
    394          	return NO_NODE_IDX;
   \                     ??find_two_hop_node_2: (+1)
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    395          }
    396          

   \                                 In section .text, align 2, keep-with-next
    397          uint8_t add_one_hop_node(uint8_t ID, uint16_t link_factor)
    398          {
   \                     add_one_hop_node: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    399          	uint8_t y;
    400          	if ( MMCR_MAX_ONE_HOPS == Neighborhood.OneHopNodes)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable19_2
   \   00000006   0xF8D2 0x4136      LDR      R4,[R2, #+310]
   \   0000000A   0x2C0A             CMP      R4,#+10
   \   0000000C   0xD101             BNE.N    ??add_one_hop_node_0
    401          	{
    402          		return NO_NODE_IDX;
   \   0000000E   0x20FF             MOVS     R0,#+255
   \   00000010   0xBD10             POP      {R4,PC}
    403          	}
    404          	Neighborhood.OneHop[Neighborhood.OneHopNodes].ID = ID;
   \                     ??add_one_hop_node_0: (+1)
   \   00000012   0x231C             MOVS     R3,#+28
   \   00000014   0xFB03 0x2404      MLA      R4,R3,R4,R2
   \   00000018   0x8020             STRH     R0,[R4, #+0]
    405          	Neighborhood.OneHop[Neighborhood.OneHopNodes].flags.MPR = false;
   \   0000001A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000001E   0x7884             LDRB     R4,[R0, #+2]
   \   00000020   0xF004 0x04FE      AND      R4,R4,#0xFE
   \   00000024   0x7084             STRB     R4,[R0, #+2]
    406          	Neighborhood.OneHop[Neighborhood.OneHopNodes].Links = 0;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000002C   0x75C4             STRB     R4,[R0, #+23]
    407          	Neighborhood.OneHop[Neighborhood.OneHopNodes].LinkCost = link_factor;
    408          	// Redundant - the count (Links) is sufficient
    409          	for (y=0;y<MMCR_MAX_TWO_HOPS;y++)
   \   0000002E   0x24FF             MOVS     R4,#+255
   \   00000030   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000034   0x6181             STR      R1,[R0, #+24]
   \   00000036   0x2000             MOVS     R0,#+0
    410          	{
    411          		Neighborhood.OneHop[Neighborhood.OneHopNodes].Link[y] = NO_NODE_IDX;
   \                     ??add_one_hop_node_1: (+1)
   \   00000038   0xF8D2 0x1136      LDR      R1,[R2, #+310]
   \   0000003C   0xFB03 0x2101      MLA      R1,R3,R1,R2
   \   00000040   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
    412          	}
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x280A             CMP      R0,#+10
   \   00000048   0xF8A1 0x4003      STRH     R4,[R1, #+3]
   \   0000004C   0xDBF4             BLT.N    ??add_one_hop_node_1
    413          	// Return current index and then increment neighbor count
    414          	return Neighborhood.OneHopNodes++;
   \   0000004E   0xF8D2 0x0136      LDR      R0,[R2, #+310]
   \   00000052   0x1C41             ADDS     R1,R0,#+1
   \   00000054   0xF8C2 0x1136      STR      R1,[R2, #+310]
   \   00000058   0xB2C0             UXTB     R0,R0
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    415          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xF8D2 0x0136      LDR      R0,[R2, #+310]
   \   00000004   0xFB03 0x2000      MLA      R0,R3,R0,R2
   \   00000008   0x4770             BX       LR
    416          
    417          // Return: two hop node index

   \                                 In section .text, align 2, keep-with-next
    418          uint8_t add_two_hop_node(uint8_t one_hop_idx, uint8_t two_hop_id)
    419          {
   \                     add_two_hop_node: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
    420          	uint8_t lidx = NO_NODE_IDX;
    421          	uint8_t x = find_two_hop_node(two_hop_id);
   \   00000006   0x4638             MOV      R0,R7
   \   00000008   0x.... 0x....      BL       find_two_hop_node
   \   0000000C   0x4606             MOV      R6,R0
    422          	if (NO_NODE_IDX == x)
   \   0000000E   0x2EFF             CMP      R6,#+255
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable19_2
   \   00000014   0xD116             BNE.N    ??add_two_hop_node_0
    423          	{
    424          		if (MMCR_MAX_TWO_HOPS == Neighborhood.TwoHopNodes)
   \   00000016   0xF8D5 0x013A      LDR      R0,[R5, #+314]
   \   0000001A   0x280A             CMP      R0,#+10
   \   0000001C   0xD01F             BEQ.N    ??add_two_hop_node_1
    425          		{
    426          			return NO_NODE_IDX;
    427          		}
    428          		Neighborhood.TwoHop[Neighborhood.TwoHopNodes].ID = two_hop_id;
   \   0000001E   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   00000022   0x1940             ADDS     R0,R0,R5
    429          		Neighborhood.TwoHop[Neighborhood.TwoHopNodes].Covered = 0;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xF8A0 0x7118      STRH     R7,[R0, #+280]
   \   0000002A   0xF8D5 0x013A      LDR      R0,[R5, #+314]
   \   0000002E   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   00000032   0x1940             ADDS     R0,R0,R5
   \   00000034   0xF880 0x111A      STRB     R1,[R0, #+282]
    430          		x = Neighborhood.TwoHopNodes++;
   \   00000038   0xF8D5 0x013A      LDR      R0,[R5, #+314]
   \   0000003C   0x4606             MOV      R6,R0
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xF8C5 0x013A      STR      R0,[R5, #+314]
    431          	}
    432          	// Add two hop link
    433          	lidx = find_link(one_hop_idx, x);
   \                     ??add_two_hop_node_0: (+1)
   \   00000044   0xB2F1             UXTB     R1,R6
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       find_link
    434          	if (NO_NODE_IDX == lidx)
   \   0000004C   0x211C             MOVS     R1,#+28
   \   0000004E   0x28FF             CMP      R0,#+255
   \   00000050   0xFB01 0x5104      MLA      R1,R1,R4,R5
   \   00000054   0xB2F6             UXTB     R6,R6
   \   00000056   0xD10C             BNE.N    ??add_two_hop_node_2
   \   00000058   0x7DC8             LDRB     R0,[R1, #+23]
   \   0000005A   0x280A             CMP      R0,#+10
   \   0000005C   0xD101             BNE.N    ??add_two_hop_node_3
    435          	{
    436          		if (MMCR_MAX_TWO_HOPS == Neighborhood.OneHop[one_hop_idx].Links)
    437          		{
    438          			return NO_NODE_IDX; // no space left
   \                     ??add_two_hop_node_1: (+1)
   \   0000005E   0x20FF             MOVS     R0,#+255
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}
    439          		}
    440          		Neighborhood.OneHop[one_hop_idx].Link[Neighborhood.OneHop[one_hop_idx].Links] = x;
   \                     ??add_two_hop_node_3: (+1)
   \   00000062   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \   00000066   0xF8A0 0x6003      STRH     R6,[R0, #+3]
    441          		lidx = Neighborhood.OneHop[one_hop_idx].Links++;
   \   0000006A   0x7DC8             LDRB     R0,[R1, #+23]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x75C8             STRB     R0,[R1, #+23]
   \   00000070   0xE003             B.N      ??add_two_hop_node_4
    442          	}
    443          	else
    444          	{
    445          		Neighborhood.OneHop[one_hop_idx].Link[lidx] = x;
   \                     ??add_two_hop_node_2: (+1)
   \   00000072   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \   00000076   0xF8A0 0x6003      STRH     R6,[R0, #+3]
    446          	}
    447          	return x;
   \                     ??add_two_hop_node_4: (+1)
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    448          }
    449          //uint8_t add_one_hop_node(uint8_t ID, uint16_t link_factor)
    450          //uint8_t add_two_hop_node(uint8_t one_hop_idx, uint8_t two_hop_id)
    451          

   \                                 In section .text, align 2, keep-with-next
    452          uint8_t find_link(uint8_t one_idx, uint8_t two_idx)
    453          {
   \                     find_link: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    454          	uint8_t i;
    455          	for( i=0; i<Neighborhood.OneHop[one_idx].Links; i++)
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable19_2
   \   00000006   0x241C             MOVS     R4,#+28
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xFB04 0x3000      MLA      R0,R4,R0,R3
   \   0000000E   0xE000             B.N      ??find_link_0
   \                     ??find_link_1: (+1)
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \                     ??find_link_0: (+1)
   \   00000012   0x7DC3             LDRB     R3,[R0, #+23]
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x429A             CMP      R2,R3
   \   00000018   0xD207             BCS.N    ??find_link_2
    456          	{
    457          		if (two_idx == Neighborhood.OneHop[one_idx].Link[i])
   \   0000001A   0xEB00 0x0442      ADD      R4,R0,R2, LSL #+1
   \   0000001E   0xF8B4 0x4003      LDRH     R4,[R4, #+3]
   \   00000022   0x42A1             CMP      R1,R4
   \   00000024   0xD1F4             BNE.N    ??find_link_1
    458          		{
    459          			return i;
   \   00000026   0x4610             MOV      R0,R2
   \   00000028   0xBD10             POP      {R4,PC}
    460          		}
    461          	}
    462          	return NO_NODE_IDX;
   \                     ??find_link_2: (+1)
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    463          }
    464          
    465          ///////////////////////////////////////////////
    466          ///////////////////////////////////////////////
    467          
    468          ///////////////////////////////////////////////
    469          ///////////////////////////////////////////////
    470          /**
    471            * startRouteSearch - starts the route discovery procedure
    472            *
    473            *
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          void mmcr_startRouteSearch ( uint8_t *dst )
    476          {
   \                     mmcr_startRouteSearch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    477          	if ( ( 0 < mmcr_Hello_countdown_ ) || ( MMCR_STATE_IDLE != mmcr_state_ ) )
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable19
   \   00000006   0x78E0             LDRB     R0,[R4, #+3]
   \   00000008   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000A   0x4308             ORRS     R0,R1,R0
   \   0000000C   0xD109             BNE.N    ??mmcr_startRouteSearch_0
    478          	{
    479          			return;
    480          	}
    481          
    482          	// ###############################
    483          	// start route Discovery toward BS
    484          	//mmcr_route_search_BS_ = *dst;
    485          	
    486          	// OR only age the tables/costs
    487          	//mmcr_neighbor_clear();
    488          	//mmcr_neighborhood_age();
    489          		
    490          	rtr_MMCR_Hello_Phase();
   \   0000000E   0x.... 0x....      BL       rtr_MMCR_Hello_Phase
    491          
    492          	mmcr_Hello_countdown_ = MMCR_DEFAULT_ROUTE_SEARCH_ON_REPETITIONS;
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0x70E0             STRB     R0,[R4, #+3]
    493          	mmcr_state_ = MMCR_STATE_ROUTE_DISCOVERY;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x70A0             STRB     R0,[R4, #+2]
    494          	
    495          	mmcr_set_tx_timeout ( 10 );
   \   0000001A   0x200A             MOVS     R0,#+10
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x....             B.N      mmcr_set_tx_timeout
   \                     ??mmcr_startRouteSearch_0: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    496          	
    497          
    498          }
    499          ///////////////////////////////////////////////
    500          ///////////////////////////////////////////////
    501          
    502          ///////////////////////////////////////////////
    503          ///////////////////////////////////////////////
    504          /**
    505            * rtr_MMCR_Hello_Phase() - handles the routing phase of transmitting HELLO pkts
    506            */

   \                                 In section .text, align 2, keep-with-next
    507          void rtr_MMCR_Hello_Phase()
    508          {
   \                     rtr_MMCR_Hello_Phase: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    509          	//int a;
    510          //	if ( ROUTING_PROTOCOL_MMCR == my_protocol_ )
    511          	{
    512          		// Send HELLO routing packet
    513          // MZ: Why??		if ( 1 == mmcr_request_send_HELLO_ )
    514          		{
    515          //			uint8_t packet[RTR_MMCR_HELLO_PKT_SIZE];
    516          			uint16_t len = mmcr_sendHELLO ( (hpkt_mmcr_t XDATA*)packet );
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable19_3
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       mmcr_sendHELLO
    517          
    518          			/*a = */ sendPriorityPacket ( len, packet, MAC_BROADCAST );
   \   0000000C   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x.... 0x....      BL       sendPriorityPacket
    519          			my_energy_ = my_energy_ - HELLO_LENGTH;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19_4
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x3912             SUBS     R1,R1,#+18
   \   00000020   0x6001             STR      R1,[R0, #+0]
    520          
    521          //			mmcr_request_send_HELLO_ = 0;
    522          		}
    523          	}
    524          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    525          
    526          
    527          
    528          ///////////////////////////////////////////////
    529          ///////////////////////////////////////////////
    530          /**
    531            * mmcr_sendHELLO - broadcasts a HELLO packet
    532            */

   \                                 In section .text, align 2, keep-with-next
    533          unsigned int mmcr_sendHELLO ( hpkt_mmcr_t XDATA*hello_pkt )
    534          {
    535          //	int len = PKT_HEADER_LENGTH; // size of the packet header (start + flag + dst(2) + src(2) + len)
    536          
    537          	hpkt_mmcr_t XDATA *hpkt = ( ( hpkt_mmcr_t XDATA * ) hello_pkt);
    538          
    539          	hpkt->start = START_BYTE;
   \                     mmcr_sendHELLO: (+1)
   \   00000000   0x2142             MOVS     R1,#+66
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    540          	hpkt->flags = FLAG_HELLO_MMCR;  // HELLO_MMCR packet
   \   00000004   0x216A             MOVS     R1,#+106
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    541          	hpkt->mac_dst = ENDIAN16(MAC_BROADCAST); // Broadcast
   \   00000008   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000C   0x8041             STRH     R1,[R0, #+2]
    542          	hpkt->mac_src = ENDIAN16(MY_ADDR);
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000012   0x780A             LDRB     R2,[R1, #+0]
   \   00000014   0x0212             LSLS     R2,R2,#+8
   \   00000016   0x8082             STRH     R2,[R0, #+4]
    543          
    544          	// FILL END-TO-END ADDRESSING
    545          	hpkt->dst_id = 0xFF;
   \   00000018   0x22FF             MOVS     R2,#+255
   \   0000001A   0x71C2             STRB     R2,[R0, #+7]
    546          	hpkt->src_id = MY_ADDR;
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x7201             STRB     R1,[R0, #+8]
    547          	hpkt->length = HELLO_LENGTH_MMCR - PKT_HEADER_LENGTH;;
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x7181             STRB     R1,[R0, #+6]
    548          
    549          	// FILL THE MMCR field
    550          	hpkt->energy=ENDIAN32(my_energy_);
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19_4
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x0A0A             LSRS     R2,R1,#+8
   \   0000002C   0xF402 0x427F      AND      R2,R2,#0xFF00
   \   00000030   0x020B             LSLS     R3,R1,#+8
   \   00000032   0xEA42 0x6211      ORR      R2,R2,R1, LSR #+24
   \   00000036   0xF403 0x037F      AND      R3,R3,#0xFF0000
   \   0000003A   0x431A             ORRS     R2,R3,R2
   \   0000003C   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000040   0xF8C0 0x1009      STR      R1,[R0, #+9]
    551          
    552          	// FILL the CHECKSUM
    553          	// TODO: calculate checksum
    554          	hpkt->crc = 65;
   \   00000044   0x2141             MOVS     R1,#+65
   \   00000046   0x7341             STRB     R1,[R0, #+13]
    555          
    556          	return HELLO_LENGTH_MMCR;
   \   00000048   0x200E             MOVS     R0,#+14
   \   0000004A   0x4770             BX       LR               ;; return
    557          }
    558          ///////////////////////////////////////////////
    559          ///////////////////////////////////////////////
    560          /**
    561            * mmcr_recvHELLO - handles a received HELLO packet
    562            * should identify if this node is potential relay node
    563            * if yes, then send response (ACK?)
    564            */
    565          #ifdef _ARM_
    566          #pragma optimize=none
    567          #endif // _ARM_

   \                                 In section .text, align 2, keep-with-next
    568          unsigned int mmcr_recvHELLO ( hpkt_mmcr_t XDATA *hp )
    569          {
   \                     mmcr_recvHELLO: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    570          
    571          	unsigned long int link_factor, i=0;
   \   00000006   0x2600             MOVS     R6,#+0
    572          	//uint16_t	mac_src = ENDIAN16(hp->mac_src);
    573          	//uint16_t t = 0x0000;
    574          //	uint16_t hop_mac = Neighborhood.OneHop[0].ID;
    575          //	uint8_t j;
    576          	uint32_t energy = ENDIAN32(hp->energy);
   \   00000008   0xF8D4 0x0009      LDR      R0,[R4, #+9]
   \   0000000C   0xF8D4 0x1009      LDR      R1,[R4, #+9]
   \   00000010   0x0A09             LSRS     R1,R1,#+8
   \   00000012   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \   00000016   0xEA51 0x6010      ORRS     R0,R1,R0, LSR #+24
   \   0000001A   0xF8D4 0x1009      LDR      R1,[R4, #+9]
   \   0000001E   0x0209             LSLS     R1,R1,#+8
   \   00000020   0xF411 0x017F      ANDS     R1,R1,#0xFF0000
   \   00000024   0x4308             ORRS     R0,R1,R0
   \   00000026   0xF8D4 0x1009      LDR      R1,[R4, #+9]
   \   0000002A   0xEA50 0x6701      ORRS     R7,R0,R1, LSL #+24
    577          	long int delay = TYPICAL_DELAY_FOR_LINK;
   \   0000002E   0xF05F 0x0801      MOVS     R8,#+1
    578          //	int channel_i;
    579          
    580          	if (ENDIAN16(hp->mac_src) == MY_ADDR)
   \   00000032   0x88A0             LDRH     R0,[R4, #+4]
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x88A1             LDRH     R1,[R4, #+4]
   \   0000003C   0x0209             LSLS     R1,R1,#+8
   \   0000003E   0xF411 0x417F      ANDS     R1,R1,#0xFF00
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0x....             LDR.N    R1,??DataTable19_5
   \   00000046   0x7809             LDRB     R1,[R1, #+0]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD106             BNE.N    ??mmcr_recvHELLO_0
    581          	{
    582          	  	cs_req_switch (MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL), CHANNEL_SWITCH_DELAY);
                 	  	^
Warning[Pe223]: function "cs_req_switch" declared implicitly
   \   0000004C   0xF44F 0x61FA      MOV      R1,#+2000
   \   00000050   0x2015             MOVS     R0,#+21
   \   00000052   0x.... 0x....      BL       cs_req_switch
    583          		//mmcr_ch_counter = 0;
    584          		//mmcr_rf_ch_sw(&mmcr_return_ch);
    585          		//channel_i = mmcr_sendSwitch((tpkt_t_mmcr*)hp); // Workaround to compiler issues
    586          		//channel_i = mmcr_sendSwitch((tpkt_t_mmcr*)hp);
    587          		//mmcr_return_ch = channel_i;
    588          //		phy_set_RF_channel(channel_i);
    589          //        routing_init_MMCR();
    590          		return 1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xE02F             B.N      ??mmcr_recvHELLO_1
    591          	}
    592          
    593          ////////////////////////////////////////////////////////
    594          //if ((hp->mac_src == 0x000A)||(hp->mac_src == 0x000F))
    595           //return 1;
    596          
    597          ///////////////////////////////////////////////////////// For block hello packet from source A
    598          
    599          	if (ENERGY_MAX_VALUE < energy)
   \                     ??mmcr_recvHELLO_0: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable19_6  ;; 0x2ab99
   \   0000005C   0x4287             CMP      R7,R0
   \   0000005E   0xD301             BCC.N    ??mmcr_recvHELLO_2
    600          		energy = ENERGY_MAX_VALUE;
   \   00000060   0x....             LDR.N    R0,??DataTable19_7  ;; 0x2ab98
   \   00000062   0x0007             MOVS     R7,R0
    601          	link_factor = ( energy * MMCR_BANDWIDTH_FACTOR * DELAY_SCALING ) / (delay);
   \                     ??mmcr_recvHELLO_2: (+1)
   \   00000064   0x2064             MOVS     R0,#+100
   \   00000066   0xFB00 0xF007      MUL      R0,R0,R7
   \   0000006A   0xFBB0 0xF0F8      UDIV     R0,R0,R8
   \   0000006E   0x0005             MOVS     R5,R0
    602          
    603          	i = find_one_hop_node(ENDIAN16(hp->mac_src));
   \   00000070   0x88A0             LDRH     R0,[R4, #+4]
   \   00000072   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000074   0x88A1             LDRH     R1,[R4, #+4]
   \   00000076   0x0209             LSLS     R1,R1,#+8
   \   00000078   0xEA51 0x2010      ORRS     R0,R1,R0, LSR #+8
   \   0000007C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007E   0x.... 0x....      BL       find_one_hop_node
   \   00000082   0x0006             MOVS     R6,R0
    604          	if ( NO_NODE_IDX != i )
   \   00000084   0x2EFF             CMP      R6,#+255
   \   00000086   0xD005             BEQ.N    ??mmcr_recvHELLO_3
    605          	{
    606          		Neighborhood.OneHop[i].LinkCost = link_factor;
   \   00000088   0x....             LDR.N    R0,??DataTable19_2
   \   0000008A   0x211C             MOVS     R1,#+28
   \   0000008C   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000090   0x6185             STR      R5,[R0, #+24]
   \   00000092   0xE008             B.N      ??mmcr_recvHELLO_4
    607          	}
    608          	else
    609          	{
    610          		i = add_one_hop_node(ENDIAN16(hp->mac_src), link_factor);
   \                     ??mmcr_recvHELLO_3: (+1)
   \   00000094   0x0029             MOVS     R1,R5
   \   00000096   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000098   0x88A0             LDRH     R0,[R4, #+4]
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0x0A00             LSRS     R0,R0,#+8
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x.... 0x....      BL       add_one_hop_node
   \   000000A4   0x0006             MOVS     R6,R0
    611          	}
    612          // NOT PRESENT IN HELLO
    613          	/*
    614          	// For all one-hop neighbors of the sender add to Two hop neighberhood
    615          	for (j=0; j< hello_node_count; j++)
    616          	{
    617          		add_two_hop_node(i, two_hop_id);
    618          	}
    619          */
    620          	sch_create_timeout(rtc_get_ticks()+5, mmcr_sendACK, (uint8_t XDATA*)hp, str_MMCR_sendACK);
   \                     ??mmcr_recvHELLO_4: (+1)
   \   000000A6   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   000000AA   0x....             LDR.N    R3,??DataTable19_8
   \   000000AC   0x0022             MOVS     R2,R4
   \   000000AE   0x.... 0x....      ADR.W    R1,mmcr_sendACK
   \   000000B2   0x1D40             ADDS     R0,R0,#+5
   \   000000B4   0x.... 0x....      BL       sch_create_timeout
    621          	//mmcr_sendACK( (hpkt_mmcr_t XDATA *) hp);
    622          	return 1;
   \   000000B8   0x2001             MOVS     R0,#+1
   \                     ??mmcr_recvHELLO_1: (+1)
   \   000000BA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    623          
    624          }
    625          
    626          
    627          ///////////////////////////////////////////////
    628          ///////////////////////////////////////////////
    629          /**
    630            * mmcr_sendACK - handles a sending of ACK packet
    631            * collects all info for packet
    632            * prepares timestamp
    633            */

   \                                 In section .text, align 4, keep-with-next
    634          void mmcr_sendACK ( uint8_t XDATA * p)
    635          {
   \                     mmcr_sendACK: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    636          	uint8_t i;
    637          	hpkt_mmcr_t XDATA* hp = (hpkt_mmcr_t XDATA*)p;
    638          //	long int delay = TYPICAL_DELAY_FOR_LINK;
    639          
    640          	apkt_t_mmcr *ap = ( (apkt_t_mmcr *) packet );
    641          	IAR_PACKED	uint16_t *pkt_neighbor_addr = (uint16_t *)&(ap->neighbor_addr_first);
   \   00000002   0x....             LDR.N    R1,??DataTable19_3
    642          	uint32_t *pkt_neighbor_cost = NULL;
    643          	uint8_t *pkt_crc;
    644          
    645          	ap->start = START_BYTE;
   \   00000004   0x2342             MOVS     R3,#+66
   \   00000006   0x700B             STRB     R3,[R1, #+0]
    646          	ap->flags = FLAG_ACK_MMCR;
    647          	ap->mac_dst = hp->mac_src;	 //MAC DST
    648          	ap->mac_src = ENDIAN16(MY_ADDR); 		// MAC SRC
    649          
    650          	ap->length = 15 + (Neighborhood.OneHopNodes*6);		
   \   00000008   0x2606             MOVS     R6,#+6
   \   0000000A   0x236B             MOVS     R3,#+107
   \   0000000C   0x704B             STRB     R3,[R1, #+1]
   \   0000000E   0xF101 0x020E      ADD      R2,R1,#+14
   \   00000012   0x8883             LDRH     R3,[R0, #+4]
   \   00000014   0x804B             STRH     R3,[R1, #+2]
   \   00000016   0x....             LDR.N    R3,??DataTable19_5
   \   00000018   0x781D             LDRB     R5,[R3, #+0]
   \   0000001A   0x022B             LSLS     R3,R5,#+8
   \   0000001C   0x808B             STRH     R3,[R1, #+4]
   \   0000001E   0x....             LDR.N    R3,??DataTable19_2
   \   00000020   0xF8D3 0x4136      LDR      R4,[R3, #+310]
   \   00000024   0x4366             MULS     R6,R6,R4
   \   00000026   0x360F             ADDS     R6,R6,#+15
   \   00000028   0x718E             STRB     R6,[R1, #+6]
    651          
    652          	ap->dst_id = hp->src_id;
   \   0000002A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000002C   0x71C8             STRB     R0,[R1, #+7]
    653          	ap->src_id = MY_ADDR;
   \   0000002E   0x720D             STRB     R5,[R1, #+8]
    654          
    655          	ap->energy = ENDIAN32(my_energy_);
    656          
    657          	ap->neighbor_count=Neighborhood.OneHopNodes;
   \   00000030   0x734C             STRB     R4,[R1, #+13]
    658          
    659          	for(i=0;i<Neighborhood.OneHopNodes;i++)
   \   00000032   0x2400             MOVS     R4,#+0
   \   00000034   0x....             LDR.N    R0,??DataTable19_4
   \   00000036   0x6805             LDR      R5,[R0, #+0]
   \   00000038   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000003C   0xF8C1 0x5009      STR      R5,[R1, #+9]
   \   00000040   0xE00F             B.N      ??mmcr_sendACK_0
    660          	{
    661          		*pkt_neighbor_addr = ENDIAN16(Neighborhood.OneHop[i].ID);
   \                     ??mmcr_sendACK_1: (+1)
   \   00000042   0x251C             MOVS     R5,#+28
   \   00000044   0x4365             MULS     R5,R5,R4
    662          		pkt_neighbor_addr++;
    663          		pkt_neighbor_cost = (uint32_t *)pkt_neighbor_addr;
    664          		*pkt_neighbor_cost = ENDIAN32(Neighborhood.OneHop[i].LinkCost);
    665          		pkt_neighbor_addr +=2;
    666          	}
   \   00000046   0x1C64             ADDS     R4,R4,#+1
   \   00000048   0x5AEE             LDRH     R6,[R5, R3]
   \   0000004A   0x0237             LSLS     R7,R6,#+8
   \   0000004C   0xEA47 0x2616      ORR      R6,R7,R6, LSR #+8
   \   00000050   0x18ED             ADDS     R5,R5,R3
   \   00000052   0xF822 0x6B02      STRH     R6,[R2], #+2
   \   00000056   0xB2E4             UXTB     R4,R4
   \   00000058   0x69AD             LDR      R5,[R5, #+24]
   \   0000005A   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000005E   0xF842 0x5B04      STR      R5,[R2], #+4
   \                     ??mmcr_sendACK_0: (+1)
   \   00000062   0xF8D3 0x5136      LDR      R5,[R3, #+310]
   \   00000066   0x42AC             CMP      R4,R5
   \   00000068   0xDBEB             BLT.N    ??mmcr_sendACK_1
    667          
    668          	pkt_crc = (uint8_t *)pkt_neighbor_addr;
    669          	*pkt_crc = STOP_BYTE;
   \   0000006A   0x2341             MOVS     R3,#+65
   \   0000006C   0x7013             STRB     R3,[R2, #+0]
    670          
    671          	my_energy_ = my_energy_ - ap->length;
   \   0000006E   0x6802             LDR      R2,[R0, #+0]
   \   00000070   0x798B             LDRB     R3,[R1, #+6]
   \   00000072   0x1AD2             SUBS     R2,R2,R3
   \   00000074   0x6002             STR      R2,[R0, #+0]
    672          
    673          
    674          	sendPriorityPacket ( ap->length, (char XDATA*) ap, MAC_BROADCAST );//ap->mac_dst );
   \   00000076   0x4618             MOV      R0,R3
   \   00000078   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   0000007C   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000080   0x.... 0x....      B.W      sendPriorityPacket
    675          	//mmcr_count_ack_tx_++;
    676          	return;
    677          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x0A2E             LSRS     R6,R5,#+8
   \   00000002   0xF406 0x467F      AND      R6,R6,#0xFF00
   \   00000006   0x022F             LSLS     R7,R5,#+8
   \   00000008   0xEA46 0x6615      ORR      R6,R6,R5, LSR #+24
   \   0000000C   0xF407 0x077F      AND      R7,R7,#0xFF0000
   \   00000010   0x433E             ORRS     R6,R7,R6
   \   00000012   0xEA46 0x6505      ORR      R5,R6,R5, LSL #+24
   \   00000016   0x4770             BX       LR
    678          ///////////////////////////////////////////////
    679          ///////////////////////////////////////////////
    680          /**
    681            * mmcr_revcACK - handles a received ACK packet
    682            * should identify if this node is potential relay node
    683            * if yes, then send response (ACK?)
    684            */

   \                                 In section .text, align 2, keep-with-next
    685          unsigned int mmcr_recvACK (apkt_t_mmcr *apkt )
    686          {
   \                     mmcr_recvACK: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
    687          	apkt_t_mmcr XDATA *ap = (( apkt_t_mmcr XDATA * ) apkt);
    688          	long int delay = TYPICAL_DELAY_FOR_LINK;
    689          	unsigned long int link_factor;
    690          	uint32_t energy = ENDIAN32(ap->energy);
    691          	IAR_PACKED uint16_t *pkt_neighbor_addr = (uint16_t *)&(ap->neighbor_addr_first);
   \   00000006   0xF104 0x050E      ADD      R5,R4,#+14
   \   0000000A   0xF8D4 0x0009      LDR      R0,[R4, #+9]
   \   0000000E   0x0A01             LSRS     R1,R0,#+8
   \   00000010   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   00000014   0x0202             LSLS     R2,R0,#+8
   \   00000016   0xEA41 0x6110      ORR      R1,R1,R0, LSR #+24
   \   0000001A   0xF402 0x027F      AND      R2,R2,#0xFF0000
   \   0000001E   0x4311             ORRS     R1,R2,R1
   \   00000020   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
    692          	uint32_t *pkt_neighbor_cost = NULL;
    693          	uint8_t i,j;
    694          	uint8_t two_hop_id;
    695          	//if (0 == mmcr_Hello_countdown_) return 1; // do not receive ACK if I have not sent HELLO
    696          	
    697          	if (ENERGY_MAX_VALUE < energy)
   \   00000024   0x....             LDR.N    R1,??DataTable19_6  ;; 0x2ab99
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xBF28             IT       CS 
   \   0000002A   0x....             LDRCS.N  R0,??DataTable19_7  ;; 0x2ab98
    698          		energy = ENERGY_MAX_VALUE;
    699          	link_factor = ( energy * MMCR_BANDWIDTH_FACTOR * DELAY_SCALING ) / (delay);
   \   0000002C   0x2164             MOVS     R1,#+100
   \   0000002E   0xFB01 0xF600      MUL      R6,R1,R0
    700          
    701          	i = find_one_hop_node(ap->src_id);
   \   00000032   0x7A20             LDRB     R0,[R4, #+8]
   \   00000034   0x.... 0x....      BL       find_one_hop_node
    702          	if ( NO_NODE_IDX != i )
   \   00000038   0x28FF             CMP      R0,#+255
   \   0000003A   0x4680             MOV      R8,R0
   \   0000003C   0xD003             BEQ.N    ??mmcr_recvACK_0
    703          	{
    704          		Neighborhood.OneHop[i].LinkCost = link_factor;
   \   0000003E   0x.... 0x....      BL       ?Subroutine5
    705          	}
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000042   0x6186             STR      R6,[R0, #+24]
   \   00000044   0xE004             B.N      ??mmcr_recvACK_1
    706          	else
    707          	{
    708          		i = add_one_hop_node(ap->src_id, link_factor);
   \                     ??mmcr_recvACK_0: (+1)
   \   00000046   0x7A20             LDRB     R0,[R4, #+8]
   \   00000048   0xB2B1             UXTH     R1,R6
   \   0000004A   0x.... 0x....      BL       add_one_hop_node
   \   0000004E   0x4680             MOV      R8,R0
    709          	}
    710          // For all one-hop neighbors of the sender add to Two hop neighberhood
    711          	for (j=0; j< ap->neighbor_count; j++)
   \                     ??mmcr_recvACK_1: (+1)
   \   00000050   0x2700             MOVS     R7,#+0
   \   00000052   0x.... 0x....      LDR.W    R9,??DataTable19_5
   \   00000056   0xE025             B.N      ??mmcr_recvACK_2
    712          	{
    713          		two_hop_id = ENDIAN16(*pkt_neighbor_addr);
   \                     ??mmcr_recvACK_3: (+1)
   \   00000058   0x8828             LDRH     R0,[R5, #+0]
   \   0000005A   0xEA4F 0x2A10      LSR      R10,R0,#+8
    714          		if (MY_ADDR != two_hop_id)
   \   0000005E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000062   0x4550             CMP      R0,R10
   \   00000064   0xD01C             BEQ.N    ??mmcr_recvACK_4
    715          		{
    716          			pkt_neighbor_cost = (uint32_t *)(pkt_neighbor_addr+1);
   \   00000066   0xF105 0x0B02      ADD      R11,R5,#+2
    717          			add_two_hop_node(i, two_hop_id);
   \   0000006A   0x4651             MOV      R1,R10
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       add_two_hop_node
    718          			// Is it the right way/place to do it? - Maybe after MPR selection?
    719          			mmcr_set_route(two_hop_id, ENDIAN16(ap->mac_src), link_factor + ENDIAN32(*pkt_neighbor_cost));
                 			^
Warning[Pe223]: function "mmcr_set_route" declared implicitly
   \   00000072   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \   00000076   0x88A0             LDRH     R0,[R4, #+4]
   \   00000078   0x0A0A             LSRS     R2,R1,#+8
   \   0000007A   0xF402 0x427F      AND      R2,R2,#0xFF00
   \   0000007E   0x020B             LSLS     R3,R1,#+8
   \   00000080   0xEA42 0x6211      ORR      R2,R2,R1, LSR #+24
   \   00000084   0xF403 0x037F      AND      R3,R3,#0xFF0000
   \   00000088   0x431A             ORRS     R2,R3,R2
   \   0000008A   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   0000008E   0x198A             ADDS     R2,R1,R6
   \   00000090   0x0A01             LSRS     R1,R0,#+8
   \   00000092   0x0200             LSLS     R0,R0,#+8
   \   00000094   0xF400 0x407F      AND      R0,R0,#0xFF00
   \   00000098   0x4301             ORRS     R1,R0,R1
   \   0000009A   0x4650             MOV      R0,R10
   \   0000009C   0x.... 0x....      BL       mmcr_set_route
    720          		}
    721          		pkt_neighbor_addr +=3;
   \                     ??mmcr_recvACK_4: (+1)
   \   000000A0   0x1DAD             ADDS     R5,R5,#+6
    722          	}
   \   000000A2   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mmcr_recvACK_2: (+1)
   \   000000A4   0x7B60             LDRB     R0,[R4, #+13]
   \   000000A6   0xB2FF             UXTB     R7,R7
   \   000000A8   0x4287             CMP      R7,R0
   \   000000AA   0xD3D5             BCC.N    ??mmcr_recvACK_3
    723          	return 1;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    724          }	

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable19_2
   \   00000002   0x221C             MOVS     R2,#+28
   \   00000004   0xFB02 0x1000      MLA      R0,R2,R0,R1
   \   00000008   0x4770             BX       LR
    725          
    726          
    727          /////////////////////////////////
    728          /**
    729            * mmcr_sendTC - send channel switch message
    730            *
    731            */

   \                                 In section .text, align 2, keep-with-next
    732          void mmcr_sendTC ( uint8_t *context )
    733          {
   \                     mmcr_sendTC: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    734          	int i;
    735          	tpkt_t_mmcr XDATA*tpkt = (tpkt_t_mmcr XDATA*) packet;
    736          	uint16_t IAR_PACKED	*mpr_list = (uint16_t*) &(tpkt->mpr_list); //
    737          		
    738          	mpr_select();
   \   00000002   0x.... 0x....      BL       mpr_select
    739          
    740          	tpkt->start = START_BYTE;
   \   00000006   0x....             LDR.N    R1,??DataTable19_3
   \   00000008   0x2042             MOVS     R0,#+66
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    741          	tpkt->flags = FLAG_TC_MMCR;  // TC packet
    742          	tpkt->mac_dst = MAC_BROADCAST; // Broadcast
   \   0000000C   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000010   0x206C             MOVS     R0,#+108
   \   00000012   0x7048             STRB     R0,[R1, #+1]
   \   00000014   0x804A             STRH     R2,[R1, #+2]
    743          	tpkt->mac_src = ENDIAN16(MY_ADDR);
   \   00000016   0x....             LDR.N    R0,??DataTable19_5
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
    744          
    745          	tpkt->length = RTR_MMCR_TC_PKT_SIZE - PKT_HEADER_LENGTH + (mpr_count_<<1); // of the packet'd data
    746          
    747          	// FILL END-TO-END ADDRESSING
    748          	tpkt->dst_id = MAC_BROADCAST;
                 	               ^
Warning[Pe069]: integer conversion resulted in truncation
    749          	tpkt->src_id = MY_ADDR;//ENDIAN16(MY_ADDR); //01/17/2011
   \   0000001A   0x720C             STRB     R4,[R1, #+8]
   \   0000001C   0x0220             LSLS     R0,R4,#+8
   \   0000001E   0x8088             STRH     R0,[R1, #+4]
    750          
    751          	tpkt->energy=ENDIAN32(my_energy_);
   \   00000020   0x....             LDR.N    R4,??DataTable19_4
   \   00000022   0x....             LDR.N    R0,??DataTable19_1
   \   00000024   0x7803             LDRB     R3,[R0, #+0]
   \   00000026   0x6824             LDR      R4,[R4, #+0]
   \   00000028   0x005D             LSLS     R5,R3,#+1
   \   0000002A   0x3509             ADDS     R5,R5,#+9
   \   0000002C   0x718D             STRB     R5,[R1, #+6]
   \   0000002E   0x0226             LSLS     R6,R4,#+8
   \   00000030   0x25FF             MOVS     R5,#+255
   \   00000032   0x71CD             STRB     R5,[R1, #+7]
   \   00000034   0xF406 0x067F      AND      R6,R6,#0xFF0000
   \   00000038   0x0A25             LSRS     R5,R4,#+8
   \   0000003A   0xF405 0x457F      AND      R5,R5,#0xFF00
   \   0000003E   0xEA45 0x6514      ORR      R5,R5,R4, LSR #+24
   \   00000042   0x4335             ORRS     R5,R6,R5
   \   00000044   0xEA45 0x6404      ORR      R4,R5,R4, LSL #+24
   \   00000048   0xF8C1 0x4009      STR      R4,[R1, #+9]
    752          	tpkt->channel=my_rf_channel_;
    753          
    754          	if (MAX_MPRS_PER_PKT <= mpr_count_)
   \   0000004C   0x2B28             CMP      R3,#+40
   \   0000004E   0x....             LDR.N    R4,??DataTable19_9
    755          	{
    756          		mpr_count_ = MAX_MPRS_PER_PKT; // need to split the TC list into multiple TC packets
    757          	}
    758          	tpkt->mpr_count = mpr_count_;
    759          	for(i=0; i < mpr_count_; i++)
   \   00000050   0x....             LDR.N    R5,??DataTable19_2
   \   00000052   0x7824             LDRB     R4,[R4, #+0]
   \   00000054   0x734C             STRB     R4,[R1, #+13]
   \   00000056   0xBFA4             ITT      GE 
   \   00000058   0x2328             MOVGE    R3,#+40
   \   0000005A   0x7003             STRBGE   R3,[R0, #+0]
   \   0000005C   0x7803             LDRB     R3,[R0, #+0]
   \   0000005E   0x738B             STRB     R3,[R1, #+14]
   \   00000060   0x2400             MOVS     R4,#+0
   \   00000062   0xE00D             B.N      ??mmcr_sendTC_0
   \                     ??mmcr_sendTC_1: (+1)
   \   00000064   0x1826             ADDS     R6,R4,R0
   \   00000066   0x271C             MOVS     R7,#+28
   \   00000068   0x7936             LDRB     R6,[R6, #+4]
   \   0000006A   0xFB07 0x5606      MLA      R6,R7,R6,R5
   \   0000006E   0x8836             LDRH     R6,[R6, #+0]
   \   00000070   0x0237             LSLS     R7,R6,#+8
   \   00000072   0xEA47 0x2616      ORR      R6,R7,R6, LSR #+8
   \   00000076   0xEB01 0x0744      ADD      R7,R1,R4, LSL #+1
    760          	{
    761          		mpr_list[i] = ENDIAN16(Neighborhood.OneHop[mpr_idx[i]].ID);
   \   0000007A   0x1C64             ADDS     R4,R4,#+1
   \   0000007C   0xF8A7 0x600F      STRH     R6,[R7, #+15]
   \                     ??mmcr_sendTC_0: (+1)
   \   00000080   0x429C             CMP      R4,R3
   \   00000082   0xDBEF             BLT.N    ??mmcr_sendTC_1
    762          	}
    763          	
    764          	*((uint8_t*)(&mpr_list[mpr_count_])) = PKT_MODULE_TYPE_END;
   \   00000084   0xEB01 0x0343      ADD      R3,R1,R3, LSL #+1
   \   00000088   0x2041             MOVS     R0,#+65
   \   0000008A   0x73D8             STRB     R0,[R3, #+15]
    765          	
    766          	sendPriorityPacket ( tpkt->length+PKT_HEADER_LENGTH, (char XDATA*) tpkt, MAC_BROADCAST );//ap->mac_dst );
   \   0000008C   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000090   0x7988             LDRB     R0,[R1, #+6]
   \   00000092   0x1DC0             ADDS     R0,R0,#+7
   \   00000094   0xB2C0             UXTB     R0,R0
   \   00000096   0x.... 0x....      B.W      sendPriorityPacket
    767          }
    768          
    769          // 				ch_sw_TIDX = sch_create_timeout(rtc_get_ticks()+MMCR_CHANNEL_SWITCH_REQ_INTERVAL, mmcr_rf_ch_sw, &ch_sw_TIDX);
    770          
    771          
    772          /////////////////////////////////
    773          /**
    774            * mmcr_recvTC - Topology Control packet (MPR info)
    775            *
    776            */

   \                                 In section .text, align 2, keep-with-next
    777          unsigned int mmcr_recvTC ( tpkt_t_mmcr *tp )
    778          {
   \                     mmcr_recvTC: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    779          	// Check if I'm MP for the sender -> update neighbor list to indicate it
    780          //	tp->channel=MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL);
    781          //	tp->channel=MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL); // Workaround for compiler issue
    782          //	tp->channel=MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL);
    783          //	phy_set_RF_channel(tp->channel);
    784          	uint8_t i, idx;
    785          	uint16_t IAR_PACKED *mpr_list = &(tp->mpr_list);
   \   00000004   0xF104 0x050F      ADD      R5,R4,#+15
    786          	uint16_t src = ENDIAN16(tp->mac_src);
   \   00000008   0x88A0             LDRH     R0,[R4, #+4]
   \   0000000A   0x0201             LSLS     R1,R0,#+8
   \   0000000C   0xEA41 0x2610      ORR      R6,R1,R0, LSR #+8
    787          
    788              if (tp->channel != my_rf_channel_)
   \   00000010   0x....             LDR.N    R1,??DataTable19_9
   \   00000012   0x7B60             LDRB     R0,[R4, #+13]
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xBF18             IT       NE 
   \   0000001A   0x.... 0x....      BLNE     phy_set_RF_channel
    789              {
    790                  //channel_switch_countdown_ms
    791                  phy_set_RF_channel(tp->channel);
    792              }
    793          	for( i=0; i< tp->mpr_count; i++)
   \   0000001E   0x2700             MOVS     R7,#+0
   \   00000020   0xE017             B.N      ??mmcr_recvTC_0
    794          	{
    795          		if (MY_ADDR == ENDIAN16(mpr_list[i]))
   \                     ??mmcr_recvTC_1: (+1)
   \   00000022   0xF835 0x0017      LDRH     R0,[R5, R7, LSL #+1]
   \   00000026   0x....             LDR.N    R1,??DataTable19_5
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x0A02             LSRS     R2,R0,#+8
   \   0000002C   0x0200             LSLS     R0,R0,#+8
   \   0000002E   0xF400 0x407F      AND      R0,R0,#0xFF00
   \   00000032   0x4310             ORRS     R0,R0,R2
   \   00000034   0x4281             CMP      R1,R0
   \   00000036   0xD10A             BNE.N    ??mmcr_recvTC_2
    796          		{
    797          			idx = find_one_hop_node(src);
   \   00000038   0xB2B0             UXTH     R0,R6
   \   0000003A   0x.... 0x....      BL       find_one_hop_node
    798          			if (NO_NODE_IDX == idx)
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0xD005             BEQ.N    ??mmcr_recvTC_2
    799          			{
    800          				// the node is not my one-hop neighbor ??!!! -> Fatal Error
    801          			}
    802          			else
    803          			{
    804          				// set myself as MPR for the one hop neighbor
    805          				Neighborhood.OneHop[idx].flags.IAM_MPR = 1;
   \   00000042   0x.... 0x....      BL       ?Subroutine5
    806          			}
    807          		}
    808          	}
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000046   0x7881             LDRB     R1,[R0, #+2]
   \   00000048   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000004C   0x7081             STRB     R1,[R0, #+2]
   \                     ??mmcr_recvTC_2: (+1)
   \   0000004E   0x1C7F             ADDS     R7,R7,#+1
   \   00000050   0xB2FF             UXTB     R7,R7
   \                     ??mmcr_recvTC_0: (+1)
   \   00000052   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000054   0x4287             CMP      R7,R0
   \   00000056   0xDBE4             BLT.N    ??mmcr_recvTC_1
    809          	return 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    810          }
    811          ///////////////////////////////////////////////
    812          ///////////////////////////////////////////////
    813          
    814          ///////////////////////////////////////////////
    815          ///////////////////////////////////////////////
    816          
    817          ///////////////////////////////////////////////
    818          ///////////////////////////////////////////////
    819          /**
    820            * mmcr_set_tx_timeout(??) - set one-time timeout for MMCR hello/tc packets
    821            */

   \                                 In section .text, align 2, keep-with-next
    822          void mmcr_set_tx_timeout ( uint16_t ms )
    823          {
   \                     mmcr_set_tx_timeout: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    824          	if (SCH_NO_TIMEOUT_ID != mmcr_hello_tidx)
   \   00000002   0x....             LDR.N    R5,??DataTable19
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD004             BEQ.N    ??mmcr_set_tx_timeout_0
    825          	{
    826          		sch_remove_timeout(mmcr_hello_tidx, str_MMCR_HELLO);
   \   0000000C   0x1D29             ADDS     R1,R5,#+4
   \   0000000E   0x.... 0x....      BL       sch_remove_timeout
    827          		mmcr_hello_tidx = SCH_NO_TIMEOUT_ID;
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    828          	}
    829          	mmcr_hello_tidx = sch_create_timeout( rtc_get_ticks() + ms, mmcr_hello_timeout, 0, str_MMCR_HELLO);
   \                     ??mmcr_set_tx_timeout_0: (+1)
   \   00000016   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000001A   0x1D2B             ADDS     R3,R5,#+4
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x.... 0x....      ADR.W    R1,mmcr_hello_timeout
   \   00000022   0x1820             ADDS     R0,R4,R0
   \   00000024   0x.... 0x....      BL       sch_create_timeout
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    830          //	mmcr_hello_timeout_ = rtc_get_ticks() + ms;
    831          //	mmcr_hello_timeout_enabled_ = 1;
    832          }
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    833          
    834          /////////////////////////////////
    835          /**
    836            * mmcr_hello_timeout(??) - runs the procedure of periodic sending of Hello packets
    837            */

   \                                 In section .text, align 4, keep-with-next
    838          void mmcr_hello_timeout()
    839          {
   \                     mmcr_hello_timeout: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    840          	// Workaround - remove long Hello interval timeout - since we are already here
    841          	if (SCH_NO_TIMEOUT_ID != mmcr_routeStart_tidx_)
   \   00000002   0x....             LDR.N    R4,??DataTable19
   \   00000004   0x7860             LDRB     R0,[R4, #+1]
   \   00000006   0x25FF             MOVS     R5,#+255
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD004             BEQ.N    ??mmcr_hello_timeout_0
    842          	{
    843          		sch_remove_timeout(mmcr_routeStart_tidx_, str_MMCR_startRT);
   \   0000000C   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000010   0x.... 0x....      BL       sch_remove_timeout
    844          		mmcr_routeStart_tidx_ = SCH_NO_TIMEOUT_ID;
   \   00000014   0x7065             STRB     R5,[R4, #+1]
    845          	}
    846          	// Timeout reached -> is there a route found? or should I retransmit HELLO?
    847          	mmcr_hello_tidx = SCH_NO_TIMEOUT_ID; // Clear THIS timeout's ID - it already fired
    848          //	unsigned int mac_addr = mmcr_neighbor_analyse(MY_DEST);
    849          	if ( 0 < mmcr_Hello_countdown_ )
   \                     ??mmcr_hello_timeout_0: (+1)
   \   00000016   0x78E0             LDRB     R0,[R4, #+3]
   \   00000018   0x7025             STRB     R5,[R4, #+0]
   \   0000001A   0xB178             CBZ.N    R0,??mmcr_hello_timeout_1
    850          	{			mmcr_Hello_countdown_ --; // count down HELLO retransmissions
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x70E0             STRB     R0,[R4, #+3]
    851          		// number of retransmission not reached -> resent HELLO
    852          		TOGGLE_LED(YLED);//YLED = ~YLED;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       STM_EVAL_LEDToggle
    853          				
    854          		//mmcr_request_send_HELLO_ = 1;
    855          		//mmcr_request_send_TC_= 1;
    856          		mmcr_set_tx_timeout(MMCR_ROUTE_SEARCH_HELLO_INTERVAL);
   \   00000026   0xF44F 0x70FA      MOV      R0,#+500
   \   0000002A   0x.... 0x....      BL       mmcr_set_tx_timeout
    857          		rtr_MMCR_Hello_Phase();
   \   0000002E   0x.... 0x....      BL       rtr_MMCR_Hello_Phase
    858          		TOGGLE_LED(YLED);//YLED = ~YLED;
   \   00000032   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      B.W      STM_EVAL_LEDToggle
    859          	}
    860          	else
    861          	{
    862          		// all Hello messages has been without response -> STOP
    863          		mmcr_Hello_countdown_=0;
    864          		//mmcr_request_send_HELLO_ = 0; //1;
    865          		//mmcr_request_send_TC_ = 0;
    866          		mmcr_state_ = MMCR_STATE_IDLE;
   \                     ??mmcr_hello_timeout_1: (+1)
   \   0000003C   0x70A0             STRB     R0,[R4, #+2]
    867          		sch_create_timeout(rtc_get_ticks()+10, mmcr_sendTC, (uint8_t*)packet, str_MMCR_TC);
   \   0000003E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000042   0xF104 0x0310      ADD      R3,R4,#+16
   \   00000046   0x....             LDR.N    R2,??DataTable19_3
   \   00000048   0x....             LDR.N    R1,??DataTable19_10
   \   0000004A   0x300A             ADDS     R0,R0,#+10
   \   0000004C   0x.... 0x....      BL       sch_create_timeout
    868          		mmcr_routeStart_tidx_ = sch_create_timeout(rtc_get_ticks()+MMCR_LONG_HELLO_INTERVAL, mmcr_startRouteSearch, 0, str_MMCR_startRT);
   \   00000050   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000054   0xF500 0x406A      ADD      R0,R0,#+59904
   \   00000058   0xF104 0x0318      ADD      R3,R4,#+24
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x....             LDR.N    R1,??DataTable19_11
   \   00000060   0x3060             ADDS     R0,R0,#+96
   \   00000062   0x.... 0x....      BL       sch_create_timeout
   \   00000066   0x7060             STRB     R0,[R4, #+1]
    869          
    870          		enableDataTx_ = 1;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x....             LDR.N    R1,??DataTable19_12
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    871          	}
    872          }	
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     mmcr_hello_tidx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     mpr_count_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     Neighborhood

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     packet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x........         DC32     my_energy_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     my_addr8_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x0002AB99         DC32     0x2ab99

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x0002AB98         DC32     0x2ab98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x........         DC32     str_MMCR_sendACK

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0x........         DC32     my_rf_channel_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \   00000000   0x........         DC32     mmcr_sendTC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \   00000000   0x........         DC32     mmcr_startRouteSearch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_12:
   \   00000000   0x........         DC32     enableDataTx_
    873          ///////////////////////////////////////////////
    874          ///////////////////////////////////////////////
    875          
    876          ///////////////////////////////////////////////
    877          ///////////////////////////////////////////////
    878          
    879          
    880          
    881          /////////////////////////////////
    882          
    883          
    884          
    885          
    886          /*
    887          void copyOneHop(uint8_t idx_src, idx_dst)
    888          {
    889          	Neighborhood		uint16_t 	ID;
    890          	union {hop_flags_t flags; 	uint8_t flags_u8;};	// flags for one hop node
    891          	uint16_t	Link[10]; // point to index (ID) of the second hop node
    892          	char	Links;
    893          	uint32_t LinkCost;
    894          }
    895          
    896          void removeOneHop(uint16_t id)
    897          {
    898          }
    899          */
    900          
    901          #endif /* FEAT_ENABLE_MMCR */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   add_one_hop_node
      24   add_two_hop_node
        24   -> find_link
        24   -> find_two_hop_node
       8   find_link
       8   find_one_hop_node
       8   find_two_hop_node
       0   init_topology
         0   -> mmcr_neighbor_clear
      16   mmcr_hello_timeout
         0   -> STM_EVAL_LEDToggle
        16   -> STM_EVAL_LEDToggle
        16   -> halCommonGetInt32uMillisecondTick
        16   -> mmcr_set_tx_timeout
        16   -> rtr_MMCR_Hello_Phase
        16   -> sch_create_timeout
        16   -> sch_remove_timeout
      16   mmcr_neighbor_clear
        16   -> __aeabi_memclr
      16   mmcr_neighborhood_age
        16   -> __aeabi_memclr
      40   mmcr_recvACK
        40   -> add_one_hop_node
        40   -> add_two_hop_node
        40   -> find_one_hop_node
        40   -> mmcr_set_route
      24   mmcr_recvHELLO
        24   -> add_one_hop_node
        24   -> cs_req_switch
        24   -> find_one_hop_node
        24   -> halCommonGetInt32uMillisecondTick
        24   -> sch_create_timeout
      24   mmcr_recvTC
        24   -> find_one_hop_node
      24   mmcr_sendACK
         0   -> sendPriorityPacket
       0   mmcr_sendHELLO
      24   mmcr_sendTC
        24   -> mpr_select
         0   -> sendPriorityPacket
      16   mmcr_set_tx_timeout
        16   -> halCommonGetInt32uMillisecondTick
        16   -> sch_create_timeout
        16   -> sch_remove_timeout
       8   mmcr_startRouteSearch
         0   -> mmcr_set_tx_timeout
         8   -> rtr_MMCR_Hello_Phase
      48   mpr_select
        48   -> find_two_hop_node
       8   routing_init_MPR_select
         8   -> mmcr_neighbor_clear
         0   -> mmcr_startRouteSearch
         8   -> mpr_select
       8   rtr_MMCR_Hello_Phase
         8   -> mmcr_sendHELLO
         8   -> sendPriorityPacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      18  ?Subroutine0
      18  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
      24  ?Subroutine4
      10  ?Subroutine5
     320  Neighborhood
      92  add_one_hop_node
     126  add_two_hop_node
      46  find_link
      44  find_one_hop_node
      44  find_two_hop_node
       2  init_topology
      40  mmcr_hello_tidx
          mmcr_routeStart_tidx_
          mmcr_state_
          mmcr_Hello_countdown_
          str_MMCR_HELLO
          str_MMCR_TC
          str_MMCR_startRT
     112  mmcr_hello_timeout
       2  mmcr_len_sample
      64  mmcr_neighbor_clear
      52  mmcr_neighborhood_age
     178  mmcr_recvACK
     190  mmcr_recvHELLO
      92  mmcr_recvTC
       1  mmcr_request_send_TC_
     132  mmcr_sendACK
      76  mmcr_sendHELLO
     154  mmcr_sendTC
      44  mmcr_set_tx_timeout
      36  mmcr_startRouteSearch
      16  mpr_count_
          mpr_idx
     356  mpr_select
      26  routing_init_MPR_select
      36  rtr_MMCR_Hello_Phase
      16  str_MMCR_sendACK

 
   339 bytes in section .bss
    56 bytes in section .data
 2 044 bytes in section .text
 
 2 044 bytes of CODE memory
   395 bytes of DATA memory

Errors: none
Warnings: 3
