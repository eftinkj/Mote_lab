###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:29:38
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_adc.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_adc.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"stm32w108xx_adc.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\stm32w108xx_adc.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\stm32w108xx_adc.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_adc.c
      1            /**
      2            ******************************************************************************
      3            * @file    stm32w108xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           + ADC initialization and Configuration 
     10            *           + DMA Configuration functions
     11            *           + Interrupts and flags management functions
     12            *         
     13            *  @verbatim
     14            * 
     15           ===============================================================================
     16                                ##### How to use this driver #####
     17           ===============================================================================                  
     18              [..] 
     19                   (#) Configure GPIO pins to be used by the ADC in analog mode.
     20                   (#) Configure the voltage reference (internal or external).
     21                   (#) Set the offset and gain values.
     22                   (#) Reset the ADC DMA, define the DMA buffer, and start the DMA in the 
     23                       proper transfer mode. 
     24                   (#) Write the ADC configuration register to define the inputs, voltage 
     25                       range, sample time and start the conversions.
     26                       
     27              @endverbatim
     28            *  
     29            ******************************************************************************
     30            * @attention
     31            *
     32            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     33            *
     34            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     35            * You may not use this file except in compliance with the License.
     36            * You may obtain a copy of the License at:
     37            *
     38            *        http://www.st.com/software_license_agreement_liberty_v2
     39            *
     40            * Unless required by applicable law or agreed to in writing, software 
     41            * distributed under the License is distributed on an "AS IS" BASIS, 
     42            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     43            * See the License for the specific language governing permissions and
     44            * limitations under the License.
     45            *
     46            ******************************************************************************
     47            */
     48          
     49          /* Includes ------------------------------------------------------------------*/
     50          
     51          #include "stm32w108xx_adc.h"
     52          
     53          /** @addtogroup STM32W108xx_StdPeriph_Driver
     54            * @{
     55            */
     56          
     57          /** @defgroup ADC 
     58            * @brief ADC driver modules
     59            * @{
     60            */
     61          
     62          /* External variables --------------------------------------------------------*/
     63          /* Private typedef -----------------------------------------------------------*/
     64          /* Private defines -----------------------------------------------------------*/
     65          /* ADC INPUTN and INPUTP channel mask */
     66          #define ADC_INPUT_NP_Reset  ((uint16_t)0xF807)
     67          
     68          /* Private macros ------------------------------------------------------------*/
     69          /* Private variables ---------------------------------------------------------*/
     70          /* Private function prototypes -----------------------------------------------*/
     71          
     72          /* Private functions ---------------------------------------------------------*/
     73          /** @defgroup ADC_Private_Functions
     74            * @{
     75            */ 
     76          
     77          /** @defgroup ADC_Group1 Initialization and Control functions
     78           *  @brief    Initialization and Control functions 
     79           *
     80          @verbatim    
     81           ===============================================================================
     82                              ##### Initialization and Control functions #####
     83           ===============================================================================
     84            [..] This section provides functions allowing to:
     85                 (+) Initialize and configure the ADC 
     86                 (+) ADC Conversion Resolution (5bits --> 12bits)
     87                 (+) Enable or disable the ADC peripheral
     88             
     89          @endverbatim
     90            * @{
     91            */
     92            
     93          /**
     94            * @brief  Deinitializes ADC peripheral registers to their default reset 
     95            *         values.
     96            * @param  None
     97            * @retval None
     98            */

   \                                 In section .text, align 2, keep-with-next
     99          void ADC_DeInit(void)
    100          {
    101            ADC->ISR = 0x0000001F; 
   \                     ADC_DeInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12  ;; 0x4000a810
   \   00000002   0x211F             MOVS     R1,#+31
   \   00000004   0x6001             STR      R1,[R0, #+0]
    102            ADC->IER = 0x00000000; 
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6401             STR      R1,[R0, #+64]
    103            ADC->CR = 0x00001800;
   \   0000000A   0xF44F 0x51C0      MOV      R1,#+6144
   \   0000000E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x4000d004
   \   00000010   0x6001             STR      R1,[R0, #+0]
    104            ADC->OFFSETR = 0x00000000; 
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6041             STR      R1,[R0, #+4]
    105            ADC->GAINR = 0x00008000;
   \   00000016   0xF44F 0x4100      MOV      R1,#+32768
   \   0000001A   0x6081             STR      R1,[R0, #+8]
    106            ADC->DMACR = 0x00000010;
   \   0000001C   0x2110             MOVS     R1,#+16
   \   0000001E   0x60C1             STR      R1,[R0, #+12]
    107            ADC->DMAMSAR = 0x20000000;
   \   00000020   0xF04F 0x5100      MOV      R1,#+536870912
   \   00000024   0x6141             STR      R1,[R0, #+20]
    108            ADC->DMANDTR = 0x00000000;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x6181             STR      R1,[R0, #+24]
    109          }
   \   0000002A   0x4770             BX       LR               ;; return
    110          
    111          /**
    112            * @brief  Initializes the ADC peripheral according to the specified
    113            *         parameters in the ADC_InitStruct.
    114            * @param  ADC_InitStruct: pointer to ADC_InitTypeDef structure
    115            *         that contains the configuration information for the ADC peripheral.
    116            * @retval None
    117            */

   \                                 In section .text, align 2, keep-with-next
    118          void ADC_Init(ADC_InitTypeDef* ADC_InitStruct)
    119          {
    120            uint32_t tmpreg = 0;
    121            
    122            /* Check the parameters */
    123            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
    124            assert_param(IS_ADC_VoltageP(ADC_InitStruct->ADC_VoltageP));
    125            assert_param(IS_ADC_VoltageN(ADC_InitStruct->ADC_VoltageN));
    126            assert_param(IS_ADC_CHANNEL(ADC_InitStruct->ADC_Input));
    127            assert_param(IS_ADC_DMA_MODE(ADC_InitStruct->ADC_DMAMode));  
    128            assert_param(IS_ADC_CLOCK(ADC_InitStruct->ADC_Clock));
    129            assert_param(IS_ADC_OFFSET(ADC_InitStruct->ADC_Offset));
    130            assert_param(IS_ADC_GAIN(ADC_InitStruct->ADC_Gain));  
    131                      
    132            /*---------------------------- ADC CR Configuration -----------------------*/
    133          
    134            /* Configure ADC: scan conversion mode and resolution */
    135            /* Set ADC_1MHZCLK bit according to ADC_Clock value */
    136            /* Set ADC_MUX bits according to ADC_Input values */
    137            /* Set ADC_HVSELN bit according to ADC_VoltageN value */
    138            /* Set ADC_HVSELP bit according to ADC_VoltageP value */
    139            /* Set ADC_PERIOD[0:2] bits according to ADC_Clock value */
    140            tmpreg |= (uint32_t)(ADC_InitStruct->ADC_Resolution | ADC_InitStruct->ADC_VoltageP |
    141                                 ADC_InitStruct->ADC_VoltageN | (uint32_t)((ADC_InitStruct->ADC_Input) << 0x3) | 
    142                                 ADC_InitStruct->ADC_Clock);
    143                                  
    144            /* Write to ADC CR */
    145            ADC->CR = (uint32_t)tmpreg;
   \                     ADC_Init: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0x....             LDR.N    R1,??DataTable12_1  ;; 0x4000d004
   \   00000006   0x431A             ORRS     R2,R3,R2
   \   00000008   0x6883             LDR      R3,[R0, #+8]
   \   0000000A   0x431A             ORRS     R2,R3,R2
   \   0000000C   0x68C3             LDR      R3,[R0, #+12]
   \   0000000E   0xEA42 0x02C3      ORR      R2,R2,R3, LSL #+3
   \   00000012   0x6903             LDR      R3,[R0, #+16]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x600A             STR      R2,[R1, #+0]
    146           
    147            /*---------------------------- ADC DMA Configuration -----------------------*/
    148            /* Write to ADC DMA */
    149            ADC->DMACR = (uint32_t)(ADC_InitStruct->ADC_DMAMode);
   \   00000018   0x6942             LDR      R2,[R0, #+20]
   \   0000001A   0x60CA             STR      R2,[R1, #+12]
    150           
    151            /*---------------------------- ADC ADC_OFFSETR Configuration ---------------*/
    152            /* Write to ADC ADC_OFFSETR */
    153            ADC->OFFSETR = (int32_t)(ADC_InitStruct->ADC_Offset);
   \   0000001C   0x6982             LDR      R2,[R0, #+24]
   \   0000001E   0x604A             STR      R2,[R1, #+4]
    154            
    155            /*---------------------------- ADC ADC_GAINR Configuration -----------------*/
    156            /* Write to ADC ADC_GAINR */
    157            ADC->GAINR = (uint32_t)(ADC_InitStruct->ADC_Gain);
   \   00000020   0x69C0             LDR      R0,[R0, #+28]
   \   00000022   0x6088             STR      R0,[R1, #+8]
    158          }
   \   00000024   0x4770             BX       LR               ;; return
    159          
    160          /**
    161            * @brief  Fills each ADC_InitStruct member with its default value
    162            * @param  ADC_InitStruct: pointer to a ADC_InitTypeDef structure
    163            *         which will be initialized.
    164            * @retval None
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    167          {
    168            /* Initialize the ADC resolution */
    169            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
   \                     ADC_StructInit: (+1)
   \   00000000   0xF44F 0x4160      MOV      R1,#+57344
   \   00000004   0x6001             STR      R1,[R0, #+0]
    170            ADC_InitStruct->ADC_VoltageP = ADC_VoltageP_Low;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6041             STR      R1,[R0, #+4]
    171            ADC_InitStruct->ADC_VoltageN = ADC_VoltageN_Low;
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    172            ADC_InitStruct->ADC_Input = ADC_SOURCE_VREF;
   \   0000000C   0x21A8             MOVS     R1,#+168
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    173            ADC_InitStruct->ADC_DMAMode = ADC_DMAMode_Linear;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6141             STR      R1,[R0, #+20]
    174            ADC_InitStruct->ADC_Clock = ADC_Clock_6MHz;
   \   00000014   0x6101             STR      R1,[R0, #+16]
    175            ADC_InitStruct->ADC_Offset = 0;
   \   00000016   0x6181             STR      R1,[R0, #+24]
    176            ADC_InitStruct->ADC_Gain = 0x00008000;
   \   00000018   0xF44F 0x4100      MOV      R1,#+32768
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
    177          }
   \   0000001E   0x4770             BX       LR               ;; return
    178          
    179          /**
    180            * @brief  Enables or disables the specified ADC peripheral
    181            * @param  NewState: new state of the ADC peripheral.
    182            *         This parameter can be: ENABLE or DISABLE.
    183            * @retval None
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          void ADC_Cmd(FunctionalState NewState)
    186          {
    187            /* Check the parameters */
    188            assert_param(IS_FUNCTIONAL_STATE(NewState));
    189            if (NewState != DISABLE)
   \                     ADC_Cmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12_1  ;; 0x4000d004
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xBF12             ITEE     NE 
   \   00000008   0xF040 0x0001      ORRNE    R0,R0,#0x1
   \   0000000C   0x0840             LSREQ    R0,R0,#+1
   \   0000000E   0x0040             LSLEQ    R0,R0,#+1
    190            {
    191              /* Enable the ADC peripheral */
    192              ADC->CR |= (uint32_t)ADC_CR_ADON;
    193            }
    194            else
    195            {
    196              /* Disable the ADC peripheral */
    197              ADC->CR &= (uint32_t)(~ADC_CR_ADON); 
   \   00000010   0x6008             STR      R0,[R1, #+0]
    198            }
    199          }
   \   00000012   0x4770             BX       LR               ;; return
    200          
    201          /**
    202            * @}
    203            */
    204          
    205          /** @defgroup ADC_Group2 ADC channel Configuration functions
    206           *  @brief   ADC channel Configuration functions
    207           *
    208          @verbatim   
    209           ===============================================================================
    210                          ##### ADC channel Configuration functions #####
    211           ===============================================================================
    212           [..] This section provides function allowing to configure the ADC channels
    213          
    214          @endverbatim
    215            * @{
    216            */
    217          
    218          /**
    219            * @brief  Selects the ADC channel
    220            * @param  ADC_Channels: specifies the ADC channel
    221            *         This parameter can be one of the following values:
    222            *           @arg ADC_SOURCE_ADC0_VREF2
    223            *           @arg ADC_SOURCE_ADC0_GND
    224            *           @arg ADC_SOURCE_ADC1_VREF2
    225            *           @arg ADC_SOURCE_ADC1_GND
    226            *           @arg ADC_SOURCE_ADC2_VREF2
    227            *           @arg ADC_SOURCE_ADC2_GND
    228            *           @arg ADC_SOURCE_ADC3_VREF2
    229            *           @arg ADC_SOURCE_ADC3_GND
    230            *           @arg ADC_SOURCE_ADC4_VREF2
    231            *           @arg ADC_SOURCE_ADC5_VREF2
    232            *           @arg ADC_SOURCE_ADC1_ADC0
    233            *           @arg ADC_SOURCE_ADC0_ADC1
    234            *           @arg ADC_SOURCE_ADC3_ADC2
    235            *           @arg ADC_SOURCE_ADC2_ADC3
    236            *           @arg ADC_SOURCE_ADC5_ADC4
    237            *           @arg ADC_SOURCE_GND_VREF2
    238            *           @arg ADC_SOURCE_VGND
    239            *           @arg ADC_SOURCE_VREF_VREF2
    240            *           @arg ADC_SOURCE_VREF
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void ADC_ChannelConfig(uint32_t ADC_Channels)
    244          {
    245            uint32_t tmpreg = 0;
    246            /* Check the parameters */
    247            assert_param(IS_ADC_CHANNEL(ADC_Channels));
    248            
    249            /* Get the old register value */
    250            tmpreg = ADC->CR;
   \                     ADC_ChannelConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12_1  ;; 0x4000d004
   \   00000002   0x680A             LDR      R2,[R1, #+0]
    251            /* Clear the old channels */
    252            tmpreg &= ADC_INPUT_NP_Reset;
    253            /* Set the new channels */
    254            tmpreg |= (uint32_t)((ADC_Channels << 0x3));
    255            /* Store the new register value */
    256            ADC->CR = (uint32_t)tmpreg;
   \   00000004   0xF64F 0x0307      MOVW     R3,#+63495
   \   00000008   0x401A             ANDS     R2,R3,R2
   \   0000000A   0xEA42 0x00C0      ORR      R0,R2,R0, LSL #+3
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    257          }
   \   00000010   0x4770             BX       LR               ;; return
    258          
    259          /**
    260            * @}
    261            */
    262          
    263          /** @defgroup ADC_Group3 DMA Configuration functions
    264           *  @brief   DMA Configuration functions
    265           *
    266          @verbatim
    267           ===============================================================================
    268                            ##### DMA Configuration functions #####
    269           ===============================================================================
    270           [..] This section provides functions allowing to:
    271                  (+) initialize and configure the DMA
    272                  (+) reset and enable the DMA
    273          @endverbatim
    274            * @{
    275            */
    276          
    277          /**
    278            * @brief  Selects the specified DMA configuration
    279            * @param  ADC_DMABeg: specifies the ADC buffer start address
    280            * @param  ADC_DMASize: specifies the ADC buffer size
    281            * @retval None
    282            */
    283            

   \                                 In section .text, align 2, keep-with-next
    284          void ADC_DMA_Config(uint32_t ADC_DMABeg, uint32_t ADC_DMASize)
    285          {
    286            /* Check the parameters */
    287            assert_param(IS_ADC_BEGIN(ADC_DMABeg));
    288            assert_param(IS_ADC_SIZE(ADC_DMASize));
    289          
    290            ADC->DMAMSAR = (uint32_t)ADC_DMABeg;
   \                     ADC_DMA_Config: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable12_2  ;; 0x4000d018
   \   00000002   0x6010             STR      R0,[R2, #+0]
    291            ADC->DMANDTR = (uint32_t)ADC_DMASize;
   \   00000004   0x6051             STR      R1,[R2, #+4]
    292          }
   \   00000006   0x4770             BX       LR               ;; return
    293          
    294           /**
    295            * @brief  Enables specified ADC DMA Channel
    296            * @param  None
    297            * @retval None
    298            */

   \                                 In section .text, align 2, keep-with-next
    299          void ADC_DMA_ChannelLoadEnable(void)
    300          {
    301            /* Start the ADC DMA */
    302            ADC->DMACR |= (uint32_t)ADC_DMACR_LOAD;
   \                     ADC_DMA_ChannelLoadEnable: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_3  ;; 0x4000d010
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    303          }
   \   0000000A   0x4770             BX       LR               ;; return
    304          
    305           /**
    306            * @brief  Reset specified ADC DMA
    307            * @param  None
    308            * @retval None
    309            */

   \                                 In section .text, align 2, keep-with-next
    310          void ADC_DMA_ChannelReset(void)
    311          {
    312            /* Reset the ADC DMA */
    313            ADC->DMACR = (uint32_t)ADC_DMACR_RST;
   \                     ADC_DMA_ChannelReset: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12_3  ;; 0x4000d010
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0x6008             STR      R0,[R1, #+0]
    314          }
   \   00000006   0x4770             BX       LR               ;; return
    315          
    316           /**
    317            * @brief  Gets the the location that will be written next by the DMA
    318            * @param  None
    319            * @retval the current DMA address
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          uint32_t ADC_DMA_GetNextAddress(void)
    322          {
    323            /*return the next address buffer*/
    324            return (uint32_t) ADC->DMAMNAR;
   \                     ADC_DMA_GetNextAddress: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_4  ;; 0x4000d020
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    325          }
    326          
    327           /**
    328            * @brief  Gets the number of 16-bit conversion results that have been
    329            *         written to the buffer
    330            * @param  None
    331            * @retval The number of conversions
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          uint32_t ADC_DMA_GetCounter(void)
    334          {
    335            /*return the number of conversions*/
    336            return (uint32_t) ADC->DMACNDTR;
   \                     ADC_DMA_GetCounter: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_5  ;; 0x4000d024
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    337          }
    338          
    339          /** @defgroup ADC_Group4 Interrupts and flags management functions
    340           *  @brief   Interrupts and flags management functions
    341           *
    342          @verbatim
    343           ===============================================================================
    344                      ##### Interrupts and flags management functions ##### 
    345           ===============================================================================
    346          
    347            [..] This section provides functions allowing to :
    348                 (+) configure the ADC Interrupts and to get the status and clear flags 
    349                     and Interrupts pending bits.
    350                 (+) get the status of DMA and clear flags
    351            
    352            *** Flags and Interrupts for ADC ***
    353            ==============================================
    354            [..]   
    355             (+)Flags :  
    356              (##) ADC_IT_DMABHF: DMA buffer half full interrupt pending
    357              (##) ADC_IT_DMABF: DMA buffer full interrupt pending
    358              (##) ADC_IT_SAT: Gain correction saturation interrupt pending
    359              (##) ADC_IT_DMAOVF: DMA buffer overflow interrupt pending
    360          
    361             (+)Interrupts :  
    362              (##) ADC_IT_DMABHF: DMA buffer half full interrupt enable
    363              (##) ADC_IT_DMABF: DMA buffer full interrupt enable
    364              (##) ADC_IT_SAT: Gain correction saturation interrupt enable
    365              (##) ADC_IT_DMAOVF: DMA buffer overflow interrupt enable
    366          
    367            *** Flags for ADC_DMA ***
    368            ==============================================
    369            [..]
    370            (+)Flags :
    371              (##) ADC_FLAG_ACT: DMA active
    372              (##) ADC_FLAG_OVF: DMA over flow
    373              
    374          @endverbatim
    375          
    376            * @{
    377            */
    378          
    379          /**
    380            * @brief  Enables or disables the specified ADC interrupts
    381            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled
    382            *         This parameter can be one of the following values:
    383            *            @arg ADC_IT_DMABHF: DMA buffer half full interrupt enable
    384            *            @arg ADC_IT_DMABF: DMA buffer full interrupt enable
    385            *            @arg ADC_IT_SAT: Gain correction saturation interrupt enable
    386            *            @arg ADC_IT_DMAOVF: DMA buffer overflow interrupt enable
    387            * @param  NewState: new state of the specified ADC interrupts
    388            *          This parameter can be: ENABLE or DISABLE
    389            * @retval None
    390            */

   \                                 In section .text, align 2, keep-with-next
    391          void ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
    392          {
    393            /* Check the parameters */
    394            assert_param(IS_FUNCTIONAL_STATE(NewState));
    395            assert_param(IS_ADC_IT(ADC_IT)); 
    396          
    397            if (NewState != DISABLE)
   \                     ADC_ITConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable12_6  ;; 0x4000a850
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x6811             LDR      R1,[R2, #+0]
   \   00000006   0xBF14             ITE      NE 
   \   00000008   0x4308             ORRNE    R0,R0,R1
   \   0000000A   0xEA21 0x0000      BICEQ    R0,R1,R0
    398            {
    399              /* Enable the selected ADC interrupts */
    400              ADC->IER |= (uint32_t)ADC_IT;
    401            }
    402            else
    403            {
    404              /* Disable the selected ADC interrupts */
    405              ADC->IER &= ~(uint32_t)ADC_IT;
   \   0000000E   0x6010             STR      R0,[R2, #+0]
    406            }
    407          }
   \   00000010   0x4770             BX       LR               ;; return
    408          
    409          /**
    410            * @brief  Checks whether the specified ADC interrupt has occurred or not
    411            * @param  ADC_DMA_FLAG: specifies the flag to check
    412            *         This parameter can be one of the following values:
    413            *            @arg ADC_FLAG_ACT: DMA active
    414            *            @arg ADC_FLAG_OVF: DMA over flow
    415            * @retval The new state of ADC_DMA_FLAG (SET or RESET).
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          FlagStatus ADC_DMA_GetFlagStatus(uint32_t ADC_DMA_FLAG)
    418          {
    419            FlagStatus bitstatus = RESET;
    420          
    421            /* Check the parameters */
    422            assert_param(IS_ADC_DMA_FLAG(ADC_DMA_FLAG));
    423          
    424            if ((ADC->ISR & ADC_DMA_FLAG) != RESET)
   \                     ADC_DMA_GetFlagStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable12  ;; 0x4000a810
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x4202             TST      R2,R0
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2101             MOVNE    R1,#+1
    425            {
    426              bitstatus = SET;
    427            }
    428            else
    429            {
    430              bitstatus = RESET;
    431            }
    432            return  bitstatus;
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    433          }
    434          
    435          /**
    436            * @brief  Checks whether the specified ADC pending interrupt has occurred or not
    437            * @param  ADC_IT: specifies the flag to check
    438            *         This parameter can be one of the following values:
    439            *            @arg ADC_IT_DMABHF: DMA buffer half full interrupt pending
    440            *            @arg ADC_IT_DMABF: DMA buffer full interrupt pending
    441            *            @arg ADC_IT_SAT: Gain correction saturation interrupt pending
    442            *            @arg ADC_IT_DMAOVF: DMA buffer overflow interrupt pending
    443            * @retval The new state of ADC_IT (SET or RESET)
    444            */
    445            

   \                                 In section .text, align 2, keep-with-next
    446          ITStatus ADC_GetITStatus(uint32_t ADC_IT)
    447          {
    448            ITStatus bitstatus = RESET;
    449            uint32_t enablestatus = 0;
    450            
    451            /* Check the parameters */
    452            assert_param(IS_ADC_IT(ADC_IT));
    453            
    454            enablestatus = (uint32_t)(ADC->IER & ADC_IT);
   \                     ADC_GetITStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable12  ;; 0x4000a810
   \   00000002   0x6C13             LDR      R3,[R2, #+64]
    455            if (((ADC->ISR & ADC_IT) != (uint32_t)RESET) && enablestatus)
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4003             ANDS     R3,R0,R3
   \   0000000A   0x4202             TST      R2,R0
   \   0000000C   0xBF1C             ITT      NE 
   \   0000000E   0x2B00             CMPNE    R3,#+0
   \   00000010   0x2101             MOVNE    R1,#+1
    456            {
    457              bitstatus = SET;
    458            }
    459            else
    460            {
    461              bitstatus = RESET;
    462            }
    463            return  bitstatus;
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x4770             BX       LR               ;; return
    464          }
    465          
    466          /**
    467            * @brief  Clears the ADC interrupt pending bits
    468            * @param  ADC_IT: specifies the flag to clear
    469            *         This parameter can be one of the following values:
    470            *            @arg ADC_IT_DMABHF: DMA buffer half full interrupt pending
    471            *            @arg ADC_IT_DMABF: DMA buffer full interrupt pending
    472            *            @arg ADC_IT_SAT: Gain correction saturation interrupt pending
    473            *            @arg ADC_IT_DMAOVF: DMA buffer overflow interrupt pending
    474            * @retval None
    475            */

   \                                 In section .text, align 2, keep-with-next
    476          void ADC_ClearITPendingBit(uint32_t ADC_IT)
    477          {
    478            /* Check the parameters */
    479            assert_param(IS_ADC_IT(ADC_IT));
    480          
    481            /* Clear the selected ADC flags */
    482            ADC->ISR = (uint32_t)ADC_IT;
   \                     ADC_ClearITPendingBit: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12  ;; 0x4000a810
   \   00000002   0x6008             STR      R0,[R1, #+0]
    483          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x4000A810         DC32     0x4000a810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x4000D004         DC32     0x4000d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x4000D018         DC32     0x4000d018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x4000D010         DC32     0x4000d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x4000D020         DC32     0x4000d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x4000D024         DC32     0x4000d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x4000A850         DC32     0x4000a850
    484          
    485          /**
    486            * @}
    487            */
    488          
    489          /**
    490            * @}
    491            */
    492          
    493          /**
    494            * @}
    495            */
    496          
    497          /**
    498            * @}
    499            */
    500          
    501          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_ChannelConfig
       0   ADC_ClearITPendingBit
       0   ADC_Cmd
       0   ADC_DMA_ChannelLoadEnable
       0   ADC_DMA_ChannelReset
       0   ADC_DMA_Config
       0   ADC_DMA_GetCounter
       0   ADC_DMA_GetFlagStatus
       0   ADC_DMA_GetNextAddress
       0   ADC_DeInit
       0   ADC_GetITStatus
       0   ADC_ITConfig
       0   ADC_Init
       0   ADC_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
      18  ADC_ChannelConfig
       6  ADC_ClearITPendingBit
      20  ADC_Cmd
      12  ADC_DMA_ChannelLoadEnable
       8  ADC_DMA_ChannelReset
       8  ADC_DMA_Config
       6  ADC_DMA_GetCounter
      16  ADC_DMA_GetFlagStatus
       6  ADC_DMA_GetNextAddress
      44  ADC_DeInit
      22  ADC_GetITStatus
      18  ADC_ITConfig
      38  ADC_Init
      32  ADC_StructInit

 
 282 bytes in section .text
 
 282 bytes of CODE memory

Errors: none
Warnings: none
