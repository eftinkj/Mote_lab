###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:26:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_clocks.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_clocks.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"hal_clocks.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\hal_clocks.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\hal_clocks.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_clocks.c
      1          /**
      2            ******************************************************************************
      3            * @file    clock.c
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the clock peripheral:
      9            *           + Internal/external clocks, 
     10            *           + Modes management
     11            *
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     16            *
     17            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     18            * You may not use this file except in compliance with the License.
     19            * You may obtain a copy of the License at:
     20            *
     21            *        http://www.st.com/software_license_agreement_liberty_v2
     22            *
     23            * Unless required by applicable law or agreed to in writing, software 
     24            * distributed under the License is distributed on an "AS IS" BASIS, 
     25            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     26            * See the License for the specific language governing permissions and
     27            * limitations under the License.
     28            *
     29            ******************************************************************************
     30            */
     31          
     32          /* Includes ------------------------------------------------------------------*/
     33          #include PLATFORM_HEADER
     34          #include "error.h"
     35          #include "hal.h"
     36          #include "mpu.h"
     37          #include "mfg-token.h"
     38          
     39          /** @addtogroup HAL
     40            * @{
     41            */
     42          
     43          /** @defgroup hal clocks
     44            * @brief hal clocks driver modules
     45            * @{
     46            */
     47          
     48          /* External variables --------------------------------------------------------*/
     49          /* Private typedef -----------------------------------------------------------*/
     50          /* Private defines -----------------------------------------------------------*/
     51          /* brief Set this define to 1 to run CPU clock at 12MHz to achieve some power
     52            consumption savings */
     53          #ifndef CORTEXM3_STM32W108_CPU_CLOCK_12MHz
     54          #define CORTEXM3_STM32W108_CPU_CLOCK_12MHz 0
     55          #endif
     56          
     57          /* Provide a simple means for enabling calibration debug output */
     58          #define CALDBG(x)
     59          /* #define CALDBG(x) x */
     60          
     61          /* The xtal needs to wait DEFAULT_XTAL_SETTLING_TIME_US microseconds after the
     62             bias is changed from max to normal to give the xtal time to settle.
     63             100us was chosen as a safe value because it was ~10x larger than the worst
     64             case measured settling time with the xtals tested in May 2011 by svec */
     65          #define DEFAULT_XTAL_SETTLING_TIME_US (100)
     66          
     67          /* Some builds don't want to use the complex idle delay code which requires
     68          interrupts. The define DISABLE_IDLING_DELAY simply swaps the fancy
     69          idleDelayMicroseconds for the traditional halCommonDelayMicroseconds */
     70          #ifdef DISABLE_IDLING_DELAY
     71            #define idleDelayMicroseconds(usDelay) halCommonDelayMicroseconds(usDelay)
     72          #else /* DISABLE_IDLING_DELAY */
     73          
     74          /* The slowest frequency for the 10kHz RC source is 8kHz (125us).  The PERIOD
     75          register updates every 16 cycles, so to be safe 17 cycles = 2125us.  But,
     76          we need twice this maximum time because the period measurement runs
     77          asynchronously, and the value of CLK->LSI10KCR is changed immediately before
     78          the delay */
     79          #define SLOWRC_PERIOD_SETTLE_TIME 4250
     80          
     81          /* The CLK->PERIODSR register measures the number of 12MHz clock cycles that
     82          occur in 16 cycles of the SlowRC clock.  This is meant to smooth out the the
     83          noise inherently present in the analog RC source.  While these 16 cycles
     84          smooths out most noise, there is still some jitter in the bottom bits of
     85          CLK->PERIODSR.  To further smooth out the noise, we take several readings of
     86          CLK->PERIODSR and average them out.  Testing has shown that the bottom 3 and 4
     87          bits of CLK->PERIODSR contain most of the jitter.  Averaging 8 samples will
     88          smooth out 3 bits of jitter and provide a realiable and stable reading useful
     89          in the calculations, while taking much less time than 16 or 32 samples */
     90          #define SLOWRC_PERIOD_SAMPLES 8
     91          
     92          /* The register CLK->LSI1KCR is a fractional divider that divides the 10kHz analog
     93          source with the goal of generating a 1024Hz, clk1k output.
     94            10000Hz / CLK->LSI1KCR = 1024Hz.
     95          Since the CLK->PERIODSR register measures the number of 12MHz cycles in 16
     96          cycles of the RC:
     97               16 * 12000000
     98               ------------- = ~10kHz
     99                CLK->PERIODSR
    100          and
    101            ~10kHz / 1024 = X
    102          where X is the fractional number that belongs in CLK->LSI1KCR.  Since the
    103          integer portion of CLK->LSI1KCR is bits 15:11 and the fractional is 10:0,
    104          multiplying X by 2048 (bit shift left by 11) generates the proper CLK->LSI1KCR
    105          register value.
    106          
    107          Putting this all together:
    108               16 * 12000000 * 2048     384000000
    109               --------------------  = ------------  =  CLK->LSI1KCR
    110                CLK->PERIODSR * 1024       CLK->PERIODSR
    111          */
    112          #define CLK1K_NUMERATOR 384000000
    113          
    114          /* The slowest frequency for the FastRC source is 4MHz (250ns).  The PERIOD
    115             register updates every 256 cycles, so to be safe 257 cycles = 64us.  But,
    116             we need twice this maximum time because the period measurement runs
    117             asynchronously, and the value of CLK->HSICR is changed immediately before
    118             the delay */
    119          #define FASTRC_PERIOD_SETTLE_TIME 128
    120          
    121          /*  XTAL switching and bias trimming code */
    122          /* Artificially increasing the MIN to 2 gives us a little breathing room
    123             and "feels safer". */
    124          #define OSC24M_BIASTRIM_MIN      (0x2)
    125          #define OSC24M_BIASTRIM_MAX      (0x0F)
    126          #define OSC24M_BIASTRIM_UNINIT   (0xFFFF)
    127          #define XTAL_STABILIZING_TIME_US (1500)
    128          
    129          /* Private macros ------------------------------------------------------------*/
    130          /* Private variables ---------------------------------------------------------*/
    131          /* Flag indicating that CLK->HSECR1 has been set, but the requisite
    132             delay has not elapsed so the XTAL and the trim flags are not stable */

   \                                 In section .data, align 2
    133          __IO boolean xtalUnstable = FALSE;
   \                     xtalUnstable:
   \   00000000   0x00               DC8 0
    134          
    135          __IO WakeupXtalState wakeupXtalState = WAKEUP_XTAL_STATE_START;
   \                     wakeupXtalState:
   \   00000001   0x00               DC8 0
    136          uint8_t xtalAboveLoThresholdUs = DEFAULT_XTAL_SETTLING_TIME_US;
   \                     xtalAboveLoThresholdUs:
   \   00000002   0x64               DC8 100
   \   00000003   0x00               DC8 0
    137          static boolean useXtalAsIs = FALSE;
    138          
    139          /* Shadow variable for the bias trim register. */
    140          tokTypeMfgOsc24mBiasTrim biasTrim = OSC24M_BIASTRIM_UNINIT;
    141          
    142          /* To prevent oscillating around trim values in certain situations,
    143          we must know some prior state. */
    144          boolean previousLoValue = 1;
   \                     previousLoValue:
   \   00000004   0x01               DC8 1
   \   00000005   0x00               DC8 0
   \                     biasTrim:
   \   00000006   0xFFFF             DC16 65535
    145          
    146          #ifdef BIASTRIM_TEST
    147          /* The purpose of this define and test variables is to allow test code
    148          (such as clock-test.c) to manipulate the results of the loSet and hiSet
    149          variables, allowing the test code to verify the algorithm will
    150          converge on the optimal value.  Effectively, this is a replacement
    151          for the emulator only registers EMU_CLK->HSECR2_OSC24M_THRESH_H and
    152          EMU_CLK->HSECR2_OSC24M_THRESH_L, allowing the same functionality to
    153          be performed/tested on a real chip. */
    154          extern boolean biasTrimTestEnabled;
    155          extern uint32_t osc24mThreshLo;
    156          extern uint32_t osc24mThreshHi;
    157          #endif /* BIASTRIM_TEST */
    158          
    159          /* Private function prototypes -----------------------------------------------*/
    160          /* Private functions ---------------------------------------------------------*/
    161          
    162          
    163          /** @defgroup  clocks_Private_Functions
    164            * @{
    165            */
    166          
    167          /**
    168            * @brief  Calculates delay 
    169            * @param  None
    170            * @retval None
    171            */

   \                                 In section .text, align 2, keep-with-next
    172          void idleDelayMicroseconds(uint16_t usDelay)
    173          {
   \                     idleDelayMicroseconds: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    174            uint32_t sysTickCount;
    175            
    176          /* Don't bother with idling if delaying less than 30us since there is
    177             overhead associated with idling which could cause the delay to be
    178             too long.  While the overhead is not long, with such short delays
    179             it becomes a larger percentage of the delay so it's safer to just
    180             default to a traditional delay */
    181            if(usDelay<30) 
   \   00000002   0x281E             CMP      R0,#+30
   \   00000004   0xBFBC             ITT      LT 
    182            {
    183              halCommonDelayMicroseconds(usDelay);
   \   00000006   0xE8BD 0x4032      POPLT    {R1,R4,R5,LR}
   \   0000000A   0x.... 0x....      BLT.W    halCommonDelayMicroseconds
    184              return;
    185            }
    186            
    187            /* sysTickCount = (usDelay)*(1*(10**-6) / (1.0/((MHz)*(10**6)))) */
    188            if( (CLK->HSECR2&CLK_HSECR2_SW1) && CLK->CPUCR) 
   \   0000000E   0x.... 0x....      BL       ?Subroutine0
    189            {
    190              /* 24MHz XTAL */
    191              sysTickCount = 24;
    192              
    193              /* a little more than 5us of overhead */
    194              usDelay -= 5;
    195            } 
    196            else if( (CLK->HSECR2&CLK_HSECR2_SW1) && !CLK->CPUCR) 
    197            {
    198              /* 12MHz XTAL */
    199              sysTickCount = 12;
    200              
    201              /* a little more than 10us of overhead */
    202              usDelay -= 10;
    203            }
    204            else if( !(CLK->HSECR2&CLK_HSECR2_SW1) && CLK->CPUCR) 
    205            {
    206              /* 12MHz OSCHF */
    207              sysTickCount = 12;
    208              /* a little more than 15us of overhead */
    209              usDelay -= 15;
    210            } 
    211            else 
    212            {
    213              /* 6MHz OSCHF */
    214              sysTickCount = 6;
    215              
    216              /* a little more than 20us of overhead */
    217              usDelay -= 20;
    218            }
    219            sysTickCount *= usDelay;
    220            
    221            ATOMIC(
    222              /* NOTE: SysTick's priority level causes it to bypass the ATOMIC behavior.
    223                    The ATOMIC is used to block all normal interrupts.  Therefore,
    224                    we don't have to use INTERRUPTS_ON when transitioning to
    225                    idle sleep, but we still need to use PRIMASK to disable all
    226                    interrupts, including SysTick, to transition to idle */
    227              __disable_irq();
    228              
    229              /* Enable SysTick from FCLK and enable interrupt */
    230               SysTick->CTRL= SysTick_CTRL_CLKSOURCE | SysTick_CTRL_ENABLE | SysTick_CTRL_TICKINT;
    231              
    232              /* Setting reload and count to zero will disable SysTick and clear COUNTFLAG */
    233              SysTick->LOAD = 0;
    234              SysTick->VAL = 0;
    235              
    236              /* Clear any stale SysTick interrupt */
    237              SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk;
    238              
    239              /* Setting reload value effectively starts timer counting */
    240              SysTick->LOAD = (sysTickCount-1);
    241              
    242          #ifdef FLASH_ACCESS_FLASH_LP
    243              BYPASS_MPU(
    244                         uint32_t FLASH_ACCESS_SAVED = FLASH_ACCESS;
    245                         halInternalIdleSleep();
    246                         FLASH->ACR= FLASH_ACCESS_SAVED;
    247                         )
    248          #else /* FLASH_ACCESS_FLASH_LP */
    249              halInternalIdleSleep();
    250              
    251          #endif /* FLASH_ACCESS_FLASH_LP */
    252              __enable_irq();
    253              )
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000012   0xF3EF 0x8411      MRS      R4,BASEPRI
   \   00000016   0x2260             MOVS     R2,#+96
   \   00000018   0xF382 0x8811      MSR      BASEPRI,R2
   \   0000001C   0xB672             CPSID    I
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable11  ;; 0xe000e010
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable11_1  ;; 0xe000ed04
   \   00000026   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000002A   0x602B             STR      R3,[R5, #+0]
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0x6050             STR      R0,[R2, #+4]
   \   00000030   0x.... 0x....      BL       halInternalIdleSleep
   \   00000034   0xB662             CPSIE    I
   \   00000036   0xB2E4             UXTB     R4,R4
   \   00000038   0xF384 0x8811      MSR      BASEPRI,R4
    254          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2307             MOVS     R3,#+7
   \   00000002   0x6013             STR      R3,[R2, #+0]
   \   00000004   0xB280             UXTH     R0,R0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x6053             STR      R3,[R2, #+4]
   \   0000000A   0x6093             STR      R3,[R2, #+8]
   \   0000000C   0x4348             MULS     R0,R0,R1
   \   0000000E   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000012   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11_5  ;; 0x4000401c
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x07D2             LSLS     R2,R2,#+31
   \   00000006   0xD504             BPL.N    ??Subroutine0_0
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0xB112             CBZ.N    R2,??Subroutine0_0
   \   0000000C   0x2118             MOVS     R1,#+24
   \   0000000E   0x1F40             SUBS     R0,R0,#+5
   \   00000010   0x4770             BX       LR
   \                     ??Subroutine0_0: (+1)
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0x07D2             LSLS     R2,R2,#+31
   \   00000016   0xD504             BPL.N    ??Subroutine0_1
   \   00000018   0x684A             LDR      R2,[R1, #+4]
   \   0000001A   0xB912             CBNZ.N   R2,??Subroutine0_1
   \   0000001C   0x210C             MOVS     R1,#+12
   \   0000001E   0x380A             SUBS     R0,R0,#+10
   \   00000020   0x4770             BX       LR
   \                     ??Subroutine0_1: (+1)
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x07D2             LSLS     R2,R2,#+31
   \   00000026   0xD404             BMI.N    ??Subroutine0_2
   \   00000028   0x6849             LDR      R1,[R1, #+4]
   \   0000002A   0xB111             CBZ.N    R1,??Subroutine0_2
   \   0000002C   0x210C             MOVS     R1,#+12
   \   0000002E   0x380F             SUBS     R0,R0,#+15
   \   00000030   0x4770             BX       LR
   \                     ??Subroutine0_2: (+1)
   \   00000032   0x2106             MOVS     R1,#+6
   \   00000034   0x3814             SUBS     R0,R0,#+20
   \                     ??Subroutine0_3: (+1)
   \   00000036   0x4770             BX       LR
    255          #endif /* DISABLE_IDLING_DELAY */
    256          
    257          /**
    258            * @brief hal SysTick Interrupt status   
    259            * @param  None
    260            * @retval None
    261            */

   \                                 In section .text, align 2, keep-with-next
    262          void halSysTickIsr(void)
    263          {
    264            /* Setting reload and count to zero will disable SysTick */
    265            SysTick->LOAD = 0;
   \                     halSysTickIsr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11  ;; 0xe000e010
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6041             STR      R1,[R0, #+4]
    266            SysTick->VAL = 0;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    267            
    268            /* Disable interrupt since we don't need it till the next tick event */
    269             SysTick->CTRL&= ~SysTick_CTRL_TICKINT;
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    270            
    271            /* When the ISR fires, that means our delay is over and the XTAL is stable */
    272            xtalUnstable = FALSE;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R0,??DataTable11_2
   \   00000014   0x7001             STRB     R1,[R0, #+0]
    273          
    274            #ifndef DISABLE_IDLING_DELAY
    275              if (wakeupXtalState == WAKEUP_XTAL_STATE_BEFORE_LO_EN) 
   \   00000016   0x7841             LDRB     R1,[R0, #+1]
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD10A             BNE.N    ??halSysTickIsr_0
    276              {
    277                /* Clear any past LO interrupts before checking current state */
    278                MGMT_IT->ISR = MGMT_ISR_HSECOMPLLIF;
   \   0000001C   0x....             LDR.N    R2,??DataTable11_3  ;; 0x4000a018
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    279          
    280                if ((CLK->HSECOMPR & CLK_HSECOMPR_LLEVEL) == CLK_HSECOMPR_LLEVEL) 
   \   00000020   0x....             LDR.N    R1,??DataTable11_4  ;; 0x4000400c
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x07C9             LSLS     R1,R1,#+31
   \   00000026   0xBF48             IT       MI 
   \   00000028   0x2103             MOVMI    R1,#+3
    281                {
    282                  /* Special case: if the LO threshold has already been crossed we don't
    283                   want to enable the LO crossing interrupt (we already missed it!),
    284                   we just want to proceed as if we already saw the interrupt.
    285                   This can happen if we go to sleep and then wakeup in less time than
    286                   it takes for the xtal to ramp down */
    287                  wakeupXtalState = WAKEUP_XTAL_STATE_READY_SWITCH;
   \   0000002A   0xD406             BMI.N    ??halSysTickIsr_1
    288                } 
    289                else 
    290                {
    291                   /* We can now enable the LO interrupt, the xtal has had enough time to
    292                      settle after being hit with max current.         
    293                      We're in the SysTick interrupt which has the same priority as the
    294                      MGMT interrupt, so we're guaranteed that the MGMT interrupt won't
    295                      fire while we're running this SysTick code. */
    296                  wakeupXtalState = WAKEUP_XTAL_STATE_LO_EN;
   \   0000002C   0x2102             MOVS     R1,#+2
   \   0000002E   0x7041             STRB     R1,[R0, #+1]
    297                  halInternalInitMgmtIsrLo();
   \   00000030   0x....             B.N      halInternalInitMgmtIsrLo
    298                }
    299              } 
    300              else if (wakeupXtalState == WAKEUP_XTAL_STATE_WAITING_FINAL) 
   \                     ??halSysTickIsr_0: (+1)
   \   00000032   0x7841             LDRB     R1,[R0, #+1]
   \   00000034   0x2904             CMP      R1,#+4
   \   00000036   0xD101             BNE.N    ??halSysTickIsr_2
    301              {
    302                /* If we're waking up (as opposed to coming out of initial powerup) then we
    303                   need to wait for the final xtal check to call the xtal "fully ready." */
    304                wakeupXtalState = WAKEUP_XTAL_STATE_FINAL;
   \   00000038   0x2105             MOVS     R1,#+5
   \                     ??halSysTickIsr_1: (+1)
   \   0000003A   0x7041             STRB     R1,[R0, #+1]
    305              }
    306            #endif
    307          }
   \                     ??halSysTickIsr_2: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
    308          
    309          /**
    310            * @brief Enables SysTick from FCLK and enable interrupt
    311            *        alSysTickIsr() is the handler for this ISR.
    312            * @param  None
    313            * @retval None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void scheduleHalSysTickIsrUs(uint16_t usDelay)
    316          {
   \                     scheduleHalSysTickIsrUs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    317            uint32_t sysTickCount;
    318            /* uint16_t usDelay = 100; */
    319          
    320            /* FIXME-svec-2011.01.31: we can possibly cut down this if/else tree if we
    321               decide what clks we'll support in this function */
    322            
    323            /* sysTickCount = (usDelay)*(1*(10**-6) / (1.0/((MHz)*(10**6)))) */
    324            if( (CLK->HSECR2&CLK_HSECR2_SW1) && CLK->CPUCR) 
   \   00000002   0x.... 0x....      BL       ?Subroutine0
    325            {
    326              /* 24MHz XTAL */
    327              sysTickCount = 24;
    328              
    329              /* a little more than 5us of overhead */
    330              usDelay -= 5;
    331            } 
    332            else if( (CLK->HSECR2&CLK_HSECR2_SW1) && !CLK->CPUCR) 
    333            {
    334              /* 12MHz XTAL */
    335              sysTickCount = 12;
    336              
    337              /* a little more than 10us of overhead */
    338              usDelay -= 10;
    339            } 
    340            else if( !(CLK->HSECR2&CLK_HSECR2_SW1) && CLK->CPUCR) 
    341            {
    342              /* 12MHz OSCHF */
    343              sysTickCount = 12;
    344              
    345              /* a little more than 15us of overhead */
    346              usDelay -= 15;
    347            } 
    348            else 
    349            {
    350              /* 6MHz OSCHF*/
    351              sysTickCount = 6;
    352              
    353              /* a little more than 20us of overhead */
    354              usDelay -= 20;
    355            }
    356            sysTickCount *= usDelay;
    357            
    358            /* Enable SysTick from FCLK and enable interrupt */
    359             SysTick->CTRL= SysTick_CTRL_CLKSOURCE | SysTick_CTRL_ENABLE | SysTick_CTRL_TICKINT;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x....             LDR.N    R2,??DataTable11  ;; 0xe000e010
   \   00000008   0x....             LDR.N    R4,??DataTable11_1  ;; 0xe000ed04
   \   0000000A   0x.... 0x....      BL       ?Subroutine1
    360            
    361            /* Setting reload and count to zero will disable SysTick and clear COUNTFLAG */
    362            SysTick->LOAD = 0;
    363            SysTick->VAL = 0;
    364            
    365            /* Clear any stale SysTick interrupt */
    366            SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000000E   0x6023             STR      R3,[R4, #+0]
    367            
    368            /* Setting reload value effectively starts timer counting */
    369            SysTick->LOAD = (sysTickCount-1);
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x6050             STR      R0,[R2, #+4]
    370          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    371          
    372          /**
    373            * @brief Calibrates Slow RC
    374            * @param  None
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          void halInternalCalibrateSlowRc(void)
    378          {
   \                     halInternalCalibrateSlowRc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    379            uint8_t i;
    380            uint32_t average=0;
    381            int16_t delta;
    382            uint32_t period;
    383            
    384            CALDBG(
    385              stSerialPrintf(ST_ASSERT_SERIAL_PORT, "halInternalCalibrateSlowRc:\r\n");
    386            )
    387            
    388              /* STEP 1: coarsely tune SlowRC in analog section to ~10kHz */
    389              /* To operate properly across the full temperature and voltage range,
    390              the RC source in the analog section needs to be first coarsely tuned
    391              to 10kHz.  The CLK->LSI10KCR register, which is 2's compliment, provides 16
    392              steps at ~400Hz per step yielding approximate frequences of 8kHz at 7
    393              and 15kHz at -8.
    394              Start with our reset values for TUNE and CAL */
    395              CLK->PERIODCR = 0; //measure SlowRC
   \   00000004   0x....             LDR.N    R5,??DataTable11_6  ;; 0x40004010
    396              CLK->LSI10KCR = 0x00;
   \   00000006   0x....             LDR.N    R6,??DataTable11_7  ;; 0x4000000c
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x602C             STR      R4,[R5, #+0]
   \   0000000C   0x6034             STR      R4,[R6, #+0]
    397              CLK->LSI1KCR = 0x5000;
   \   0000000E   0xF44F 0x40A0      MOV      R0,#+20480
   \   00000012   0x6070             STR      R0,[R6, #+4]
    398              /* wait for the PERIOD register to properly update */
    399              idleDelayMicroseconds(SLOWRC_PERIOD_SETTLE_TIME);
   \   00000014   0xF241 0x089A      MOVW     R8,#+4250
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0x.... 0x....      BL       idleDelayMicroseconds
    400              
    401              /* Measure the current CLK->PERIODSR to obtain a baseline */
    402              CALDBG(
    403                stSerialPrintf(ST_ASSERT_SERIAL_PORT,
    404                "period: %u, ", CLK->PERIODSR);
    405                stSerialPrintf(ST_ASSERT_SERIAL_PORT, "%u Hz\r\n", 
    406                                 ((uint16_t)(((uint32_t)192000000)/((uint32_t)CLK->PERIODSR))));
    407              )
    408              /* For 10kHz, the ideal CLK->PERIODSR is 19200.  Calculate the PERIOD delta.
    409              It's possible for a chip's 10kHz source RC to be too far out of range
    410              for the CLK->LSI10KCR to bring it back to 10kHz.  Therefore, we have to
    411              ensure that our delta correction does not exceed the tune range so
    412              tune has to be capped to the end of the vailable range so it does not
    413              wrap.  Even if we cannot achieve 10kHz, the 1kHz calibration can still
    414              properly correct to 1kHz.
    415              Each CLK->LSI10KCR step yields a CLK->PERIODSR delta of *approximately* 800.
    416              Calculate how many steps we are off.  While dividing by 800 may seem
    417              like an ugly calculation, the precision of the result is worth the small
    418              bit of code and time needed to do a divide */
    419              period = CLK->PERIODSR;
   \   0000001E   0x6868             LDR      R0,[R5, #+4]
    420              
    421              /* Round to the nearest integer*/
    422              delta = (19200+400) - period;
    423              delta /= 800;
   \   00000020   0xF644 0x4190      MOVW     R1,#+19600
   \   00000024   0x1A08             SUBS     R0,R1,R0
   \   00000026   0xB200             SXTH     R0,R0
   \   00000028   0xF44F 0x7148      MOV      R1,#+800
   \   0000002C   0xFB90 0xF0F1      SDIV     R0,R0,R1
    424              
    425              /* CLK->LSI10KCR is a 4 bit signed number.  cap the delta to 7/-8*/
    426              if(delta > 7) 
   \   00000030   0xB200             SXTH     R0,R0
   \   00000032   0x2808             CMP      R0,#+8
   \   00000034   0xBFA8             IT       GE 
   \   00000036   0x2007             MOVGE    R0,#+7
    427              {
    428                delta = 7;
   \   00000038   0xDA04             BGE.N    ??halInternalCalibrateSlowRc_0
    429              }
    430              if(delta < -8) 
   \   0000003A   0xF110 0x0F08      CMN      R0,#+8
   \   0000003E   0xBFB8             IT       LT 
   \   00000040   0xF06F 0x0007      MVNLT    R0,#+7
    431              {
    432                delta = -8;
    433              }
    434              CALDBG(
    435                stSerialPrintf(ST_ASSERT_SERIAL_PORT, "TUNE steps delta: %d\r\n",
    436                                  delta);
    437              )
    438              CLK->LSI10KCR = delta;
   \                     ??halInternalCalibrateSlowRc_0: (+1)
   \   00000044   0x6030             STR      R0,[R6, #+0]
    439              /* wait for PERIOD to update before taking another sample */
    440              idleDelayMicroseconds(SLOWRC_PERIOD_SETTLE_TIME);
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       idleDelayMicroseconds
    441              CALDBG(
    442                stSerialPrintf(ST_ASSERT_SERIAL_PORT,
    443                "period: %u, ", CLK->PERIODSR);
    444                stSerialPrintf(ST_ASSERT_SERIAL_PORT, "%u Hz\r\n", 
    445                                 ((uint16_t)(((uint32_t)192000000)/((uint32_t)CLK->PERIODSR))));
    446              )
    447              /* The analog section should now be producing an output of ~10kHz */
    448              
    449              /* ---- STEP 2: fine tune the SlowRC to 1024Hz ---- */
    450              /* Our goal is to generate a 1024Hz source.  The register CLK->LSI1KCR is a
    451              fractional divider that divides the 10kHz analog source and generates
    452              the clk1k output.  At reset, the default value is 0x5000 which yields a
    453              division of 10.000.  By averaging several samples of CLK->PERIODSR, we
    454              can then calculate the proper divisor need for CLK->LSI1KCR to make 1024Hz */
    455              for(i=0;i<SLOWRC_PERIOD_SAMPLES;i++) 
   \   0000004C   0x2708             MOVS     R7,#+8
    456              {
    457                idleDelayMicroseconds(SLOWRC_PERIOD_SETTLE_TIME);
   \                     ??halInternalCalibrateSlowRc_1: (+1)
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0x.... 0x....      BL       idleDelayMicroseconds
    458                average += CLK->PERIODSR;
   \   00000054   0x6868             LDR      R0,[R5, #+4]
   \   00000056   0x1904             ADDS     R4,R0,R4
    459              }
   \   00000058   0x1E7F             SUBS     R7,R7,#+1
   \   0000005A   0xD1F8             BNE.N    ??halInternalCalibrateSlowRc_1
    460              /* calculate the average, with proper rounding */
    461              average = (average+(SLOWRC_PERIOD_SAMPLES/2))/SLOWRC_PERIOD_SAMPLES;
    462              CALDBG(
    463                stSerialPrintf(ST_ASSERT_SERIAL_PORT, "average: %u, %u Hz\r\n",
    464                  ((uint16_t)average), ((uint16_t)(((uint32_t)192000000)/((uint32_t)average))));
    465              )    
    466              /* using an average period sample, calculate the clk1k divisor */
    467              CLK->LSI1KCR = (uint16_t)(CLK1K_NUMERATOR/average);
   \   0000005C   0x1D21             ADDS     R1,R4,#+4
   \   0000005E   0x....             LDR.N    R0,??DataTable11_8  ;; 0x16e36000
   \   00000060   0x08C9             LSRS     R1,R1,#+3
   \   00000062   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000066   0xB280             UXTH     R0,R0
   \   00000068   0x6070             STR      R0,[R6, #+4]
    468              CALDBG(
    469                stSerialPrintf(ST_ASSERT_SERIAL_PORT,"CLK->LSI1KCR=%2X\r\n",CLK->LSI1KCR);
    470              )
    471              /* The SlowRC timer is now producing a 1024Hz tick (+/-2Hz) */
    472              
    473            CALDBG(
    474              stSerialPrintf(ST_ASSERT_SERIAL_PORT, "DONE\r\n");
    475            )
    476          }
   \   0000006A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    477          
    478          /**
    479            * @brief Calibrates Fast RC
    480            *        The CLK->PERIODSR register measures the number of 12MHz cycles in 256
    481            *        cycles of OSCHF:
    482            *                       256 * 12000000
    483            *                      ------------- = ~12MHz
    484            *                       CLK->PERIODSR
    485            * @param  None
    486            * @retval None
    487            */   

   \                                 In section .text, align 2, keep-with-next
    488          void halInternalCalibrateFastRc(void)
    489          {
   \                     halInternalCalibrateFastRc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    490            int32_t newTune = -16;
    491            
    492            CALDBG(
    493              stSerialPrintf(ST_ASSERT_SERIAL_PORT, "halInternalCalibrateFastRc:\r\n");
    494            )
    495            
    496              /* ---- coarsely tune FastRC in analog section to ~12MHz ---- */
    497              /* The RC source in the analog section needs to be coarsely tuned
    498                 to 12MHz.  The CLK->HSICR register, which is 2's compliment, provides 32
    499                 steps at ~0.5MHz per step yielding approximate frequences of 4MHz at 15
    500                 and 20MHz at -16 */
    501              /* measure FastRC */
    502              CLK->PERIODCR = 1; 
   \   00000002   0x....             LDR.N    R5,??DataTable11_9  ;; 0x40004008
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF06F 0x040F      MVN      R4,#+15
   \   0000000A   0x60A8             STR      R0,[R5, #+8]
    503            
    504              CALDBG(
    505                /* start at the fastest possible frequency */
    506                CLK->HSICR = newTune;
    507                
    508                /* wait for the PERIOD register to properly update */
    509                idleDelayMicroseconds(FASTRC_PERIOD_SETTLE_TIME);
    510                
    511                /* Measure the current CLK->PERIODSR to obtain a baseline */
    512                stSerialPrintf(ST_ASSERT_SERIAL_PORT,
    513                "period: %u, ", CLK->PERIODSR);
    514                stSerialPrintf(ST_ASSERT_SERIAL_PORT, "%u kHz\r\n", 
    515                                 ((uint16_t)((((uint32_t)3072000000)/((uint32_t)CLK->PERIODSR))/1000)));
    516              )
    517              /* For 12MHz, the ideal CLK->PERIODSR is 256.  Tune the frequency down until
    518              the period is <= 256, which says the frequency is as close to 12MHz as
    519              possible (without going over 12MHz)
    520              Start at the fastest possible frequency (-16) and increase to the slowest
    521              possible (15).  When CLK->PERIODSR is <=256 or we run out of tune values,
    522              we're done */
    523              for(;newTune<16;newTune++) {
    524                /* decrease frequency by one step (by increasing tune value) */
    525                CLK->HSICR = newTune;
   \                     ??halInternalCalibrateFastRc_0: (+1)
   \   0000000C   0x602C             STR      R4,[R5, #+0]
    526                
    527                /* wait for the PERIOD register to properly update */
    528                idleDelayMicroseconds(FASTRC_PERIOD_SETTLE_TIME);
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x.... 0x....      BL       idleDelayMicroseconds
    529                
    530                /* kickout if we're tuned */
    531                if(CLK->PERIODSR>=256) {
   \   00000014   0x68E8             LDR      R0,[R5, #+12]
   \   00000016   0x28FF             CMP      R0,#+255
   \   00000018   0xD802             BHI.N    ??halInternalCalibrateFastRc_1
    532                  break;
    533                }
    534              }
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0x2C10             CMP      R4,#+16
   \   0000001E   0xDBF5             BLT.N    ??halInternalCalibrateFastRc_0
    535              CALDBG(
    536                /* Measure the current CLK->PERIODSR to show the final result */
    537                stSerialPrintf(ST_ASSERT_SERIAL_PORT,
    538                "period: %u, ", CLK->PERIODSR);
    539                stSerialPrintf(ST_ASSERT_SERIAL_PORT, "%u kHz\r\n", 
    540                                 ((uint16_t)((((uint32_t)3072000000)/((uint32_t)CLK->PERIODSR))/1000)));
    541              )
    542              
    543              /* The analog section should now be producing an output of 11.5MHz - 12.0MHz */
    544          }
   \                     ??halInternalCalibrateFastRc_1: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    545          
    546          /**
    547            * @brief  This function configures the flash access controller for optimal
    548            *         current consumption when FCLK is operating from XTAL.  By providing
    549            *         this function, the calling code does not have to be aware of the
    550            *         details of setting FLASH_ACCESS.
    551            *         NOTE: HALFCYCLE_ACCESS should not be used on STM32W108 
    552            * @param  None
    553            * @retval None
    554            */
    555          static void halInternalConfigXtalFlashAccess(void)
    556          {
    557            ATOMIC(
    558              BYPASS_MPU(
    559                #if defined(CORTEXM3_STM32W108) 
    560                #if defined(CORTEXM3_STM32W108xB) 
    561                  /* For STM32W108xB, due to an hardware limitation we are forced to use 1 wait state both on 24MHz and 12MHz */
    562                  FLASH->ACR= (FLASH_ACR_PRFTBE |
    563                                  (1<<0));
    564                #endif
    565                #if defined(CORTEXM3_STM32W108CC) 
    566                  FLASH->ACR= (FLASH_ACR_PRFTBE |
    567                                  ((CLK->CPUCR&CLK_CPUCR_SW2)<<0));
    568                #endif
    569                #else
    570                  FLASH->ACR= (FLASH_ACCESS_FLASH_LP             |
    571                                  FLASH_ACR_PRFTBE          |
    572                                  (1<<0));
    573                #endif
    574              )
    575            )
    576          }
    577          
    578          /**
    579            * @brief  Enable SysTick from FCLK and enable interrupt
    580            * @param  None
    581            * @retval None
    582            */
    583          static void scheduleNextBiasTrimEvent(void)
    584          {
    585            /* Enable SysTick from FCLK and enable interrupt */
    586             SysTick->CTRL= SysTick_CTRL_CLKSOURCE | SysTick_CTRL_ENABLE | SysTick_CTRL_TICKINT;
    587            
    588            /* Setting reload and count to zero will disable SysTick and clear COUNTFLAG */
    589            SysTick->LOAD = 0;
    590            SysTick->VAL = 0;
    591            
    592            /* Clear any stale SysTick interrupt */
    593            SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk;
    594            
    595            /* Setting reload value effectively starts timer counting. This code can
    596               be called from any clock configuration. */
    597            if( (CLK->HSECR2&CLK_HSECR2_SW1) && CLK->CPUCR) 
    598            {
    599              /* 24MHz XTAL */
    600              SysTick->LOAD = (24*XTAL_STABILIZING_TIME_US)-1;
    601            } else if( (CLK->HSECR2&CLK_HSECR2_SW1) && !CLK->CPUCR) {
    602              /* 12MHz XTAL */
    603              SysTick->LOAD = (12*XTAL_STABILIZING_TIME_US)-1;
    604            } else if( !(CLK->HSECR2&CLK_HSECR2_SW1) && CLK->CPUCR) {
    605              /* 12MHz OSCHF */
    606              SysTick->LOAD = (12*XTAL_STABILIZING_TIME_US)-1;
    607            } else {
    608              /* 6MHz OSCHF */
    609              SysTick->LOAD = (6*XTAL_STABILIZING_TIME_US)-1;
    610            }
    611          }
    612          
    613          /**
    614            * @brief  Setup the managment ISR
    615            * @param  None
    616            * @retval None
    617            */

   \                                 In section .text, align 2, keep-with-next
    618          void halInternalInitMgmtIsrLo(void)
    619          {
    620            /* Setup the managment ISR so we are notified when the xtal crosses the 
    621              'LO' threshold */
    622            MGMT_IT->IER |= MGMT_ISR_HSECOMPLLIF;
   \                     halInternalInitMgmtIsrLo: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_10  ;; 0x4000a058
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    623            NVIC->ICPR[0] = NVIC_IxxR_MGMT;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x....             LDR.N    R1,??DataTable11_11  ;; 0xe000e280
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    624            NVIC->ISER[0] = NVIC_IxxR_MGMT;
   \   00000010   0x....             LDR.N    R1,??DataTable11_12  ;; 0xe000e100
   \   00000012   0x6008             STR      R0,[R1, #+0]
    625          }
   \   00000014   0x4770             BX       LR               ;; return
    626          
    627          /**
    628            * @brief  Called only when waking from sleep
    629            *         We want to "kick" the xtal to get it to start ASAP, so we apply the max
    630            *         current to it 
    631            * @param  None
    632            * @retval None
    633            */

   \                                 In section .text, align 2, keep-with-next
    634          void halInternalPowerUpKickXtal(void)
    635          {
   \                     halInternalPowerUpKickXtal: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    636            useXtalAsIs = FALSE;
   \   00000002   0x....             LDR.N    R4,??DataTable11_2
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x70E0             STRB     R0,[R4, #+3]
    637          
    638            /* If the xtal is already enabled and we're running from it, then we'll try
    639               to keep using it as-is. As long as the bias is what we expect, we'll just
    640               keep on truckin'! */
    641            if ((CLK->HSECR2 & (CLK_HSECR2_EN | CLK_HSECR2_SW1))
    642                           == (CLK_HSECR2_EN | CLK_HSECR2_SW1)) 
   \   00000008   0x....             LDR.N    R0,??DataTable11_13  ;; 0x40004004
   \   0000000A   0x6981             LDR      R1,[R0, #+24]
   \   0000000C   0xF001 0x0103      AND      R1,R1,#0x3
   \   00000010   0x2903             CMP      R1,#+3
   \   00000012   0xD106             BNE.N    ??halInternalPowerUpKickXtal_0
    643            {
    644              /* FIXME-svec-2011.02.09: do we need to set previousLoValue=TRUE to make it
    645                 faster? */
    646              xtalUnstable = FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    647              halCommonSwitchToXtal();
   \   00000018   0x.... 0x....      BL       halCommonSwitchToXtal
    648          
    649              useXtalAsIs = TRUE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x70E0             STRB     R0,[R4, #+3]
    650              return;
   \   00000020   0xBD10             POP      {R4,PC}
    651            }
    652          
    653            /* Send max current to the xtal so it ramps ASAP. */
    654            CLK->HSECR1 = OSC24M_BIASTRIM_MAX;
   \                     ??halInternalPowerUpKickXtal_0: (+1)
   \   00000022   0x210F             MOVS     R1,#+15
   \   00000024   0x6001             STR      R1,[R0, #+0]
    655            CLK->HSECR2 = CLK_HSECR2_EN;
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x6181             STR      R1,[R0, #+24]
    656          
    657            /* We're going to give the xtal 100us to ramp/settle until we enable the LO
    658               interrupt. */
    659            wakeupXtalState = WAKEUP_XTAL_STATE_BEFORE_LO_EN;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x7060             STRB     R0,[R4, #+1]
    660            scheduleHalSysTickIsrUs(100);
   \   0000002E   0x2064             MOVS     R0,#+100
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x....             B.N      scheduleHalSysTickIsrUs
    661          }
    662          
    663          /**
    664            * @brief  Switches to Xtal24M
    665            * @param  None
    666            * @retval None
    667            */

   \                                 In section .text, align 2, keep-with-next
    668          void halInternalSwitchToXtal24M(void)
    669          {
    670          /* We've found a valid trim value and we've waited for the oscillator
    671             to stabalize, it's now safe to select the XTAL */
    672            CLK->HSECR2 |= CLK_HSECR2_SW1;
   \                     halInternalSwitchToXtal24M: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_5  ;; 0x4000401c
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    673          
    674          /* Standard mode of operation is 24MHz (FCLK is sourced from SYSCLK) */
    675          #if CORTEXM3_STM32W108_CPU_CLOCK_12MHz == 1
    676            CLK->CPUCR = 0;
    677          #else
    678            CLK->CPUCR = CLK_CPUCR_SW2;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    679          #endif
    680          
    681          /* Configures flash access for optimal current consumption */
    682            halInternalConfigXtalFlashAccess();
   \   0000000E   0xF3EF 0x8011      MRS      R0,BASEPRI
   \   00000012   0x2160             MOVS     R1,#+96
   \   00000014   0xF381 0x8811      MSR      BASEPRI,R1
   \   00000018   0x....             LDR.N    R2,??DataTable11_14  ;; 0x40008000
   \   0000001A   0x2111             MOVS     R1,#+17
   \   0000001C   0x6011             STR      R1,[R2, #+0]
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0xF380 0x8811      MSR      BASEPRI,R0
    683          }
   \   00000024   0x4770             BX       LR               ;; return
    684          
    685          /**
    686            * @brief  This is the core function for enabling the XTAL, 
    687            *          biasing the XTAL, checking the XTAL biasing, 
    688            *          switching to the XTAL, configuring FCLK, and configuring flash access settings
    689            * @param  None
    690            * @retval None
    691            */

   \                                 In section .text, align 2, keep-with-next
    692          boolean halCommonTryToSwitchToXtal(void)
    693          {
   \                     halCommonTryToSwitchToXtal: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    694            boolean loSet = 0;
    695            boolean hiSet = 0;
    696            
    697            if(biasTrim == OSC24M_BIASTRIM_UNINIT) 
   \   00000002   0x....             LDR.N    R1,??DataTable11_2
   \   00000004   0x....             LDR.N    R0,??DataTable11_13  ;; 0x40004004
   \   00000006   0x88CA             LDRH     R2,[R1, #+6]
   \   00000008   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000000C   0x42A2             CMP      R2,R4
   \   0000000E   0xD11E             BNE.N    ??halCommonTryToSwitchToXtal_0
    698            {
    699             /* halCommonGetMfgToken(&biasTrim, TOKEN_MFG_OSC24M_BIAS_TRIM);
    700                If the biasTrim loaded from the token is not a valid trim,
    701                select a common starting value.  Then the normal algorithm
    702                will occur to optimize the biasTrim. */
    703              if(biasTrim == OSC24M_BIASTRIM_UNINIT) 
    704              {
    705                /* Since many chips endup at minimum, let's just start at minimum
    706                   and let the linear search do the rest */
    707                biasTrim = OSC24M_BIASTRIM_MIN;
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x80CA             STRH     R2,[R1, #+6]
    708            }    
    709              /* If the XTAL is not already enabled, then enable it */
    710              if((CLK->HSECR2&CLK_HSECR2_EN) != CLK_HSECR2_EN)
   \   00000014   0x6982             LDR      R2,[R0, #+24]
   \   00000016   0x0792             LSLS     R2,R2,#+30
   \   00000018   0xD403             BMI.N    ??halCommonTryToSwitchToXtal_1
    711              {
    712                CLK->HSECR2 |= CLK_HSECR2_EN;
   \                     ??halCommonTryToSwitchToXtal_2: (+1)
   \   0000001A   0x6982             LDR      R2,[R0, #+24]
   \   0000001C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000020   0x6182             STR      R2,[R0, #+24]
    713              }
    714              goto setNewTrim;
    715            }
    716            
    717            /* If the XTAL is not already enabled, then enable it.  But, we need
    718               to set the trim value and wait for the HI/LO flags to become stable
    719               before taking action on the flags. */
    720            if((CLK->HSECR2&CLK_HSECR2_EN) != CLK_HSECR2_EN) {
    721              CLK->HSECR2 |= CLK_HSECR2_EN;
    722              goto setNewTrim;
    723            }
    724            
    725            #ifdef DISABLE_IDLING_DELAY
    726            if( SysTick->CTRL& ST_CSR_COUNTFLAG) {
    727              halSysTickIsr();
    728            }
    729            #endif /* DISABLE_IDLING_DELAY */
    730            if(xtalUnstable) {
    731             /* This means our HI/LO flags cannot be read so there is nothing to
    732                do until the XTAL/flags are stable.  Indicate selection has not
    733                changed and the XTAL is unstable. */
    734              return FALSE;
    735            }
    736            
    737            /* OBTAIN THE HI/LO flags */
    738            loSet = ((CLK->HSECOMPR & CLK_HSECOMPR_LLEVEL) == CLK_HSECOMPR_LLEVEL);
    739            hiSet = ((CLK->HSECOMPR & CLK_HSECOMPR_HLEVEL) == CLK_HSECOMPR_HLEVEL);
    740            #ifdef BIASTRIM_TEST
    741            if(biasTrimTestEnabled) {
    742              loSet = (OSC24M_BIASTRIM>osc24mThreshLo);
    743              hiSet = (OSC24M_BIASTRIM>osc24mThreshHi);
    744            }
    745            #endif /* BIASTRIM_TEST */
    746            
    747            /* DETERMINE TRIM CHANGE */
    748            /* The goal is the lowest value for which HI=0 and LO=1.  For all possible
    749               scenarios, the LO flag gets priority.  That means the final TRIM should
    750               always be bounded by MAX and MIN and the LO flag should always be set. */
    751            if(!loSet) {
    752              /*The bias is too low, so we need to increment the bias trim.
    753                but don't trim above our max value */
    754              if(biasTrim<OSC24M_BIASTRIM_MAX) {
    755                biasTrim++;
    756              }
    757            } else if(hiSet && previousLoValue) {
    758              /* The bias is too high, so we need to decrement the bias trim.
    759                 but don't trim below our min value */
    760              if(biasTrim>OSC24M_BIASTRIM_MIN) {
    761                biasTrim--;
    762              }
    763            }
    764            /* In a situation where LO and HI track identically to the same bias trim
    765               threshold value, the increment and decrement code would cause
    766               oscillation on the trim value.  Knowing that the previous LO was
    767               cleared and the current HI is set means that they match and we're
    768               already oscillating around the minimal value.  The net effect of knowing
    769               the previous value is to not oscillate and stay at the minimal value.
    770               The only penalty is two unnecessary trim settings; but that's needed
    771               to find the transition point where the flags change. */
    772            previousLoValue = loSet;
    773            
    774            /* Don't allow bias trim to dip below the min regardless of LO/HI. */
    775            if(biasTrim<OSC24M_BIASTRIM_MIN) {
    776              biasTrim = OSC24M_BIASTRIM_MIN;
    777            }
    778            
    779            /* TRY TO APPLY CHANGES */
    780            if(CLK->HSECR1 == biasTrim) {
    781          
    782              halInternalSwitchToXtal24M();
    783              
    784              /* Indicate the switch has ocurred and the XTAL is stable. */
    785              return TRUE;
    786            }
    787            
    788          setNewTrim:
    789            xtalUnstable = TRUE;
   \                     ??halCommonTryToSwitchToXtal_1: (+1)
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x700A             STRB     R2,[R1, #+0]
   \   00000026   0x2207             MOVS     R2,#+7
    790            CLK->HSECR1 = biasTrim;
   \   00000028   0x88C9             LDRH     R1,[R1, #+6]
   \   0000002A   0x....             LDR.N    R3,??DataTable11_1  ;; 0xe000ed04
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    791            scheduleNextBiasTrimEvent();
   \   0000002E   0x....             LDR.N    R1,??DataTable11  ;; 0xe000e010
   \   00000030   0x600A             STR      R2,[R1, #+0]
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x604A             STR      R2,[R1, #+4]
   \   00000036   0x608A             STR      R2,[R1, #+8]
   \   00000038   0xF04F 0x7200      MOV      R2,#+33554432
   \   0000003C   0x601A             STR      R2,[R3, #+0]
   \   0000003E   0x6982             LDR      R2,[R0, #+24]
   \   00000040   0x07D2             LSLS     R2,R2,#+31
   \   00000042   0xD527             BPL.N    ??halCommonTryToSwitchToXtal_3
   \   00000044   0x69C2             LDR      R2,[R0, #+28]
   \   00000046   0xB32A             CBZ.N    R2,??halCommonTryToSwitchToXtal_3
   \   00000048   0xF648 0x409F      MOVW     R0,#+35999
   \   0000004C   0xE031             B.N      ??halCommonTryToSwitchToXtal_4
   \                     ??halCommonTryToSwitchToXtal_0: (+1)
   \   0000004E   0x6985             LDR      R5,[R0, #+24]
   \   00000050   0x07AD             LSLS     R5,R5,#+30
   \   00000052   0xD5E2             BPL.N    ??halCommonTryToSwitchToXtal_2
   \   00000054   0x780D             LDRB     R5,[R1, #+0]
   \   00000056   0xBB6D             CBNZ.N   R5,??halCommonTryToSwitchToXtal_5
   \   00000058   0x6885             LDR      R5,[R0, #+8]
   \   0000005A   0x6886             LDR      R6,[R0, #+8]
   \   0000005C   0xF015 0x0501      ANDS     R5,R5,#0x1
   \   00000060   0xD103             BNE.N    ??halCommonTryToSwitchToXtal_6
   \   00000062   0x2A0F             CMP      R2,#+15
   \   00000064   0xDA08             BGE.N    ??halCommonTryToSwitchToXtal_7
   \   00000066   0x1C52             ADDS     R2,R2,#+1
   \   00000068   0xE006             B.N      ??halCommonTryToSwitchToXtal_7
   \                     ??halCommonTryToSwitchToXtal_6: (+1)
   \   0000006A   0x07B6             LSLS     R6,R6,#+30
   \   0000006C   0xD504             BPL.N    ??halCommonTryToSwitchToXtal_7
   \   0000006E   0x790E             LDRB     R6,[R1, #+4]
   \   00000070   0xB116             CBZ.N    R6,??halCommonTryToSwitchToXtal_7
   \   00000072   0x2A03             CMP      R2,#+3
   \   00000074   0xBFA8             IT       GE 
   \   00000076   0x18A2             ADDGE    R2,R4,R2
   \                     ??halCommonTryToSwitchToXtal_7: (+1)
   \   00000078   0xB292             UXTH     R2,R2
   \   0000007A   0x2A02             CMP      R2,#+2
   \   0000007C   0xBFB8             IT       LT 
   \   0000007E   0x2202             MOVLT    R2,#+2
   \   00000080   0x80CA             STRH     R2,[R1, #+6]
   \   00000082   0x710D             STRB     R5,[R1, #+4]
   \   00000084   0x6802             LDR      R2,[R0, #+0]
   \   00000086   0x88CB             LDRH     R3,[R1, #+6]
   \   00000088   0x429A             CMP      R2,R3
   \   0000008A   0xD1CA             BNE.N    ??halCommonTryToSwitchToXtal_1
   \   0000008C   0x.... 0x....      BL       halInternalSwitchToXtal24M
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xBD70             POP      {R4-R6,PC}
   \                     ??halCommonTryToSwitchToXtal_3: (+1)
   \   00000094   0x6982             LDR      R2,[R0, #+24]
   \   00000096   0x07D2             LSLS     R2,R2,#+31
   \   00000098   0xD501             BPL.N    ??halCommonTryToSwitchToXtal_8
   \   0000009A   0x69C2             LDR      R2,[R0, #+28]
   \   0000009C   0xB122             CBZ.N    R2,??halCommonTryToSwitchToXtal_9
   \                     ??halCommonTryToSwitchToXtal_8: (+1)
   \   0000009E   0x6982             LDR      R2,[R0, #+24]
   \   000000A0   0x07D2             LSLS     R2,R2,#+31
   \   000000A2   0xD404             BMI.N    ??halCommonTryToSwitchToXtal_10
   \   000000A4   0x69C0             LDR      R0,[R0, #+28]
   \   000000A6   0xB110             CBZ.N    R0,??halCommonTryToSwitchToXtal_10
   \                     ??halCommonTryToSwitchToXtal_9: (+1)
   \   000000A8   0xF244 0x604F      MOVW     R0,#+17999
   \   000000AC   0xE001             B.N      ??halCommonTryToSwitchToXtal_4
   \                     ??halCommonTryToSwitchToXtal_10: (+1)
   \   000000AE   0xF242 0x3027      MOVW     R0,#+8999
   \                     ??halCommonTryToSwitchToXtal_4: (+1)
   \   000000B2   0x6048             STR      R0,[R1, #+4]
    792            /* Indicate selection has not changed and the XTAL is unstable. */
    793            return FALSE;
   \                     ??halCommonTryToSwitchToXtal_5: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
    794          }
    795          
    796          /**
    797            * @brief  performs/completes the switch process to the XTAL.  This function is the blocking form of
    798            *         halCommonTryToSwitchToXtal.  Instead of burning cycles, it idles the CPU and uses the xtalUnstable 
    799            *         event ISR to exit idling.
    800            * @param  None
    801            * @retval None
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          void halCommonSwitchToXtal(void)
    804          {
   \                     halCommonSwitchToXtal: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    805            boolean switched = FALSE;
    806            
    807            while(!switched) {
    808              #ifdef DISABLE_IDLING_DELAY
    809              switched = halCommonTryToSwitchToXtal();
    810              if(!switched) {
    811                halCommonDelayMicroseconds(XTAL_STABILIZING_TIME_US);
    812              }
    813              #else //DISABLE_IDLING_DELAY
    814              ATOMIC(
    815               /* NOTE: SysTick's priority level causes it to bypass the ATOMIC behavior.
    816                      The ATOMIC is used to block all normal interrupts.  Therefore,
    817                      we don't have to use INTERRUPTS_ON when transitioning to
    818                      idle sleep, but we still need to use PRIMASK to disable all
    819                      interrupts, including SysTick, to transition to idle. */
    820                __disable_irq();
    821                
    822               /* halCommonTryToSwitchToXtal could/will schedule an interrupt
    823                to take us out of idle sleep.  By scheduling that interrupt in
    824                an ATOMIC block, we ensure that the interrupt is still valid
    825                for when we invoke idle sleep. */
    826                switched = halCommonTryToSwitchToXtal();
    827                
    828                /* TRUE: Using the XTAL. xtalUnstable==FALSE. No ISR is pending.
    829                   That means we're done, so return. */
    830                /* FALSE: XTAL *selection unchanged*. xtalUnstable==TRUE.
    831                   *ISR is pending.* Even though we may be on the XTAL already, 
    832                    the key here is that there is an ISR pending which will allow 
    833                    us to exit idle sleep, however long (or short) in the future that may be. */
    834                if(!switched) {
    835          #ifdef FLASH_ACCESS_FLASH_LP
    836                  BYPASS_MPU(
    837                             uint32_t FLASH_ACCESS_SAVED = FLASH_ACCESS;
    838                             FLASH->ACR&= ~FLASH_ACCESS_FLASH_LP;
    839                             halInternalIdleSleep();
    840                             FLASH->ACR= FLASH_ACCESS_SAVED;
    841                             )
    842          #else /* FLASH_ACCESS_FLASH_LP */
    843                halInternalIdleSleep();
    844          #endif /* FLASH_ACCESS_FLASH_LP */
    845                }
    846                __enable_irq();
    847                )
   \                     ??halCommonSwitchToXtal_0: (+1)
   \   00000002   0xF3EF 0x8411      MRS      R4,BASEPRI
   \   00000006   0x2060             MOVS     R0,#+96
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0xB672             CPSID    I
   \   0000000E   0x.... 0x....      BL       halCommonTryToSwitchToXtal
   \   00000012   0x0005             MOVS     R5,R0
   \   00000014   0xBF08             IT       EQ 
   \   00000016   0x.... 0x....      BLEQ     halInternalIdleSleep
   \   0000001A   0xB662             CPSIE    I
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0xF384 0x8811      MSR      BASEPRI,R4
    848              #endif /* DISABLE_IDLING_DELAY */
    849            }
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD0ED             BEQ.N    ??halCommonSwitchToXtal_0
    850          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    851          
    852          #ifndef DISABLE_IDLING_DELAY
    853          
    854          /**
    855            * @brief Blocks until Xtal above LO  
    856            * @param  None
    857            * @retval None
    858            */
    859          static void halInternalBlockUntilXtalAboveLo(void)
    860          {
    861            /* We must be above the LO threshold for at least xtalAboveLoThresholdUs in
    862               order to proceed. */
    863            boolean done = 0;
    864          
    865            /* We're not using the XTAL, the MAC Timer is running off OSCHF,
    866            that means the clock is half speed, 6MHz.  We need to halve our delay
    867            time. */
    868            uint16_t shiftedDelay = xtalAboveLoThresholdUs >> 1;
    869          
    870            /* MAC Timer is enabled in emRadioInit, which may not have been called yet. */
    871            /* This algorithm needs the MAC Timer so we enable it here. */
    872            MACTMR->CR |= MACTMR_CR_EN;
    873          
    874            while (! done) {
    875          
    876              /* Most of this code was stolen from halCommonDelayMicroseconds(). */
    877              uint32_t beginTime = MACTMR->CNTR;
    878              done = 1;
    879          
    880              do {
    881               /* We must check that we're above the LO threshold even if we've already
    882                 gone past the timer delay limit. */
    883                if ((CLK->HSECOMPR & CLK_HSECOMPR_LLEVEL) != CLK_HSECOMPR_LLEVEL) 
    884                {
    885                  done = 0;
    886                  break;
    887                }
    888          
    889               /* since our max delay (255) is less than half the size of the 
    890                  20 bit mac timer, we can easily just handle the potential for
    891                  mac timer wrapping by subtracting the time delta and masking out
    892                  the extra bits */
    893              } while( ((MACTMR->CNTR - beginTime)&MACTMR_CNTR_CNT) < shiftedDelay );
    894            }
    895          }
    896          
    897          /**
    898            * @brief we're ready to switch to the XTAL as the clock, then switch
    899            * @param  None
    900            * @retval None
    901            */

   \                                 In section .text, align 2, keep-with-next
    902          void halInternalBlockUntilXtal(void)
    903          {
   \                     halInternalBlockUntilXtal: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    904            if (useXtalAsIs) 
   \   00000002   0x....             LDR.N    R4,??DataTable11_2
   \   00000004   0x78E0             LDRB     R0,[R4, #+3]
   \   00000006   0xB178             CBZ.N    R0,??halInternalBlockUntilXtal_0
    905            {
    906              return;
   \   00000008   0xBD31             POP      {R0,R4,R5,PC}
    907            }
    908            while (wakeupXtalState != WAKEUP_XTAL_STATE_READY_SWITCH) 
    909            {
    910              ATOMIC(
    911               /* ATOMIC sets basepri==12, so any interrupts <priority12 are still
    912                  running, which includes systick and mgmtisr. */
    913                      
    914               /* NOTE: SysTick's priority level causes it to bypass the ATOMIC behavior.
    915                      The ATOMIC is used to block all normal interrupts.  Therefore,
    916                      we don't have to use INTERRUPTS_ON when transitioning to
    917                      idle sleep, but we still need to use PRIMASK to disable all
    918                      interrupts, including SysTick, to transition to idle. */
    919                
    920               /*   After __disable_irq *NO* interrupt can be handled (except NMI) until
    921                 __enable_irq.  If an interrupt occurs the CPU will wakeup and set the
    922                 appropriate 'iinterrupted' bit, but the handler won't run until after
    923                 the __enable_irq() below. */
    924                __disable_irq();
    925           
    926                if (wakeupXtalState != WAKEUP_XTAL_STATE_READY_SWITCH) 
    927                {
    928          #ifdef FLASH_ACCESS_FLASH_LP
    929                  BYPASS_MPU(
    930                             uint32_t FLASH_ACCESS_SAVED = FLASH_ACCESS;
    931                             FLASH->ACR&= ~FLASH_ACCESS_FLASH_LP;
    932                             halInternalIdleSleep();
    933                             FLASH->ACR= FLASH_ACCESS_SAVED;
    934                             )
    935          #else /* FLASH_ACCESS_FLASH_LP */
    936                halInternalIdleSleep();
    937          #endif /* FLASH_ACCESS_FLASH_LP */
    938                }
    939                __enable_irq();
    940              )
   \                     ??halInternalBlockUntilXtal_1: (+1)
   \   0000000A   0xF3EF 0x8511      MRS      R5,BASEPRI
   \   0000000E   0x2060             MOVS     R0,#+96
   \   00000010   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000014   0xB672             CPSID    I
   \   00000016   0x7860             LDRB     R0,[R4, #+1]
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x.... 0x....      BLNE     halInternalIdleSleep
   \   00000020   0xB662             CPSIE    I
   \   00000022   0xB2ED             UXTB     R5,R5
   \   00000024   0xF385 0x8811      MSR      BASEPRI,R5
    941            }
   \                     ??halInternalBlockUntilXtal_0: (+1)
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD1ED             BNE.N    ??halInternalBlockUntilXtal_1
    942          
    943            /* Restore the bias from previous known good value. */
    944            CLK->HSECR1 = biasTrim;
   \   0000002E   0x....             LDR.N    R0,??DataTable11_13  ;; 0x40004004
   \   00000030   0x88E1             LDRH     R1,[R4, #+6]
   \   00000032   0x6001             STR      R1,[R0, #+0]
    945          
    946            if (xtalAboveLoThresholdUs) 
   \   00000034   0x78A1             LDRB     R1,[R4, #+2]
   \   00000036   0xB179             CBZ.N    R1,??halInternalBlockUntilXtal_2
    947            {
    948              halInternalBlockUntilXtalAboveLo();
   \   00000038   0x....             LDR.N    R2,??DataTable11_15  ;; 0x40002038
   \   0000003A   0x6D53             LDR      R3,[R2, #+84]
   \   0000003C   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000040   0x6553             STR      R3,[R2, #+84]
   \                     ??halInternalBlockUntilXtal_3: (+1)
   \   00000042   0x6813             LDR      R3,[R2, #+0]
   \                     ??halInternalBlockUntilXtal_4: (+1)
   \   00000044   0x6885             LDR      R5,[R0, #+8]
   \   00000046   0x07ED             LSLS     R5,R5,#+31
   \   00000048   0xD5FB             BPL.N    ??halInternalBlockUntilXtal_3
   \   0000004A   0x6815             LDR      R5,[R2, #+0]
   \   0000004C   0x1AED             SUBS     R5,R5,R3
   \   0000004E   0x032D             LSLS     R5,R5,#+12
   \   00000050   0x0B2D             LSRS     R5,R5,#+12
   \   00000052   0xEBB5 0x0F51      CMP      R5,R1, LSR #+1
   \   00000056   0xD3F5             BCC.N    ??halInternalBlockUntilXtal_4
    949            }
    950            halInternalSwitchToXtal24M();
   \                     ??halInternalBlockUntilXtal_2: (+1)
   \   00000058   0x.... 0x....      BL       halInternalSwitchToXtal24M
    951            wakeupXtalState = WAKEUP_XTAL_STATE_WAITING_FINAL;
   \   0000005C   0x2004             MOVS     R0,#+4
   \   0000005E   0x7060             STRB     R0,[R4, #+1]
    952            scheduleHalSysTickIsrUs(400);
   \   00000060   0xF44F 0x70C8      MOV      R0,#+400
   \   00000064   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000068   0x....             B.N      scheduleHalSysTickIsrUs
    953          }
    954          #endif /* DISABLE_IDLING_DELAY */
    955          
    956          /**
    957            * @brief This is the final check the RX/TX code must use to make sure we're running
    958            *        on a stable xtal before any xtal-sensitive radio code can run.
    959            *        FIXME-svec-2011.02.02: similar to halInternalBlockUntilXtal(), perhaps can
    960            *        combine into 1 function with different callers to specify wakeupXtalState and
    961            *        function to call after while() loop? 
    962            * @param  None
    963            * @retval None
    964            */

   \                                 In section .text, align 2, keep-with-next
    965          void halCommonBlockUntilXtal(void)
    966          {
    967            if ((! (RST->SR & RST_SR_WKUP)) || (useXtalAsIs)) 
   \                     halCommonBlockUntilXtal: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_16  ;; 0x4000002c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0680             LSLS     R0,R0,#+26
   \   00000006   0xD400             BMI.N    ??halCommonBlockUntilXtal_0
   \   00000008   0x4770             BX       LR
   \                     ??halCommonBlockUntilXtal_0: (+1)
   \   0000000A   0xB538             PUSH     {R3-R5,LR}
   \   0000000C   0x....             LDR.N    R4,??DataTable11_2
   \   0000000E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000010   0xB178             CBZ.N    R0,??halCommonBlockUntilXtal_1
    968            {
    969              return;
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}
    970            }
    971          
    972            while (wakeupXtalState != WAKEUP_XTAL_STATE_FINAL) 
    973            {
    974              ATOMIC(
    975              /* ATOMIC sets basepri==12, so any interrupts <priority12 are still
    976                 running, which includes systick and mgmtisr. */      
    977                
    978              /* NOTE: SysTick's priority level causes it to bypass the ATOMIC behavior.
    979                      The ATOMIC is used to block all normal interrupts.  Therefore,
    980                      we don't have to use INTERRUPTS_ON when transitioning to
    981                      idle sleep, but we still need to use PRIMASK to disable all
    982                      interrupts, including SysTick, to transition to idle. */
    983                
    984               /*  After __disable_irq() *NO* interrupt can be handled (except NMI) until
    985                 __enable_irq.  If an interrupt occurs the CPU will wakeup and set the
    986                 appropriate 'iinterrupted' bit, but the handler won't run until after
    987                 the __enable_irq() below. */
    988                __disable_irq();
    989            
    990                if (wakeupXtalState != WAKEUP_XTAL_STATE_FINAL) 
    991                {
    992          #ifdef FLASH_ACCESS_FLASH_LP
    993                  BYPASS_MPU(
    994                             uint32_t FLASH_ACCESS_SAVED = FLASH_ACCESS;
    995                             FLASH->ACR&= ~FLASH_ACCESS_FLASH_LP;
    996                             halInternalIdleSleep();
    997                             FLASH->ACR= FLASH_ACCESS_SAVED;
    998                             )
    999          #else /* FLASH_ACCESS_FLASH_LP */
   1000                halInternalIdleSleep();
   1001          #endif /* FLASH_ACCESS_FLASH_LP */
   1002                }
   1003                __enable_irq();
   1004                )
   \                     ??halCommonBlockUntilXtal_2: (+1)
   \   00000014   0xF3EF 0x8511      MRS      R5,BASEPRI
   \   00000018   0x2060             MOVS     R0,#+96
   \   0000001A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001E   0xB672             CPSID    I
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xBF18             IT       NE 
   \   00000026   0x.... 0x....      BLNE     halInternalIdleSleep
   \   0000002A   0xB662             CPSIE    I
   \   0000002C   0xB2ED             UXTB     R5,R5
   \   0000002E   0xF385 0x8811      MSR      BASEPRI,R5
   1005            }
   \                     ??halCommonBlockUntilXtal_1: (+1)
   \   00000032   0x7860             LDRB     R0,[R4, #+1]
   \   00000034   0x2805             CMP      R0,#+5
   \   00000036   0xD1ED             BNE.N    ??halCommonBlockUntilXtal_2
   1006            /* When we get here we know we've the 400us timer has expired, so
   1007             the xtal should be settled.  Make sure the LO/HI conditions are met by
   1008             using the same xtal setup code as the cold-powerup sequence uses. */
   1009            xtalUnstable = FALSE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   1010            halCommonSwitchToXtal();
   \   0000003C   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000040   0x....             B.N      halCommonSwitchToXtal
   1011          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     xtalUnstable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x4000A018         DC32     0x4000a018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x4000400C         DC32     0x4000400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x4000401C         DC32     0x4000401c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x40004010         DC32     0x40004010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x4000000C         DC32     0x4000000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x16E36000         DC32     0x16e36000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x40004008         DC32     0x40004008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x4000A058         DC32     0x4000a058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x40004004         DC32     0x40004004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x40002038         DC32     0x40002038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x4000002C         DC32     0x4000002c
   1012          
   1013          /**
   1014            * @}
   1015            */
   1016          
   1017          /**
   1018            * @}
   1019            */ 
   1020          
   1021          /**
   1022            * @}
   1023            */
   1024          
   1025          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   halCommonBlockUntilXtal
         0   -> halCommonSwitchToXtal
      16   halCommonSwitchToXtal
        16   -> halCommonTryToSwitchToXtal
      16   halCommonTryToSwitchToXtal
        16   -> halInternalSwitchToXtal24M
      16   halInternalBlockUntilXtal
        16   -> halInternalSwitchToXtal24M
         0   -> scheduleHalSysTickIsrUs
      16   halInternalCalibrateFastRc
        16   -> idleDelayMicroseconds
      24   halInternalCalibrateSlowRc
        24   -> idleDelayMicroseconds
       0   halInternalInitMgmtIsrLo
       8   halInternalPowerUpKickXtal
         8   -> halCommonSwitchToXtal
         0   -> scheduleHalSysTickIsrUs
       0   halInternalSwitchToXtal24M
       0   halSysTickIsr
         0   -> halInternalInitMgmtIsrLo
      16   idleDelayMicroseconds
        16   -> halCommonDelayMicroseconds
        16   -> halInternalIdleSleep
       8   scheduleHalSysTickIsrUs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      56  ?Subroutine0
      20  ?Subroutine1
      66  halCommonBlockUntilXtal
      40  halCommonSwitchToXtal
     184  halCommonTryToSwitchToXtal
     106  halInternalBlockUntilXtal
      34  halInternalCalibrateFastRc
     110  halInternalCalibrateSlowRc
      22  halInternalInitMgmtIsrLo
      54  halInternalPowerUpKickXtal
      38  halInternalSwitchToXtal24M
      62  halSysTickIsr
      62  idleDelayMicroseconds
      22  scheduleHalSysTickIsrUs
       8  xtalUnstable
          wakeupXtalState
          xtalAboveLoThresholdUs
          useXtalAsIs
          previousLoValue
          biasTrim

 
   8 bytes in section .data
 944 bytes in section .text
 
 944 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
