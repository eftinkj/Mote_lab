###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:29:42
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_clk.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_clk.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"stm32w108xx_clk.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\stm32w108xx_clk.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\stm32w108xx_clk.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_clk.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32w108xx_clk.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the clock peripheral:
      9            *           + Internal/external clocks, 
     10            *           + Modes management
     11            *
     12            *  @verbatim
     13            * 
     14           ===============================================================================
     15                                  ##### CLK specific features #####
     16           ===============================================================================
     17              [..] After reset the device is running from OSCHF (12 MHz) 
     18                              
     19              [..] Once the device started from reset, the user application has to:
     20                   (#) Configure the clock source to be used to drive the System clock
     21                   (#) Configure the System clock frequency: 24Mhz/12Mhz  
     22                   (#) Configure the Flash clock frequency: 24Mhz/12Mhz/6Mhz
     23          
     24          
     25              @endverbatim
     26            *               
     27            ******************************************************************************
     28            * @attention
     29            *
     30            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     31            *
     32            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     33            * You may not use this file except in compliance with the License.
     34            * You may obtain a copy of the License at:
     35            *
     36            *        http://www.st.com/software_license_agreement_liberty_v2
     37            *
     38            * Unless required by applicable law or agreed to in writing, software 
     39            * distributed under the License is distributed on an "AS IS" BASIS, 
     40            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     41            * See the License for the specific language governing permissions and
     42            * limitations under the License.
     43            *
     44            ******************************************************************************
     45            */
     46          
     47          /* Includes ------------------------------------------------------------------*/
     48          #include "stm32w108xx_clk.h"
     49          
     50          /** @addtogroup STM32W108xx_StdPeriph_Driver
     51            * @{
     52            */
     53          
     54          /** @defgroup CLK 
     55            * @brief CLK driver modules
     56            * @{
     57            */
     58          
     59          /* Private typedef -----------------------------------------------------------*/
     60          /* Private defines -----------------------------------------------------------*/
     61          #define SLOWRC_PERIOD_SETTLE_TIME 4250
     62          #define SLOWRC_PERIOD_SAMPLES 8
     63          #define CLK1K_NUMERATOR 384000000
     64          
     65          #define FASTRC_PERIOD_SETTLE_TIME 128
     66          
     67          /* CLK_HSECR2 register Mask */
     68          #define CLK_HSECR2_Mask            ((uint32_t)0x00000003)
     69          
     70          /* Private macros ------------------------------------------------------------*/
     71          /* Private variables ---------------------------------------------------------*/
     72          /* Private function prototypes -----------------------------------------------*/
     73          /* Private functions ---------------------------------------------------------*/
     74          
     75          /** @defgroup CLK_Private_Functions 
     76            * @{
     77            */
     78            
     79          /** @defgroup CLK_Group1 Internal and external clocks
     80            *  @brief   Internal and external clocks configuration functions 
     81            *
     82          @verbatim
     83           ===============================================================================
     84           ##### Internal-external clocks configuration functions #####
     85           ===============================================================================
     86              [..] This section provides functions allowing to configure the internal/external clocks,
     87                   
     88                   (#) HSI (high-frequency RC oscillator (OSCHF)), is used as the default system clock 
     89                       source when power is applied to the core domain. The nominal frequency coming 
     90                       out of reset is 12 MHz.
     91                   (#) HSE (high-frequency crystal oscillator), 24 MHz crystal oscillator 
     92          
     93          @endverbatim
     94            * @{
     95            */
     96          
     97          /**
     98            * @brief  Resets the CLOCK configuration to the default reset state.
     99            * @note   The default reset state of the clock configuration is given below:
    100            *         HSI ON and used as system clock source 
    101            * @param  None
    102            * @retval None
    103            */

   \                                 In section .text, align 2, keep-with-next
    104          void CLK_DeInit(void)
    105          {
    106            CLK->SLEEPCR = 0x00000002;
   \                     CLK_DeInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10  ;; 0x40000008
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x6001             STR      R1,[R0, #+0]
    107            CLK->LSI10KCR = 0x00000000;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6041             STR      R1,[R0, #+4]
    108            CLK->LSI1KCR = 0x00005000;
   \   0000000A   0xF44F 0x41A0      MOV      R1,#+20480
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    109            CLK->HSECR1 = 0x0000000F;
   \   00000010   0x210F             MOVS     R1,#+15
   \   00000012   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40004004
   \   00000014   0x6001             STR      R1,[R0, #+0]
    110            CLK->HSICR = 0x00000017;
   \   00000016   0x2117             MOVS     R1,#+23
   \   00000018   0x6041             STR      R1,[R0, #+4]
    111            CLK->PERIODCR = 0x00000000;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
    112            CLK->DITHERCR = 0x00000000;
   \   0000001E   0x6141             STR      R1,[R0, #+20]
    113            CLK->HSECR2 = 0x00000000;
   \   00000020   0x6181             STR      R1,[R0, #+24]
    114            CLK->CPUCR = 0x00000000; 
   \   00000022   0x61C1             STR      R1,[R0, #+28]
    115          }
   \   00000024   0x4770             BX       LR               ;; return
    116          
    117          /**
    118            * @brief  Calibrate the low speed internal clock (LSI) to be close to 10KHZ in
    119            *         order to generate 1KHZ clock.
    120            * @param  None
    121            * @retval None
    122            */

   \                                 In section .text, align 2, keep-with-next
    123          void CLK_InternalCalibrateLSI(void)
    124          {
   \                     CLK_InternalCalibrateLSI: (+1)
   \   00000000   0xB57E             PUSH     {R1-R6,LR}
    125            uint8_t i = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    126            uint32_t average = 0;
    127            int16_t delta = 0;
    128            uint32_t period = 0;
    129            __IO uint32_t StartUpCounter = 0;
   \   00000004   0x9000             STR      R0,[SP, #+0]
    130            __IO uint32_t LSI10KCR_RESET = 0x0, LSI1KCR_RESET = 0x5000;
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0xF44F 0x42A0      MOV      R2,#+20480
   \   0000000C   0x9201             STR      R2,[SP, #+4]
   \   0000000E   0x2100             MOVS     R1,#+0
    131            
    132            /* The slowest frequency for the 10kHz RC source is 8kHz (125us).  The PERIODSR
    133            register updates every 16 cycles, so to be safe 17 cycles = 2125us.  But,
    134            we need twice this maximum time because the period measurement runs
    135            asynchronously, and the value of LSI10KCR is changed immediately before
    136            the delay.
    137            SLOWRC_PERIOD_SETTLE_TIME 4250
    138            The CLK_PERIOD register measures the number of 12MHz clock cycles that
    139            occur in 16 cycles of the SlowRC clock.  This is meant to smooth out the the
    140            noise inherently present in the analog RC source.  While these 16 cycles
    141            smooths out most noise, there is still some jitter in the bottom bits of
    142            PERIODSR.  To further smooth out the noise, we take several readings of
    143            PERIODSR and average them out.  Testing has shown that the bottom 3 and 4
    144            bits of PERIODSR contain most of the jitter.  Averaging 8 samples will
    145            smooth out 3 bits of jitter and provide a realiable and stable reading useful
    146            in the calculations, while taking much less time than 16 or 32 samples.
    147            SLOWRC_PERIOD_SAMPLES 8
    148            The register LSI1KCR is a fractional divider that divides the 10kHz analog
    149            source with the goal of generating a 1024Hz, clk1k output.
    150            10000Hz / LSI1KCR = 1024Hz.
    151            Since the PERIODSR register measures the number of 12MHz cycles in 16
    152            cycles of the RC:
    153            16 * 12000000
    154            ------------- = ~10kHz
    155            PERIODSR
    156            and
    157            ~10kHz / 1024 = X
    158            where X is the fractional number that belongs in LSI1KCR.  Since the
    159            integer portion of LSI1KCR is bits 15:11 and the fractional is 10:0,
    160            multiplying X by 2048 (bit shift left by 11) generates the proper LSI1KCR
    161            register value.
    162            
    163            Putting this all together:
    164            16 * 12000000 * 2048     384000000
    165            --------------------  = ------------  =  LSI1KCR
    166            PERIODSR * 1024       PERIODSR
    167            
    168            CLK1K_NUMERATOR 384000000 */
    169            
    170            /* ---- STEP 1: coarsely tune SlowRC in analog section to ~10kHz ---- */
    171            /* To operate properly across the full temperature and voltage range,
    172            the RC source in the analog section needs to be first coarsely tuned
    173            to 10kHz.  The LSI10KCR register, which is 2's compliment, provides 16
    174            steps at ~400Hz per step yielding approximate frequences of 8kHz at 7
    175            and 15kHz at -8. */
    176            /* Start with our reset values for TUNE and CAL */
    177            CLK->PERIODCR = 0; /* measure SlowRC */
   \   00000010   0x....             LDR.N    R2,??DataTable10_2  ;; 0x40004010
    178            CLK->LSI10KCR = LSI10KCR_RESET;
   \   00000012   0x....             LDR.N    R3,??DataTable10_3  ;; 0x4000000c
   \   00000014   0x6010             STR      R0,[R2, #+0]
   \   00000016   0x9C02             LDR      R4,[SP, #+8]
   \   00000018   0x601C             STR      R4,[R3, #+0]
    179            CLK->LSI1KCR = LSI1KCR_RESET;
   \   0000001A   0x9C01             LDR      R4,[SP, #+4]
   \   0000001C   0x605C             STR      R4,[R3, #+4]
   \   0000001E   0xF241 0x049A      MOVW     R4,#+4250
   \   00000022   0x.... 0x....      BL       ?Subroutine0
    180            
    181            /* wait for the PERIODSR register to properly update */
    182            do
    183            {
    184              StartUpCounter++;  
    185            } while(StartUpCounter != SLOWRC_PERIOD_SETTLE_TIME);
    186            
    187            /* Measure the current PERIODSR to obtain a baseline
    188            For 10kHz, the ideal PERIODSR value is 19200. Calculate the PERIOD delta.
    189            It's possible for a chip's 10kHz source RC to be too far out of range
    190            for the LSI10KCR to bring it back to 10kHz.  Therefore, we have to
    191            ensure that our delta correction does not exceed the tune range so
    192            tune has to be capped to the end of the vailable range so it does not
    193            wrap.  Even if we cannot achieve 10kHz, the 1kHz calibration can still
    194            properly correct to 1kHz.
    195            Each LSI10KCR step yields a PERIODSR delta of *approximately* 800.
    196            Calculate how many steps we are off.  While dividing by 800 may seem
    197            like an ugly calculation, the precision of the result is worth the small
    198            bit of code and time needed to do a divide. */
    199            period = CLK->PERIODSR;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000026   0x6855             LDR      R5,[R2, #+4]
    200            
    201            /* Round to the nearest integer */
    202            delta = (19200+400) - period;
    203            delta /= 800;
   \   00000028   0xF644 0x4690      MOVW     R6,#+19600
   \   0000002C   0x1B75             SUBS     R5,R6,R5
   \   0000002E   0xB22D             SXTH     R5,R5
   \   00000030   0xF44F 0x7648      MOV      R6,#+800
   \   00000034   0xFB95 0xF5F6      SDIV     R5,R5,R6
    204            
    205            /* LSI10KCR is a 4 bit signed number.  cap the delta to 7/-8 */
    206            if(delta > 7) {
   \   00000038   0xB22D             SXTH     R5,R5
   \   0000003A   0x2D08             CMP      R5,#+8
   \   0000003C   0xBFA8             IT       GE 
   \   0000003E   0x2507             MOVGE    R5,#+7
    207              delta = 7;
   \   00000040   0xDA04             BGE.N    ??CLK_InternalCalibrateLSI_0
    208            }
    209            if(delta < -8) {
   \   00000042   0xF115 0x0F08      CMN      R5,#+8
   \   00000046   0xBFB8             IT       LT 
   \   00000048   0xF06F 0x0507      MVNLT    R5,#+7
    210              delta = -8;
    211            }
    212            CLK->LSI10KCR = delta;
   \                     ??CLK_InternalCalibrateLSI_0: (+1)
   \   0000004C   0x601D             STR      R5,[R3, #+0]
    213            
    214            /* Wait for PERIOD to update before taking another sample */
    215            StartUpCounter = 0;
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x.... 0x....      BL       ?Subroutine0
    216            do
    217            {
    218              StartUpCounter++;  
    219            } while(StartUpCounter != SLOWRC_PERIOD_SETTLE_TIME);
    220            
    221            /* The analog section should now be producing an output of ~10kHz */
    222            
    223            /* ---- STEP 2: fine tune the SlowRC to 1024Hz ---- */
    224            /* Our goal is to generate a 1024Hz source.  The register LSI1KCR is a
    225            fractional divider that divides the 10kHz analog source and generates
    226            the clk1k output.  At reset, the default value is 0x5000 which yields a
    227            division of 10.000.  By averaging several samples of CLK_PERIOD, we
    228            can then calculate the proper divisor need for LSI1KCR to make 1024Hz. */
    229            for(i=0;i<SLOWRC_PERIOD_SAMPLES;i++) {
    230              StartUpCounter = 0;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000054   0x2500             MOVS     R5,#+0
   \   00000056   0x9500             STR      R5,[SP, #+0]
   \   00000058   0x.... 0x....      BL       ?Subroutine0
    231              do
    232              {
    233                StartUpCounter++;  
    234              } while(StartUpCounter != SLOWRC_PERIOD_SETTLE_TIME);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
    235              average += CLK->PERIODSR;
   \   0000005E   0x6855             LDR      R5,[R2, #+4]
   \   00000060   0x1869             ADDS     R1,R5,R1
    236            }
   \   00000062   0x2808             CMP      R0,#+8
   \   00000064   0xDBF6             BLT.N    ??CrossCallReturnLabel_1
    237            
    238            /* Calculate the average, with proper rounding */
    239            average = (average+(SLOWRC_PERIOD_SAMPLES/2))/SLOWRC_PERIOD_SAMPLES;
    240            
    241            /* Using an average period sample, calculate the clk1k divisor */
    242            CLK->LSI1KCR = (uint16_t)(CLK1K_NUMERATOR/average);
   \   00000066   0x1D09             ADDS     R1,R1,#+4
   \   00000068   0x....             LDR.N    R0,??DataTable10_4  ;; 0x16e36000
   \   0000006A   0x08C9             LSRS     R1,R1,#+3
   \   0000006C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000070   0xB280             UXTH     R0,R0
   \   00000072   0x6058             STR      R0,[R3, #+4]
    243            
    244            /* The SlowRC timer is now producing a 1024Hz tick (+/-2Hz). */ 
    245          }
   \   00000074   0xBD77             POP      {R0-R2,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x9D00             LDR      R5,[SP, #+0]
   \   00000002   0x1C6D             ADDS     R5,R5,#+1
   \   00000004   0x9500             STR      R5,[SP, #+0]
   \   00000006   0x9D00             LDR      R5,[SP, #+0]
   \   00000008   0x42A5             CMP      R5,R4
   \   0000000A   0xD1F9             BNE.N    ?Subroutine0
   \   0000000C   0x4770             BX       LR
    246          
    247          /**
    248            * @brief  Calibrate the high speed internal clock (HSI) to be close to 12MHZ.
    249            * @note   To calibrate the HSI, the high speed external clock (HSE) must be the 
    250            *         system clock.
    251            * @param  None
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void CLK_InternalCalibrateHSI(void)
    255          {
   \                     CLK_InternalCalibrateHSI: (+1)
   \   00000000   0xB083             SUB      SP,SP,#+12
    256            __IO uint32_t StartUpCounter = 0, CLK_PERIOD = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0x2101             MOVS     R1,#+1
    257            __IO int32_t newTune = -16;
   \   0000000A   0xF06F 0x000F      MVN      R0,#+15
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    258            /* ---- coarsely tune FastRC in analog section to ~12MHz ---- */
    259            /* The slowest frequency for the FastRC source is 4MHz (250ns).  The PERIODSR
    260            register updates every 256 cycles, so to be safe 257 cycles = 64us.  But,
    261            we need twice this maximum time because the period measurement runs
    262            asynchronously, and the value of HSICR1 is changed immediately before
    263            the delay.
    264            The CLK_PERIODSR register measures the number of 12MHz cycles in 256
    265            cycles of OSCHF:
    266            
    267            256 * 12000000
    268            ------------- = ~12MHz
    269            CLK_PERIOD 
    270            
    271            The RC source in the analog section needs to be coarsely tuned
    272            to 12MHz.  The HSICR1 register, which is 2's compliment, provides 32
    273            steps at ~0.5MHz per step yielding approximate frequences of 4MHz at 15
    274            and 20MHz at -16. */
    275          
    276            CLK->PERIODCR = 1; /* Measure FastRC */
   \   00000010   0x....             LDR.N    R0,??DataTable10_5  ;; 0x40004008
   \   00000012   0x6081             STR      R1,[R0, #+8]
    277          
    278            /* Start at the fastest possible frequency */
    279            CLK->HSICR = newTune;
   \   00000014   0x9901             LDR      R1,[SP, #+4]
   \   00000016   0x6001             STR      R1,[R0, #+0]
    280          
    281            /* Wait for the PERIOD register to properly update */
    282            do
    283            {
    284              StartUpCounter++;  
   \                     ??CLK_InternalCalibrateHSI_0: (+1)
   \   00000018   0x9900             LDR      R1,[SP, #+0]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x9100             STR      R1,[SP, #+0]
    285            } while(StartUpCounter != FASTRC_PERIOD_SETTLE_TIME);
   \   0000001E   0x9900             LDR      R1,[SP, #+0]
   \   00000020   0x2980             CMP      R1,#+128
   \   00000022   0xD1F9             BNE.N    ??CLK_InternalCalibrateHSI_0
    286          
    287            /* For 12MHz, the ideal CLK_PERIOD is 256.  Tune the frequency down until
    288            the period is <= 256, which says the frequency is as close to 12MHz as
    289            possible (without going over 12MHz)
    290            Start at the fastest possible frequency (-16) and increase to the slowest
    291            possible (15).  When CLK_PERIOD is <=256 or we run out of tune values,
    292            we're done. */
    293            for(;newTune<16;newTune++) 
   \                     ??CLK_InternalCalibrateHSI_1: (+1)
   \   00000024   0x9901             LDR      R1,[SP, #+4]
   \   00000026   0x2910             CMP      R1,#+16
   \   00000028   0xDA12             BGE.N    ??CLK_InternalCalibrateHSI_2
    294            {
    295              StartUpCounter = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x9100             STR      R1,[SP, #+0]
    296              /* Decrease frequency by one step (by increasing tune value) */
    297              CLK->HSICR = newTune;
   \   0000002E   0x9901             LDR      R1,[SP, #+4]
   \   00000030   0x6001             STR      R1,[R0, #+0]
    298          
    299              /* Wait for the PERIOD register to properly update */
    300              do
    301              {
    302                StartUpCounter++;
   \                     ??CLK_InternalCalibrateHSI_3: (+1)
   \   00000032   0x9900             LDR      R1,[SP, #+0]
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0x9100             STR      R1,[SP, #+0]
    303              } while(StartUpCounter != FASTRC_PERIOD_SETTLE_TIME);
   \   00000038   0x9900             LDR      R1,[SP, #+0]
   \   0000003A   0x2980             CMP      R1,#+128
   \   0000003C   0xD1F9             BNE.N    ??CLK_InternalCalibrateHSI_3
    304          
    305              /* Kickout if we're tuned */
    306              CLK_PERIOD = CLK->PERIODSR;
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0x9102             STR      R1,[SP, #+8]
    307              if(CLK_PERIOD >= 256) {
   \   00000042   0x9902             LDR      R1,[SP, #+8]
   \   00000044   0x29FF             CMP      R1,#+255
   \   00000046   0xD803             BHI.N    ??CLK_InternalCalibrateHSI_2
    308                break;
    309              }
    310            }
   \   00000048   0x9901             LDR      R1,[SP, #+4]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0x9101             STR      R1,[SP, #+4]
   \   0000004E   0xE7E9             B.N      ??CLK_InternalCalibrateHSI_1
    311            /* The analog section should now be producing an output of 11.5MHz - 12.0MHz */
    312          }
   \                     ??CLK_InternalCalibrateHSI_2: (+1)
   \   00000050   0xB003             ADD      SP,SP,#+12
   \   00000052   0x4770             BX       LR               ;; return
    313          
    314          /**
    315            * @brief  Configures the clock mode to use:
    316            * @param MODE: specifies the frequency mode to use.
    317            *   This parameter can be one of the following values:
    318            *     @arg MODE0: Normal CPU, SCLK =12MHZ, PCLK=6MHZ, Flash Program/Erase Inactive =6Mhz,
    319            *                 FlashProgram/Erase Active = 12Mhz. 
    320            *     @arg MODE1: Fast CPU, SCLK =12MHZ, PCLK=6MHZ, Flash Program/Erase Inactive =12Mhz,
    321            *                 FlashProgram/Erase Active = 12Mhz. 
    322            *     @arg MODE2: Normal CPU, SCLK =24MHZ, PCLK=12MHZ, Flash Program/Erase Inactive =12Mhz,
    323            *                 FlashProgram/Erase Active = 12Mhz. 
    324            *     @arg MODE3: Fast CPU, SCLK =24MHZ, PCLK=12MHZ, Flash Program/Erase Inactive =24Mhz,
    325            *                 FlashProgram/Erase Active = 12Mhz. 
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          void CLK_Config(uint8_t MODE)
    329          {
   \                     CLK_Config: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    330             __IO uint32_t StartUpCounter = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
    331          
    332            /* Check the parameters */
    333            assert_param(IS_CLK_MODE(MODE));
    334           
    335            switch (MODE)
   \   00000006   0x....             LDR.N    R1,??DataTable10_6  ;; 0x4000401c
   \   00000008   0xB360             CBZ.N    R0,??CLK_Config_0
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD004             BEQ.N    ??CLK_Config_1
   \   0000000E   0x2810             CMP      R0,#+16
   \   00000010   0xD006             BEQ.N    ??CLK_Config_2
   \   00000012   0x2811             CMP      R0,#+17
   \   00000014   0xD013             BEQ.N    ??CLK_Config_3
   \   00000016   0xE025             B.N      ??CLK_Config_0
    336            {
    337              case CLK_MODE0:  /* HSI used as system clock : Normal CPU*/
    338                CLK->HSECR2 &= ~CLK_HSECR2_SW1; 
    339                CLK->CPUCR &= ~CLK_CPUCR_SW2;
    340                break;
    341          
    342              case CLK_MODE1:  /* HSI used as system clock : Fast CPU */
    343                CLK->HSECR2 &= ~CLK_HSECR2_SW1; 
   \                     ??CLK_Config_1: (+1)
   \   00000018   0x6808             LDR      R0,[R1, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0xE01C             B.N      ??CLK_Config_4
    344                CLK->CPUCR |=  CLK_CPUCR_SW2;       
    345                break;
    346          
    347              case CLK_MODE2:  /* HSE used as system clock : Normal CPU*/
    348                /* Enable HSE */
    349                CLK->HSECR2 |= CLK_HSECR2_EN;
   \                     ??CLK_Config_2: (+1)
   \   00000020   0x6808             LDR      R0,[R1, #+0]
   \   00000022   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000026   0x6008             STR      R0,[R1, #+0]
    350           
    351              /* Wait till HSE is ready and if Time out is reached exit */
    352                do
    353                {
    354                  StartUpCounter++;
   \                     ??CLK_Config_5: (+1)
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    355                } while(StartUpCounter != HSE_STARTUP_TIMEOUT);
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   00000034   0xD1F8             BNE.N    ??CLK_Config_5
    356          
    357                CLK->HSECR2 |= CLK_HSECR2_SW1;
   \   00000036   0x6808             LDR      R0,[R1, #+0]
   \   00000038   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000003C   0xE015             B.N      ??CLK_Config_6
    358                CLK->CPUCR &= ~CLK_CPUCR_SW2;
    359                break;
    360                
    361              case CLK_MODE3:  /* HSE used as system clock : Fast CPU*/
    362               /* Enable HSE */
    363                CLK->HSECR2 |= CLK_HSECR2_EN;
   \                     ??CLK_Config_3: (+1)
   \   0000003E   0x6808             LDR      R0,[R1, #+0]
   \   00000040   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000044   0x6008             STR      R0,[R1, #+0]
    364           
    365              /* Wait till HSE is ready and if Time out is reached exit */
    366                do
    367                {
    368                  StartUpCounter++;
   \                     ??CLK_Config_7: (+1)
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    369                } while(StartUpCounter != HSE_STARTUP_TIMEOUT);
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   00000052   0xD1F8             BNE.N    ??CLK_Config_7
    370          
    371                CLK->HSECR2 |= CLK_HSECR2_SW1;
   \   00000054   0x6808             LDR      R0,[R1, #+0]
   \   00000056   0xF040 0x0001      ORR      R0,R0,#0x1
   \                     ??CLK_Config_4: (+1)
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    372                CLK->CPUCR |= CLK_CPUCR_SW2;
   \   0000005C   0x6848             LDR      R0,[R1, #+4]
   \   0000005E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000062   0xE006             B.N      ??CLK_Config_8
    373                break;
    374              default: /* HSI used as system clock */
    375                CLK->HSECR2 &= ~CLK_HSECR2_SW1;
   \                     ??CLK_Config_0: (+1)
   \   00000064   0x6808             LDR      R0,[R1, #+0]
   \   00000066   0x0840             LSRS     R0,R0,#+1
   \   00000068   0x0040             LSLS     R0,R0,#+1
   \                     ??CLK_Config_6: (+1)
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    376                CLK->CPUCR &= ~CLK_CPUCR_SW2;
   \   0000006C   0x6848             LDR      R0,[R1, #+4]
   \   0000006E   0x0840             LSRS     R0,R0,#+1
   \   00000070   0x0040             LSLS     R0,R0,#+1
   \                     ??CLK_Config_8: (+1)
   \   00000072   0x6048             STR      R0,[R1, #+4]
    377                break;
    378            }
    379          }
   \   00000074   0xB001             ADD      SP,SP,#+4
   \   00000076   0x4770             BX       LR               ;; return
    380          
    381          /**
    382            * @brief  Enables or disables the External High Speed oscillator (HSE).
    383            * @note   After enabling HSE the user should wait for HSE_STARTUP_TIMEOUT 
    384            * @note   to be sure that the clok is stabilized.     
    385            * @param  NewState: new state of the HSE.
    386            *         This parameter can be: ENABLE or DISABLE.
    387            * @retval None
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          void CLK_HSECmd(FunctionalState NewState)
    390          {
    391            /* Check the parameters */
    392            assert_param(IS_FUNCTIONAL_STATE(NewState));
    393            
    394            if (NewState != DISABLE)
   \                     CLK_HSECmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_6  ;; 0x4000401c
   \   00000002   0xB110             CBZ.N    R0,??CLK_HSECmd_0
    395            {
    396              CLK->HSECR2 |= CLK_HSECR2_EN; 
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xF040 0x0002      ORR      R0,R0,#0x2
    397            }
    398            else
    399            {
    400              CLK->HSECR2 = 0x00;
   \                     ??CLK_HSECmd_0: (+1)
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    401            }
    402          }
   \   0000000C   0x4770             BX       LR               ;; return
    403          
    404          /**
    405            * @brief  Enables or disables the specified SLPTIM clock.
    406            * @param  CLK_SLPTIM: specifies the SLPTIM clock to be enabled or disabled.
    407            *   This parameter can be any combination of the following values:
    408            *     @arg SLPTIM_CLK_32KH: 32kHz external XTAL
    409            *     @arg SLPTIM_CLK_10KH: 10kHz internal RC (during deep sleep)
    410            * @param  NewState: new state of the SLPTIM clock.
    411            *   This parameter can be: ENABLE or DISABLE.
    412            * @retval None
    413            */

   \                                 In section .text, align 2, keep-with-next
    414          void CLK_SLPTIMClockConfig(uint32_t CLK_SLPTIM, FunctionalState NewState)
    415          {
    416            /* Check the parameters */
    417            assert_param(IS_SLPTIM_GET_CLK(CLK_SLPTIM));
    418            assert_param(IS_FUNCTIONAL_STATE(NewState));
    419          
    420              if (NewState != DISABLE)
   \                     CLK_SLPTIMClockConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10  ;; 0x40000008
   \   00000002   0xB139             CBZ.N    R1,??CLK_SLPTIMClockConfig_0
    421              {
    422                if (CLK_SLPTIM == SLPTIM_CLK_32KH)
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD102             BNE.N    ??CLK_SLPTIMClockConfig_1
    423                {
    424                  CLK->SLEEPCR &= 0x0;
   \   00000008   0x6811             LDR      R1,[R2, #+0]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    425                }
    426                /* Enable the clock */
    427                CLK->SLEEPCR |= (uint32_t)CLK_SLPTIM;
   \                     ??CLK_SLPTIMClockConfig_1: (+1)
   \   0000000E   0x6811             LDR      R1,[R2, #+0]
   \   00000010   0x4308             ORRS     R0,R0,R1
   \   00000012   0xE002             B.N      ??CLK_SLPTIMClockConfig_2
    428              }
    429              else
    430              {
    431                /* Disable the clock */
    432                CLK->SLEEPCR &= (uint32_t)~CLK_SLPTIM;
   \                     ??CLK_SLPTIMClockConfig_0: (+1)
   \   00000014   0x6811             LDR      R1,[R2, #+0]
   \   00000016   0xEA21 0x0000      BIC      R0,R1,R0
   \                     ??CLK_SLPTIMClockConfig_2: (+1)
   \   0000001A   0x6010             STR      R0,[R2, #+0]
    433              }
    434          }
   \   0000001C   0x4770             BX       LR               ;; return
    435          
    436          /**
    437            * @brief  Calibration of CLK1K clock.
    438            * @param  CALINT: specifies the divider value integer portion.
    439            *   This parameter can be a value between 0x0 and 0x1F.
    440            * @param  CALFRAC: specifies the divider value fractional portion.
    441            *   This parameter can be a value between 0x0 and 0x7FF.
    442            * @retval None.
    443            */

   \                                 In section .text, align 2, keep-with-next
    444          void CLK_1KClockCalibration(uint32_t CALINT, uint32_t CALFRAC)
    445          {
    446            uint32_t tmpclk1k;
    447            /* Check the parameters */
    448            assert_param(IS_LSI1KCRINT(CALINT));
    449            assert_param(IS_LSI1KCRFRAC(CALFRAC));
    450          
    451            CLK->LSI1KCR = 0x00000000;
   \                     CLK_1KClockCalibration: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10_7  ;; 0x40000010
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x6013             STR      R3,[R2, #+0]
    452          
    453            /* set the divider value integer portion */
    454            tmpclk1k = (uint32_t)(CALINT <<11);
    455          
    456            /* set the divider value fractional portion */  
    457            tmpclk1k |= CALFRAC;
    458          
    459            CLK->LSI1KCR = tmpclk1k;  
   \   00000006   0xEA41 0x20C0      ORR      R0,R1,R0, LSL #+11
   \   0000000A   0x6010             STR      R0,[R2, #+0]
    460          }
   \   0000000C   0x4770             BX       LR               ;; return
    461          
    462          /**
    463            * @brief  Set tune value for CLKRC clock.
    464            * @param  TUNE_VALUE: specifies the tune value for CLKRC clock.
    465            *   This parameter can be a value between 0x0 and 0xF.
    466            * @retval None.
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          void CLK_RCTuneConfig(uint32_t TUNE_VALUE)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_CLK_TUNE_VALUE(TUNE_VALUE));
    472          
    473            CLK->LSI10KCR = 0x00000000;
   \                     CLK_RCTuneConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_3  ;; 0x4000000c
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x600A             STR      R2,[R1, #+0]
    474          
    475            /* set the tune value for CLKRC */  
    476            CLK->LSI10KCR = TUNE_VALUE;  
   \   00000006   0x6008             STR      R0,[R1, #+0]
    477          }
   \   00000008   0x4770             BX       LR               ;; return
    478          
    479          /**
    480            * @brief  Select the clock period to be measured.
    481            * @param  CLK_MEASURED: specifies the clock for which the period will be measured.
    482            *   This parameter can be :
    483            *     @arg MEASURE_CLKRC: Measure CLKRC.
    484            *     @arg MEASURE_OSCHF: Measure OSCHF.
    485            *     @arg MEASURE_TUNEFILT: Measure TUNE_FILTER_RESULT.
    486            * @retval None.
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          void CLK_MeasurePeriod(uint32_t CLK_MEASURED)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_CLK_MEASURE(CLK_MEASURED));
    492          
    493            CLK->PERIODCR = CLK_MEASURED;
   \                     CLK_MeasurePeriod: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40004010
   \   00000002   0x6008             STR      R0,[R1, #+0]
    494          }
   \   00000004   0x4770             BX       LR               ;; return
    495          
    496          /**
    497            * @brief  Returns the clock period measured depend on clock selected.
    498            *@note    measured period is equal to:
    499            *       16 x Clock period in clk12m cycles (CLKRC/TUNE_FILTER_RESULT modes) 
    500            *       256 x clock period in clk12m cycles (OSCHF mode)
    501            * @param  None.
    502            * @retval None.
    503            */

   \                                 In section .text, align 2, keep-with-next
    504          uint32_t CLK_GetMeasurePeriod(void)
    505          {
    506            return CLK->PERIODSR;
   \                     CLK_GetMeasurePeriod: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_8  ;; 0x40004014
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    507          }
    508          
    509          /**
    510            * @brief  Returns the clock source used as system clock.
    511            * @param  None
    512            * @retval The clock source used as system clock. The returned value can
    513            *   be one of the following:
    514            *     - 0x00,0x01,0x10: HSI used as system clock
    515            *     - 0x03: HSE used as system clock
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          uint32_t CLK_GetClocksFreq(void)
    518          {
    519            uint32_t tmp = 0;
    520            uint32_t clockvalue = 0;
    521            /* Get SYSCLK source -------------------------------------------------------*/
    522            tmp = CLK->HSECR2 & CLK_HSECR2_Mask;
   \                     CLK_GetClocksFreq: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_6  ;; 0x4000401c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
    523          
    524            switch (tmp)
   \   00000004   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD101             BNE.N    ??CLK_GetClocksFreq_0
    525            {
    526              case 0x00:
    527              case 0x02:  /* HSI used as system clock */
    528                clockvalue = (uint32_t)HSI_VALUE;
    529                break;
    530              case 0x03:  /* HSE used as system clock */
    531                clockvalue = (uint32_t)HSE_VALUE;
   \   0000000C   0x....             LDR.N    R0,??DataTable10_9  ;; 0x16e3600
    532                break;
   \   0000000E   0x4770             BX       LR
    533                
    534              default: /* HSI used as system clock */
    535                clockvalue = (uint32_t)HSI_VALUE;
   \                     ??CLK_GetClocksFreq_0: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable10_10  ;; 0xb71b00
    536                break;
    537             }
    538             return clockvalue;
   \   00000012   0x4770             BX       LR               ;; return
    539          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40000008         DC32     0x40000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40004004         DC32     0x40004004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40004010         DC32     0x40004010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x4000000C         DC32     0x4000000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x16E36000         DC32     0x16e36000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40004008         DC32     0x40004008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x4000401C         DC32     0x4000401c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40000010         DC32     0x40000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x40004014         DC32     0x40004014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x016E3600         DC32     0x16e3600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x00B71B00         DC32     0xb71b00
    540          
    541          /**
    542            * @}
    543            */
    544          
    545          /**
    546            * @}
    547            */
    548          
    549          /**
    550            * @}
    551            */
    552          
    553          /**
    554            * @}
    555            */
    556          
    557          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLK_1KClockCalibration
       4   CLK_Config
       0   CLK_DeInit
       0   CLK_GetClocksFreq
       0   CLK_GetMeasurePeriod
       0   CLK_HSECmd
      12   CLK_InternalCalibrateHSI
      28   CLK_InternalCalibrateLSI
       0   CLK_MeasurePeriod
       0   CLK_RCTuneConfig
       0   CLK_SLPTIMClockConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      14  ?Subroutine0
      14  CLK_1KClockCalibration
     120  CLK_Config
      38  CLK_DeInit
      20  CLK_GetClocksFreq
       6  CLK_GetMeasurePeriod
      14  CLK_HSECmd
      84  CLK_InternalCalibrateHSI
     118  CLK_InternalCalibrateLSI
       6  CLK_MeasurePeriod
      10  CLK_RCTuneConfig
      30  CLK_SLPTIMClockConfig

 
 518 bytes in section .text
 
 518 bytes of CODE memory

Errors: none
Warnings: none
