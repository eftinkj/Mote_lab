###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:27:51
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\HW_LIB\OneWire.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\HW_LIB\OneWire.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"OneWire.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\HW_LIB\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\OneWire.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\OneWire.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\HW_LIB\OneWire.c
      1          #include "OneWire.h"
      2          
      3          //extern void DelayuS(uint32_t nCount);
      4          

   \                                 In section .text, align 2, keep-with-next
      5          void OWInit(OWire* owire, GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
      6          {
   \                     OWInit: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
      7            //RCC_APB2PeriphClockCmd(PeriphClock, ENABLE);
      8          
      9            GPIO_InitTypeDef  GPIO_InitStructure;
     10          
     11            GPIO_InitStructure.GPIO_Pin = GPIO_Pin;
     12          //  GPIO_InitStructure. .GPIO_Speed = GPIO_Speed_50MHz;
     13            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000000A   0x460E             MOV      R6,R1
   \   0000000C   0x4615             MOV      R5,R2
   \   0000000E   0x9500             STR      R5,[SP, #+0]
     14            GPIO_Init(GPIOx, &GPIO_InitStructure);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0x.... 0x....      BL       GPIO_Init
     15          
     16            uint32_t pinpos = 0x00, pos = 0x00, currentpin = 0x00;
     17          
     18            owire->m_BitMask = GPIO_Pin;
   \   00000018   0x82A5             STRH     R5,[R4, #+20]
   \   0000001A   0x2100             MOVS     R1,#+0
     19            owire->m_Port = GPIOx;
   \   0000001C   0x6026             STR      R6,[R4, #+0]
     20          
     21            uint8_t RegShift;
     22          
     23            if((GPIO_Pin & (uint32_t)0x00FF) > 0)
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xB2EB             UXTB     R3,R5
   \   00000022   0xB153             CBZ.N    R3,??OWInit_0
     24            {
     25              owire->m_Register = &GPIOx->CRL;
   \   00000024   0x6066             STR      R6,[R4, #+4]
     26          
     27              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
     28              {
     29                pos = ((uint32_t)0x01) << pinpos;
   \                     ??OWInit_1: (+1)
   \   00000026   0xFA02 0xF301      LSL      R3,R2,R1
     30                /* Get the port pins position */
     31                currentpin = (uint16_t)((GPIO_Pin) & pos);
     32                if (currentpin == pos)
   \   0000002A   0xEA03 0x0605      AND      R6,R3,R5
   \   0000002E   0x429E             CMP      R6,R3
   \   00000030   0xD00D             BEQ.N    ??OWInit_2
     33                {
     34                  RegShift = (pinpos*4);
     35                  owire->m_RegMask = ((uint32_t)0x0F) << (pinpos*4);
     36                  break;
     37                }
     38               }
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0x2908             CMP      R1,#+8
   \   00000036   0xD3F6             BCC.N    ??OWInit_1
   \   00000038   0xE013             B.N      ??OWInit_3
     39            }
     40            else
     41            {
     42              owire->m_Register = &GPIOx->CRH;
   \                     ??OWInit_0: (+1)
   \   0000003A   0x1D33             ADDS     R3,R6,#+4
   \   0000003C   0x6063             STR      R3,[R4, #+4]
     43          
     44              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
     45              {
     46                pos = ((uint32_t)0x01) << (pinpos + 0x08);
   \                     ??OWInit_4: (+1)
   \   0000003E   0xF101 0x0308      ADD      R3,R1,#+8
   \   00000042   0xFA02 0xF303      LSL      R3,R2,R3
     47                /* Get the port pins position */
     48                currentpin = (uint16_t)((GPIO_Pin) & pos);
     49                if (currentpin == pos)
   \   00000046   0xEA03 0x0605      AND      R6,R3,R5
   \   0000004A   0x429E             CMP      R6,R3
   \   0000004C   0xD106             BNE.N    ??OWInit_5
     50                {
     51                  RegShift = (pinpos*4);
   \                     ??OWInit_2: (+1)
   \   0000004E   0x0088             LSLS     R0,R1,#+2
     52                  owire->m_RegMask = ((uint32_t)0x0F) << (pinpos*4);
   \   00000050   0x220F             MOVS     R2,#+15
   \   00000052   0x0089             LSLS     R1,R1,#+2
   \   00000054   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000058   0x60A1             STR      R1,[R4, #+8]
     53                  break;
   \   0000005A   0xE002             B.N      ??OWInit_3
     54                }
     55              }
   \                     ??OWInit_5: (+1)
   \   0000005C   0x1C49             ADDS     R1,R1,#+1
   \   0000005E   0x2908             CMP      R1,#+8
   \   00000060   0xD3ED             BCC.N    ??OWInit_4
     56            }
     57          
     58            owire->m_InputMask = (((GPIO_Mode_IN) << RegShift) & owire->m_RegMask);
   \                     ??OWInit_3: (+1)
   \   00000062   0x2104             MOVS     R1,#+4
   \   00000064   0x68A2             LDR      R2,[R4, #+8]
   \   00000066   0x4081             LSLS     R1,R1,R0
   \   00000068   0x4011             ANDS     R1,R2,R1
   \   0000006A   0x60E1             STR      R1,[R4, #+12]
     59          //  owire->m_OutputMask = (((uint32_t)GPIO_Mode_Out_OD|(uint32_t)GPIO_Speed_50MHz) << RegShift) & owire->m_RegMask;
     60            owire->m_OutputMask = (((uint32_t)GPIO_Mode_OUT_OD) << RegShift) & owire->m_RegMask;
   \   0000006C   0x2105             MOVS     R1,#+5
   \   0000006E   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000072   0x68A1             LDR      R1,[R4, #+8]
   \   00000074   0x4008             ANDS     R0,R1,R0
   \   00000076   0x6120             STR      R0,[R4, #+16]
     61          
     62          #ifdef ONEWIRE_SEARCH
     63          	OWReset_search(owire);
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       OWReset_search
     64          #endif
     65          }
   \   0000007E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void OWInput(OWire* owire)
     68          {
   \                     OWInput: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     69          	  GPIO_InitTypeDef  GPIO_InitStructure;
     70            GPIO_InitStructure.GPIO_Pin = owire->m_BitMask;
   \   00000004   0x8A81             LDRH     R1,[R0, #+20]
   \   00000006   0x9100             STR      R1,[SP, #+0]
     71            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000008   0x2104             MOVS     R1,#+4
   \   0000000A   0x....             B.N      ?Subroutine0
     72            GPIO_Init(owire->m_Port, &GPIO_InitStructure);
     73          //  *owire->m_Register &= ~owire->m_RegMask;
     74            //*owire->m_Register |= (((GPIO_Mode_IN_FLOATING) << owire->m_RegShift) & owire->m_RegMask);
     75          //  *owire->m_Register |= owire->m_InputMask;
     76          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF88D 0x1004      STRB     R1,[SP, #+4]
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       GPIO_Init
   \   0000000C   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
     77          void OWOutput(OWire* owire)
     78          {
   \                     OWOutput: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     79          		  GPIO_InitTypeDef  GPIO_InitStructure;
     80            GPIO_InitStructure.GPIO_Pin = owire->m_BitMask;
   \   00000004   0x8A81             LDRH     R1,[R0, #+20]
   \   00000006   0x9100             STR      R1,[SP, #+0]
     81            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_OD;
   \   00000008   0x2105             MOVS     R1,#+5
   \   0000000A                      REQUIRE ?Subroutine0
   \   0000000A                      ;; // Fall through to label ?Subroutine0
     82            GPIO_Init(owire->m_Port, &GPIO_InitStructure);
     83          //  *owire->m_Register &= ~owire->m_RegMask;
     84            //*owire->m_Register |= ((((uint32_t)GPIO_Mode_Out_OD|(uint32_t)GPIO_Speed_50MHz) << owire->m_RegShift) & owire->m_RegMask);
     85          //  *owire->m_Register |= owire->m_OutputMask;
     86          
     87          }
     88          

   \                                 In section .text, align 2, keep-with-next
     89          uint8_t OWReadPin(OWire* owire)
     90          {
   \                     OWReadPin: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     91            //return (uint8_t)((owire->m_Port->IDR & owire->m_BitMask) > 0 ? 1 : 0);
     92            return GPIO_ReadInputDataBit(owire->m_Port, owire->m_BitMask);
   \   00000002   0x8A81             LDRH     R1,[R0, #+20]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
     93          }
     94          

   \                                 In section .text, align 2, keep-with-next
     95          void OWWriteHigh(OWire* owire)
     96          {
     97          	GPIO_SetBits(owire->m_Port, owire->m_BitMask);
   \                     OWWriteHigh: (+1)
   \   00000000   0x8A81             LDRH     R1,[R0, #+20]
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x.... 0x....      B.W      GPIO_SetBits
     98            //owire->m_Port->BSR = owire->m_BitMask;
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void OWWriteLow(OWire* owire)
    102          {
    103          	GPIO_ResetBits(owire->m_Port, owire->m_BitMask);
   \                     OWWriteLow: (+1)
   \   00000000   0x8A81             LDRH     R1,[R0, #+20]
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x.... 0x....      B.W      GPIO_ResetBits
    104            //owire->m_Port->BRR = owire->m_BitMask;
    105          }
    106          

   \                                 In section .text, align 4, keep-with-next
    107          static void OWNoInterrupts(void)
    108          {
    109            __asm("cpsid i");
   \                     OWNoInterrupts: (+1)
   \   00000000   0xB672             cpsid i
    110          }
   \   00000002   0x4770             BX       LR               ;; return
    111          

   \                                 In section .text, align 4, keep-with-next
    112          static void OWInterrupts(void)
    113          {
    114            __asm("cpsie i");
   \                     OWInterrupts: (+1)
   \   00000000   0xB662             cpsie i
    115          }
   \   00000002   0x4770             BX       LR               ;; return
    116          

   \                                 In section .text, align 2, keep-with-next
    117          uint8_t OWReset(OWire* owire)
    118          {
   \                     OWReset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    119          	uint8_t r;
    120          	uint8_t retries = 125;
                 	        ^
Warning[Pe177]: variable "retries" was declared but never referenced
    121          
    122          	OWNoInterrupts();
   \   00000004   0x.... 0x....      BL       OWNoInterrupts
    123          	OWInput(owire);
   \   00000008   0x.... 0x....      BL       ?Subroutine1
    124          	OWInterrupts();
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000000C   0x.... 0x....      BL       OWInterrupts
    125          	// wait until the wire is high... just in case
    126          //	do {
    127          //		if (--retries == 0) return 0;
    128          		halCommonDelayMicroseconds(5);//DelayuS(2);
   \   00000010   0x2005             MOVS     R0,#+5
   \   00000012   0x.... 0x....      BL       halCommonDelayMicroseconds
    129          //	} while ( !OWReadPin(owire));
    130          
    131          	OWNoInterrupts();
   \   00000016   0x.... 0x....      BL       OWNoInterrupts
    132          	OWWriteLow(owire);
   \   0000001A   0x.... 0x....      BL       ?Subroutine2
    133          	OWOutput(owire);	// drive output low
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000001E   0x.... 0x....      BL       ?Subroutine3
    134          	OWInterrupts();
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000022   0x.... 0x....      BL       OWInterrupts
    135          	halCommonDelayMicroseconds(500);
   \   00000026   0xF44F 0x70FA      MOV      R0,#+500
   \   0000002A   0x.... 0x....      BL       halCommonDelayMicroseconds
    136          	OWNoInterrupts();
   \   0000002E   0x.... 0x....      BL       OWNoInterrupts
    137          	OWInput(owire);	// allow it to float
   \   00000032   0x.... 0x....      BL       ?Subroutine1
    138          	halCommonDelayMicroseconds(80);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000036   0x2050             MOVS     R0,#+80
   \   00000038   0x.... 0x....      BL       halCommonDelayMicroseconds
    139          	r = !OWReadPin(owire);
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       OWReadPin
   \   00000042   0x1E44             SUBS     R4,R0,#+1
   \   00000044   0x41A4             SBCS     R4,R4,R4
    140          	OWInterrupts();
   \   00000046   0x.... 0x....      BL       OWInterrupts
    141          	halCommonDelayMicroseconds(420);
   \   0000004A   0xF44F 0x70D2      MOV      R0,#+420
   \   0000004E   0x.... 0x....      BL       halCommonDelayMicroseconds
    142          	return r;
   \   00000052   0x0FE0             LSRS     R0,R4,#+31
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    143          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      OWOutput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      OWWriteLow

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      OWInput
    144          

   \                                 In section .text, align 2, keep-with-next
    145          void OWWrite_bit(OWire* owire, uint8_t v)
    146          {
   \                     OWWrite_bit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    147          	if (v & 1) {
   \   00000004   0x07C8             LSLS     R0,R1,#+31
   \   00000006   0xD50F             BPL.N    ??OWWrite_bit_0
    148          		OWNoInterrupts();
   \   00000008   0x.... 0x....      BL       OWNoInterrupts
    149          		OWWriteLow(owire);
   \   0000000C   0x.... 0x....      BL       ?Subroutine2
    150          		OWOutput(owire);	// drive output low
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000010   0x.... 0x....      BL       ?Subroutine3
    151          		halCommonDelayMicroseconds(10);
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x.... 0x....      BL       halCommonDelayMicroseconds
    152          		OWWriteHigh(owire);	// drive output high
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       OWWriteHigh
    153          		OWInterrupts();
   \   00000020   0x.... 0x....      BL       OWInterrupts
    154          		halCommonDelayMicroseconds(55);
   \   00000024   0x2037             MOVS     R0,#+55
   \   00000026   0xE00E             B.N      ??OWWrite_bit_1
    155          	} else {
    156          		OWNoInterrupts();
   \                     ??OWWrite_bit_0: (+1)
   \   00000028   0x.... 0x....      BL       OWNoInterrupts
    157          		OWWriteLow(owire);
   \   0000002C   0x.... 0x....      BL       ?Subroutine2
    158          		OWOutput(owire);	// drive output low
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000030   0x.... 0x....      BL       ?Subroutine3
    159          		halCommonDelayMicroseconds(65);
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000034   0x2041             MOVS     R0,#+65
   \   00000036   0x.... 0x....      BL       halCommonDelayMicroseconds
    160          		OWWriteHigh(owire);	// drive output high
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       OWWriteHigh
    161          		OWInterrupts();
   \   00000040   0x.... 0x....      BL       OWInterrupts
    162          		halCommonDelayMicroseconds(5);
   \   00000044   0x2005             MOVS     R0,#+5
   \                     ??OWWrite_bit_1: (+1)
   \   00000046   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004A   0x.... 0x....      B.W      halCommonDelayMicroseconds
    163          	}
    164          }
    165          
    166          

   \                                 In section .text, align 2, keep-with-next
    167          uint8_t OWRead_bit(OWire* owire)
    168          {
   \                     OWRead_bit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    169          	uint8_t r;
    170          
    171          	OWNoInterrupts();
   \   00000004   0x.... 0x....      BL       OWNoInterrupts
    172                  OWWriteLow(owire);
   \   00000008   0x.... 0x....      BL       ?Subroutine2
    173          	OWOutput(owire);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    174          	halCommonDelayMicroseconds(3);
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x.... 0x....      BL       halCommonDelayMicroseconds
    175          	OWInput(owire);	// let pin float, pull up will raise
   \   00000016   0x.... 0x....      BL       ?Subroutine1
    176          	halCommonDelayMicroseconds(10);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000001A   0x200A             MOVS     R0,#+10
   \   0000001C   0x.... 0x....      BL       halCommonDelayMicroseconds
    177          	r = OWReadPin(owire);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       OWReadPin
   \   00000026   0x4604             MOV      R4,R0
    178          	OWInterrupts();
   \   00000028   0x.... 0x....      BL       OWInterrupts
    179          	halCommonDelayMicroseconds(53);
   \   0000002C   0x2035             MOVS     R0,#+53
   \   0000002E   0x.... 0x....      BL       halCommonDelayMicroseconds
    180          	return r;
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    181          }
    182          

   \                                 In section .text, align 2, keep-with-next
    183          void OWWrite(OWire* owire, uint8_t v) {
   \                     OWWrite: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    184              uint8_t bitMask;
    185          
    186              for (bitMask = 0x01; bitMask; bitMask <<= 1) {
   \   00000006   0x2601             MOVS     R6,#+1
    187          	OWWrite_bit(owire, (bitMask & v)?1:0);
   \                     ??OWWrite_0: (+1)
   \   00000008   0xEA15 0x0106      ANDS     R1,R5,R6
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2101             MOVNE    R1,#+1
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       OWWrite_bit
    188              }
   \   00000016   0x0676             LSLS     R6,R6,#+25
   \   00000018   0x0E36             LSRS     R6,R6,#+24
   \   0000001A   0xD1F5             BNE.N    ??OWWrite_0
    189          
    190              OWNoInterrupts();
   \   0000001C   0x.... 0x....      BL       OWNoInterrupts
    191              OWInput(owire);
   \   00000020   0x.... 0x....      BL       ?Subroutine1
    192              OWWriteLow(owire);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000024   0x.... 0x....      BL       ?Subroutine2
    193              OWInterrupts();
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000028   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002C   0x....             B.N      OWInterrupts
    194          }
    195          

   \                                 In section .text, align 2, keep-with-next
    196          void OWWrite_bytes(OWire* owire, const uint8_t *buf, uint16_t count) {
   \                     OWWrite_bytes: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    197            uint16_t i;
    198            for (i = 0 ; i < count ; i++)
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE004             B.N      ??OWWrite_bytes_0
    199              OWWrite(owire,buf[i]);
   \                     ??OWWrite_bytes_1: (+1)
   \   0000000C   0x5D79             LDRB     R1,[R7, R5]
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       OWWrite
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
   \                     ??OWWrite_bytes_0: (+1)
   \   00000016   0xB2BF             UXTH     R7,R7
   \   00000018   0x42B7             CMP      R7,R6
   \   0000001A   0xD3F7             BCC.N    ??OWWrite_bytes_1
    200          
    201          
    202            OWNoInterrupts();
   \   0000001C   0x.... 0x....      BL       OWNoInterrupts
    203            OWInput(owire);
   \   00000020   0x.... 0x....      BL       ?Subroutine1
    204            OWWriteLow(owire);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000024   0x.... 0x....      BL       ?Subroutine2
    205            OWInterrupts();
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000028   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   0000002C   0x....             B.N      OWInterrupts
    206          
    207          }
    208          

   \                                 In section .text, align 2, keep-with-next
    209          uint8_t OWRead(OWire* owire) {
   \                     OWRead: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    210              uint8_t bitMask;
    211              uint8_t r = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    212          
    213              for (bitMask = 0x01; bitMask; bitMask <<= 1) {
   \   00000006   0x2601             MOVS     R6,#+1
    214          	if ( OWRead_bit(owire)) r |= bitMask;
   \                     ??OWRead_0: (+1)
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       OWRead_bit
   \   0000000E   0xB100             CBZ.N    R0,??OWRead_1
   \   00000010   0x4335             ORRS     R5,R6,R5
    215              }
   \                     ??OWRead_1: (+1)
   \   00000012   0x0676             LSLS     R6,R6,#+25
   \   00000014   0x0E36             LSRS     R6,R6,#+24
   \   00000016   0xD1F7             BNE.N    ??OWRead_0
    216              return r;
   \   00000018   0xB2E8             UXTB     R0,R5
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    217          }
    218          

   \                                 In section .text, align 2, keep-with-next
    219          void OWRead_bytes(OWire* owire, uint8_t *buf, uint16_t count) {
   \                     OWRead_bytes: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    220            uint16_t i;
    221            for (i = 0 ; i < count ; i++)
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE004             B.N      ??OWRead_bytes_0
    222              buf[i] = OWRead(owire);
   \                     ??OWRead_bytes_1: (+1)
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       OWRead
   \   00000012   0x5578             STRB     R0,[R7, R5]
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
   \                     ??OWRead_bytes_0: (+1)
   \   00000016   0xB2BF             UXTH     R7,R7
   \   00000018   0x42B7             CMP      R7,R6
   \   0000001A   0xD3F7             BCC.N    ??OWRead_bytes_1
    223          }
   \   0000001C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void OWSelect(OWire* owire, uint8_t rom[8])
    226          {
   \                     OWSelect: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    227              int i;
    228          
    229              OWWrite(owire, 0x55);           // Choose ROM
   \   00000006   0x2155             MOVS     R1,#+85
   \   00000008   0x.... 0x....      BL       OWWrite
    230          
    231              for( i = 0; i < 8; i++) OWWrite(owire, rom[i]);
   \   0000000C   0x2600             MOVS     R6,#+0
   \                     ??OWSelect_0: (+1)
   \   0000000E   0x5D71             LDRB     R1,[R6, R5]
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       OWWrite
   \   00000016   0x1C76             ADDS     R6,R6,#+1
   \   00000018   0x2E08             CMP      R6,#+8
   \   0000001A   0xDBF8             BLT.N    ??OWSelect_0
    232          }
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void OWSkip(OWire* owire)
    235          {
    236              OWWrite(owire,0xCC);           // Skip ROM
   \                     OWSkip: (+1)
   \   00000000   0x21CC             MOVS     R1,#+204
   \   00000002   0x....             B.N      OWWrite
    237          }
    238          

   \                                 In section .text, align 2, keep-with-next
    239          void OWDepower(OWire* owire)
    240          {
   \                     OWDepower: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    241          	OWNoInterrupts();
   \   00000004   0x.... 0x....      BL       OWNoInterrupts
    242          	OWInput(owire);
   \   00000008   0x.... 0x....      BL       ?Subroutine1
    243          	OWInterrupts();
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x....             B.N      OWInterrupts
    244          }
    245          
    246          #ifdef ONEWIRE_SEARCH
    247          

   \                                 In section .text, align 2, keep-with-next
    248          void OWReset_search(OWire* owire)
    249          {
    250            int i;
    251            // reset the search state
    252            owire->LastDiscrepancy = 0;
   \                     OWReset_search: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7781             STRB     R1,[R0, #+30]
    253            owire->LastDeviceFlag = FALSE;
   \   00000004   0xF880 0x1020      STRB     R1,[R0, #+32]
    254            owire->LastFamilyDiscrepancy = 0;
   \   00000008   0x77C1             STRB     R1,[R0, #+31]
    255            for(i = 7; ; i--)
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2107             MOVS     R1,#+7
   \   0000000E   0xE000             B.N      ??OWReset_search_0
   \                     ??OWReset_search_1: (+1)
   \   00000010   0x1E49             SUBS     R1,R1,#+1
    256            {
    257              owire->ROM_NO[i] = 0;
   \                     ??OWReset_search_0: (+1)
   \   00000012   0x180B             ADDS     R3,R1,R0
    258              if ( i == 0) break;
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0x759A             STRB     R2,[R3, #+22]
   \   00000018   0xD1FA             BNE.N    ??OWReset_search_1
    259            }
    260          }
   \   0000001A   0x4770             BX       LR               ;; return
    261          

   \                                 In section .text, align 2, keep-with-next
    262          uint8_t OWSearch(OWire* owire, uint8_t *newAddr)
    263          {
   \                     OWSearch: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
    264             uint8_t id_bit_number;
    265             uint8_t last_zero, rom_byte_number, search_result;
    266             uint8_t id_bit, cmp_id_bit;
    267             int i;
    268             unsigned char rom_byte_mask, search_direction;
    269          
    270             // initialize for search
    271             id_bit_number = 1;
   \   00000006   0x2601             MOVS     R6,#+1
    272             last_zero = 0;
    273             rom_byte_number = 0;
    274             rom_byte_mask = 1;
    275             search_result = 0;
    276          
    277             // if the last call was not the last one
    278             if (!owire->LastDeviceFlag)
   \   00000008   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000000C   0x2700             MOVS     R7,#+0
   \   0000000E   0x2501             MOVS     R5,#+1
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0x4689             MOV      R9,R1
   \   00000014   0x46B8             MOV      R8,R7
   \   00000016   0xD14F             BNE.N    ??OWSearch_0
    279             {
    280                // 1-Wire reset
    281                if (!OWReset(owire))
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       OWReset
   \   0000001E   0xB920             CBNZ.N   R0,??OWSearch_1
    282                {
    283                   // reset the search
    284                   owire->LastDiscrepancy = 0;
   \   00000020   0x77A0             STRB     R0,[R4, #+30]
    285                   owire->LastDeviceFlag = FALSE;
   \   00000022   0xF884 0x0020      STRB     R0,[R4, #+32]
    286                   owire->LastFamilyDiscrepancy = 0;
   \   00000026   0x77E0             STRB     R0,[R4, #+31]
    287                   return FALSE;
   \   00000028   0xE053             B.N      ??OWSearch_2
    288                }
    289          
    290                // issue the search command
    291                OWWrite(owire, 0xF0);
   \                     ??OWSearch_1: (+1)
   \   0000002A   0x21F0             MOVS     R1,#+240
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       OWWrite
    292          
    293                // loop to do the search
    294                do
    295                {
    296                   // read a bit and its complement
    297                   id_bit = OWRead_bit(owire);
   \                     ??OWSearch_3: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       OWRead_bit
   \   00000038   0x4682             MOV      R10,R0
    298                   cmp_id_bit = OWRead_bit(owire);
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       OWRead_bit
    299          
    300                   // check for no devices on 1-wire
    301                   if ((id_bit == 1) && (cmp_id_bit == 1))
   \   00000040   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0x2801             CMPEQ    R0,#+1
   \   00000048   0xD02A             BEQ.N    ??OWSearch_4
    302                      break;
    303                   else
    304                   {
    305                      // all devices coupled have 0 or 1
    306                      if (id_bit != cmp_id_bit)
   \   0000004A   0x4582             CMP      R10,R0
   \   0000004C   0xEB08 0x0104      ADD      R1,R8,R4
   \   00000050   0xD005             BEQ.N    ??OWSearch_5
    307                         search_direction = id_bit;  // bit write value for search
    308                      else
    309                      {
    310                         // if this discrepancy if before the Last Discrepancy
    311                         // on a previous next then pick the same as last time
    312                         if (id_bit_number < owire->LastDiscrepancy)
    313                            search_direction = ((owire->ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
    314                         else
    315                            // if equal to last pick 1, if not then pick 0
    316                            search_direction = (id_bit_number == owire->LastDiscrepancy);
    317          
    318                         // if 0 was picked then record its position in LastZero
    319                         if (search_direction == 0)
    320                         {
    321                            last_zero = id_bit_number;
    322          
    323                            // check for Last discrepancy in family
    324                            if (last_zero < 9)
    325                               owire->LastFamilyDiscrepancy = last_zero;
    326                         }
    327                      }
    328          
    329                      // set or clear the bit in the ROM byte rom_byte_number
    330                      // with mask rom_byte_mask
    331                      if (search_direction == 1)
   \   00000052   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000056   0xD110             BNE.N    ??OWSearch_6
    332                        owire->ROM_NO[rom_byte_number] |= rom_byte_mask;
   \                     ??OWSearch_7: (+1)
   \   00000058   0x7D88             LDRB     R0,[R1, #+22]
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0xE00F             B.N      ??OWSearch_8
   \                     ??OWSearch_5: (+1)
   \   0000005E   0x7FA0             LDRB     R0,[R4, #+30]
   \   00000060   0xB2F6             UXTB     R6,R6
   \   00000062   0x4286             CMP      R6,R0
   \   00000064   0xD237             BCS.N    ??OWSearch_9
   \   00000066   0x7D88             LDRB     R0,[R1, #+22]
   \   00000068   0x4028             ANDS     R0,R5,R0
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xDA34             BGE.N    ??OWSearch_10
   \                     ??OWSearch_11: (+1)
   \   0000006E   0x4637             MOV      R7,R6
   \   00000070   0x2F09             CMP      R7,#+9
   \   00000072   0xF04F 0x0A00      MOV      R10,#+0
   \   00000076   0xBFB8             IT       LT 
   \   00000078   0x77E7             STRBLT   R7,[R4, #+31]
    333                      else
    334                        owire->ROM_NO[rom_byte_number] &= ~rom_byte_mask;
   \                     ??OWSearch_6: (+1)
   \   0000007A   0x7D88             LDRB     R0,[R1, #+22]
   \   0000007C   0x43A8             BICS     R0,R0,R5
   \                     ??OWSearch_8: (+1)
   \   0000007E   0x7588             STRB     R0,[R1, #+22]
    335          
    336                      // serial number search direction write bit
    337                      OWWrite_bit(owire, search_direction);
   \   00000080   0x4651             MOV      R1,R10
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       OWWrite_bit
    338          
    339                      // increment the byte counter id_bit_number
    340                      // and shift the mask rom_byte_mask
    341                      id_bit_number++;
   \   00000088   0x1C76             ADDS     R6,R6,#+1
    342                      rom_byte_mask <<= 1;
   \   0000008A   0x0668             LSLS     R0,R5,#+25
   \   0000008C   0x0E05             LSRS     R5,R0,#+24
    343          
    344                      // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
    345                      if (rom_byte_mask == 0)
   \   0000008E   0xD104             BNE.N    ??OWSearch_12
    346                      {
    347                          rom_byte_number++;
   \   00000090   0xF108 0x0001      ADD      R0,R8,#+1
   \   00000094   0xFA5F 0xF880      UXTB     R8,R0
    348                          rom_byte_mask = 1;
   \   00000098   0x2501             MOVS     R5,#+1
    349                      }
    350                   }
    351                }
    352                while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
   \                     ??OWSearch_12: (+1)
   \   0000009A   0xF1B8 0x0F08      CMP      R8,#+8
   \   0000009E   0xDBC8             BLT.N    ??OWSearch_3
    353          
    354                // if the search was successful then
    355                if (!(id_bit_number < 65))
   \                     ??OWSearch_4: (+1)
   \   000000A0   0xB2F6             UXTB     R6,R6
   \   000000A2   0x2E41             CMP      R6,#+65
   \   000000A4   0xDB08             BLT.N    ??OWSearch_0
    356                {
    357                   // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
    358                   owire->LastDiscrepancy = last_zero;
   \   000000A6   0x77A7             STRB     R7,[R4, #+30]
    359          
    360                   // check for last device
    361                   if (owire->LastDiscrepancy == 0)
   \   000000A8   0x7FA0             LDRB     R0,[R4, #+30]
   \   000000AA   0xB910             CBNZ.N   R0,??OWSearch_13
    362                      owire->LastDeviceFlag = TRUE;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xF884 0x0020      STRB     R0,[R4, #+32]
    363          
    364                   search_result = TRUE;
   \                     ??OWSearch_13: (+1)
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0x7DA1             LDRB     R1,[R4, #+22]
   \   000000B6   0xB921             CBNZ.N   R1,??OWSearch_14
    365                }
    366             }
    367          
    368             // if no device found then reset counters so next 'search' will be like a first
    369             if (!search_result || !owire->ROM_NO[0])
    370             {
    371                owire->LastDiscrepancy = 0;
   \                     ??OWSearch_0: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x77A0             STRB     R0,[R4, #+30]
    372                owire->LastDeviceFlag = FALSE;
   \   000000BC   0xF884 0x0020      STRB     R0,[R4, #+32]
    373                owire->LastFamilyDiscrepancy = 0;
   \   000000C0   0x77E0             STRB     R0,[R4, #+31]
    374                search_result = FALSE;
    375             }
    376             for (i = 0; i < 8; i++) newAddr[i] = owire->ROM_NO[i];
   \                     ??OWSearch_14: (+1)
   \   000000C2   0x2100             MOVS     R1,#+0
   \                     ??OWSearch_15: (+1)
   \   000000C4   0x190A             ADDS     R2,R1,R4
   \   000000C6   0x7D92             LDRB     R2,[R2, #+22]
   \   000000C8   0xF801 0x2009      STRB     R2,[R1, R9]
   \   000000CC   0x1C49             ADDS     R1,R1,#+1
   \   000000CE   0x2908             CMP      R1,#+8
   \   000000D0   0xDBF8             BLT.N    ??OWSearch_15
   \                     ??OWSearch_2: (+1)
   \   000000D2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??OWSearch_9: (+1)
   \   000000D6   0xD1CA             BNE.N    ??OWSearch_11
   \                     ??OWSearch_10: (+1)
   \   000000D8   0xF04F 0x0A01      MOV      R10,#+1
   \   000000DC   0xE7BC             B.N      ??OWSearch_7
    377             return search_result;
    378            }
    379          #endif
    380          
    381          #ifdef ONEWIRE_CRC
    382          // The 1-Wire CRC scheme is described in Maxim Application Note 27:
    383          // "Understanding and Using Cyclic Redundancy Checks with Maxim iButton Products"
    384          //
    385          
    386          #ifdef ONEWIRE_CRC8_TABLE
    387          // This table comes from Dallas sample code where it is freely reusable,
    388          // though Copyright (C) 2000 Dallas Semiconductor Corporation

   \                                 In section .text, align 4, keep-with-next
    389          static const uint8_t dscrc_table[] = {
   \                     dscrc_table:
   \   00000000   0x00 0x5E          DC8 0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31
   \              0xBC 0xE2    
   \              0x61 0x3F    
   \              0xDD 0x83    
   \              0xC2 0x9C    
   \              0x7E 0x20    
   \              0xA3 0xFD    
   \              0x1F         
   \   0000000F   0x41 0x9D          DC8 65, 157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96
   \              0xC3 0x21    
   \              0x7F 0xFC    
   \              0xA2 0x40    
   \              0x1E 0x5F    
   \              0x01 0xE3    
   \              0xBD 0x3E    
   \              0x60         
   \   0000001E   0x82 0xDC          DC8 130, 220, 35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128
   \              0x23 0x7D    
   \              0x9F 0xC1    
   \              0x42 0x1C    
   \              0xFE 0xA0    
   \              0xE1 0xBF    
   \              0x5D 0x03    
   \              0x80         
   \   0000002D   0xDE 0x3C          DC8 222, 60, 98, 190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158
   \              0x62 0xBE    
   \              0xE0 0x02    
   \              0x5C 0xDF    
   \              0x81 0x63    
   \              0x3D 0x7C    
   \              0x22 0xC0    
   \              0x9E         
   \   0000003C   0x1D 0x43          DC8 29, 67, 161, 255, 70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56
   \              0xA1 0xFF    
   \              0x46 0x18    
   \              0xFA 0xA4    
   \              0x27 0x79    
   \              0x9B 0xC5    
   \              0x84 0xDA    
   \              0x38         
   \   0000004B   0x66 0xE5          DC8 102, 229, 187, 89, 7, 219, 133, 103, 57, 186, 228, 6, 88, 25, 71
   \              0xBB 0x59    
   \              0x07 0xDB    
   \              0x85 0x67    
   \              0x39 0xBA    
   \              0xE4 0x06    
   \              0x58 0x19    
   \              0x47         
   \   0000005A   0xA5 0xFB          DC8 165, 251, 120, 38, 196, 154, 101, 59, 217, 135, 4, 90, 184, 230
   \              0x78 0x26    
   \              0xC4 0x9A    
   \              0x65 0x3B    
   \              0xD9 0x87    
   \              0x04 0x5A    
   \              0xB8 0xE6    
   \   00000068   0xA7 0xF9          DC8 167, 249, 27, 69, 198, 152, 122, 36, 248, 166, 68, 26, 153, 199, 37
   \              0x1B 0x45    
   \              0xC6 0x98    
   \              0x7A 0x24    
   \              0xF8 0xA6    
   \              0x44 0x1A    
   \              0x99 0xC7    
   \              0x25         
   \   00000077   0x7B 0x3A          DC8 123, 58, 100, 134, 216, 91, 5, 231, 185, 140, 210, 48, 110, 237
   \              0x64 0x86    
   \              0xD8 0x5B    
   \              0x05 0xE7    
   \              0xB9 0x8C    
   \              0xD2 0x30    
   \              0x6E 0xED    
   \   00000085   0xB3 0x51          DC8 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205, 17, 79, 173, 243
   \              0x0F 0x4E    
   \              0x10 0xF2    
   \              0xAC 0x2F    
   \              0x71 0x93    
   \              0xCD 0x11    
   \              0x4F 0xAD    
   \              0xF3         
   \   00000094   0x70 0x2E          DC8 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80, 175, 241
   \              0xCC 0x92    
   \              0xD3 0x8D    
   \              0x6F 0x31    
   \              0xB2 0xEC    
   \              0x0E 0x50    
   \              0xAF 0xF1    
   \   000000A2   0x13 0x4D          DC8 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238, 50
   \              0xCE 0x90    
   \              0x72 0x2C    
   \              0x6D 0x33    
   \              0xD1 0x8F    
   \              0x0C 0x52    
   \              0xB0 0xEE    
   \              0x32         
   \   000000B1   0x6C 0x8E          DC8 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45
   \              0xD0 0x53    
   \              0x0D 0xEF    
   \              0xB1 0xF0    
   \              0xAE 0x4C    
   \              0x12 0x91    
   \              0xCF 0x2D    
   \   000000BF   0x73 0xCA          DC8 115, 202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55
   \              0x94 0x76    
   \              0x28 0xAB    
   \              0xF5 0x17    
   \              0x49 0x08    
   \              0x56 0xB4    
   \              0xEA 0x69    
   \              0x37         
   \   000000CE   0xD5 0x8B          DC8 213, 139, 87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119
   \              0x57 0x09    
   \              0xEB 0xB5    
   \              0x36 0x68    
   \              0x8A 0xD4    
   \              0x95 0xCB    
   \              0x29 0x77    
   \   000000DC   0xF4 0xAA          DC8 244, 170, 72, 22, 233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151
   \              0x48 0x16    
   \              0xE9 0xB7    
   \              0x55 0x0B    
   \              0x88 0xD6    
   \              0x34 0x6A    
   \              0x2B 0x75    
   \              0x97         
   \   000000EB   0xC9 0x4A          DC8 201, 74, 20, 246, 168, 116, 42, 200, 150, 21, 75, 169, 247, 182
   \              0x14 0xF6    
   \              0xA8 0x74    
   \              0x2A 0xC8    
   \              0x96 0x15    
   \              0x4B 0xA9    
   \              0xF7 0xB6    
   \   000000F9   0xE8 0x0A          DC8 232, 10, 84, 215, 137, 107, 53
   \              0x54 0xD7    
   \              0x89 0x6B    
   \              0x35         
    390                0, 94,188,226, 97, 63,221,131,194,156,126, 32,163,253, 31, 65,
    391              157,195, 33,127,252,162, 64, 30, 95,  1,227,189, 62, 96,130,220,
    392               35,125,159,193, 66, 28,254,160,225,191, 93,  3,128,222, 60, 98,
    393              190,224,  2, 92,223,129, 99, 61,124, 34,192,158, 29, 67,161,255,
    394               70, 24,250,164, 39,121,155,197,132,218, 56,102,229,187, 89,  7,
    395              219,133,103, 57,186,228,  6, 88, 25, 71,165,251,120, 38,196,154,
    396              101, 59,217,135,  4, 90,184,230,167,249, 27, 69,198,152,122, 36,
    397              248,166, 68, 26,153,199, 37,123, 58,100,134,216, 91,  5,231,185,
    398              140,210, 48,110,237,179, 81, 15, 78, 16,242,172, 47,113,147,205,
    399               17, 79,173,243,112, 46,204,146,211,141,111, 49,178,236, 14, 80,
    400              175,241, 19, 77,206,144,114, 44,109, 51,209,143, 12, 82,176,238,
    401               50,108,142,208, 83, 13,239,177,240,174, 76, 18,145,207, 45,115,
    402              202,148,118, 40,171,245, 23, 73,  8, 86,180,234,105, 55,213,139,
    403               87,  9,235,181, 54,104,138,212,149,203, 41,119,244,170, 72, 22,
    404              233,183, 85, 11,136,214, 52,106, 43,117,151,201, 74, 20,246,168,
    405              116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53};
    406          
    407          //
    408          // Compute a Dallas Semiconductor 8 bit CRC. These show up in the ROM
    409          // and the registers.  (note: this might better be done without to
    410          // table, it would probably be smaller and certainly fast enough
    411          // compared to all those delayMicrosecond() calls.  But I got
    412          // confused, so I use this table from the examples.)
    413          //

   \                                 In section .text, align 2, keep-with-next
    414          uint8_t OWCrc8( uint8_t *addr, uint8_t len)
    415          {
   \                     OWCrc8: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    416          	uint8_t crc = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x.... 0x....      ADR.W    R3,dscrc_table
   \   00000008   0xE003             B.N      ??OWCrc8_0
    417          
    418          	while (len--) {
    419          		crc = dscrc_table[(crc ^ *addr++)];
   \                     ??OWCrc8_1: (+1)
   \   0000000A   0xF810 0x4B01      LDRB     R4,[R0], #+1
   \   0000000E   0x4062             EORS     R2,R4,R2
   \   00000010   0x5CD2             LDRB     R2,[R2, R3]
    420          	}
   \                     ??OWCrc8_0: (+1)
   \   00000012   0x460C             MOV      R4,R1
   \   00000014   0x1E61             SUBS     R1,R4,#+1
   \   00000016   0xB2E4             UXTB     R4,R4
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD1F6             BNE.N    ??OWCrc8_1
    421          	return crc;
   \   0000001C   0x4610             MOV      R0,R2
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    422          }
    423          #else
    424          //
    425          // Compute a Dallas Semiconductor 8 bit CRC directly.
    426          // this is much slower, but much smaller, than the lookup table.
    427          //
    428          uint8_t OWCrc8( uint8_t *addr, uint8_t len)
    429          {
    430          	uint8_t crc = 0;
    431          	
    432          	while (len--) {
    433          		uint8_t inbyte = *addr++;
    434          		for (uint8_t i = 8; i; i--) {
    435          			uint8_t mix = (crc ^ inbyte) & 0x01;
    436          			crc >>= 1;
    437          			if (mix) crc ^= 0x8C;
    438          			inbyte >>= 1;
    439          		}
    440          	}
    441          	return crc;
    442          }
    443          #endif
    444          
    445          #ifdef ONEWIRE_CRC16

   \                                 In section .text, align 2, keep-with-next
    446          uint8_t OWCheck_crc16(uint8_t* input, uint16_t len, uint8_t* inverted_crc)
    447          {
   \                     OWCheck_crc16: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4614             MOV      R4,R2
    448              uint16_t crc = ~OWCrc16(input, len);
   \   00000004   0x.... 0x....      BL       OWCrc16
   \   00000008   0x43C0             MVNS     R0,R0
   \   0000000A   0xB280             UXTH     R0,R0
    449              return (crc & 0xFF) == inverted_crc[0] && (crc >> 8) == inverted_crc[1];
   \   0000000C   0x7822             LDRB     R2,[R4, #+0]
   \   0000000E   0xB2C1             UXTB     R1,R0
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x0A00             LSREQ    R0,R0,#+8
   \   00000016   0x7861             LDRBEQ   R1,[R4, #+1]
   \   00000018   0x4288             CMPEQ    R0,R1
   \   0000001A   0xD101             BNE.N    ??OWCheck_crc16_0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD10             POP      {R4,PC}
   \                     ??OWCheck_crc16_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    450          }
    451          

   \                                 In section .text, align 2, keep-with-next
    452          uint16_t OWCrc16(uint8_t* input, uint16_t len)
    453          {
   \                     OWCrc16: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    454              static const uint8_t oddparity[16] = { 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0 };
    455              uint16_t crc = 0;    // Starting seed is zero.
   \   00000002   0x2200             MOVS     R2,#+0
    456              uint16_t i;
    457              for (i = 0 ; i < len ; i++) {
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x.... 0x....      ADR.W    R4,??oddparity
   \   0000000A   0xE014             B.N      ??OWCrc16_0
    458                // Even though we're just copying a byte from the input,
    459                // we'll be doing 16-bit computation with it.
    460                uint16_t cdata = input[i];
    461                cdata = (cdata ^ (crc & 0xff)) & 0xff;
   \                     ??OWCrc16_1: (+1)
   \   0000000C   0x5C1D             LDRB     R5,[R3, R0]
   \   0000000E   0x4055             EORS     R5,R2,R5
   \   00000010   0xB2ED             UXTB     R5,R5
    462                crc >>= 8;
    463          
    464                if (oddparity[cdata & 0x0F] ^ oddparity[cdata >> 4])
   \   00000012   0xF005 0x060F      AND      R6,R5,#0xF
   \   00000016   0x092F             LSRS     R7,R5,#+4
   \   00000018   0x5D36             LDRB     R6,[R6, R4]
   \   0000001A   0x5D3F             LDRB     R7,[R7, R4]
   \   0000001C   0x0A12             LSRS     R2,R2,#+8
   \   0000001E   0xEA97 0x0F06      TEQ      R7,R6
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0xF482 0x4240      EORNE    R2,R2,#0xC000
   \   00000028   0xF082 0x0201      EORNE    R2,R2,#0x1
    465                    crc ^= 0xC001;
    466          
    467                cdata <<= 6;
   \   0000002C   0x01AD             LSLS     R5,R5,#+6
    468                crc ^= cdata;
    469                cdata <<= 1;
    470                crc ^= cdata;
   \   0000002E   0xEA85 0x0545      EOR      R5,R5,R5, LSL #+1
   \   00000032   0x406A             EORS     R2,R5,R2
    471              }
   \   00000034   0x1C5B             ADDS     R3,R3,#+1
   \                     ??OWCrc16_0: (+1)
   \   00000036   0xB29B             UXTH     R3,R3
   \   00000038   0x428B             CMP      R3,R1
   \   0000003A   0xD3E7             BCC.N    ??OWCrc16_1
    472              return crc;
   \   0000003C   0x4610             MOV      R0,R2
   \   0000003E   0xBDF0             POP      {R4-R7,PC}       ;; return
    473          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??oddparity:
   \   00000000   0x00 0x01          DC8 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0
   \              0x01 0x00    
   \              0x01 0x00    
   \              0x00 0x01    
   \              0x01 0x00    
   \              0x00 0x01    
   \              0x00 0x01    
   \              0x01 0x00    
    474          #endif
    475          
    476          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OWCheck_crc16
         8   -> OWCrc16
      20   OWCrc16
       8   OWCrc8
       8   OWDepower
         8   -> OWInput
         0   -> OWInterrupts
         8   -> OWNoInterrupts
      24   OWInit
        24   -> GPIO_Init
        24   -> OWReset_search
      16   OWInput
        16   -> GPIO_Init
       0   OWInterrupts
       0   OWNoInterrupts
      16   OWOutput
        16   -> GPIO_Init
      16   OWRead
        16   -> OWRead_bit
       8   OWReadPin
         8   -> GPIO_ReadInputDataBit
       8   OWRead_bit
         8   -> OWInput
         8   -> OWInterrupts
         8   -> OWNoInterrupts
         8   -> OWOutput
         8   -> OWReadPin
         8   -> OWWriteLow
         8   -> halCommonDelayMicroseconds
      24   OWRead_bytes
        24   -> OWRead
       8   OWReset
         8   -> OWInput
         8   -> OWInterrupts
         8   -> OWNoInterrupts
         8   -> OWOutput
         8   -> OWReadPin
         8   -> OWWriteLow
         8   -> halCommonDelayMicroseconds
       0   OWReset_search
      32   OWSearch
        32   -> OWRead_bit
        32   -> OWReset
        32   -> OWWrite
        32   -> OWWrite_bit
      16   OWSelect
        16   -> OWWrite
       0   OWSkip
         0   -> OWWrite
      16   OWWrite
        16   -> OWInput
         0   -> OWInterrupts
        16   -> OWNoInterrupts
        16   -> OWWriteLow
        16   -> OWWrite_bit
       0   OWWriteHigh
         0   -> GPIO_SetBits
       0   OWWriteLow
         0   -> GPIO_ResetBits
       8   OWWrite_bit
         8   -> OWInterrupts
         8   -> OWNoInterrupts
         8   -> OWOutput
         8   -> OWWriteHigh
         8   -> OWWriteLow
         0   -> halCommonDelayMicroseconds
         8   -> halCommonDelayMicroseconds
      24   OWWrite_bytes
        24   -> OWInput
         0   -> OWInterrupts
        24   -> OWNoInterrupts
        24   -> OWWrite
        24   -> OWWriteLow


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      14  ?Subroutine0
       4  ?Subroutine1
       4  ?Subroutine2
       4  ?Subroutine3
      36  OWCheck_crc16
      64  OWCrc16
      32  OWCrc8
      18  OWDepower
     128  OWInit
      12  OWInput
       4  OWInterrupts
       4  OWNoInterrupts
      10  OWOutput
      28  OWRead
      14  OWReadPin
      54  OWRead_bit
      30  OWRead_bytes
      86  OWReset
      28  OWReset_search
     222  OWSearch
      30  OWSelect
       4  OWSkip
      46  OWWrite
       8  OWWriteHigh
       8  OWWriteLow
      78  OWWrite_bit
      46  OWWrite_bytes
     256  dscrc_table
      16  oddparity

 
 1 288 bytes in section .text
 
 1 288 bytes of CODE memory

Errors: none
Warnings: 1
