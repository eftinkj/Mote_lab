###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:29:57
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_gpio.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_gpio.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"stm32w108xx_gpio.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\stm32w108xx_gpio.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\stm32w108xx_gpio.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32w108xx_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the GPIO peripheral:           
      9            *           + Initialization and Configuration
     10            *           + GPIO Read and Write
     11            *  @verbatim
     12            *
     13          ================================================================================
     14                                   ##### How to use this driver #####
     15          ================================================================================
     16                [..]
     17                (#) Configure the GPIO pin(s) using GPIO_Init().
     18                    Four possible configuration are available for each pin:
     19                   (++) Input: Floating, Pull-up, Pull-down.
     20                   (++) Output: Push-Pull (Pull-up, Pull-down or no Pull)
     21                                Open Drain (Pull-up, Pull-down or no Pull).
     22                   (++) Alternate Function: Push-Pull (PP or SPI mode)
     23                                           Open Drain (Pull-up, Pull-down or no Pull).
     24                   (++) Analog
     25                   
     26                (#) To get the level of a pin configured in input mode use GPIO_ReadInputDataBit()
     27                (#) To set/reset the level of a pin configured in output mode use
     28                    GPIO_SetBits()/GPIO_ResetBits()
     29                (#) During and just after reset, the alternate functions are not active and 
     30                    the GPIO pins are configured in input floating mode (except JTAG pins).
     31                (#) A full chip reset affects the GPIO configuration as follows:
     32                    (++) All pins are configured as floating inputs.
     33                    (++) The GPIO_EXTREGEN bit is set which overrides the normal configuration for PA7.
     34                    (++) The GPIO_DBGDIS bit is cleared, allowing Serial Wire/JTAG access 
     35                        to override the normal configuration of PC0, PC2, PC3, and PC4.
     36                        
     37              @endverbatim
     38            *  
     39            ******************************************************************************
     40            * @attention
     41            *
     42            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     43            *
     44            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     45            * You may not use this file except in compliance with the License.
     46            * You may obtain a copy of the License at:
     47            *
     48            *        http://www.st.com/software_license_agreement_liberty_v2
     49            *
     50            * Unless required by applicable law or agreed to in writing, software 
     51            * distributed under the License is distributed on an "AS IS" BASIS, 
     52            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     53            * See the License for the specific language governing permissions and
     54            * limitations under the License.
     55            *
     56            ******************************************************************************  
     57            */ 
     58          
     59          /* Includes ------------------------------------------------------------------*/
     60          #include "stm32w108xx_gpio.h"
     61          
     62          /** @addtogroup STM32W108xx_StdPeriph_Driver
     63            * @{
     64            */
     65          
     66          /** @defgroup GPIO 
     67            * @brief GPIO driver modules
     68            * @{
     69            */
     70          
     71          /* Private typedef -----------------------------------------------------------*/
     72          /* Private define ------------------------------------------------------------*/
     73          /* Private macro -------------------------------------------------------------*/
     74          /* Private variables ---------------------------------------------------------*/
     75          /* Private function prototypes -----------------------------------------------*/
     76          /* Private functions ---------------------------------------------------------*/
     77          
     78          
     79          /** @defgroup GPIO_Private_Functions
     80            * @{
     81            */
     82          
     83          /** @defgroup GPIO_Group1 Initialization and Configuration
     84           *  @brief   Initialization and Configuration
     85           *
     86          @verbatim   
     87           ===============================================================================
     88                                  Initialization and Configuration
     89           ===============================================================================  
     90          
     91          @endverbatim
     92            * @{
     93            */
     94          
     95          /**
     96            * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
     97            * @param  GPIOx: where x can be (A..C) to select the GPIO peripheral.
     98            * @retval None
     99            */

   \                                 In section .text, align 2, keep-with-next
    100          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
    101          {
    102            /* Check the parameters */
    103            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    104          
    105            GPIOx->CRL = 0x00004444;
   \                     GPIO_DeInit: (+1)
   \   00000000   0xF244 0x4144      MOVW     R1,#+17476
   \   00000004   0x6001             STR      R1,[R0, #+0]
    106            GPIOx->CRH = 0x00004444;
   \   00000006   0x6041             STR      R1,[R0, #+4]
    107            GPIOx->IDR = 0x00000000;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    108            GPIOx->ODR = 0x00000000;
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    109            GPIOx->BSR = 0x00000000;
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    110            GPIOx->BRR = 0x00000000;
   \   00000010   0x6141             STR      R1,[R0, #+20]
    111          
    112            GPIO_DBG->PCTRACECR = 0x00000000;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable4  ;; 0x40004028
   \   00000016   0x6008             STR      R0,[R1, #+0]
    113            GPIO_DBG->DBGCR = 0x00000010;
   \   00000018   0x2010             MOVS     R0,#+16
   \   0000001A   0x....             LDR.N    R1,??DataTable4_1  ;; 0x4000bc00
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    114          }
   \   0000001E   0x4770             BX       LR               ;; return
    115          
    116          /**
    117            * @brief  Initializes the GPIOx peripheral according to the specified 
    118            *         parameters in the GPIO_InitStruct.
    119            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    120            * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that 
    121            *         contains the configuration information for the specified GPIO
    122            *         peripheral.
    123            *         GPIO_Pin: selects the pin to be configured: GPIO_Pin_0 -> GPIO_Pin_7
    124            *         GPIO_Mode: selects the mode of the pin: 
    125            *                          - GPIO Analog Mode: GPIO_Mode_AN 
    126            *                          - GPIO Output Mode PP: GPIO_Mode_OUT_PP
    127            *                          - GPIO Input Mode NOPULL: GPIO_Mode_IN
    128            *                          - GPIO Output Mode OD: GPIO_Mode_OUT_OD
    129            *                          - GPIO Input Mode PuPd: GPIO_Mode_IN_PUD 
    130            *                          - GPIO Alternate function Mode PP: GPIO_Mode_AF_PP
    131            *                          - GPIO Alternate function Mode SPI SCLK PP: GPIO_Mode_AF_PP_SPI
    132            *                          - GPIO Alternate function Mode OD: GPIO_Mode_AF_OD
    133            * @retval None
    134            */

   \                                 In section .text, align 2, keep-with-next
    135          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    136          {
   \                     GPIO_Init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    137            uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
    138            uint32_t tmpreg = 0x00, pinmask = 0x00;
    139            /* Check the parameters */
    140            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    141            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    142            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
    143            
    144            /*---------------------------- GPIO Mode Configuration -----------------------*/
    145            currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
    146            
    147            /*---------------------------- GPIO CRL Configuration ------------------------*/
    148            /* Configure the four low port pins */
    149            if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x0F)) != 0x00)
   \   00000002   0xF8D1 0xC000      LDR      R12,[R1, #+0]
   \   00000006   0x790B             LDRB     R3,[R1, #+4]
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0x250F             MOVS     R5,#+15
   \   0000000E   0xF01C 0x0F0F      TST      R12,#0xF
   \   00000012   0xF003 0x030F      AND      R3,R3,#0xF
   \   00000016   0xD012             BEQ.N    ??GPIO_Init_0
    150            {
    151              tmpreg = GPIOx->CRL;
   \   00000018   0x6807             LDR      R7,[R0, #+0]
    152              for (pinpos = 0x00; pinpos < 0x04; pinpos++)
    153              {
    154                pos = ((uint32_t)0x01) << pinpos;
   \                     ??GPIO_Init_1: (+1)
   \   0000001A   0xFA04 0xF602      LSL      R6,R4,R2
    155                /* Get the port pins position */
    156                currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    157                if (currentpin == pos)
   \   0000001E   0xEA06 0x0E0C      AND      LR,R6,R12
   \   00000022   0x45B6             CMP      LR,R6
   \   00000024   0xD107             BNE.N    ??GPIO_Init_2
    158                {
    159                  pos = pinpos << 2;
   \   00000026   0x0096             LSLS     R6,R2,#+2
    160                  /* Clear the corresponding low control register bits */
    161                  pinmask = ((uint32_t)0x0F) << pos;
    162                  tmpreg &= ~pinmask;
    163                  /* Write the mode configuration in the corresponding bits */
    164                  tmpreg |= (currentmode << pos);
   \   00000028   0xFA05 0xFE06      LSL      LR,R5,R6
   \   0000002C   0xEA27 0x070E      BIC      R7,R7,LR
   \   00000030   0xFA03 0xF606      LSL      R6,R3,R6
   \   00000034   0x4337             ORRS     R7,R6,R7
    165                }
    166              }
   \                     ??GPIO_Init_2: (+1)
   \   00000036   0x1C52             ADDS     R2,R2,#+1
   \   00000038   0x2A04             CMP      R2,#+4
   \   0000003A   0xD3EE             BCC.N    ??GPIO_Init_1
    167              GPIOx->CRL = tmpreg;
   \   0000003C   0x6007             STR      R7,[R0, #+0]
    168            }
    169            /*---------------------------- GPIO CRH Configuration ------------------------*/
    170            /* Configure the four high port pins */
    171            if (GPIO_InitStruct->GPIO_Pin > 0x0F)
   \                     ??GPIO_Init_0: (+1)
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x2910             CMP      R1,#+16
   \   00000042   0xD314             BCC.N    ??GPIO_Init_3
    172            {
    173              tmpreg = GPIOx->CRH;
   \   00000044   0x6847             LDR      R7,[R0, #+4]
    174              for (pinpos = 0x00; pinpos < 0x04; pinpos++)
   \   00000046   0x2200             MOVS     R2,#+0
    175              {
    176                pos = (((uint32_t)0x01) << (pinpos + 0x04));
   \                     ??GPIO_Init_4: (+1)
   \   00000048   0x1D16             ADDS     R6,R2,#+4
   \   0000004A   0xFA04 0xF606      LSL      R6,R4,R6
    177                /* Get the port pins position */
    178                currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    179                if (currentpin == pos)
   \   0000004E   0xEA06 0x0C01      AND      R12,R6,R1
   \   00000052   0x45B4             CMP      R12,R6
   \   00000054   0xD107             BNE.N    ??GPIO_Init_5
    180                {
    181                  pos = pinpos << 2;
   \   00000056   0x0096             LSLS     R6,R2,#+2
    182                  /* Clear the corresponding high control register bits */
    183                  pinmask = ((uint32_t)0x0F) << pos;
    184                  tmpreg &= ~pinmask;
    185                  /* Write the mode configuration in the corresponding bits */
    186                  tmpreg |= (currentmode << pos);
   \   00000058   0xFA05 0xFC06      LSL      R12,R5,R6
   \   0000005C   0xEA27 0x070C      BIC      R7,R7,R12
   \   00000060   0xFA03 0xF606      LSL      R6,R3,R6
   \   00000064   0x4337             ORRS     R7,R6,R7
    187                } 
    188              }
   \                     ??GPIO_Init_5: (+1)
   \   00000066   0x1C52             ADDS     R2,R2,#+1
   \   00000068   0x2A04             CMP      R2,#+4
   \   0000006A   0xD3ED             BCC.N    ??GPIO_Init_4
    189              GPIOx->CRH = tmpreg;
   \   0000006C   0x6047             STR      R7,[R0, #+4]
    190            }
    191          }
   \                     ??GPIO_Init_3: (+1)
   \   0000006E   0xBDF0             POP      {R4-R7,PC}       ;; return
    192          
    193          /**
    194            * @brief  Fills each GPIO_InitStruct member with its default value.
    195            * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will 
    196            *         be initialized.
    197            * @retval None
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    200          {
    201            /* Reset GPIO init structure parameters values */
    202            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit: (+1)
   \   00000000   0x21FF             MOVS     R1,#+255
   \   00000002   0x6001             STR      R1,[R0, #+0]
    203            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    204          }
   \   00000008   0x4770             BX       LR               ;; return
    205          
    206          /**
    207            * @}
    208            */
    209          
    210          /** @defgroup GPIO_Group2 GPIO Read and Write
    211           *  @brief   GPIO Read and Write
    212           *
    213          @verbatim   
    214           ===============================================================================
    215                                        GPIO Read and Write
    216           ===============================================================================  
    217          
    218          @endverbatim
    219            * @{
    220            */
    221          
    222          /**
    223            * @brief  Reads the specified input port pin.
    224            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    225            * @param  GPIO_Pin: specifies the port bit to read.
    226            *   This parameter can be GPIO_Pin_x where x can be (0..7).
    227            * @retval The input port pin value.
    228            */

   \                                 In section .text, align 2, keep-with-next
    229          uint32_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin)
    230          {
    231            uint32_t bitstatus = 0x00;
    232            /* Check the parameters */
    233            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    234            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    235            
    236            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \                     GPIO_ReadInputDataBit: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
    237            {
    238              bitstatus = (uint32_t)Bit_SET;
    239            }
    240            else
    241            {
    242              bitstatus = (uint32_t)Bit_RESET;
    243            }
    244            return bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    245          }
    246          
    247          /**
    248            * @brief  Reads the specified GPIO input data port.
    249            * @param  GPIOx: where x can be (A..C) to select the GPIO peripheral.
    250            * @retval GPIO input data port value.
    251            */

   \                                 In section .text, align 2, keep-with-next
    252          uint32_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    253          {
    254            /* Check the parameters */
    255            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    256            
    257            return ((uint32_t)GPIOx->IDR);
   \                     GPIO_ReadInputData: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x4770             BX       LR               ;; return
    258          }
    259          
    260          /**
    261            * @brief  Reads the specified output data port bit.
    262            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    263            * @param  GPIO_Pin: Specifies the port bit to read.
    264            *   This parameter can be GPIO_Pin_x where x can be (0..7).
    265            * @retval The output port pin value.
    266            */

   \                                 In section .text, align 2, keep-with-next
    267          uint32_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin)
    268          {
    269            uint32_t bitstatus = 0x00;
    270            
    271            /* Check the parameters */
    272            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    273            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    274            
    275            if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \                     GPIO_ReadOutputDataBit: (+1)
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
    276            {
    277              bitstatus = (uint32_t)Bit_SET;
    278            }
    279            else
    280            {
    281              bitstatus = (uint32_t)Bit_RESET;
    282            }
    283            return bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    284          }
    285          
    286          /**
    287            * @brief  Reads the specified GPIO output data port.
    288            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    289            * @retval GPIO output data port value.
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          uint32_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    292          {
    293            /* Check the parameters */
    294            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    295            
    296            return ((uint32_t)GPIOx->ODR);
   \                     GPIO_ReadOutputData: (+1)
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0x4770             BX       LR               ;; return
    297          }
    298          
    299          /**
    300            * @brief  Sets the selected data port bits.
    301            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    302            * @param  GPIO_Pin: specifies the port bits to be written.
    303            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..7).
    304            * @note  This functions uses GPIOx_SET register to allow atomic read/modify 
    305            *        accesses. In this way, there is no risk of an IRQ occurring between
    306            *        the read and the modify access.
    307            * @retval None
    308            */

   \                                 In section .text, align 2, keep-with-next
    309          void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin)
    310          {
    311            /* Check the parameters */
    312            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    313            assert_param(IS_GPIO_PIN(GPIO_Pin));
    314            
    315            GPIOx->BSR = GPIO_Pin;
   \                     GPIO_SetBits: (+1)
   \   00000000   0x6101             STR      R1,[R0, #+16]
    316          }
   \   00000002   0x4770             BX       LR               ;; return
    317          
    318          /**
    319            * @brief  Clears the selected data port bits.
    320            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    321            * @param  GPIO_Pin: specifies the port bits to be written.
    322            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..7).
    323            * @note  This functions uses GPIOx_CLR register to allow atomic read/modify 
    324            *        accesses. In this way, there is no risk of an IRQ occurring between
    325            *        the read and the modify access.
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin)
    329          {
    330            /* Check the parameters */
    331            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    332            assert_param(IS_GPIO_PIN(GPIO_Pin));
    333            
    334            GPIOx->BRR = GPIO_Pin;
   \                     GPIO_ResetBits: (+1)
   \   00000000   0x6141             STR      R1,[R0, #+20]
    335          }
   \   00000002   0x4770             BX       LR               ;; return
    336          
    337          /**
    338            * @brief  Sets or clears the selected data port bit.
    339            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    340            * @param  GPIO_Pin: specifies the port bit to be written.
    341            *   This parameter can be one of GPIO_Pin_x where x can be (0..7).
    342            * @param  BitVal: specifies the value to be written to the selected bit.
    343            *   This parameter can be one of the BitAction enum values:
    344            *     @arg Bit_RESET: to clear the port pin
    345            *     @arg Bit_SET: to set the port pin
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint32_t GPIO_Pin, BitAction BitVal)
    349          {
    350            /* Check the parameters */
    351            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    352            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    353            assert_param(IS_GPIO_BIT_ACTION(BitVal));
    354            
    355            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit: (+1)
   \   00000000   0xB10A             CBZ.N    R2,??GPIO_WriteBit_0
    356            {
    357              GPIOx->BSR = GPIO_Pin;
   \   00000002   0x6101             STR      R1,[R0, #+16]
   \   00000004   0x4770             BX       LR
    358            }
    359            else
    360            {
    361              GPIOx->BRR = GPIO_Pin ;
   \                     ??GPIO_WriteBit_0: (+1)
   \   00000006   0x6141             STR      R1,[R0, #+20]
    362            }
    363          }
   \   00000008   0x4770             BX       LR               ;; return
    364          
    365          /**
    366            * @brief  Writes data to the specified GPIO data port.
    367            * @param  GPIOx: where x can be (A, B or C) to select the GPIO peripheral.
    368            * @param  PortVal: specifies the value to be written to the port output data 
    369            *                  register.
    370            * @retval None
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
    373          {
    374            /* Check the parameters */
    375            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    376            
    377            GPIOx->ODR = PortVal;
   \                     GPIO_Write: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    378          }
   \   00000002   0x4770             BX       LR               ;; return
    379          /**
    380            * @}
    381            */
    382          
    383          /** @defgroup GPIO_Group3 GPIO Wake and Debug Configuration 
    384           *  @brief  GPIO Wake and Debug Configuration 
    385           *
    386          @verbatim   
    387           ===============================================================================
    388                                  Debug Configuration
    389           ===============================================================================  
    390          
    391          @endverbatim
    392            * @{
    393            */
    394            
    395          /**
    396            * @brief  Selects PC_TRACE source on bb_debug GPIO pins.
    397            * @param  PCTRACE_SEL: specifies the PC_TRACE source on bb_debug GPIO pins.
    398            *   This parameter can be :
    399            *     @arg GPIO_BBDEBUG: bb debug.
    400            *     @arg GPIO_PCTRACE: pc trace.
    401            * @retval None.
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          void GPIO_PCTraceConfig(uint32_t PCTRACE_SEL)
    404          {
    405            /* Check the parameters */
    406            assert_param(IS_GPIO_PCTRACE(PCTRACE_SEL));
    407          
    408            GPIO_DBG->PCTRACECR = PCTRACE_SEL;
   \                     GPIO_PCTraceConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4  ;; 0x40004028
   \   00000002   0x6008             STR      R0,[R1, #+0]
    409          }
   \   00000004   0x4770             BX       LR               ;; return
    410          
    411          /**
    412            * @brief  Enables or disables the debug interface.
    413            * @param  NewState: new state of the debug interface.
    414            *   This parameter can be: ENABLE or DISABLE.
    415            * @retval None
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          void GPIO_DebugInterfaceCmd(FunctionalState NewState)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_FUNCTIONAL_STATE(NewState));
    421            if (NewState != DISABLE)
   \                     GPIO_DebugInterfaceCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_1  ;; 0x4000bc00
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xBF14             ITE      NE 
   \   00000008   0xF020 0x0020      BICNE    R0,R0,#0x20
   \   0000000C   0xF040 0x0020      ORREQ    R0,R0,#0x20
    422            {
    423              /* Clear the DEBUGDIS bit to Enable the debug interface */
    424              GPIO_DBG->DBGCR &= (uint32_t)~GPIO_DBGCR_DBGDIS;
    425          
    426            }
    427            else
    428            {
    429              /* Set the DEBUGDIS bit to Disable the debug interface */
    430              GPIO_DBG->DBGCR |= (uint32_t)GPIO_DBGCR_DBGDIS;
   \   00000010   0x6008             STR      R0,[R1, #+0]
    431            }
    432          }
   \   00000012   0x4770             BX       LR               ;; return
    433          
    434          /**
    435            * @brief  Enables or Disable REG_EN override of PA7's normal GPIO configuration.
    436            * @param  NewState: new state of the REG_EN.
    437            *   This parameter can be: ENABLE or DISABLE.
    438            * @retval None
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          void GPIO_ExternalOverrideCmd(FunctionalState NewState)
    441          {
    442            /* Check the parameters */
    443            assert_param(IS_FUNCTIONAL_STATE(NewState));
    444            if (NewState != DISABLE)
   \                     GPIO_ExternalOverrideCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_1  ;; 0x4000bc00
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xBF14             ITE      NE 
   \   00000008   0xF020 0x0010      BICNE    R0,R0,#0x10
   \   0000000C   0xF040 0x0010      ORREQ    R0,R0,#0x10
    445            {
    446              /* Clear the GPIO_EXTREGEN bit to Enable the debug interface */
    447              GPIO_DBG->DBGCR &= (uint32_t)~GPIO_DBGCR_EXTREGEN;
    448          
    449            }
    450            else
    451            {
    452              /* Set the GPIO_EXTREGEN bit to Disable the debug interface */
    453              GPIO_DBG->DBGCR |= (uint32_t)GPIO_DBGCR_EXTREGEN;
   \   00000010   0x6008             STR      R0,[R1, #+0]
    454            }
    455          }
   \   00000012   0x4770             BX       LR               ;; return
    456          
    457          /**
    458            * @brief  Checks whether the specified GPIO debug flag is set or not.
    459            * @param  GPIO_DBGFLAG: specifies the flag to check. 
    460            *   This parameter can be one of the following values:
    461            *     @arg GPIO_DBGSR_SWEN: Serial Wire interface flag
    462            *     @arg GPIO_DBGSR_FORCEDBG: Debugger interface flag
    463            *     @arg GPIO_DBGSR_BOOTMODE: nBOOTMODE signal sampled at the end of reset flag
    464            * @retval The new state of GPIO_DBGFLAG (SET or RESET).
    465            */

   \                                 In section .text, align 2, keep-with-next
    466          FlagStatus GPIO_GetDebugFlagStatus(uint16_t GPIO_DBGFLAG)
    467          {
    468            FlagStatus bitstatus = RESET;
    469          
    470            /* Check the parameters */
    471            assert_param(IS_GPIO_GET_DBGFLAG(GPIO_DBGFLAG));
    472          
    473            /* Check the status of the specified GPIO debug flag */
    474            if ((GPIO_DBG->DBGSR & GPIO_DBGFLAG) != (uint32_t)RESET)
   \                     GPIO_GetDebugFlagStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable4_2  ;; 0x4000bc04
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x4202             TST      R2,R0
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2101             MOVNE    R1,#+1
    475            {
    476              /* GPIO_DBGFLAG is set */
    477              bitstatus = SET;
    478            }
    479            else
    480            {
    481              /* GPIO_DBGFLAG is reset */
    482              bitstatus = RESET;
    483            }
    484            /* Return the GPIO_DBGFLAG status */
    485            return  bitstatus;
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    486          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40004028         DC32     0x40004028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x4000BC00         DC32     0x4000bc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x4000BC04         DC32     0x4000bc04
    487          
    488          /**
    489            * @}
    490            */
    491          
    492          /**
    493            * @}
    494            */
    495          
    496          /**
    497            * @}
    498            */
    499          
    500          /**
    501            * @}
    502            */
    503            
    504          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GPIO_DeInit
       0   GPIO_DebugInterfaceCmd
       0   GPIO_ExternalOverrideCmd
       0   GPIO_GetDebugFlagStatus
      20   GPIO_Init
       0   GPIO_PCTraceConfig
       0   GPIO_ReadInputData
       0   GPIO_ReadInputDataBit
       0   GPIO_ReadOutputData
       0   GPIO_ReadOutputDataBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_StructInit
       0   GPIO_Write
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
      32  GPIO_DeInit
      20  GPIO_DebugInterfaceCmd
      20  GPIO_ExternalOverrideCmd
      16  GPIO_GetDebugFlagStatus
     112  GPIO_Init
       6  GPIO_PCTraceConfig
       4  GPIO_ReadInputData
      14  GPIO_ReadInputDataBit
       4  GPIO_ReadOutputData
      14  GPIO_ReadOutputDataBit
       4  GPIO_ResetBits
       4  GPIO_SetBits
      10  GPIO_StructInit
       4  GPIO_Write
      10  GPIO_WriteBit

 
 286 bytes in section .text
 
 286 bytes of CODE memory

Errors: none
Warnings: none
