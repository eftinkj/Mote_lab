###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:28:40
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_OEDSR.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_OEDSR.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"routing_OEDSR.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\routing_OEDSR.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\routing_OEDSR.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_OEDSR.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          #include "routing_OEDSR.h"
     17          
     18          #ifdef _ENABLE_OEDSR_
     19          
     20          #include "routing.h"
     21          //#include "network_hardware.h"
     22          #include "common.h"
     23          #include "FEAT_Xbee_API/AT_scripts.h"
     24          //#include "uart_0.h"
     25          //#include "API_frames.h"
     26          #include "FEAT_Queuing/Queuing.h"
     27          #include "Application.h"
     28          #include "FEAT_Networking/Phy_layer.h"
     29          #include "FEAT_Scheduler/sch_basic_pub.h"
     30          
     31          #include "FEAT_STM32W/STM32W_Radio.h"
     32          
     33          // Variables to manage (periodic) timeout

   \                                 In section .data, align 4
     34          uint8_t oedsr_hello_timeout_enabled_ = 0;
   \                     oedsr_hello_timeout_enabled_:
   \   00000000   0x00               DC8 0
   \   00000001   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     35          rtc_tick_t oedsr_hello_timeout_ = RTC_OVERFLOW_TIMER_VALUE;
   \                     oedsr_hello_timeout_:
   \   00000004   0x05265C00         DC32 86400000
     36          
     37          #ifdef _ARM_
     38          #else // _ARM_
     39          	#ifdef __KEIL__
     40          		#ifdef _ENABLE_F1_MOTE_TEST_01_
     41          			sbit YLED = P2 ^ 5;
     42          		#else // _ENABLE_F1_MOTE_TEST_01_
     43          			sbit YLED = P2 ^ 2;
     44          		#endif // else/not _ENABLE_F1_MOTE_TEST_01_
     45          	#endif
     46          
     47          	#ifdef __SDCC__
     48          		#ifdef _ENABLE_F1_MOTE_TEST_01_
     49          			#define YLED P2_5
     50          		#else // _ENABLE_F1_MOTE_TEST_01_
     51          			#define YLED P2_2
     52          		#endif // else/not _ENABLE_F1_MOTE_TEST_01_
     53          	#endif // __SDCC__
     54          #endif // else _ARM_
     55          ///////////////////////////////////////////////
     56          ///////////////////////////////////////////////

   \                                 In section .bss, align 4
     57          uint16_t XDATA r_dst[MAX_ROUTES_OEDSR];
   \                     r_dst:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
     58          uint16_t XDATA r_next_hop[MAX_ROUTES_OEDSR];
   \                     r_next_hop:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
     59          uint8_t XDATA r_metric[MAX_ROUTES_OEDSR];
     60          int8_t XDATA r_last_line;
   \                     r_last_line:
   \   00000000                      DS8 1
     61          
     62          
     63          uint8_t oedsr_state_; // state of the routing agent (e.g. IDLE, routing in-progress)
   \                     oedsr_state_:
   \   00000001                      DS8 1
     64          uint8_t XDATA oedsr_Hello_countdown_;	// ON - periodically send HELLO
   \                     oedsr_Hello_countdown_:
   \   00000002                      DS8 1
     65          int16_t XDATA route_search_BS_;	// address of the target node (BS)
     66          //int16_t xdata route_search_count_;	// count down the interval between HELLO and period for ACK reception
     67          //int8_t xdata route_search_timer_on_; //indicates if the timer should be set
     68          
     69          ///////////////////////////////////////////////
     70          ///////////////////////////////////////////////
     71          
     72          uint16_t XDATA ack_temp_addr_[MAX_ACK_TEMP];
     73          uint16_t XDATA ack_temp_link_cost_[MAX_ACK_TEMP];
     74          uint8_t XDATA ack_temp_free_;	// the first free element (and count of used)
   \                     ack_temp_free_:
   \   00000003                      DS8 1
     75          
     76          // Temp to handle dynamic packets
     77          #define RTR_OEDSR_PKT_SIZE 30
     78          uint8_t XDATA rtr_oedsr_pkt[RTR_OEDSR_PKT_SIZE];
     79          
     80          ///////////////////////////////////////////////
     81          
     82          //Counters for the Routing Energy Analysis
     83          uint8_t XDATA Select_counter;
   \                     Select_counter:
   \   00000004                      DS8 1
     84          uint8_t XDATA Hello_counter;
   \                     Hello_counter:
   \   00000005                      DS8 1
     85          uint8_t XDATA ACK_OEDSR_counter;
   \                     ACK_OEDSR_counter:
   \   00000006                      DS8 1
     86          uint8_t XDATA DAT_OEDSR_counter;
   \                     DAT_OEDSR_counter:
   \   00000007                      DS8 1
   \                     r_metric:
   \   00000008                      DS8 20
   \                     route_search_BS_:
   \   0000001C                      DS8 2
   \   0000001E                      DS8 2
   \                     ack_temp_addr_:
   \   00000020                      DS8 32

   \                                 In section .bss, align 4
   \                     ack_temp_link_cost_:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
   \                     rtr_oedsr_pkt:
   \   00000000                      DS8 32
     87          
     88          ///////////////////////////////////////////////
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void send_OEDSR_counters()
     91          {
   \                     send_OEDSR_counters: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     92          
     93          	CNTpkt_OEDSR *cnt = ( CNTpkt_OEDSR * ) packet;
     94          	uint8_t temp_power = my_tx_power_;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23
     95          
     96          	cnt->start = START_BYTE;
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable23_1
   \   0000000A   0x7804             LDRB     R4,[R0, #+0]
   \   0000000C   0x2042             MOVS     R0,#+66
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
     97          	cnt->flags = FLAG_COUNTERS;
   \   00000010   0x2079             MOVS     R0,#+121
   \   00000012   0x7068             STRB     R0,[R5, #+1]
     98          	cnt->mac_dst = SWAP16((uint16_t)BS_ADDR);
   \   00000014   0xF44F 0x407E      MOV      R0,#+65024
   \   00000018   0x8068             STRH     R0,[R5, #+2]
     99          	cnt->mac_src = SWAP16((uint16_t)MY_ADDR);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0200             LSLS     R0,R0,#+8
   \   00000022   0x80A8             STRH     R0,[R5, #+4]
    100          	cnt->Hellocnt = Hello_counter;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000028   0x7941             LDRB     R1,[R0, #+5]
   \   0000002A   0x71A9             STRB     R1,[R5, #+6]
    101          	cnt->Selcnt = Select_counter;
   \   0000002C   0x7901             LDRB     R1,[R0, #+4]
   \   0000002E   0x71E9             STRB     R1,[R5, #+7]
    102          	cnt->ACKcnt = ACK_OEDSR_counter;
   \   00000030   0x7981             LDRB     R1,[R0, #+6]
    103          	cnt->DATcnt = DAT_OEDSR_counter;
   \   00000032   0x79C0             LDRB     R0,[R0, #+7]
   \   00000034   0x7268             STRB     R0,[R5, #+9]
   \   00000036   0x7229             STRB     R1,[R5, #+8]
    104          	cnt->BEAMcnt = app_beam_count_;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable23_4
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x72A8             STRB     R0,[R5, #+10]
    105          	cnt->BEACONcnt = app_beacon_count_;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable23_5
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x72E8             STRB     R0,[R5, #+11]
    106          	cnt->crc = STOP_BYTE;
   \   00000048   0x2041             MOVS     R0,#+65
   \   0000004A   0x7328             STRB     R0,[R5, #+12]
    107          
    108          	phy_set_power_level ( MAX_POWER_LEVEL );
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x.... 0x....      BL       phy_set_power_level
    109          #ifdef _ENABLE_XBEE_API_
    110          	api_send_packet16 ( ( int8_t* ) packet, COUNT_LEN_OEDSR+2, BS_ADDR );
    111          #else
    112          	sendPriorityPacket (  COUNT_LEN_OEDSR+2, ( sint8_t* ) packet, BS_ADDR );
   \   00000052   0x22FE             MOVS     R2,#+254
   \   00000054   0x4629             MOV      R1,R5
   \   00000056   0x200D             MOVS     R0,#+13
   \   00000058   0x.... 0x....      BL       sendPriorityPacket
    113          #endif // _ENABLE_XBEE_API_
    114          
    115          	phy_set_power_level ( temp_power );
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000062   0x.... 0x....      B.W      phy_set_power_level
    116          }
    117          ///////////////////////////////////////////////
    118          
    119          
    120          ///////////////////////////////////////////////
    121          /*void set_distance(uint8_t rssi)
    122          {
    123          	if(0==rssi)
    124          		{
    125          		my_distance_ = DEFAULT_DISTANCE;
    126          		}
    127          	else
    128          		{
    129          		my_distance_ = ALPHA*rssi+(1-ALPHA)*my_distance_;
    130          		}
    131          
    132          }*/
    133          ///////////////////////////////////////////////
    134          
    135          
    136          
    137          ///////////////////////////////////////////////
    138          /**
    139            * ack_temp_clear - setups up temporary ACKs table
    140            */

   \                                 In section .text, align 2, keep-with-next
    141          void ack_temp_clear()
    142          {
    143          	ack_temp_free_ = 0;
   \                     ack_temp_clear: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable23_3
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x70C8             STRB     R0,[R1, #+3]
    144          }
   \   00000008   0x4770             BX       LR               ;; return
    145          ///////////////////////////////////////////////
    146          ///////////////////////////////////////////////
    147          /**
    148            * ack_temp_add - adds new ACK to the temporary ACKs table
    149            */

   \                                 In section .text, align 2, keep-with-next
    150          int8_t ack_temp_add ( apkt_t *ap, uint16_t delay )
    151          {
   \                     ack_temp_add: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    152          	unsigned long int link_factor;
    153          	uint16_t mac_d;
    154          	// saturate energy level
    155          	uint32_t energy = ap->energy;
   \   00000002   0xF8D0 0x100D      LDR      R1,[R0, #+13]
    156          	if (ENERGY_MAX_VALUE < energy)
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable23_6  ;; 0x2ab99
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xBF28             IT       CS 
   \   0000000E   0x.... 0x....      LDRCS.W  R1,??DataTable23_7  ;; 0x2ab98
    157          		energy = ENERGY_MAX_VALUE;
    158          	link_factor = ( energy * DELAY_SCALING ) / ( TYPICAL_DELAY_FOR_LINK * ap->distance );
   \   00000012   0x2264             MOVS     R2,#+100
   \   00000014   0x4351             MULS     R1,R2,R1
   \   00000016   0xF8D0 0x2009      LDR      R2,[R0, #+9]
   \   0000001A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    159          	if ( MAX_ACK_TEMP > ack_temp_free_ )
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable23_3
   \   00000022   0x78D3             LDRB     R3,[R2, #+3]
   \   00000024   0x461C             MOV      R4,R3
   \   00000026   0x2C0F             CMP      R4,#+15
   \   00000028   0xDA0E             BGE.N    ??ack_temp_add_0
    160          	{
    161          		mac_d = SWAP16(ap->mac_src);
    162          		ack_temp_addr_[ack_temp_free_] = mac_d;
   \   0000002A   0x8880             LDRH     R0,[R0, #+4]
   \   0000002C   0x0205             LSLS     R5,R0,#+8
   \   0000002E   0xEA45 0x2010      ORR      R0,R5,R0, LSR #+8
   \   00000032   0xEB02 0x0544      ADD      R5,R2,R4, LSL #+1
   \   00000036   0x8428             STRH     R0,[R5, #+32]
    163          		ack_temp_link_cost_[ack_temp_free_] = link_factor;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable23_8
   \   0000003C   0xF820 0x1014      STRH     R1,[R0, R4, LSL #+1]
    164          		ack_temp_free_++;
   \   00000040   0x1C58             ADDS     R0,R3,#+1
   \   00000042   0x70D0             STRB     R0,[R2, #+3]
    165          		return 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xBD30             POP      {R4,R5,PC}
    166          	}
    167          	return 0;
   \                     ??ack_temp_add_0: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD30             POP      {R4,R5,PC}       ;; return
    168          }
    169          ///////////////////////////////////////////////
    170          ///////////////////////////////////////////////
    171          /**
    172            * ack_temp_analyse - performs analysis of the temporary ACKs table
    173          		and selects the best node
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          uint16_t ack_temp_analyse()
    176          {
   \                     ack_temp_analyse: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    177          	uint8_t i = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    178          	uint16_t best_val = 0;	// any node with equal or higher value is better
   \   00000004   0x2200             MOVS     R2,#+0
    179          	uint16_t result = 0xFFFF;	// by default FFFF indicating lack of route
   \   00000006   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000000A   0x.... 0x....      LDR.W    R3,??DataTable23_8
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable23_3
   \   00000012   0xE005             B.N      ??ack_temp_analyse_0
    180          
    181          	while ( ( i < ack_temp_free_ ) && ( best_val <= ack_temp_link_cost_[i] ) )
    182          	{
    183          		best_val = ack_temp_link_cost_[i];
    184          		result = ack_temp_addr_[i];
   \                     ??ack_temp_analyse_1: (+1)
   \   00000014   0xEB04 0x0041      ADD      R0,R4,R1, LSL #+1
    185          		i++;
   \   00000018   0x1C49             ADDS     R1,R1,#+1
   \   0000001A   0x8C00             LDRH     R0,[R0, #+32]
   \   0000001C   0x462A             MOV      R2,R5
   \   0000001E   0xB2C9             UXTB     R1,R1
    186          	}
   \                     ??ack_temp_analyse_0: (+1)
   \   00000020   0x78E5             LDRB     R5,[R4, #+3]
   \   00000022   0x42A9             CMP      R1,R5
   \   00000024   0xDA03             BGE.N    ??ack_temp_analyse_2
   \   00000026   0xF833 0x5011      LDRH     R5,[R3, R1, LSL #+1]
   \   0000002A   0x4295             CMP      R5,R2
   \   0000002C   0xD2F2             BCS.N    ??ack_temp_analyse_1
    187          #ifdef DEBUG_OEDSR_ACKS
    188          	{
    189          		//int8_t xdata tmp[35];
    190          		uint8_t* tmp = rtr_oedsr_pkt;
    191          		pkt_t *p = tmp;
    192          		uint16_t *list = & ( p->hop_list );
    193          		p->start = START_BYTE;
    194          		p->flags = FLAG_ACK_DEBUG;
    195          		p->mac_dst = SWAP16(BS_ADDR);
    196          		p->mac_src = SWAP16(MY_ADDR);
    197          		p->length = 17; // of the packet'd data
    198          		p->dst_id = BS_ADDR; // part of DATA field (dest_id) - actual length depends on "length"
    199          		p->src_id = MY_ADDR; // part of DATA field
    200          
    201          		p->sequ_num = ack_temp_free_;
    202          		p->numhops = 0xFF;
    203          
    204          		for ( i = 0; i < ack_temp_free_; i++ )
    205          		{
    206          			*list = ack_temp_addr_[i];
    207          			list++;
    208          			*list = ack_temp_link_cost_[i];
    209          			list++;
    210          		}
    211          		*list = 0x0000;
    212          		list++;
    213          		*list = 0x0000;
    214          		list++;
    215          #ifdef _ENABLE_XBEE_API_
    216          		api_send_packet16 ( tmp, 27, BS_ADDR );
    217          #else
    218          		sendPriorityPacket ( 27, tmp, BS_ADDR );
    219          #endif
    220          	}
    221          #endif
    222          
    223          	return result;
   \                     ??ack_temp_analyse_2: (+1)
   \   0000002E   0xBD30             POP      {R4,R5,PC}       ;; return
    224          }
    225          ///////////////////////////////////////////////
    226          ///////////////////////////////////////////////
    227          /**
    228            * ack_temp_get_cost - get cost for the selected node
    229            */

   \                                 In section .text, align 2, keep-with-next
    230          uint16_t ack_temp_get_cost ( uint16_t addr )
    231          {
   \                     ack_temp_get_cost: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    232          	uint8_t i = 0;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable23_3
   \   00000006   0x78D3             LDRB     R3,[R2, #+3]
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xE001             B.N      ??ack_temp_get_cost_0
    233          	while ( ( i < ack_temp_free_ ) && ( addr != ack_temp_addr_[i] ) )
    234          	{
    235          		i++;
   \                     ??ack_temp_get_cost_1: (+1)
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0xB2C9             UXTB     R1,R1
    236          	}
   \                     ??ack_temp_get_cost_0: (+1)
   \   00000010   0x4299             CMP      R1,R3
   \   00000012   0xDA04             BGE.N    ??ack_temp_get_cost_2
   \   00000014   0xEB02 0x0441      ADD      R4,R2,R1, LSL #+1
   \   00000018   0x8C24             LDRH     R4,[R4, #+32]
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD1F6             BNE.N    ??ack_temp_get_cost_1
    237          
    238          	// if not found -> return cost = 0
    239          	if ( ack_temp_free_ == i )
   \                     ??ack_temp_get_cost_2: (+1)
   \   0000001E   0x428B             CMP      R3,R1
   \   00000020   0xD101             BNE.N    ??ack_temp_get_cost_3
    240          	{
    241          		return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}
    242          	}
    243          
    244          	return ack_temp_link_cost_[i];
   \                     ??ack_temp_get_cost_3: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable23_8
   \   0000002A   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    245          }
    246          ///////////////////////////////////////////////
    247          ///////////////////////////////////////////////
    248          /**
    249            * routing_init - performs initial setup of routing
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          void routing_init_OEDSR()
    252          {
    253          	r_last_line = -1;
   \                     routing_init_OEDSR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable23_3
    254          	oedsr_state_ = OEDSR_STATE_IDLE;
    255          	oedsr_Hello_countdown_ = 0;		// (>0) - periodically send HELLO
    256          	route_search_BS_ = 0xFE;	// address of the target node (BS)
    257          //	route_search_count_ = 0;	// count down the interval between HELLO
    258          	// ... and waiting period for ACK reception
    259          	ack_temp_clear();
    260          	AODVcounter_update = 1;
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable23_9
   \   00000008   0xF04F 0x31FF      MOV      R1,#-1
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7041             STRB     R1,[R0, #+1]
   \   00000012   0x7081             STRB     R1,[R0, #+2]
   \   00000014   0x21FE             MOVS     R1,#+254
   \   00000016   0x8381             STRH     R1,[R0, #+28]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x70C1             STRB     R1,[R0, #+3]
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7011             STRB     R1,[R2, #+0]
    261          	Select_counter = 0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7101             STRB     R1,[R0, #+4]
    262          	Hello_counter = 0;
   \   00000024   0x7141             STRB     R1,[R0, #+5]
    263          	ACK_OEDSR_counter = 0;
   \   00000026   0x7181             STRB     R1,[R0, #+6]
    264          	DAT_OEDSR_counter = 0;
   \   00000028   0x71C1             STRB     R1,[R0, #+7]
    265          
    266          
    267          	sch_add_loop(( sch_loop_func_t )oedsr_loop );
   \   0000002A   0x.... 0x....      ADR.W    R0,oedsr_loop
   \   0000002E   0x.... 0x....      B.W      sch_add_loop
    268          }
    269          
    270          ///////////////////////////////////////////////
    271          ///////////////////////////////////////////////
    272          /**
    273            * oedsr_loop() - executes main loop block (BUT DOES NOT LOOP ITSELF!!!)
    274            */

   \                                 In section .text, align 4, keep-with-next
    275          void oedsr_loop( void )
    276          {
   \                     oedsr_loop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    277          	if (1 == oedsr_hello_timeout_enabled_)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable23_10
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD10C             BNE.N    ??oedsr_loop_0
    278          		if ( oedsr_hello_timeout_ < rtc_get_ticks())
   \   0000000C   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000010   0x6861             LDR      R1,[R4, #+4]
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD207             BCS.N    ??oedsr_loop_0
    279          		{
    280          			oedsr_hello_timeout_enabled_ = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7020             STRB     R0,[R4, #+0]
    281          			oedsr_hello_timeout_ = RTC_OVERFLOW_TIMER_VALUE;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable23_11  ;; 0x5265c00
   \   0000001E   0x6060             STR      R0,[R4, #+4]
    282          			oedsr_hello_timoeout();
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x....             B.N      oedsr_hello_timoeout
    283          		}
    284          
    285          }
   \                     ??oedsr_loop_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    286          ///////////////////////////////////////////////
    287          ///////////////////////////////////////////////
    288          
    289          ///////////////////////////////////////////////
    290          ///////////////////////////////////////////////
    291          /**
    292            * oedsr_set_route - adds or updates a route to "dst_id"
    293            * returns '0' if failed to do so (no free space) or '1' when successful
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          int16_t oedsr_set_route ( uint16_t dst_id, uint16_t next_hop, uint8_t metric )
    296          {
   \                     oedsr_set_route: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    297          	int16_t index;
    298          	uint16_t mac_next_hop = next_hop;
    299          // Workaround for small demo-setups
    300          //  -> allows only specific nodes to transmit directlt to the BS
    301          #ifndef BS_NEIGHBOR
    302          	if ( BS_ADDR == dst_id)
    303          	{
    304          		if (BS_ADDR == next_hop)			return 0;
    305          	}
    306          #endif // BS_NEIGHBOR
    307          	if ( 0xFF == dst_id )
   \   00000006   0x2CFF             CMP      R4,#+255
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0xF64F 0x75FF      MOVWEQ   R5,#+65535
    308          	{
    309          		mac_next_hop = 0xffff;
    310          	}
    311          
    312          	index = find_route ( dst_id );
   \   00000010   0x.... 0x....      BL       find_route
    313          	if ( -1 == index )
   \   00000014   0xF110 0x0F01      CMN      R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable23_3
   \   0000001C   0xD109             BNE.N    ??oedsr_set_route_0
    314          	{
    315          		r_last_line++;
   \   0000001E   0x7808             LDRB     R0,[R1, #+0]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    316          		index = r_last_line;
   \   00000024   0xB240             SXTB     R0,R0
    317          		if ( MAX_ROUTES_OEDSR == r_last_line )
   \   00000026   0x2814             CMP      R0,#+20
   \   00000028   0xD103             BNE.N    ??oedsr_set_route_0
    318          		{
    319          			r_last_line--;
   \   0000002A   0x2013             MOVS     R0,#+19
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    320          			return 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD70             POP      {R4-R6,PC}
    321          		}
    322          	}
    323          	r_dst[index] = dst_id;
   \                     ??oedsr_set_route_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable23_12
   \   00000036   0xF822 0x4010      STRH     R4,[R2, R0, LSL #+1]
    324          	r_next_hop[index] = mac_next_hop;
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable23_13
   \   0000003E   0xF822 0x5010      STRH     R5,[R2, R0, LSL #+1]
    325          	r_metric[index] = metric;
   \   00000042   0x1840             ADDS     R0,R0,R1
   \   00000044   0x7206             STRB     R6,[R0, #+8]
    326          
    327          	return 1; // successfully added/updated route
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    328          }
    329          ///////////////////////////////////////////////
    330          ///////////////////////////////////////////////
    331          /**
    332            * find_route - searches for a route to a given destination
    333            * returns index to the route record or '-1' if not found
    334            */

   \                                 In section .text, align 2, keep-with-next
    335          int16_t find_route ( const uint16_t dst_id )
    336          {
    337          	int16_t i;
    338          	for ( i = 0; i <= r_last_line; i++ )
   \                     find_route: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable23_12
   \   00000006   0xE000             B.N      ??find_route_0
   \                     ??find_route_1: (+1)
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \                     ??find_route_0: (+1)
   \   0000000A   0x....             LDR.N    R3,??DataTable23_3
   \   0000000C   0xF993 0x3000      LDRSB    R3,[R3, #+0]
   \   00000010   0xB209             SXTH     R1,R1
   \   00000012   0x428B             CMP      R3,R1
   \   00000014   0xDB05             BLT.N    ??find_route_2
    339          	{
    340          		if ( dst_id == r_dst[i] )
   \   00000016   0xF832 0x3011      LDRH     R3,[R2, R1, LSL #+1]
   \   0000001A   0x4298             CMP      R0,R3
   \   0000001C   0xD1F4             BNE.N    ??find_route_1
    341          		{
    342          			return i;
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0x4770             BX       LR
    343          		}
    344          	}
    345          	return -1; // record not found
   \                     ??find_route_2: (+1)
   \   00000022   0xF04F 0x30FF      MOV      R0,#-1
   \   00000026   0x4770             BX       LR               ;; return
    346          }
    347          ///////////////////////////////////////////////
    348          ///////////////////////////////////////////////
    349          /**
    350            * get_next_hop - searches for a route to a given destination
    351            * returns MAC address of next hop on this route
    352            * or '0xFFFF' if not found any route
    353            */

   \                                 In section .text, align 2, keep-with-next
    354          uint16_t get_next_hop ( uint16_t dst_id )
    355          {
   \                     get_next_hop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    356          	int16_t index = find_route ( dst_id );
   \   00000002   0x.... 0x....      BL       find_route
    357          	if ( -1 == index )
   \   00000006   0xF110 0x0F01      CMN      R0,#+1
   \   0000000A   0xD102             BNE.N    ??get_next_hop_0
    358          	{
    359          		// TODO: no route => set the dest_id to be searched, and packet to wait
    360          
    361          		return 0xFFFF; // Not found route - try Broadcast ???
   \   0000000C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000010   0xBD02             POP      {R1,PC}
    362          	}
    363          	return r_next_hop[index];
   \                     ??get_next_hop_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable23_13
   \   00000014   0xF831 0x0010      LDRH     R0,[R1, R0, LSL #+1]
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    364          }
    365          ///////////////////////////////////////////////
    366          ///////////////////////////////////////////////
    367          /**
    368            * startRouteSearch - starts the route discovery procedure
    369            *
    370            *
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          void startRouteSearch ( uint16_t dst )
    373          {
   \                     startRouteSearch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    374          	if ( ( 0 < oedsr_Hello_countdown_ ) || ( OEDSR_STATE_IDLE != oedsr_state_ ) )
   \   00000002   0x....             LDR.N    R4,??DataTable23_3
   \   00000004   0x78A1             LDRB     R1,[R4, #+2]
   \   00000006   0x7862             LDRB     R2,[R4, #+1]
   \   00000008   0x4311             ORRS     R1,R2,R1
   \   0000000A   0xD10D             BNE.N    ??startRouteSearch_0
    375          	{
    376          		// there is one route discovery in progress
    377          		// skip the new one
    378          		// TODO: remember the new request for later
    379          		return;
    380          	}
    381          
    382          	// ###############################
    383          	// start route Discovery toward BS
    384          	route_search_BS_ = dst;
   \   0000000C   0x83A0             STRH     R0,[R4, #+28]
    385          	// Clear temporary table for ACK responses
    386          	ack_temp_clear();
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x70E0             STRB     R0,[R4, #+3]
    387          	sendHELLO();
   \   00000012   0x.... 0x....      BL       sendHELLO
    388          	oedsr_Hello_countdown_ = DEFAULT_ROUTE_SEARCH_ON_REPETITIONS;
   \   00000016   0x200A             MOVS     R0,#+10
   \   00000018   0x70A0             STRB     R0,[R4, #+2]
    389          	oedsr_state_ = OEDSR_STATE_ROUTE_DISCOVERY;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7060             STRB     R0,[R4, #+1]
    390          	oedsr_set_tx_timeout ( ROUTE_SEARCH_HELLO_INTERVAL );
   \   0000001E   0xF240 0x40E2      MOVW     R0,#+1250
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x....             B.N      oedsr_set_tx_timeout
   \                     ??startRouteSearch_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    391          }
    392          ///////////////////////////////////////////////
    393          ///////////////////////////////////////////////
    394          /**
    395            * oedsr_start_routing - re-starts the route discovery for DST_ID
    396            *
    397            *
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          void oedsr_start_routing( uint16_t dst_id )
    400          {
   \                     oedsr_start_routing: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    401          	if ( OEDSR_STATE_ROUTE_DISCOVERY == oedsr_state_ )
   \   00000002   0x....             LDR.N    R1,??DataTable23_3
   \   00000004   0x7849             LDRB     R1,[R1, #+1]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD003             BEQ.N    ??oedsr_start_routing_0
    402          	{
    403          		return;
    404          	}
    405          //	oedsr_set_route ( BS_ADDR, MAC_BROADCAST, 100 );
    406          	oedsr_set_route ( dst_id, MAC_BROADCAST, 100 );
   \   0000000A   0x2264             MOVS     R2,#+100
   \   0000000C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000010   0x....             B.N      ?Subroutine0
   \                     ??oedsr_start_routing_0: (+1)
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    407          	// stop data forwarding
    408          	enableDataTx_ = 0;
    409          	// start route discovery
    410          	startRouteSearch ( BS_ADDR );
    411          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       oedsr_set_route
   \   00000004   0x....             LDR.N    R1,??DataTable23_17
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7008             STRB     R0,[R1, #+0]
   \   0000000A   0x20FE             MOVS     R0,#+254
   \   0000000C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000010   0x....             B.N      startRouteSearch
    412          
    413          ///////////////////////////////////////////////
    414          ///////////////////////////////////////////////
    415          /**
    416            * sendHELLO - handles a sending of HELLO packet
    417            * collects all info for packet
    418            * prepares timestamp
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          uint8_t sendHELLO ()
    421          {
   \                     sendHELLO: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    422          //	uint8_t XDATA packet[RTR_OEDSR_HELLO_PKT_SIZE];
    423          //	uint8_t XDATA *packet = rtr_oedsr_pkt;
    424          	hpkt_t XDATA *hpkt = ( hpkt_t * ) packet;
    425          
    426          	if (0 != (CLUSTERING_I_AM_CH - my_CH_) ) return 0;
   \   00000002   0x....             LDR.N    R0,??DataTable23_14
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0xF1D0 0x00FD      RSBS     R0,R0,#+253
   \   0000000A   0xD001             BEQ.N    ??sendHELLO_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    427          
    428          	hpkt->start = START_BYTE;
   \                     ??sendHELLO_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable23_1
    429          	hpkt->flags = FLAG_HELLO;  // HELLO packet
    430          	hpkt->mac_dst = SWAP16((uint16_t)MAC_BROADCAST); // Broadcast
    431          	hpkt->mac_src = SWAP16((uint16_t)MY_ADDR);
    432          	hpkt->length = RTR_OEDSR_HELLO_PKT_SIZE - PKT_HEADER_LENGTH; // of the packet'd data
    433          	// FILL END-TO-END ADDRESSING
    434          	hpkt->dst_id = route_search_BS_; //BS_ADDR;
   \   00000012   0x....             LDR.N    R4,??DataTable23_3
    435          	hpkt->src_id = MY_ADDR;
    436          	// FILL THE OEDSR field
    437          	hpkt->distance = my_distance_;
    438          	hpkt->energy = my_energy_;
   \   00000014   0x....             LDR.N    R5,??DataTable23_15
   \   00000016   0x2042             MOVS     R0,#+66
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   \   0000001A   0xF64F 0x72FF      MOVW     R2,#+65535
   \   0000001E   0x200B             MOVS     R0,#+11
   \   00000020   0x7048             STRB     R0,[R1, #+1]
   \   00000022   0x804A             STRH     R2,[R1, #+2]
   \   00000024   0x....             LDR.N    R0,??DataTable23_2
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x7208             STRB     R0,[R1, #+8]
   \   0000002A   0x0203             LSLS     R3,R0,#+8
   \   0000002C   0x....             LDR.N    R0,??DataTable23_16
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF8C1 0x0009      STR      R0,[R1, #+9]
   \   00000034   0x808B             STRH     R3,[R1, #+4]
   \   00000036   0x230B             MOVS     R3,#+11
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0xF8C1 0x000D      STR      R0,[R1, #+13]
   \   0000003E   0x718B             STRB     R3,[R1, #+6]
    439          	// FILL the CHECKSUM
    440          	// TODO: calculate checksum
    441          	hpkt->crc = STOP_BYTE;
   \   00000040   0x2041             MOVS     R0,#+65
   \   00000042   0x8BA3             LDRH     R3,[R4, #+28]
   \   00000044   0x7448             STRB     R0,[R1, #+17]
   \   00000046   0x71CB             STRB     R3,[R1, #+7]
    442          
    443          
    444          	// TRANSMIT the HELLO packet out
    445          #ifdef _ENABLE_XBEE_API_
    446          	//TX_PACKET ( pkt_to_sent, len )
    447          	api_send_packet16( (int8_t*)packet, RTR_OEDSR_HELLO_PKT_SIZE, 0xFFFF);
    448          #else
    449          	sendPriorityPacket ( RTR_OEDSR_HELLO_PKT_SIZE, ( sint8_t* ) packet, 0xFFFF );
   \   00000048   0x2012             MOVS     R0,#+18
   \   0000004A   0x.... 0x....      BL       sendPriorityPacket
    450          #endif // _ENABLE_XBEE_API_
    451          	if ( AODVcounter_update )
   \   0000004E   0x....             LDR.N    R0,??DataTable23_9
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xB110             CBZ.N    R0,??sendHELLO_1
    452          	{
    453          		Hello_counter++;
   \   00000054   0x7960             LDRB     R0,[R4, #+5]
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0x7160             STRB     R0,[R4, #+5]
    454          	}
    455          	my_energy_ = my_energy_ -HELLO_LENGTH;
   \                     ??sendHELLO_1: (+1)
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x3812             SUBS     R0,R0,#+18
   \   0000005E   0x6028             STR      R0,[R5, #+0]
    456          	return 1;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    457          }
    458          ///////////////////////////////////////////////
    459          ///////////////////////////////////////////////
    460          /**
    461            * revcHELLO - handles a received HELLO packet
    462            * should identify if this node is potential relay node
    463            * if yes, then send response (ACK?)
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          uint16_t recvHELLO ( hpkt_t *hp )
    466          {
   \                     recvHELLO: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    467          	// find BS address and find correcponding distace
    468          	if (( hp->dst_id == BS_ADDR) && ( hp->distance <= my_distance_ ))
   \   00000002   0x79C1             LDRB     R1,[R0, #+7]
   \   00000004   0x29FE             CMP      R1,#+254
   \   00000006   0xD107             BNE.N    ??recvHELLO_0
   \   00000008   0x....             LDR.N    R1,??DataTable23_16
   \   0000000A   0xF8D0 0x2009      LDR      R2,[R0, #+9]
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xD301             BCC.N    ??recvHELLO_0
    469          	{
    470          		return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}
    471          	}
    472          	// check if closer then sending node
    473          
    474          	// prepare response
    475          
    476          	// sendACK packet
    477          //	com0_string("HELLO->ACK");
    478          	sendACK ( hp );
   \                     ??recvHELLO_0: (+1)
   \   00000018   0x.... 0x....      BL       sendACK
    479          	return 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    480          }
    481          ///////////////////////////////////////////////
    482          ///////////////////////////////////////////////
    483          /**
    484            * sendACK - handles a sending of ACK packet
    485            * collects all info for packet
    486            * prepares timestamp
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          uint16_t sendACK ( hpkt_t *hp )
    489          {
   \                     sendACK: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    490          	apkt_t *ap = (apkt_t *)packet;
    491          	ap->start = START_BYTE;
   \   00000002   0x....             LDR.N    R1,??DataTable23_1
   \   00000004   0x2242             MOVS     R2,#+66
   \   00000006   0x700A             STRB     R2,[R1, #+0]
    492          	ap->flags = FLAG_ACK;
    493          	ap->mac_dst = hp->mac_src;	// MAC DST
    494          	ap->mac_src = SWAP16((uint16_t)MY_ADDR); 		// MAC SRC
    495          
    496          	ap->length = 11;		// 2 x id(1B), 2 x u_long int(4B), 1 x crc (1B)
    497          
    498          	ap->dst_id = hp->src_id;
    499          	ap->src_id = MY_ADDR;
    500          
    501          
    502          	ap->distance = my_distance_;
    503          	ap->energy = my_energy_;
    504          	ap->crc = STOP_BYTE;
   \   00000008   0x2441             MOVS     R4,#+65
   \   0000000A   0x220C             MOVS     R2,#+12
   \   0000000C   0x704A             STRB     R2,[R1, #+1]
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
   \   00000010   0x804A             STRH     R2,[R1, #+2]
   \   00000012   0x....             LDR.N    R2,??DataTable23_2
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x0213             LSLS     R3,R2,#+8
   \   00000018   0x808B             STRH     R3,[R1, #+4]
   \   0000001A   0x230B             MOVS     R3,#+11
   \   0000001C   0x718B             STRB     R3,[R1, #+6]
   \   0000001E   0x7A03             LDRB     R3,[R0, #+8]
   \   00000020   0x720A             STRB     R2,[R1, #+8]
   \   00000022   0x744C             STRB     R4,[R1, #+17]
   \   00000024   0x71CB             STRB     R3,[R1, #+7]
   \   00000026   0x....             LDR.N    R2,??DataTable23_16
    505          
    506          //	com0_string("Send ACK");
    507          	if ( AODVcounter_update )
   \   00000028   0x....             LDR.N    R4,??DataTable23_9
   \   0000002A   0x6812             LDR      R2,[R2, #+0]
   \   0000002C   0x7824             LDRB     R4,[R4, #+0]
   \   0000002E   0xF8C1 0x2009      STR      R2,[R1, #+9]
   \   00000032   0x....             LDR.N    R2,??DataTable23_15
   \   00000034   0x6813             LDR      R3,[R2, #+0]
   \   00000036   0xF8C1 0x300D      STR      R3,[R1, #+13]
   \   0000003A   0xB11C             CBZ.N    R4,??sendACK_0
    508          	{
    509          		ACK_OEDSR_counter++;
   \   0000003C   0x....             LDR.N    R4,??DataTable23_3
   \   0000003E   0x79A5             LDRB     R5,[R4, #+6]
   \   00000040   0x1C6D             ADDS     R5,R5,#+1
   \   00000042   0x71A5             STRB     R5,[R4, #+6]
    510          	}
    511          	my_energy_ = my_energy_ -ACK_LENGTH;
   \                     ??sendACK_0: (+1)
   \   00000044   0x3B12             SUBS     R3,R3,#+18
   \   00000046   0x6013             STR      R3,[R2, #+0]
    512          //	return api_send_packet16 ( packet, ACK_LENGTH, 0xFFFF );// hp->mac_src );
    513          #ifdef _ENABLE_XBEE_API_
    514          	return api_send_packet16 ( packet, ACK_LENGTH, SWAP16((uint16_t)hp->mac_src) );
    515          #else // _ENABLE_XBEE_API_
    516          	sendPriorityPacket ( ACK_LENGTH, ( sint8_t* ) packet, SWAP16((uint16_t)hp->mac_src) );
   \   00000048   0x8880             LDRH     R0,[R0, #+4]
   \   0000004A   0x0202             LSLS     R2,R0,#+8
   \   0000004C   0xEA42 0x2210      ORR      R2,R2,R0, LSR #+8
   \   00000050   0xB292             UXTH     R2,R2
   \   00000052   0x2012             MOVS     R0,#+18
   \   00000054   0x.... 0x....      BL       sendPriorityPacket
    517                  return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    518          #endif // else _ENABLE_XBEE_API_
    519          
    520          }
    521          ///////////////////////////////////////////////
    522          ///////////////////////////////////////////////
    523          /**
    524            * revcACK - handles a received ACK packet
    525            * should identify if this node is potential relay node
    526            * if yes, then send response (ACK?)
    527            */

   \                                 In section .text, align 2, keep-with-next
    528          uint16_t recvACK ( sint8_t *pkt )
    529          {
   \                     recvACK: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    530          	apkt_t *p = ( apkt_t * ) pkt;
    531          	// check delay from timeout
    532          	// TODO:
    533          	// For now it will be constant
    534          	long int delay = TYPICAL_DELAY_FOR_LINK;
    535          
    536          	// analyse ACK packet
    537          	if ((0 < oedsr_Hello_countdown_)&&(SWAP16((uint16_t)(p->mac_src)) == route_search_BS_))
   \   00000004   0x....             LDR.N    R5,??DataTable23_3
   \   00000006   0x88A0             LDRH     R0,[R4, #+4]
   \   00000008   0x78AA             LDRB     R2,[R5, #+2]
   \   0000000A   0x0A01             LSRS     R1,R0,#+8
   \   0000000C   0xB1BA             CBZ.N    R2,??recvACK_0
   \   0000000E   0x0202             LSLS     R2,R0,#+8
   \   00000010   0xF402 0x427F      AND      R2,R2,#0xFF00
   \   00000014   0xF9B5 0x301C      LDRSH    R3,[R5, #+28]
   \   00000018   0x430A             ORRS     R2,R2,R1
   \   0000001A   0x429A             CMP      R2,R3
   \   0000001C   0xD10F             BNE.N    ??recvACK_0
    538          	{
    539          #ifndef BS_NEIGHBOR
    540          		if (BS_ADDR == SWAP16((uint16_t)(p->mac_src)) )
    541          		{
    542          			// Force to "not-hear" BS
    543          			return 0;
    544          		}
    545          #endif
    546          
    547          		// found the destination - ?? should it be for "src_id" instead "mac_src"??
    548          		oedsr_set_route ( SWAP16((uint16_t)(p->mac_src)), SWAP16((uint16_t)p->mac_src), 1 ); //metric not important
   \   0000001E   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000022   0xB281             UXTH     R1,R0
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0x.... 0x....      BL       oedsr_set_route
    549          		oedsr_Hello_countdown_ = 0; 	// Stop since already found final destination
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x70A8             STRB     R0,[R5, #+2]
    550          		oedsr_state_ = OEDSR_STATE_IDLE;
   \   00000030   0x7068             STRB     R0,[R5, #+1]
    551          		ack_temp_clear();
   \   00000032   0x70E8             STRB     R0,[R5, #+3]
    552          		enableDataTx_ = 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable23_17
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    553          		return 0xff;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}
    554          	}
    555          
    556          #ifndef BS_NEIGHBOR
    557          	if (BS_ADDR == SWAP16((uint16_t)(p->mac_src)) )  { return 0; }
    558          #endif
    559          	oedsr_set_route ( p->src_id, SWAP16((uint16_t)p->mac_src), 1 ); //metric not important
   \                     ??recvACK_0: (+1)
   \   0000003E   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   00000042   0x7A20             LDRB     R0,[R4, #+8]
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0xB289             UXTH     R1,R1
   \   00000048   0x.... 0x....      BL       oedsr_set_route
    560          
    561          	// store routing info in the temporarly table
    562          	return ack_temp_add ( ( apkt_t * ) pkt, delay );
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       ack_temp_add
   \   00000054   0xB280             UXTH     R0,R0
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    563          }
    564          ///////////////////////////////////////////////
    565          #ifdef NO_QUEUE
    566          ///////////////////////////////////////////////
    567          /**
    568            * sendDATA - handles a sending of DATA packet
    569            * 1) check if buffer ready then passes packet
    570            * 2) else temporarly stores
    571            */
    572          uint16_t sendDATA ( int8_t *pkt, uint8_t rssi )
    573          {
    574          	uint16_t mac_d;
    575          	pkt_t *pkt2 = ( pkt_t * ) pkt;
    576          	//enableDataTx_=1;
    577          
    578          	if ( enableDataTx_ )
    579          	{
    580          		// find destination -- only when taken out of the main loop
    581          		mac_d = get_next_hop ( GET_NEXT_HOP( pkt ) );
    582          		if ( 0xFFFF == mac_d )
    583          		{
    584          			// if the route search returned 0xFFFF then there is no route!!!
    585          			// then start new one and drop the packet
    586          			startRouteSearch ( BS_ADDR );
    587          			return 0;
    588          		}
    589          		// Set MAC header (addresses)
    590          		pkt->mac_dst = SWAP16((uint16_t)mac_d);
    591          		pkt->mac_src = SWAP16((uint16_t)MY_ADDR);
    592          
    593          		// send the packet
    594          		if ( AODVcounter_update )
    595          		{
    596          			DAT_OEDSR_counter++;
    597          		}
    598          		my_energy_ = my_energy_ - ( ( pkt_t* ) pkt )->length + 7;
    599          
    600          
    601          
    602          		if ( FLAG_DATA_TEST == pkt2->flags )
    603          		{
    604          			uint8_t *hop_list;
    605          
    606          #ifdef CH_START_ROUTE
    607          			pkt2->numhops = 0;
    608          
    609          			//uint8_t sequ_num;
    610          			//uint8_t numhops;
    611          			//uint8_t hop_list;
    612          #endif
    613          			hop_list = & ( pkt2->hop_list );
    614          			hop_list[ ( pkt2->numhops ) ++] = MY_ADDR;
    615          			hop_list[ ( pkt2->numhops ) ++] = rssi;
    616          			hop_list[ ( pkt2->numhops ) ++] = my_tx_power_;
    617          		}
    618          #ifdef _ENABLE_XBEE_API_
    619          		api_send_packet16 ( pkt, ( ( pkt_t* ) pkt )->length + 7, mac_d );
    620          #else // _ENABLE_XBEE_API_
    621          	sendPriorityPacket ( ( ( pkt_t* ) pkt )->length + 7, pkt, mac_d );
    622          #endif
    623          	}
    624          	else
    625          	{
    626          		APPEND_LOG ( NODE_ID_STR, NODE_ID_STR_LEN );
    627          		APPEND_LOG ( "DROP DATA\r", 10 );
    628          		// drop the packet
    629          		return 0;
    630          	}
    631          	return 1;
    632          
    633          }
    634          ///////////////////////////////////////////////
    635          #endif
    636          
    637          ///////////////////////////////////////////////
    638          /**
    639            * sendDATA - handles a sending of DATA packet
    640            * 1) check if buffer ready then passes packet
    641            * 2) else temporarly stores
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          int8_t OEDSR_send_DATA_base ( uint16_t base )
    644          {
   \                     OEDSR_send_DATA_base: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    645          	uint16_t mac_d;
    646          	// SDCC:
    647          	pkt_t * XDATA pkt = ( pkt_t* ) ( & ( buffer0[ base] ) ); //&(QBUFF_ACCESS(base,0));
    648          
    649          //	if (enableDataTx_)
    650          	if ( 1 )
    651          	{
    652          		if ( ((uint8_t)MAC_BROADCAST) == pkt->dst_id )
   \   00000002   0x....             LDR.N    R1,??DataTable23_18
   \   00000004   0x1844             ADDS     R4,R0,R1
   \   00000006   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000000A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD118             BNE.N    ??OEDSR_send_DATA_base_0
    653          		{
    654          			// broadcast - set BCAST Mac address
    655          			mac_d = MAC_BROADCAST;
   \   00000010   0x4628             MOV      R0,R5
    656          		}
    657          		else
    658          		{
    659          			// find destination -- only when taken out of the main loop
    660          			mac_d = get_next_hop ( pkt->dst_id );
    661          //			mac_d = NEXT_HOP;
    662          			if ( ( 0xFFFF == mac_d ) || ( 0 == enableDataTx_ ) )
    663          			{
    664          				// if the route search returned 0xFFFF then there is no route!!!
    665          				// then start new one and drop the packet
    666          				startRouteSearch ( pkt->dst_id );
    667          				enableDataTx_ = 0; // do not pass date anymore
    668          				// return the packet to queue
    669          //				app_drop_pkt ( base, MODULE_RTR, REASON_NOROUTE, EVENT_DSEND );
    670          				return ROUTING_BEGAN_ROUTE_DISCOVERY;
    671          			}
    672          		}
    673          			// Set MAC header (addresses)
    674          		pkt->mac_dst = SWAP16((uint16_t)mac_d);
   \                     ??OEDSR_send_DATA_base_1: (+1)
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x0200             LSLS     R0,R0,#+8
   \   00000016   0xEA40 0x2011      ORR      R0,R0,R1, LSR #+8
   \   0000001A   0x8060             STRH     R0,[R4, #+2]
    675          		pkt->mac_src = SWAP16((uint16_t)MY_ADDR);
   \   0000001C   0x....             LDR.N    R0,??DataTable23_2
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0200             LSLS     R0,R0,#+8
   \   00000022   0x80A0             STRH     R0,[R4, #+4]
    676          
    677          			// send the packet
    678          		if ( AODVcounter_update )
   \   00000024   0x....             LDR.N    R0,??DataTable23_9
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xB118             CBZ.N    R0,??OEDSR_send_DATA_base_2
    679          		{
    680          			DAT_OEDSR_counter++;
   \   0000002A   0x....             LDR.N    R0,??DataTable23_3
   \   0000002C   0x79C1             LDRB     R1,[R0, #+7]
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x71C1             STRB     R1,[R0, #+7]
    681          		}
    682          		// ENERGY USAGE
    683          		{
    684          			unsigned long int energy_delta = ( ( ( pkt_t* ) pkt )->length + 7 );
    685          			my_energy_ = my_energy_ - energy_delta ;
   \                     ??OEDSR_send_DATA_base_2: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable23_15
   \   00000034   0x79A2             LDRB     R2,[R4, #+6]
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x1DD2             ADDS     R2,R2,#+7
   \   0000003A   0x1A89             SUBS     R1,R1,R2
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    686          		}
    687          	}
    688          	else
    689          	{
    690          		APPEND_LOG ( NODE_ID_STR, NODE_ID_STR_LEN );
    691          		APPEND_LOG ( "DROP DATA\r", 10 );
    692          		// drop the packet
    693          		return 0;
    694          	}
    695          	return 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??OEDSR_send_DATA_base_0: (+1)
   \   00000042   0x.... 0x....      BL       get_next_hop
   \   00000046   0x....             LDR.N    R6,??DataTable23_17
   \   00000048   0x42A8             CMP      R0,R5
   \   0000004A   0xBF1C             ITT      NE 
   \   0000004C   0x7831             LDRBNE   R1,[R6, #+0]
   \   0000004E   0x2900             CMPNE    R1,#+0
   \   00000050   0xD1DF             BNE.N    ??OEDSR_send_DATA_base_1
   \   00000052   0x79E0             LDRB     R0,[R4, #+7]
   \   00000054   0x.... 0x....      BL       startRouteSearch
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7030             STRB     R0,[R6, #+0]
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0xBD70             POP      {R4-R6,PC}
    696          }
    697          ///////////////////////////////////////////////
    698          ///////////////////////////////////////////////
    699          /**
    700            * recvAcceptData - handles a received ACCEPT DATA packet from BS
    701            * 1) enables data transmission
    702            * 2)
    703            */

   \                                 In section .text, align 2, keep-with-next
    704          uint16_t recvAcceptData ( int8_t *pkt )
    705          {
    706          	pkt_t *p = ( pkt_t * ) pkt;
    707          
    708          //	int16_t i;
    709          //	float f = 0.0033;
    710          
    711          	// analyse ACK packet
    712          //	if (p->src_id == BS_ADDR)
    713          	if ( 0xFFFF == SWAP16((uint16_t)p->mac_dst) )
   \                     recvAcceptData: (+1)
   \   00000000   0x8840             LDRH     R0,[R0, #+2]
   \   00000002   0x0A01             LSRS     R1,R0,#+8
   \   00000004   0x0200             LSLS     R0,R0,#+8
   \   00000006   0xF400 0x407F      AND      R0,R0,#0xFF00
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD103             BNE.N    ??recvAcceptData_0
    714          	{
    715          		// enable DATA transmission
    716          		enableDataTx_ = 1;
   \   00000014   0x....             LDR.N    R1,??DataTable23_17
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    717          
    718          
    719          		APPEND_LOG ( NODE_ID_STR, NODE_ID_STR_LEN );
    720          		APPEND_LOG ( "DATA - OK\r\r\r", 12 );
    721          
    722          		return 1;
   \   0000001A   0x4770             BX       LR
    723          	}
    724          
    725          //	api_send_packet16(pkt, ((pkt_t*)pkt)->length + 7, 0x11);
    726          
    727          	// wrong trasmitter
    728          	return 0;
   \                     ??recvAcceptData_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    729          }
    730          ///////////////////////////////////////////////
    731          ///////////////////////////////////////////////
    732          /**
    733            * sendSelect - tells a selected node that it will be a relay node
    734            * 1)
    735            * 2)
    736            */

   \                                 In section .text, align 2, keep-with-next
    737          uint16_t sendSelect ( uint16_t relay, uint8_t bs )
    738          {
   \                     sendSelect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x4608             MOV      R0,R1
    739          	spkt_t *sp = 0;
    740          
    741          	// enable DATA formwarding since we found the route
    742          	enableDataTx_ = 1;
   \   00000006   0x....             LDR.N    R3,??DataTable23_17
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7019             STRB     R1,[R3, #+0]
    743          
    744          	// Create and fill in the SELECT packet
    745          	sp = ( spkt_t * ) packet;
    746          
    747          	sp->start = START_BYTE;
   \   0000000C   0x2342             MOVS     R3,#+66
   \   0000000E   0x....             LDR.N    R1,??DataTable23_1
   \   00000010   0x700B             STRB     R3,[R1, #+0]
    748          	sp->flags = FLAG_SELECT;
    749          	sp->mac_dst = SWAP16((uint16_t)relay);	// MAC DST
    750          	sp->mac_src = SWAP16((uint16_t)MY_ADDR); 		// MAC SRC
    751          
    752          	sp->length = 3;		// 2 x id(1B), 2 x int(2B), 1 x crc (1B)
    753          
    754          	sp->dst_id = bs;
   \   00000012   0x71C8             STRB     R0,[R1, #+7]
   \   00000014   0x230E             MOVS     R3,#+14
   \   00000016   0x704B             STRB     R3,[R1, #+1]
    755          	sp->src_id = MY_ADDR;
    756          
    757          	sp->crc = STOP_BYTE;
   \   00000018   0x2041             MOVS     R0,#+65
   \   0000001A   0x0213             LSLS     R3,R2,#+8
   \   0000001C   0xEA43 0x2312      ORR      R3,R3,R2, LSR #+8
   \   00000020   0x804B             STRH     R3,[R1, #+2]
   \   00000022   0x7248             STRB     R0,[R1, #+9]
   \   00000024   0x....             LDR.N    R3,??DataTable23_2
    758          
    759          	// Send the SELECT packet and log the activity if necessary
    760          	APPEND_LOG ( NODE_ID_STR, NODE_ID_STR_LEN );
    761          	APPEND_LOG ( ( int8_t* ) ( packet[3] ), 1 );
    762          	APPEND_LOG ( "Select sent\r", 12 );
    763          	if ( AODVcounter_update )
   \   00000026   0x....             LDR.N    R0,??DataTable23_9
   \   00000028   0x781B             LDRB     R3,[R3, #+0]
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x720B             STRB     R3,[R1, #+8]
   \   0000002E   0x021C             LSLS     R4,R3,#+8
   \   00000030   0x808C             STRH     R4,[R1, #+4]
   \   00000032   0x2403             MOVS     R4,#+3
   \   00000034   0x718C             STRB     R4,[R1, #+6]
   \   00000036   0xB118             CBZ.N    R0,??sendSelect_0
    764          	{
    765          		Select_counter++;
   \   00000038   0x....             LDR.N    R0,??DataTable23_3
   \   0000003A   0x7903             LDRB     R3,[R0, #+4]
   \   0000003C   0x1C5B             ADDS     R3,R3,#+1
   \   0000003E   0x7103             STRB     R3,[R0, #+4]
    766          	}
    767          	my_energy_ = my_energy_ -SELECT_LENGTH;
   \                     ??sendSelect_0: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable23_15
   \   00000042   0x6803             LDR      R3,[R0, #+0]
   \   00000044   0x3B0A             SUBS     R3,R3,#+10
   \   00000046   0x6003             STR      R3,[R0, #+0]
    768          
    769          #ifdef _ENABLE_XBEE_API_
    770          	if ( relay == 0xFFFF )
    771          	{
    772          		return api_send_packet16 ( packet, SELECT_LENGTH, BS_ADDR );
    773          	}
    774          
    775          	return api_send_packet16 ( packet, SELECT_LENGTH, relay );
    776          #else // _ENABLE_XBEE_API_
    777          	if ( relay == 0xFFFF )
   \   00000048   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000004C   0x4282             CMP      R2,R0
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x22FE             MOVEQ    R2,#+254
    778          	{
    779          		sendPriorityPacket ( SELECT_LENGTH, ( sint8_t* ) packet, BS_ADDR );
    780          		return 0;
    781          	}
    782          	sendPriorityPacket ( SELECT_LENGTH, ( sint8_t* ) packet, relay );
   \   00000052   0x200A             MOVS     R0,#+10
   \   00000054   0x.... 0x....      BL       sendPriorityPacket
    783          	return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    784          #endif // else _ENABLE_XBEE_API_
    785          	//Count the Select Packets sent
    786          //	return api_send_packet16(packet, SELECT_LENGTH, 0xFFFF);
    787          }
    788          ///////////////////////////////////////////////
    789          ///////////////////////////////////////////////
    790          /**
    791            * recvSelect - tells this node that it has been selected as a relay node
    792            * 1) enables data transmission
    793            * 2)
    794            */

   \                                 In section .text, align 2, keep-with-next
    795          uint16_t recvSelect ( sint8_t *pkt )
    796          {
   \                     recvSelect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    797          	uint8_t dst = (( spkt_t * ) pkt)->dst_id;
    798          	if ((uint8_t)MY_ADDR == dst)
   \   00000002   0x....             LDR.N    R1,??DataTable23_2
   \   00000004   0x79C0             LDRB     R0,[R0, #+7]
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x.... 0x....      BLNE     startRouteSearch
    799          	{
    800          		return 1;
    801          	}
    802          //	startRouteSearch ( BS_ADDR );
    803          	startRouteSearch ( dst );
    804          	return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    805          }
    806          ///////////////////////////////////////////////
    807          ///////////////////////////////////////////////
    808          /**
    809            * oedsr_dropped_link(??) - the link failed (after few retransmissions??) - update routing
    810            *    and optionally restart route discovery
    811            */

   \                                 In section .text, align 2, keep-with-next
    812          void oedsr_dropped_link()
    813          {
   \                     oedsr_dropped_link: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    814          	if ( CLUSTERING_I_AM_CH == my_CH_ )
   \   00000002   0x....             LDR.N    R0,??DataTable23_14
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x28FD             CMP      R0,#+253
   \   00000008   0xD104             BNE.N    ??oedsr_dropped_link_0
    815          	{
    816          		// delete route
    817          		oedsr_set_route ( BS_ADDR, MAC_BROADCAST, 100 );
   \   0000000A   0x2264             MOVS     R2,#+100
   \   0000000C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000010   0x20FE             MOVS     R0,#+254
   \   00000012   0x....             B.N      ?Subroutine0
    818          		// stop data forwarding
    819          		enableDataTx_ = 0;
    820          		// start route discovery
    821          		startRouteSearch ( BS_ADDR );
    822          	}
    823          }
   \                     ??oedsr_dropped_link_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    824          ///////////////////////////////////////////////
    825          ///////////////////////////////////////////////
    826          /////////////////////////////////
    827          /**
    828            * oedsr_hello_timoeout(??) - runs the procedure of periodic sending of Hello packets
    829            */

   \                                 In section .text, align 2, keep-with-next
    830          void oedsr_hello_timoeout()
    831          {
   \                     oedsr_hello_timoeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    832          	// Timeout reached -> is there a route found? or should I retransmit HELLO?
    833          	uint16_t mac_addr = ack_temp_analyse();
   \   00000002   0x.... 0x....      BL       ack_temp_analyse
   \   00000006   0x4605             MOV      R5,R0
    834          	if ( MAC_BROADCAST != mac_addr )
   \   00000008   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0x....             LDR.N    R4,??DataTable23_3
   \   00000010   0xD013             BEQ.N    ??oedsr_hello_timoeout_0
    835          	{
    836          		// finalize routing determination
    837          		// initially analyze ROUTE_TEMP_TABLE ad select the best
    838          		int16_t link_cost = ack_temp_get_cost ( mac_addr );
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       ack_temp_get_cost
    839          		oedsr_set_route ( route_search_BS_, mac_addr, link_cost );
   \   00000018   0xF9B4 0x601C      LDRSH    R6,[R4, #+28]
   \   0000001C   0xB2C2             UXTB     R2,R0
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0xB2B0             UXTH     R0,R6
   \   00000022   0x.... 0x....      BL       oedsr_set_route
    840          		ack_temp_clear();
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x70E0             STRB     R0,[R4, #+3]
    841          		sendSelect ( mac_addr, route_search_BS_ );
   \   0000002A   0xB2F1             UXTB     R1,R6
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       sendSelect
    842          #ifndef _TEMP_ARM_
    843          		YLED = 0;
    844          #endif // _TEMP_ARM_
    845          		oedsr_state_ = OEDSR_STATE_IDLE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7060             STRB     R0,[R4, #+1]
    846          		oedsr_Hello_countdown_ = 0;
   \   00000036   0x70A0             STRB     R0,[R4, #+2]
   \   00000038   0xBD70             POP      {R4-R6,PC}
    847          	}
    848          	else
    849          	{
    850          		if ( 0 < oedsr_Hello_countdown_ )
   \                     ??oedsr_hello_timoeout_0: (+1)
   \   0000003A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000003C   0xB140             CBZ.N    R0,??oedsr_hello_timoeout_1
    851          		{
    852          			oedsr_Hello_countdown_ --; // cound down HELLO retransmissions
   \   0000003E   0x1E40             SUBS     R0,R0,#+1
   \   00000040   0x70A0             STRB     R0,[R4, #+2]
    853          			// number of retransmission not reached -> resent HELLO
    854          #ifndef _TEMP_ARM_
    855          			YLED = FLIP_BIT(YLED);
    856          #endif // _TEMP_ARM_
    857          			oedsr_set_tx_timeout(ROUTE_SEARCH_HELLO_INTERVAL);
   \   00000042   0xF240 0x40E2      MOVW     R0,#+1250
   \   00000046   0x.... 0x....      BL       oedsr_set_tx_timeout
    858          			sendHELLO();
   \   0000004A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004E   0x....             B.N      sendHELLO
    859          #ifndef _TEMP_ARM_
    860          			YLED = FLIP_BIT(YLED);
    861          #endif // _TEMP_ARM_
    862          		}
    863          		else
    864          		{
    865          			// all Hello messages has been without response -> STOP
    866          			oedsr_Hello_countdown_ = 0; // stop
    867          			oedsr_state_ = OEDSR_STATE_IDLE;
   \                     ??oedsr_hello_timoeout_1: (+1)
   \   00000050   0x7060             STRB     R0,[R4, #+1]
    868          		}
    869          	}
    870          }
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    871          
    872          
    873          ///////////////////////////////////////////////
    874          ///////////////////////////////////////////////
    875          /**
    876            * oedsr_set_tx_timeout(??) - set one-time timeout for MMCR hello/tc packets
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          void oedsr_set_tx_timeout ( uint16_t ms )
    879          {
   \                     oedsr_set_tx_timeout: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    880          	oedsr_hello_timeout_ = rtc_get_ticks() + ms;
   \   00000004   0x....             LDR.N    R5,??DataTable23_10
   \   00000006   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000000A   0x1820             ADDS     R0,R4,R0
   \   0000000C   0x6068             STR      R0,[R5, #+4]
    881          	oedsr_hello_timeout_enabled_ = 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7028             STRB     R0,[R5, #+0]
    882          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     my_tx_power_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     packet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x........         DC32     my_addr8_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x........         DC32     r_last_line

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x........         DC32     app_beam_count_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x........         DC32     app_beacon_count_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x0002AB99         DC32     0x2ab99

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x0002AB98         DC32     0x2ab98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x........         DC32     ack_temp_link_cost_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x........         DC32     AODVcounter_update

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x........         DC32     oedsr_hello_timeout_enabled_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x05265C00         DC32     0x5265c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0x........         DC32     r_dst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x........         DC32     r_next_hop

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \   00000000   0x........         DC32     my_CH_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_15:
   \   00000000   0x........         DC32     my_energy_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_16:
   \   00000000   0x........         DC32     my_distance_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_17:
   \   00000000   0x........         DC32     enableDataTx_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_18:
   \   00000000   0x........         DC32     buffer0
    883          ///////////////////////////////////////////////
    884          ///////////////////////////////////////////////
    885          
    886          #endif // _ENABLE_OEDSR_

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OEDSR_send_DATA_base
        16   -> get_next_hop
        16   -> startRouteSearch
      12   ack_temp_add
      12   ack_temp_analyse
       0   ack_temp_clear
       8   ack_temp_get_cost
       0   find_route
       8   get_next_hop
         8   -> find_route
       8   oedsr_dropped_link
         8   -> oedsr_set_route
         0   -> startRouteSearch
      16   oedsr_hello_timoeout
        16   -> ack_temp_analyse
        16   -> ack_temp_get_cost
        16   -> oedsr_set_route
        16   -> oedsr_set_tx_timeout
         0   -> sendHELLO
        16   -> sendSelect
       8   oedsr_loop
         8   -> halCommonGetInt32uMillisecondTick
         0   -> oedsr_hello_timoeout
      16   oedsr_set_route
        16   -> find_route
      16   oedsr_set_tx_timeout
        16   -> halCommonGetInt32uMillisecondTick
       8   oedsr_start_routing
         8   -> oedsr_set_route
         0   -> startRouteSearch
      16   recvACK
        16   -> ack_temp_add
        16   -> oedsr_set_route
       0   recvAcceptData
       8   recvHELLO
         8   -> sendACK
       8   recvSelect
       0   routing_init_OEDSR
         0   -> sch_add_loop
      16   sendACK
        16   -> sendPriorityPacket
      16   sendHELLO
        16   -> sendPriorityPacket
       8   sendSelect
         8   -> sendPriorityPacket
      16   send_OEDSR_counters
         0   -> phy_set_power_level
        16   -> phy_set_power_level
        16   -> sendPriorityPacket
       8   startRouteSearch
         0   -> oedsr_set_tx_timeout
         8   -> sendHELLO


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_15
       4  ??DataTable23_16
       4  ??DataTable23_17
       4  ??DataTable23_18
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
      18  ?Subroutine0
      96  OEDSR_send_DATA_base
      76  ack_temp_add
      48  ack_temp_analyse
      10  ack_temp_clear
      48  ack_temp_get_cost
      32  ack_temp_link_cost_
      40  find_route
      26  get_next_hop
      22  oedsr_dropped_link
       8  oedsr_hello_timeout_enabled_
          oedsr_hello_timeout_
      84  oedsr_hello_timoeout
      40  oedsr_loop
      74  oedsr_set_route
      20  oedsr_set_tx_timeout
      20  oedsr_start_routing
      40  r_dst
      64  r_last_line
          oedsr_state_
          oedsr_Hello_countdown_
          ack_temp_free_
          Select_counter
          Hello_counter
          ACK_OEDSR_counter
          DAT_OEDSR_counter
          r_metric
          route_search_BS_
          ack_temp_addr_
      40  r_next_hop
      88  recvACK
      32  recvAcceptData
      32  recvHELLO
      20  recvSelect
      50  routing_init_OEDSR
      32  rtr_oedsr_pkt
      92  sendACK
     100  sendHELLO
      92  sendSelect
     102  send_OEDSR_counters
      42  startRouteSearch

 
   208 bytes in section .bss
     8 bytes in section .data
 1 348 bytes in section .text
 
 1 348 bytes of CODE memory
   216 bytes of DATA memory

Errors: none
Warnings: none
