###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:28:01
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\Phy_layer.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\Phy_layer.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"Phy_layer.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\Phy_layer.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\Phy_layer.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\Phy_layer.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          
     17          #include "Phy_layer.h"
     18          
     19          #include "FEAT_XBee_API/API_frames.h"
     20          #include "packet.h"
     21          #include "common.h"
     22          #include "HW_LIB/RTC.h"
     23          #include "Application.h"
     24          //#include "HW_LIB/uart_0.h"
     25          #include "FEAT_Queuing/Queuing.h"
     26          #include "FEAT_XBee_API/AT_scripts.h"
     27          #include "CongestionControl.h"
     28          
     29          #ifdef _ARM_
     30          	#include "FEAT_STM32W/STM32W_Radio.h"
     31          #endif // _ARM_
     32          
     33          #include <string.h>
     34          #include <stdio.h>
     35          #include <stdlib.h>
     36          
     37          unsigned char XDATA phy_busyThreshold_;
     38          
     39          unsigned int XDATA phy_count_free;
     40          unsigned int XDATA phy_count_busy;
     41          
     42          unsigned long int XDATA phy_scanTimestamp_;
     43          
     44          unsigned int XDATA phy_backoff_counter_;
     45          unsigned int XDATA phy_cw_;
     46          
     47          unsigned char XDATA phy_current_channel_;
     48          unsigned char XDATA my_rf_channel_;
     49          unsigned char XDATA my_tx_power_; // configured power level (default for orodinary communication
     50          unsigned char XDATA current_tx_power_; // current power level set on the radio
     51          
     52          unsigned long int XDATA phy_sent_timeout_; // timeout is not used until a packet is sent to Radio module
     53          
     54          
     55          #ifdef FEAT_ENABLE_CC
     56          uint32_t XDATA phy_backoff_timeout_;
     57          uint8_t XDATA DATA_waiting_4_BO_ = 0;
     58          #endif
     59          
     60          ///////////////////////////////////////////////
     61          
     62          
     63          
     64          /**
     65            * phy_init_scan_params() -
     66            */

   \                                 In section .text, align 2, keep-with-next
     67          void phy_init_scan_params()
     68          {
     69          #ifdef _ENABLE_XBEE_API_
     70          	unsigned int XDATA uint_value;
     71          
     72          	// Set channel to listen too
     73          	uint_value = 1 << ( DEFAULT_RF_CHANNEL - CHANNEL_MASK_SHIFT );
     74          	api_send_at ( "SC", ( char* ) &uint_value, 2 );
     75          
     76          	// Set scan duration parameter
     77          	uint_value = DEFAULT_SCAN_TIME;
     78          	api_send_at ( "SD", ( char* ) &uint_value, 2 );
     79          #endif // _ENABLE_XBEE_API_
     80          
     81          	phy_busyThreshold_ = DEFAULT_BUSY_THRESHOLD;
   \                     phy_init_scan_params: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6
   \   00000002   0x214B             MOVS     R1,#+75
   \   00000004   0x7001             STRB     R1,[R0, #+0]
     82          	phy_count_free = 0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6081             STR      R1,[R0, #+8]
     83          	phy_count_busy = 0;
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
     84          	phy_scanTimestamp_ = 0;
   \   0000000C   0x6101             STR      R1,[R0, #+16]
     85          	phy_backoff_counter_ = 1;
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x6141             STR      R1,[R0, #+20]
     86          	phy_cw_ = PHY_DEFAULT_CW;
   \   00000012   0x2120             MOVS     R1,#+32
   \   00000014   0x6181             STR      R1,[R0, #+24]
     87          
     88          	phy_current_channel_ = DEFAULT_RF_CHANNEL;
   \   00000016   0x2114             MOVS     R1,#+20
   \   00000018   0x7041             STRB     R1,[R0, #+1]
     89          	my_rf_channel_ = DEFAULT_RF_CHANNEL;
   \   0000001A   0x7081             STRB     R1,[R0, #+2]
     90          	my_tx_power_ = DEFAULT_TX_POWER; // configured power level (default for orodinary communication
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x70C1             STRB     R1,[R0, #+3]
     91          	current_tx_power_ = DEFAULT_TX_POWER;
   \   00000020   0x7101             STRB     R1,[R0, #+4]
     92          	phy_sent_timeout_ = 0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x61C1             STR      R1,[R0, #+28]
     93          }
   \   00000026   0x4770             BX       LR               ;; return
     94          
     95          
     96          
     97          /**
     98            * phy_change_backoff(mode) - switch backoff scheme
     99            */

   \                                 In section .text, align 2, keep-with-next
    100          void phy_change_backoff ( unsigned char new_backoff )
    101          {
    102          	switch ( new_backoff )
   \                     phy_change_backoff: (+1)
   \   00000000   0x2801             CMP      R0,#+1
    103          	{
    104          		case PHY_BACKOFF_DISABLE:
    105          			my_backoff_ = new_backoff;
    106          			break;
    107          		case PHY_BACKOFF_EXPONENTIAL:
    108          			my_backoff_ = new_backoff;
    109          			break;
    110          #ifdef FEAT_ENABLE_SFQ
    111          		case PHY_BACKOFF_ADFS:
    112          			my_backoff_ = new_backoff;
    113          			break;
    114          #endif // FEAT_ENABLE_SFQ
    115          #ifdef INCLUDE_PCC
    116          		case PHY_BACKOFF_PCC:
    117          			my_backoff_ = new_backoff;
    118          			cc_change_protocol();
    119          			break;
    120          		case PHY_BACKOFF_NO_PCC:
    121          			my_backoff_ = new_backoff;
    122          			cc_change_protocol();
    123          			break;
    124          #endif
    125          
    126          		default:
    127          			my_backoff_ = PHY_BACKOFF_DISABLE;
    128          			break;
   \   00000002   0x....             LDR.N    R1,??DataTable6_1
   \   00000004   0xBF88             IT       HI 
   \   00000006   0x2000             MOVHI    R0,#+0
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    129          	}
    130          }
   \   0000000A   0x4770             BX       LR               ;; return
    131          
    132          
    133          /**
    134            * phy_send_scan_request(channel) -
    135            */

   \                                 In section .text, align 2, keep-with-next
    136          void phy_send_scan_request ( unsigned char a_channel )
    137          {
    138          #ifdef _ENABLE_XBEE_API_
    139          	unsigned int XDATA uint_value;
    140          
    141          	// Change channel only if the currently used mask is different than requested
    142          	if ( phy_current_channel_ != a_channel )
    143          	{
    144          		// Set channel to listen too
    145          		uint_value = 1 << ( a_channel - CHANNEL_MASK_SHIFT );
    146          		api_send_at ( "SC", ( char* ) &uint_value, 2 );
    147          		phy_current_channel_ = a_channel;
    148          	}
    149          	// Start scan
    150          	uint_value = 0x0;
    151          	api_send_at ( "ED", ( char* ) &uint_value, 1 );
    152          #endif // _ENABLE_XBEE_API_
    153          }
   \                     phy_send_scan_request: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    154          
    155          
    156          
    157          /**
    158            * phy_send_scan_report() -
    159            */

   \                                 In section .text, align 2, keep-with-next
    160          void phy_send_scan_report()
    161          {
   \                     phy_send_scan_report: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    162          	unsigned char XDATA len = 7; // size of the packet header (start + flag + dst(2) + src(2) + len)
    163          	unsigned char XDATA msg_i;
    164          	pkt_t *pkt = ( pkt_t* ) packet;
    165          	uint8_t *msg;
    166          //	char *tmp;
    167          	unsigned char n_samples;
    168          //	unsigned int sample_value;
    169          
    170          	pkt->start = 66;
   \   00000002   0x....             LDR.N    R4,??DataTable6_2
   \   00000004   0x2042             MOVS     R0,#+66
   \   00000006   0x7020             STRB     R0,[R4, #+0]
    171          	pkt->flags = 0x0F;
    172          	pkt->mac_dst = 0xFFFF;
    173          	pkt->mac_src = MY_ADDR;
    174          
    175          	msg = & ( pkt->dst_id );
    176          
    177          	msg_i = 0;
    178          
    179          	// FILL END-TO-END ADDRESSING
    180          	msg[msg_i] = BS_ADDR;
   \   00000008   0x21FE             MOVS     R1,#+254
   \   0000000A   0x200F             MOVS     R0,#+15
   \   0000000C   0x7060             STRB     R0,[R4, #+1]
   \   0000000E   0x71E1             STRB     R1,[R4, #+7]
   \   00000010   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000014   0x8060             STRH     R0,[R4, #+2]
   \   00000016   0xB082             SUB      SP,SP,#+8
   \   00000018   0x....             LDR.N    R0,??DataTable6_3
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x80A0             STRH     R0,[R4, #+4]
    181          	msg[msg_i+1] = MY_ADDR;
   \   0000001E   0x7220             STRB     R0,[R4, #+8]
    182          
    183          	len = len + 2;
    184          	msg_i = msg_i + 2;
    185          
    186          
    187          // FILL THE REST OF 100byte packet (90 bytes of samples)
    188          	sprintf ( (char*)& ( msg[msg_i] ), "F=%d, B=%d, BO=%d\n", phy_count_free, phy_count_busy, phy_backoff_counter_ );
   \   00000020   0x....             LDR.N    R0,??DataTable6
   \   00000022   0x6941             LDR      R1,[R0, #+20]
   \   00000024   0x68C3             LDR      R3,[R0, #+12]
   \   00000026   0x6882             LDR      R2,[R0, #+8]
   \   00000028   0x9100             STR      R1,[SP, #+0]
   \   0000002A   0xF104 0x0009      ADD      R0,R4,#+9
   \   0000002E   0x.... 0x....      ADR.W    R1,?_0
   \   00000032   0x.... 0x....      BL       sprintf
    189          	n_samples = strlen ( (char*)& ( msg[msg_i] ) );
    190          	msg_i += n_samples;
   \   00000036   0xF104 0x0009      ADD      R0,R4,#+9
   \   0000003A   0x.... 0x....      BL       strlen
   \   0000003E   0x1C80             ADDS     R0,R0,#+2
   \   00000040   0xB2C0             UXTB     R0,R0
    191          	len += n_samples;
    192          
    193          	// FILL the CHECKSUM
    194          	// TODO: calculate checksum
    195          	msg[msg_i] = 65;
   \   00000042   0x1902             ADDS     R2,R0,R4
   \   00000044   0x2141             MOVS     R1,#+65
   \   00000046   0x71D1             STRB     R1,[R2, #+7]
    196          
    197          	len++;
    198          	msg_i++;
    199          
    200          	pkt->length = msg_i; // of the packet'd data
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x71A0             STRB     R0,[R4, #+6]
    201          
    202          #ifdef _ENABLE_XBEE_API_
    203          	// send the packet
    204          	api_send_packet16 ( packet, len, 0xFFFF );
    205          #endif // _ENABLE_XBEE_API_
    206          }
   \   0000004C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    207          
    208          
    209          /**
    210            * phy_start_tx_process() -
    211            */

   \                                 In section .text, align 2, keep-with-next
    212          void phy_start_tx_process()
    213          {
    214          	switch ( my_backoff_ )
   \                     phy_start_tx_process: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD000             BEQ.N    ??phy_start_tx_process_0
   \   00000008   0x4770             BX       LR
    215          	{
    216          		case PHY_BACKOFF_DISABLE:
    217          			phy_transmit_packet();
    218          			break;
    219          #ifdef FEAT_ENABLE_SFQ
    220          		case PHY_BACKOFF_ADFS:
    221          			{
    222          				// TODO: initiate Backoff timer and start scanning
    223          				unsigned int r = ( rand() % RND_DIFF );
    224          				// MZ_DFS begin
    225          				unsigned int temp_weight = Q_SFQ_get_total_weight();				
    226          				phy_backoff_counter_ =  ( PHY_BACKOFF_SF * 100 / temp_weight ) + r - ( RND_DIFF / 2 );
    227          				// MZ_DFS end
    228          				if ( ( 0 >= phy_backoff_counter_ ) || ( 0xF0 < phy_backoff_counter_ ) )
    229          					phy_backoff_counter_ = 1;
    230          				if ( MAX_BACKOFF <= phy_backoff_counter_ )
    231          					phy_backoff_counter_ = MAX_BACKOFF;
    232          				phy_send_scan_request ( DEFAULT_RF_CHANNEL );
    233          			}
    234          			break;
    235          #endif // FEAT_ENABLE_SFQ
    236          #ifdef INCLUDE_PCC
    237          		case PHY_BACKOFF_PCC:
    238          			{
    239          				// TODO: initiate Backoff timer and start scanning
    240          				/*				unsigned int r = ( rand() % RND_DIFF );
    241          								phy_backoff_counter_ =  ( PHY_BACKOFF_SF * 100 / my_weight_ ) + r - ( RND_DIFF / 2 );
    242          								if ( ( 0 >= phy_backoff_counter_ ) || ( 0xF0 < phy_backoff_counter_ ) )
    243          									phy_backoff_counter_ = 1;
    244          								if ( MAX_BACKOFF <= phy_backoff_counter_ )
    245          									phy_backoff_counter_ = MAX_BACKOFF;
    246          				*/
    247          //				phy_backoff_counter_ =  cc_bo_value_;
    248          				phy_backoff_timeout_ = rtc_get_ticks() + cc_bo_value_;
    249          				DATA_waiting_4_BO_ = 1;
    250          //				phy_send_scan_request ( DEFAULT_RF_CHANNEL );
    251          			}
    252          			break;
    253          		case PHY_BACKOFF_NO_PCC:
    254          			{
    255          				phy_backoff_timeout_ = rtc_get_ticks() + PCC_DEFAULT_BO_VALUE;
    256          				DATA_waiting_4_BO_ = 1;
    257          			}
    258          			break;
    259          #endif
    260          		case PHY_BACKOFF_EXPONENTIAL:
    261          			// TODO: initiate Backoff timer and start scanning
    262          			phy_backoff_counter_ =  1 + rand() % phy_cw_;
   \                     ??phy_start_tx_process_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x.... 0x....      BL       rand
   \   00000010   0x....             LDR.N    R1,??DataTable6
   \   00000012   0x698A             LDR      R2,[R1, #+24]
   \   00000014   0xFBB0 0xF3F2      UDIV     R3,R0,R2
   \   00000018   0xFB02 0x0013      MLS      R0,R2,R3,R0
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    263          			phy_send_scan_request ( DEFAULT_RF_CHANNEL );
    264          			if ( ( 0 >= phy_backoff_counter_ ) || ( 0xF0 < phy_backoff_counter_ ) )
   \   0000001E   0xD001             BEQ.N    ??phy_start_tx_process_1
   \   00000020   0x28F1             CMP      R0,#+241
   \   00000022   0xD300             BCC.N    ??phy_start_tx_process_2
    265          				phy_backoff_counter_ = 1;
   \                     ??phy_start_tx_process_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \                     ??phy_start_tx_process_2: (+1)
   \   00000026   0x6148             STR      R0,[R1, #+20]
    266          			if ( MAX_BACKOFF <= phy_backoff_counter_ )
   \   00000028   0x2832             CMP      R0,#+50
   \   0000002A   0xBF24             ITT      CS 
   \   0000002C   0x2032             MOVCS    R0,#+50
   \   0000002E   0x6148             STRCS    R0,[R1, #+20]
    267          				phy_backoff_counter_ = MAX_BACKOFF;
    268          			break;
    269          		default:
    270          			// ERROR
    271          			phy_transmit_packet();
    272          			break;
    273          	}
    274          #ifdef DEBUG_MODE
    275          	phy_send_scan_report();
    276          #endif
    277          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    278          
    279          
    280          
    281          #ifdef _ENABLE_XBEE_API_
    282          /**
    283            * phy_analyse_scan_response(pkt) -
    284            */
    285          void phy_analyse_scan_response ( api_frame_at_rsp_t* at_rsp )
    286          {
    287          	api_frame_at_rsp_one_t * at_rsp_one = ( api_frame_at_rsp_one_t* ) at_rsp;
    288          	if ( API_AT_STATUS_OK != at_rsp->api_at_status )
    289          	{
    290          		// failed to execute command -> ERROR
    291          		// TODO: handle AT command error
    292          	}
    293          
    294          	// DEBUG: print the packet via UART
    295          	//		api_send_packet16( pkt, 9, 0xFFFF);
    296          
    297          	// Check if channel is Free or Busy
    298          	if ( phy_busyThreshold_ > ( at_rsp_one->value ) )
    299          	{
    300          		// Channel is BUSY!!!! because the values are
    301          		//    absolut values of negative dBm signal strength
    302          		// TODO: handle busy channel
    303          		phy_count_busy++;
    304          	}
    305          	else
    306          	{
    307          		// Channel is FREE!!!! because the values are
    308          		//    absolut values of negative dBm signal strength
    309          		// TODO: handle free channel
    310          		phy_count_free++;
    311          
    312          		if ( 0 < phy_backoff_counter_ )
    313          		{
    314          			phy_backoff_counter_--;
    315          			if ( 0 == phy_backoff_counter_ )
    316          			{
    317          				// backoff elapsed -> transmit packet
    318          				phy_transmit_packet();
    319          			}
    320          //		} else {
    321          			// phy_backoff_counter_ less or equal to '0'
    322          //			phy_transmit_packet();
    323          		}
    324          	}
    325          
    326          //#ifdef DEBUG_MODE
    327          //	if (((phy_count_free + phy_count_busy) % 12) > 10)
    328          //		phy_send_scan_report();
    329          //#endif
    330          
    331          	// Send next SCAN request and timestamp this event
    332          	if ( 0 < phy_backoff_counter_ )
    333          	{
    334          		phy_send_scan_request ( DEFAULT_RF_CHANNEL );
    335          		phy_scanTimestamp_ = rtc_get_ticks();
    336          	}
    337          }
    338          #endif // _ENABLE_XBEE_API_
    339          
    340          
    341          /**
    342            * phy_transmit_packet() -
    343            */

   \                                 In section .text, align 2, keep-with-next
    344          void phy_transmit_packet()
    345          {
    346          	if ( ( 0 != pkt_to_sent_len ) && ( 0xFF != pkt_to_sent_id ) )
    347          	{
    348          //		if (1 == app_send_data)
    349          		{
    350          #ifdef _ENABLE_XBEE_API_
    351          			unsigned int base = QBUFF_BASE ( pkt_to_sent_id );
    352          			unsigned int mac_d = get_dst_mac_base ( base );
    353          			if ( /*(MAC_BROADCAST == mac_d) || */(BS_ADDR == mac_d) )
    354          			{
    355          				mac_d = BS_ADDR;
    356          			}
    357          			api_send_packet16_base ( pkt_to_sent_id, pkt_to_sent_len, mac_d );
    358          //			api_send_packet16_base ( pkt_to_sent_id, pkt_to_sent_len, 0xFFFF);
    359          			sent_DATA_ = 1;
    360          			phy_sent_timeout_ = rtc_get_ticks() + my_tx_timeout_;
    361          #endif // _ENABLE_XBEE_API_
    362          		}
    363          	}
    364          	// Make sure that all elements are cleaned!!
    365          //	pkt_to_sent_id = 0xFF;
    366          //	pkt_to_sent_len = 0;
    367          }
   \                     phy_transmit_packet: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .data, align 4
   \                     phy_busyThreshold_:
   \   00000000   0x00               DC8 0
   \                     phy_current_channel_:
   \   00000001   0x00               DC8 0
   \                     my_rf_channel_:
   \   00000002   0x00               DC8 0
   \                     my_tx_power_:
   \   00000003   0x00               DC8 0
   \                     current_tx_power_:
   \   00000004   0x00               DC8 0
    368          
    369          
    370          
    371          int8_t actual_power = 100;
   \                     actual_power:
   \   00000005   0x64               DC8 100
    372          StStatus result=0;
   \                     result:
   \   00000006   0x00               DC8 0
   \   00000007   0x00               DC8 0
   \                     phy_count_free:
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     phy_count_busy:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     phy_scanTimestamp_:
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     phy_backoff_counter_:
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     phy_cw_:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     phy_sent_timeout_:
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    373          ///////////////////////////////////////////////
    374          /**
    375            * phy_set_power_level(power) - switch an RF TX power the node is using
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          void phy_set_power_level ( unsigned char new_power_level )
    378          {
   \                     phy_set_power_level: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    379          	//Set the Power on the Radio Module
    380          	current_tx_power_ = new_power_level;  // This line is bad....
   \   00000002   0x....             LDR.N    R4,??DataTable6
    381          	stradio_power_ = -37+(10*new_power_level);
   \   00000004   0x....             LDR.N    R1,??DataTable6_4
   \   00000006   0x7120             STRB     R0,[R4, #+4]
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x4350             MULS     R0,R2,R0
   \   0000000C   0x3825             SUBS     R0,R0,#+37
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    382          	result = ST_RadioSetPower(stradio_power_);
   \   00000010   0xF991 0x0000      LDRSB    R0,[R1, #+0]
   \   00000014   0x.... 0x....      BL       ST_RadioSetPower
   \   00000018   0x71A0             STRB     R0,[R4, #+6]
    383          	actual_power = ST_RadioGetPower();
   \   0000001A   0x.... 0x....      BL       ST_RadioGetPower
   \   0000001E   0x7160             STRB     R0,[R4, #+5]
    384          
    385          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    386          
    387          ///////////////////////////////////////////////
    388          
    389          /**
    390            * phy_set_RF_channel(channel) - switch an RF channel the node is using
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          void phy_set_RF_channel ( unsigned char a_channel )
    393          {
    394          	//Set the Channel on the Radio Module -- reset to DEFAULT_RF_CHANNEL
    395          	my_rf_channel_ = a_channel;
   \                     phy_set_RF_channel: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6
   \   00000002   0x7088             STRB     R0,[R1, #+2]
    396          	ST_RadioSetChannel(my_rf_channel_);
   \   00000004   0x.... 0x....      B.W      ST_RadioSetChannel
    397          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     phy_busyThreshold_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     my_backoff_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     packet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     my_addr8_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     stradio_power_

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x46 0x3D          DC8 "F=%d, B=%d, BO=%d\012"
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x42 0x3D    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x42 0x4F    
   \              0x3D 0x25    
   \              0x64 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0
    398          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   phy_change_backoff
       0   phy_init_scan_params
      16   phy_send_scan_report
        16   -> sprintf
        16   -> strlen
       0   phy_send_scan_request
       0   phy_set_RF_channel
         0   -> ST_RadioSetChannel
       8   phy_set_power_level
         8   -> ST_RadioGetPower
         8   -> ST_RadioSetPower
       8   phy_start_tx_process
         8   -> rand
       0   phy_transmit_packet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
      20  ?_0
      32  phy_busyThreshold_
          phy_current_channel_
          my_rf_channel_
          my_tx_power_
          current_tx_power_
          actual_power
          result
          phy_count_free
          phy_count_busy
          phy_scanTimestamp_
          phy_backoff_counter_
          phy_cw_
          phy_sent_timeout_
      12  phy_change_backoff
      40  phy_init_scan_params
      78  phy_send_scan_report
       2  phy_send_scan_request
       8  phy_set_RF_channel
      34  phy_set_power_level
      50  phy_start_tx_process
       2  phy_transmit_packet

 
  32 bytes in section .data
 266 bytes in section .text
 
 266 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
