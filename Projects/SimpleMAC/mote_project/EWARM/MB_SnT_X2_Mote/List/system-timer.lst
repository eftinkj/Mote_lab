###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:30:50
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\system-timer.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\system-timer.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"system-timer.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\system-timer.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\system-timer.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\system-timer.c
      1          /**
      2            ******************************************************************************
      3            * @file    system-timer.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012 
      7            * @brief   STM32W108 System Timer HAL functions.
      8            * @verbatim
      9            *
     10           ===============================================================================
     11                                        ##### Note #####
     12           ===============================================================================
     13            * The Sleep Timer count and compare registers are only 16 bits, but
     14            * the counter and comparators themselves are actually 32bits.  To deal with
     15            * this, there are High ("H") and Low ("L") registers.  The High register is
     16            * the "action" register.  When working with SLEEPTMR_CNT, reading the "H"
     17            * register will return the upper 16 bits and simultaneously trigger the
     18            * capture of the lower 16bits in the "L" register.  The "L" register may then
     19            * be read.  When working with the SLEEPTMR_CMP registers, writing "L" will
     20            * set a shadow register.  Writing "H" will cause the value from the "H" write
     21            * and the "L" shadow register to be combined and simultaneously loaded into
     22            * the true 32bit comparator.
     23          
     24          
     25              @endverbatim
     26            ******************************************************************************
     27            * @attention
     28            *
     29            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     30            *
     31            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     32            * You may not use this file except in compliance with the License.
     33            * You may obtain a copy of the License at:
     34            *
     35            *        http://www.st.com/software_license_agreement_liberty_v2
     36            *
     37            * Unless required by applicable law or agreed to in writing, software 
     38            * distributed under the License is distributed on an "AS IS" BASIS, 
     39            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     40            * See the License for the specific language governing permissions and
     41            * limitations under the License.
     42            *
     43            ******************************************************************************
     44            */
     45          
     46          /* Includes ------------------------------------------------------------------*/
     47          #include PLATFORM_HEADER
     48          #include "error.h"
     49          #include "micro-common.h"
     50          #include "system-timer.h"
     51          
     52          /** @addtogroup HAL
     53            * @{
     54            */
     55          
     56          /** @defgroup system-timer
     57            * @brief system-timer modules
     58            * @{
     59            */
     60          
     61          /* Private define ------------------------------------------------------------*/
     62          #define CONVERT_QS_TO_TICKS(x) ((x) << 8)
     63          #define CONVERT_TICKS_TO_QS(x) ((x) >> 8)
     64          #define TIMER_MAX_QS           0x1000000 /* = 4194304 seconds * 4 = 16777216 */
     65          
     66          /* Private typedef -----------------------------------------------------------*/
     67          /* Private macros ------------------------------------------------------------*/
     68          /* Private variables ---------------------------------------------------------*/
     69          
     70          /* A simple flag used by internalSleepForQs to check that it has exited
     71             from sleep mode at the request of the expected timer interrupt. */

   \                                 In section .bss, align 4
     72          static boolean sleepTimerInterruptOccurred = FALSE;
   \                     sleepTimerInterruptOccurred:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
     73          
     74          /* sleepTmrArtificalCnt is the value expected for the SLEEPTMR_CNT if
     75             internalSleepForQs completed successfully due to a timer wakeup.  This
     76             is the value artifically returned when forceSleepTmrCnt is TRUE. */
     77          uint32_t sleepTmrArtificalCnt = 0;
   \                     sleepTmrArtificalCnt:
   \   00000004                      DS8 4
     78          
     79          /* forceSleepTmrCnt is a flag indicating that the system timer module
     80             should force a fake value for SLEEPTMR_CNT whenever the timer is
     81             accessed.  For FogBugz 11909/11920 workaround. */
     82          extern boolean forceSleepTmrCnt;
     83          
     84          /* wakeupSleepTmrCnt is a capturing of the SLEEPTMR_CNT immediately upon
     85             waking up from deep sleep.  This value is used to know when the counter
     86             has ticked forward.  For FogBugz 11909/11920 workaround. */
     87          extern uint32_t wakeupSleepTmrCnt;
     88          
     89          /* Private function prototypes -----------------------------------------------*/
     90          /* Private functions ---------------------------------------------------------*/
     91          
     92          /** @defgroup  system-timer_Private_Functions
     93            * @{
     94            */
     95          
     96          /**
     97            * @brief  Return a 16 bit real time clock value. 
     98            * @param  None
     99            * @retval 16 bit real time clock value
    100            * @note   With 1024 clock ticks per second,
    101            *         a single clock tick occurs every 0.9769625 milliseconds, and a rollover
    102            *         of the 16-bit timer occurs every 64 seconds.
    103            */

   \                                 In section .text, align 2, keep-with-next
    104          uint16_t halCommonGetInt16uMillisecondTick(void)
    105          {
   \                     halCommonGetInt16uMillisecondTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    106            return (uint16_t)halCommonGetInt32uMillisecondTick();
   \   00000002   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    107          }
    108          
    109          /**
    110            * @brief  Return a 16 bit real time clock value. 
    111            * @param  None
    112            * @retval 16 bit real time clock value
    113            */

   \                                 In section .text, align 2, keep-with-next
    114          uint16_t halCommonGetInt16uQuarterSecondTick(void)
    115          {
   \                     halCommonGetInt16uQuarterSecondTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    116            return (uint16_t)(halCommonGetInt32uMillisecondTick() >> 8);
   \   00000002   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000006   0x0200             LSLS     R0,R0,#+8
   \   00000008   0x0C00             LSRS     R0,R0,#+16
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    117          }
    118          
    119          /**
    120            * @brief  Return a 32 bit real time clock value. 
    121            * @param  None
    122            * @retval 32 bit real time clock value
    123            * @note   With 1024 clock ticks per second,
    124            *         a single clock tick occurs every 0.9769625 milliseconds, and a rollover
    125            *         of the 32-bit timer occurs approximately every 48.5 days.
    126            */

   \                                 In section .text, align 2, keep-with-next
    127          uint32_t halCommonGetInt32uMillisecondTick(void)
    128          {
    129            uint32_t currentTime;
    130            currentTime = SLPTMR->CNTH<<16;
   \                     halCommonGetInt32uMillisecondTick: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0x40006010
   \   00000002   0x6801             LDR      R1,[R0, #+0]
    131            currentTime |= SLPTMR->CNTL;
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
    132            
    133          /* forceSleepTmrCnt is set in halInternalSleep instead of performing
    134             the delay.  When we slept for exactly the correct amount of time
    135             we know what the time is supposed to be.  So, as long as the timer
    136             counter is still stuck on a stale value, we can return the
    137             value it should be (according to halSleepForQuarterSeconds). */
    138            if(forceSleepTmrCnt && (currentTime == wakeupSleepTmrCnt)) 
   \   0000000A   0x....             LDR.N    R1,??DataTable4_1
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0xB132             CBZ.N    R2,??halCommonGetInt32uMillisecondTick_0
   \   00000010   0x....             LDR.N    R2,??DataTable4_2
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x4290             CMP      R0,R2
   \   00000016   0xD102             BNE.N    ??halCommonGetInt32uMillisecondTick_0
    139            {
    140              return sleepTmrArtificalCnt;
   \   00000018   0x....             LDR.N    R0,??DataTable4_3
   \   0000001A   0x6840             LDR      R0,[R0, #+4]
   \   0000001C   0x4770             BX       LR
    141            }
    142            forceSleepTmrCnt = FALSE;
   \                     ??halCommonGetInt32uMillisecondTick_0: (+1)
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x700A             STRB     R2,[R1, #+0]
    143            
    144            return currentTime;
   \   00000022   0x4770             BX       LR               ;; return
    145          }
    146          
    147          /**
    148            * @brief  Sleep the ISR Timer
    149            * @param  None
    150            * @retval None
    151            */

   \                                 In section .text, align 2, keep-with-next
    152          void halSleepTimerIsr(void)
    153          {
    154            /* clear the second level interrupts */
    155            SLPTMR->ISR = SLPTMR_IER_WRAP | SLPTMR_IER_CMPA | SLPTMR_IER_CMPB;
   \                     halSleepTimerIsr: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_4  ;; 0x4000a014
   \   00000002   0x2007             MOVS     R0,#+7
   \   00000004   0x6008             STR      R0,[R1, #+0]
    156            
    157            /* mark a sleep timer interrupt as having occurred */
    158            sleepTimerInterruptOccurred = TRUE;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable4_3
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    159          }
   \   0000000C   0x4770             BX       LR               ;; return
    160          
    161          /**
    162            * @brief  Sleep for specific time
    163            * @param  boolean value of use Gpio Wake Mask
    164            * @param  Duration
    165            * @param  The value of the Gpio Wake Mask
    166            * @retval ST status
    167            */

   \                                 In section .text, align 2, keep-with-next
    168          static StStatus internalSleepForQs(boolean useGpioWakeMask, uint32_t *duration, uint32_t gpioWakeBitMask)
    169          {
   \                     internalSleepForQs: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0xB083             SUB      SP,SP,#+12
    170            StStatus status = ST_SUCCESS;
    171            uint32_t sleepOverflowCount;
    172            uint32_t remainder;
    173            uint32_t startCount;
    174            
    175            /* There is really no reason to bother with a duration of 0qs */
    176            if(*duration==0)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xB910             CBNZ.N   R0,??internalSleepForQs_0
    177            {
    178              INTERRUPTS_ON();
   \   00000010   0xF380 0x8811      MSR      BASEPRI,R0
    179              return status;
   \   00000014   0xE044             B.N      ??internalSleepForQs_1
    180            }
    181            
    182            ATOMIC(
    183                   /* disable top-level interrupt while configuring */
    184                   NVIC->ICER[0] = NVIC_IxxR_SLEEPTMR;
    185                   
    186                 /* Our tick is calibrated to 1024Hz, giving a tick of 976.6us and an
    187                    overflow of 4194304.0 seconds.  Calculate the number of sleep overflows
    188                    in the duration */
    189                   sleepOverflowCount = (*duration)/TIMER_MAX_QS;
    190                   /* calculate the remaining ticks */
    191                   remainder = CONVERT_QS_TO_TICKS((*duration)%TIMER_MAX_QS);
    192                   /* grab the starting sleep count */
    193                   startCount = halCommonGetInt32uMillisecondTick();
    194                   
    195                   sleepTimerInterruptOccurred = FALSE;
    196                   
    197                   if(remainder) 
    198                   {
    199                     /* set CMPA value */
    200                     SLPTMR->CMPAL = (startCount+remainder)&0xFFFF;
    201                     SLPTMR->CMPAH = ((startCount+remainder)>>16)&0xFFFF;
    202                     /* clear any stale interrupt flag and set the CMPA interrupt */
    203                     SLPTMR->ISR = SLPTMR_IER_CMPA;
    204                     SLPTMR->IER = SLPTMR_IER_CMPA;
    205                   }
    206                   if(sleepOverflowCount) 
    207                   {
    208                     /* set CMPB value */
    209                     SLPTMR->CMPBL = startCount&0xFFFF;
    210                     SLPTMR->CMPBH = (startCount>>16)&0xFFFF;
    211                   /* clear any stale interrupt flag and set the CMPB interrupt
    212                      this will also disable the CMPA interrupt, since we only want to wake
    213                      on overflows, not the remainder yet */
    214                     SLPTMR->ISR = SLPTMR_IER_CMPB;
    215                     SLPTMR->IER = SLPTMR_IER_CMPB;
    216                   }
    217                   
    218                   /* enable top-level interrupt */
    219                   NVIC->ISER[0] = NVIC_IxxR_SLEEPTMR;
    220                   )
   \                     ??internalSleepForQs_0: (+1)
   \   00000016   0xF3EF 0x8B11      MRS      R11,BASEPRI
   \   0000001A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x0E05             LSRS     R5,R0,#+24
   \   00000022   0x0200             LSLS     R0,R0,#+8
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000002A   0x4681             MOV      R9,R0
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0x.... 0x....      LDR.W    R10,??DataTable4_3
   \   00000032   0x....             LDR.N    R7,??DataTable4_4  ;; 0x4000a014
   \   00000034   0x9901             LDR      R1,[SP, #+4]
   \   00000036   0xF88A 0x6000      STRB     R6,[R10, #+0]
   \   0000003A   0x4448             ADD      R0,R0,R9
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0x....             LDR.N    R0,??DataTable4_5  ;; 0x40006018
   \   00000040   0xB141             CBZ.N    R1,??internalSleepForQs_2
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0xB289             UXTH     R1,R1
   \   00000046   0x6041             STR      R1,[R0, #+4]
   \   00000048   0x9900             LDR      R1,[SP, #+0]
   \   0000004A   0x0C09             LSRS     R1,R1,#+16
   \   0000004C   0x6001             STR      R1,[R0, #+0]
   \   0000004E   0x2102             MOVS     R1,#+2
   \   00000050   0x6039             STR      R1,[R7, #+0]
   \   00000052   0x6439             STR      R1,[R7, #+64]
   \                     ??internalSleepForQs_2: (+1)
   \   00000054   0xB145             CBZ.N    R5,??internalSleepForQs_3
   \   00000056   0xFA1F 0xF189      UXTH     R1,R9
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
   \   0000005C   0xEA4F 0x4119      LSR      R1,R9,#+16
   \   00000060   0x6081             STR      R1,[R0, #+8]
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0x6038             STR      R0,[R7, #+0]
   \   00000066   0x6438             STR      R0,[R7, #+64]
   \                     ??internalSleepForQs_3: (+1)
   \   00000068   0x2010             MOVS     R0,#+16
   \   0000006A   0x....             LDR.N    R1,??DataTable4_6  ;; 0xe000e100
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \   0000006E   0xFA5F 0xF08B      UXTB     R0,R11
   \   00000072   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000076   0xE021             B.N      ??internalSleepForQs_4
    221              
    222              while(*duration > 0)
    223              {
    224              /* Record what the SLEEPTMR_CNT is supposed to be when waking up
    225                 after a timed sleep.  halInternalSleep is responsible for setting
    226                 the forceSleepTmrCnt flag. */
    227                if(SLPTMR->IER&SLPTMR_IER_CMPB)
    228                {
    229                  /* use the value written into SLEEPTMR_CMPB */
    230                  sleepTmrArtificalCnt = startCount;
    231                } 
    232                else 
    233                { /* SLPTMR->IER&SLPTMR_IER_CMPA */
    234                  /* use the value written into SLEEPTMR_CMPA */
    235                  sleepTmrArtificalCnt = (startCount+remainder);
   \                     ??internalSleepForQs_5: (+1)
   \   00000078   0xF8CA 0x0004      STR      R0,[R10, #+4]
    236                }
    237                
    238                halSleepWithOptions(SLEEPMODE_WAKETIMER, gpioWakeBitMask);
   \   0000007C   0x4641             MOV      R1,R8
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x.... 0x....      BL       halSleepWithOptions
    239                
    240                SLPTMR->IER = 0x00; /* disable all SleepTMR interrupts */
   \   00000084   0x643E             STR      R6,[R7, #+64]
    241                
    242              /* If we didn't come out of sleep via a compare or overflow interrupt,
    243                 it was an abnormal sleep interruption; report the event. */
    244                if(!sleepTimerInterruptOccurred) 
   \   00000086   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000008A   0xB958             CBNZ.N   R0,??internalSleepForQs_6
    245                {
    246                  status = ST_SLEEP_INTERRUPTED;
   \   0000008C   0x2685             MOVS     R6,#+133
    247                /* Update duration to account for how long last sleep was.  Using the
    248                   startCount variable is always valid because full timer wraps always
    249                   return to this value and the remainder is an offset from this value.
    250                   And since the duration is always reduced after each full timer wrap,
    251                   we only need to calculate the final duration here. */
    252                  *duration -= CONVERT_TICKS_TO_QS(halCommonGetInt32uMillisecondTick() -
    253                                                   startCount);
   \   0000008E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000098   0xEBA1 0x2010      SUB      R0,R1,R0, LSR #+8
   \   0000009C   0x6020             STR      R0,[R4, #+0]
    254                  break;
    255                } else
    256                {
    257                  if(sleepOverflowCount) 
    258                  {
    259                    sleepOverflowCount--;
    260                    *duration -= TIMER_MAX_QS;
    261                  } else 
    262                  {
    263                    *duration -= CONVERT_TICKS_TO_QS(remainder);
    264                  }
    265                  sleepTimerInterruptOccurred = FALSE;
    266                  if(sleepOverflowCount) 
    267                  {
    268                    /* enable sleeping for a full timer wrap */
    269                    SLPTMR->ISR = SLPTMR_IER_CMPB;
    270                    SLPTMR->IER = SLPTMR_IER_CMPB;
    271                  } else if(!sleepOverflowCount && (*duration>0))
    272                  {
    273                    /* enable sleeping for the remainder */
    274                    SLPTMR->ISR = SLPTMR_IER_CMPA;
    275                    SLPTMR->IER = SLPTMR_IER_CMPA;
    276                  }
    277                }
    278              }
    279            
    280            return status;
   \                     ??internalSleepForQs_7: (+1)
   \   0000009E   0x4630             MOV      R0,R6
   \                     ??internalSleepForQs_1: (+1)
   \   000000A0   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \                     ??internalSleepForQs_6: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0xB195             CBZ.N    R5,??internalSleepForQs_8
   \   000000A8   0xF1A0 0x7080      SUB      R0,R0,#+16777216
   \   000000AC   0x1E6D             SUBS     R5,R5,#+1
   \   000000AE   0x6020             STR      R0,[R4, #+0]
   \   000000B0   0xF88A 0x6000      STRB     R6,[R10, #+0]
   \   000000B4   0xD011             BEQ.N    ??internalSleepForQs_9
   \   000000B6   0x2004             MOVS     R0,#+4
   \                     ??internalSleepForQs_10: (+1)
   \   000000B8   0x6038             STR      R0,[R7, #+0]
   \   000000BA   0x6438             STR      R0,[R7, #+64]
   \                     ??internalSleepForQs_4: (+1)
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD0ED             BEQ.N    ??internalSleepForQs_7
   \   000000C2   0x6C38             LDR      R0,[R7, #+64]
   \   000000C4   0x0740             LSLS     R0,R0,#+29
   \   000000C6   0xBF4C             ITE      MI 
   \   000000C8   0x4648             MOVMI    R0,R9
   \   000000CA   0x9800             LDRPL    R0,[SP, #+0]
   \   000000CC   0xE7D4             B.N      ??internalSleepForQs_5
   \                     ??internalSleepForQs_8: (+1)
   \   000000CE   0x9901             LDR      R1,[SP, #+4]
   \   000000D0   0xEBA0 0x2011      SUB      R0,R0,R1, LSR #+8
   \   000000D4   0x6020             STR      R0,[R4, #+0]
   \   000000D6   0xF88A 0x6000      STRB     R6,[R10, #+0]
   \                     ??internalSleepForQs_9: (+1)
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xBF18             IT       NE 
   \   000000E0   0x2002             MOVNE    R0,#+2
   \   000000E2   0xD1E9             BNE.N    ??internalSleepForQs_10
   \   000000E4   0xE7DB             B.N      ??internalSleepForQs_7
    281          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2060             MOVS     R0,#+96
   \   00000002   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000006   0x....             LDR.N    R1,??DataTable4_7  ;; 0xe000e180
   \   00000008   0x2010             MOVS     R0,#+16
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   \   0000000C   0x4770             BX       LR
    282          
    283          /**
    284            * @brief  Sleep for Milliseconds
    285            * @param  boolean value of use Gpio Wake Mask
    286            * @param  Duration
    287            * @param  The value of the Gpio Wake Mask
    288            * @retval ST status
    289            */
    290          static StStatus internalSleepForMilliseconds(boolean useGpioWakeMask, uint32_t *duration, uint32_t gpioWakeBitMask)
    291          {
    292            StStatus status = ST_SUCCESS;
    293            uint32_t startCount;
    294            
    295            /* There is really no reason to bother with a duration of 0 ms */
    296            if(*duration==0) 
    297            {
    298              INTERRUPTS_ON();
    299              return status;
    300            }
    301            
    302            ATOMIC(
    303                   /* disable top-level interrupt while configuring */
    304                   NVIC->ICER[0] = NVIC_IxxR_SLEEPTMR;
    305                   
    306                   /* Our tick is calibrated to 1024Hz, giving a tick of 976.6us and an
    307                    * overflow of 4194304.0 seconds.  As a result, our seconds are comprised of
    308                    * 1024 "milliseconds". */
    309                   
    310                   /* grab the starting sleep count */
    311                   startCount = halCommonGetInt32uMillisecondTick();
    312                   sleepTimerInterruptOccurred = FALSE;
    313                   /* set CMPA value */
    314                   SLPTMR->CMPAL = (startCount + *duration) & 0xFFFF;
    315                   SLPTMR->CMPAH = ((startCount + *duration) >> 16) & 0xFFFF;
    316                   /* clear any stale interrupt flag and set the CMPA interrupt */
    317                   SLPTMR->ISR = SLPTMR_IER_CMPA;
    318                   SLPTMR->IER = SLPTMR_IER_CMPA;
    319                   /* enable top-level interrupt */
    320                   NVIC->ISER[0] = NVIC_IxxR_SLEEPTMR;
    321                   )
    322              
    323              while(*duration > 0) 
    324              {
    325                /* Record what the SLEEPTMR_CNT is supposed to be when waking up
    326                 * after a timed sleep.  halInternalSleep is responsible for setting
    327                 * the forceSleepTmrCnt flag. */
    328                sleepTmrArtificalCnt = (startCount + *duration);
    329                
    330                halSleepWithOptions(SLEEPMODE_WAKETIMER, gpioWakeBitMask);
    331                
    332                SLPTMR->IER = 0x00; /* disable all SleepTMR interrupts */
    333                
    334                /* If we didn't come out of sleep via a compare or overflow interrupt,
    335                 * it was an abnormal sleep interruption; report the event. */
    336                if(!sleepTimerInterruptOccurred) 
    337                {
    338                  status = ST_SLEEP_INTERRUPTED;
    339                  /* Update duration to account for how long last sleep was.  Using the
    340                   * startCount variable is valid because full timer wraps do not occur
    341                   * in this function. */
    342                  *duration -= halCommonGetInt32uMillisecondTick() - startCount;
    343                  break;
    344                } else
    345                {
    346                  /* We have completed the full sleep cycle uninterrupted, set duration to 0
    347                   * so we exit the function */
    348                  *duration = 0;
    349                  sleepTimerInterruptOccurred = FALSE;
    350                }
    351              }
    352            
    353            return status;
    354          }
    355          
    356          /**
    357            * @brief  Uses the system timer to enter SLEEPMODE_WAKETIMER 
    358            *         for approximately the specified amount of time 
    359            * @param  duration
    360            * @param  gpio wake bit mask
    361            * @retval None
    362            */

   \                                 In section .text, align 2, keep-with-next
    363          StStatus halSleepForQsWithOptions(uint32_t *duration, uint32_t gpioWakeBitMask)
    364          {
    365            return internalSleepForQs(TRUE, duration, gpioWakeBitMask);
   \                     halSleepForQsWithOptions: (+1)
   \   00000000   0x460A             MOV      R2,R1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x....             B.N      internalSleepForQs
    366          }
    367          
    368          /**
    369            * @brief  Uses the system timer to enter SLEEPMODE_WAKETIMER 
    370            *         for approximately the specified amount of time 
    371            * @param  duration
    372            * @param  gpio wake bit mask
    373            * @retval None
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          StStatus halSleepForMillisecondsWithOptions(uint32_t *duration, uint32_t gpioWakeBitMask)
    376          {
   \                     halSleepForMillisecondsWithOptions: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
    377            return internalSleepForMilliseconds(TRUE, duration, gpioWakeBitMask);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0xB910             CBNZ.N   R0,??halSleepForMillisecondsWithOptions_0
   \   0000000E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000012   0xE032             B.N      ??halSleepForMillisecondsWithOptions_1
   \                     ??halSleepForMillisecondsWithOptions_0: (+1)
   \   00000014   0xF3EF 0x8911      MRS      R9,BASEPRI
   \   00000018   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000001C   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000020   0x4682             MOV      R10,R0
   \   00000022   0x....             LDR.N    R5,??DataTable4_3
   \   00000024   0x....             LDR.N    R0,??DataTable4_5  ;; 0x40006018
   \   00000026   0x....             LDR.N    R7,??DataTable4_4  ;; 0x4000a014
   \   00000028   0x702E             STRB     R6,[R5, #+0]
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x4451             ADD      R1,R1,R10
   \   0000002E   0xB289             UXTH     R1,R1
   \   00000030   0x6041             STR      R1,[R0, #+4]
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x4451             ADD      R1,R1,R10
   \   00000036   0x0C09             LSRS     R1,R1,#+16
   \   00000038   0x6001             STR      R1,[R0, #+0]
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x6038             STR      R0,[R7, #+0]
   \   0000003E   0x6438             STR      R0,[R7, #+64]
   \   00000040   0x2010             MOVS     R0,#+16
   \   00000042   0x....             LDR.N    R1,??DataTable4_6  ;; 0xe000e100
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xFA5F 0xF089      UXTB     R0,R9
   \   0000004A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000004E   0xE001             B.N      ??halSleepForMillisecondsWithOptions_2
   \                     ??halSleepForMillisecondsWithOptions_3: (+1)
   \   00000050   0x6026             STR      R6,[R4, #+0]
   \   00000052   0x702E             STRB     R6,[R5, #+0]
   \                     ??halSleepForMillisecondsWithOptions_2: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0xB180             CBZ.N    R0,??halSleepForMillisecondsWithOptions_1
   \   00000058   0x4450             ADD      R0,R0,R10
   \   0000005A   0x6068             STR      R0,[R5, #+4]
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x.... 0x....      BL       halSleepWithOptions
   \   00000064   0x643E             STR      R6,[R7, #+64]
   \   00000066   0x7828             LDRB     R0,[R5, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1F1             BNE.N    ??halSleepForMillisecondsWithOptions_3
   \   0000006C   0x2685             MOVS     R6,#+133
   \   0000006E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x1A08             SUBS     R0,R1,R0
   \   00000076   0x4450             ADD      R0,R10,R0
   \   00000078   0x6020             STR      R0,[R4, #+0]
   \                     ??halSleepForMillisecondsWithOptions_1: (+1)
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    378          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40006010         DC32     0x40006010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     forceSleepTmrCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     wakeupSleepTmrCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     sleepTimerInterruptOccurred

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x4000A014         DC32     0x4000a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40006018         DC32     0x40006018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0xE000E180         DC32     0xe000e180
    379          
    380          
    381          /**
    382            * @}
    383            */
    384          
    385          /**
    386            * @}
    387            */ 
    388          
    389          /**
    390            * @}
    391            */
    392          
    393          
    394          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   halCommonGetInt16uMillisecondTick
         8   -> halCommonGetInt32uMillisecondTick
       8   halCommonGetInt16uQuarterSecondTick
         8   -> halCommonGetInt32uMillisecondTick
       0   halCommonGetInt32uMillisecondTick
      32   halSleepForMillisecondsWithOptions
        32   -> halCommonGetInt32uMillisecondTick
        32   -> halSleepWithOptions
       0   halSleepForQsWithOptions
         0   -> internalSleepForQs
       0   halSleepTimerIsr
      48   internalSleepForQs
        48   -> halCommonGetInt32uMillisecondTick
        48   -> halSleepWithOptions


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
      14  ?Subroutine0
      10  halCommonGetInt16uMillisecondTick
      12  halCommonGetInt16uQuarterSecondTick
      36  halCommonGetInt32uMillisecondTick
     128  halSleepForMillisecondsWithOptions
       8  halSleepForQsWithOptions
      14  halSleepTimerIsr
     230  internalSleepForQs
       8  sleepTimerInterruptOccurred
          sleepTmrArtificalCnt

 
   8 bytes in section .bss
 484 bytes in section .text
 
 484 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
