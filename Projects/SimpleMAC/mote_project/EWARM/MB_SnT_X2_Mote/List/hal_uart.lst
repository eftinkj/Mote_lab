###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:26:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_uart.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_uart.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"hal_uart.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\hal_uart.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\hal_uart.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012
      7            * @brief   STM32W  hal uart drivers, supporting IAR's standard library IO routines.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include PLATFORM_HEADER
     30          #include "micro-common.h"
     31          
     32          #include "hal_uart.h"
     33          #include "hal.h"
     34          #ifdef __GNUC__
     35          #include <sys/stat.h>
     36          #endif /* __GNUC__ */
     37          #ifndef __ICCARM__
     38          #include <stdio.h>
     39          #define _LLIO_STDIN ((int) stdin)
     40          #define _LLIO_STDOUT ((int) stdout)
     41          #define _LLIO_STDERR ((int) stderr)
     42          #define _LLIO_ERROR ((size_t)-1)
     43          #ifndef __GNUC__
     44          #define __write _write
     45          #define __read _read
     46          #endif
     47          #undef putchar
     48          void __io_putchar( char c );
     49          int putchar (int c)
     50          {
     51            __io_putchar((char) c);
     52            return c;
     53          }
     54          #endif /* __ICCARM__ */
     55          
     56          #ifdef __GNUC__
     57          /* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf
     58          set to 'Yes') calls __io_putchar() */
     59          #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
     60          #else
     61          #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
     62          #endif /* __GNUC__ */
     63          
     64          #ifdef __GNUC__
     65          /* With GCC/RAISONANCE, small scanf calls __io_getchar() */
     66          #define GETCHAR_PROTOTYPE int __io_getchar(void)
     67          #endif /* __GNUC__ */
     68          
     69          /** @addtogroup HAL
     70            * @{
     71            */
     72          
     73          /** @defgroup micro common
     74            * @brief micro common modules
     75            * @{
     76            */
     77          
     78          #define RECEIVE_QUEUE_SIZE (128)
     79          

   \                                 In section .bss, align 4
     80          uint8_t rxQ[RECEIVE_QUEUE_SIZE];
   \                     rxQ:
   \   00000000                      DS8 128

   \                                 In section .bss, align 2
     81          uint16_t rxHead;
   \                     rxHead:
   \   00000000                      DS8 2
     82          uint16_t rxTail;
   \                     rxTail:
   \   00000002                      DS8 2
     83          uint16_t rxUsed;
   \                     rxUsed:
   \   00000004                      DS8 2
     84          
     85          /** @defgroup  micro_Private_Functions
     86            * @{
     87            */
     88          
     89          /** @defgroup  UART_Initialization_Functions
     90            * @{
     91            */
     92          
     93          /**
     94            * @brief  high level uart configuration.
     95            * @param  None
     96            * @retval None
     97            */

   \                                 In section .text, align 2, keep-with-next
     98          void uartInit(void)
     99          {
   \                     uartInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    100            UART_InitTypeDef UART_InitStructure;
    101            
    102            /* UARTx configured as follow:
    103            - BaudRate = 115200 baud  
    104            - Word Length = 8 Bits
    105            - One Stop Bit
    106            - No parity
    107            - Hardware flow control disabled (RTS and CTS signals)
    108            */
    109            UART_InitStructure.UART_BaudRate = 115200;
   \   00000004   0xF44F 0x30E1      MOV      R0,#+115200
   \   00000008   0x9000             STR      R0,[SP, #+0]
    110            UART_InitStructure.UART_WordLength = UART_WordLength_8b;
    111            UART_InitStructure.UART_StopBits = UART_StopBits_1;
    112            UART_InitStructure.UART_Parity = UART_Parity_No;
    113            UART_InitStructure.UART_HardwareFlowControl = UART_HardwareFlowControl_Disable;
    114            STM_EVAL_COMInit(COM1, &UART_InitStructure);
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9002             STR      R0,[SP, #+8]
   \   00000014   0x9003             STR      R0,[SP, #+12]
   \   00000016   0x9004             STR      R0,[SP, #+16]
   \   00000018   0x.... 0x....      BL       STM_EVAL_COMInit
    115            
    116            /* Enable the SC1_Rx Receive interrupt: this interrupt is generated when the 
    117            UART receive in data register*/ 
    118            UART_TriggerEventConfig(SC1_IT, UART_IT_RXNE, SC_TriggerEvent_Level);
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x....             LDR.N    R4,??DataTable3  ;; 0x4000a808
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       UART_TriggerEventConfig
    119            UART_ITConfig(SC1_IT, UART_IT_PE | UART_IT_FE | UART_IT_OVR | UART_IT_RXNE, ENABLE);
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0xF246 0x0109      MOVW     R1,#+24585
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       UART_ITConfig
    120            
    121            
    122            SC1_IT->ISR = 0xFFFF; /* Clear any stale interrupts */
   \   00000034   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000038   0x6020             STR      R0,[R4, #+0]
    123            NVIC->ISER[0] = NVIC_IxxR_SC1;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0x....             LDR.N    R1,??DataTable3_1  ;; 0xe000e100
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    124          }
   \   00000040   0xB006             ADD      SP,SP,#+24
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    125          
    126          /**
    127            * @}
    128            */
    129          
    130          /** @defgroup  UART_Transmit_Functions
    131            * @{
    132            */
    133          
    134          /**
    135            * @brief  IAR Standard library hook for serial output
    136            * @param  handle
    137            * @param  buffer
    138            * @param  size buffer size.
    139            * @retval size_t
    140            */

   \                                 In section .text, align 2, keep-with-next
    141          size_t __write(int handle, const unsigned char * buffer, size_t size)
    142          {
    143            size_t nChars = 0;
   \                     __write: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0xB510             PUSH     {R4,LR}
    144          
    145            /* This template only writes to "standard out" and "standard err",
    146               for all other file handles it returns failure. */
    147            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR) {
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2802             CMPNE    R0,#+2
   \   0000000A   0xD109             BNE.N    ??__write_0
    148              return _LLIO_ERROR;
    149            }
    150          
    151            if (buffer == 0) {
   \   0000000C   0x....             LDR.N    R0,??DataTable3_2  ;; 0x4000c83c
   \   0000000E   0xB921             CBNZ.N   R1,??__write_1
    152              /* This means that we should flush internal buffers.  
    153                 spin until TX complete (TX is idle) */
    154              while ((SC1_UART->UARTSR&SC_UARTSR_IDLE)!=SC_UARTSR_IDLE) {}
   \                     ??__write_2: (+1)
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0x0649             LSLS     R1,R1,#+25
   \   00000014   0xD5FC             BPL.N    ??__write_2
    155              return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}
    156            }
    157            
    158            /* ensure port is configured for UART */
    159            if(SC1_UART->CR != SC_Mode_UART) {
   \                     ??__write_1: (+1)
   \   0000001A   0x6984             LDR      R4,[R0, #+24]
   \   0000001C   0x2C01             CMP      R4,#+1
   \   0000001E   0xD009             BEQ.N    ??__write_3
    160              return _LLIO_ERROR;
   \                     ??__write_0: (+1)
   \   00000020   0xF04F 0x30FF      MOV      R0,#-1
   \   00000024   0xBD10             POP      {R4,PC}
    161            }
    162          
    163            while(size--) {
    164              /* spin until data register has room for more data */
    165              while ((SC1_UART->UARTSR&SC_UARTSR_TXE)!=SC_UARTSR_TXE) {}
   \                     ??__write_4: (+1)
   \   00000026   0x68C4             LDR      R4,[R0, #+12]
   \   00000028   0x0764             LSLS     R4,R4,#+29
   \   0000002A   0xD5FC             BPL.N    ??__write_4
    166              SC1_UART->DR = *buffer;
   \   0000002C   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   00000030   0x6004             STR      R4,[R0, #+0]
    167              buffer++;
    168          
    169              ++nChars;
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
    170            }
   \                     ??__write_3: (+1)
   \   00000034   0x4614             MOV      R4,R2
   \   00000036   0x1E62             SUBS     R2,R4,#+1
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD1F4             BNE.N    ??__write_4
    171          
    172            return nChars;
   \   0000003C   0x4618             MOV      R0,R3
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    173          }
    174          
    175          /**
    176            * @brief flush file
    177            * @param file
    178            * @retval int
    179            */
    180          #if (defined (__GNUC__))
    181          int fflush (FILE *f)
    182           #elif (defined (__CC_ARM))
    183           int fflush (FILE *f)
    184          #elif (defined (__ICCARM__))

   \                                 In section .text, align 2, keep-with-next
    185          size_t fflush(int handle)
    186          #else
    187          #error "Add fflash for the appropriate compiler"
    188          #endif
    189          {
    190            return __write(_LLIO_STDOUT, NULL, 0);
   \                     fflush: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    191          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x....             B.N      __write
    192          /**
    193            * @brief UART Tx handler
    194            * @param None
    195            * @retval None
    196            */
    197          static void halInternalUart1TxIsr(void)
    198          {
    199            /* Nothing for now, as ouput is blocking from the __write function */
    200          }
    201          
    202          /**
    203            * @brief IO putchar prototype
    204            * @param c char to transmit
    205            * @retval None
    206            */

   \                                 In section .text, align 2, keep-with-next
    207          void __io_putchar( char c )
    208          {
   \                     __io_putchar: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    209            __write(_LLIO_STDOUT, (unsigned char *)&c, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       __write
    210          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    211          
    212          /**
    213            * @brief IO flush
    214            * @param None
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void __io_flush( void )
   \                     __io_flush: (+1)
   \   00000000   0xBF00             Nop      
    218          {
    219            __write(_LLIO_STDOUT, NULL, 0);
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    220          }
    221          
    222          /**
    223            * @}
    224            */
    225          
    226          /** @defgroup  UART_Receive_Functions
    227            * @{
    228            */
    229          
    230          /**
    231            * @brief  IAR Standard library hook for serial input
    232            * @param  handle
    233            * @param  buffer
    234            * @param  size buffer size.
    235            * @retval size_t
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          size_t __read(int handle, unsigned char * buffer, size_t size)
    238          {
   \                     __read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    239            int nChars = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    240          
    241            /* This template only reads from "standard in", for all other file
    242               handles it returns failure. */
    243            if (handle != _LLIO_STDIN)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable3_3
   \   00000008   0xD018             BEQ.N    ??__read_0
    244            {
    245              return _LLIO_ERROR;
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    246            }
    247          
    248            for(nChars = 0; (rxUsed>0) && (nChars < size); nChars++) {
    249              ATOMIC(
    250                *buffer++ = rxQ[rxTail];
    251                rxTail = (rxTail+1) % RECEIVE_QUEUE_SIZE;
    252                rxUsed--;
    253              )
   \                     ??__read_1: (+1)
   \   00000010   0xF3EF 0x8411      MRS      R4,BASEPRI
   \   00000014   0x2560             MOVS     R5,#+96
   \   00000016   0xF385 0x8811      MSR      BASEPRI,R5
   \   0000001A   0x8846             LDRH     R6,[R0, #+2]
   \   0000001C   0x....             LDR.N    R5,??DataTable3_4
   \   0000001E   0x5D75             LDRB     R5,[R6, R5]
   \   00000020   0xF801 0x5B01      STRB     R5,[R1], #+1
   \   00000024   0xB2E4             UXTB     R4,R4
   \   00000026   0x8845             LDRH     R5,[R0, #+2]
   \   00000028   0x1C6D             ADDS     R5,R5,#+1
   \   0000002A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000002E   0x8045             STRH     R5,[R0, #+2]
   \   00000030   0x8885             LDRH     R5,[R0, #+4]
   \   00000032   0x1E6D             SUBS     R5,R5,#+1
   \   00000034   0x8085             STRH     R5,[R0, #+4]
   \   00000036   0xF384 0x8811      MSR      BASEPRI,R4
    254            }
   \   0000003A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??__read_0: (+1)
   \   0000003C   0x8884             LDRH     R4,[R0, #+4]
   \   0000003E   0xB10C             CBZ.N    R4,??__read_2
   \   00000040   0x4293             CMP      R3,R2
   \   00000042   0xD3E5             BCC.N    ??__read_1
    255          
    256            return nChars;
   \                     ??__read_2: (+1)
   \   00000044   0x4618             MOV      R0,R3
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    257          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x11AE             ASRS     R6,R5,#+6
   \   00000002   0xEB05 0x6656      ADD      R6,R5,R6, LSR #+25
   \   00000006   0x11F6             ASRS     R6,R6,#+7
   \   00000008   0xEBA5 0x15C6      SUB      R5,R5,R6, LSL #+7
   \   0000000C   0x4770             BX       LR
    258          
    259          /**
    260            * @brief UART Rx handler
    261            * @param None
    262            * @retval None
    263            */
    264          static void halInternalUart1RxIsr(void)
    265          {
    266            /* At present we really don't care which interrupt(s)
    267               occurred, just that one did.  Loop reading RXVALID
    268               data, processing any errors noted
    269               along the way. */
    270            while ( SC1_UART->UARTSR & SC_UARTSR_RXNE ) {
    271              uint8_t errors = SC1_UART->UARTSR & (SC_UARTSR_FE |
    272                                             SC_UARTSR_OVR  |
    273                                             SC_UARTSR_PE );
    274              uint8_t incoming = (uint8_t) SC1_UART->DR;
    275          
    276              if ( (errors == 0) && (rxUsed < (RECEIVE_QUEUE_SIZE-1)) ) {
    277                rxQ[rxHead] = incoming;
    278                rxHead = (rxHead+1) % RECEIVE_QUEUE_SIZE;
    279                rxUsed++;
    280              } else {
    281                /* IAR standard library doesn't allow for any error handling in the 
    282                   case of rx errors or not having space in the receive queue, so the
    283                   errors are just silently dropped.*/
    284              }
    285            } /* end of while ( SC1_UART->UARTSR & SC1_UARTRXVAL ) */
    286          }
    287          
    288          /**
    289            * @brief Non blocking read
    290            * @param dataByte: buffer containing the read byte if any
    291            * @retval TRUE if there is a data, FALSE otherwise
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          boolean __io_getcharNonBlocking(uint8_t *data)
    294          {
   \                     __io_getcharNonBlocking: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    295            if (__read(_LLIO_STDIN,data,1))
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       __read
   \   0000000C   0xB100             CBZ.N    R0,??__io_getcharNonBlocking_0
    296              return TRUE;
   \   0000000E   0x2001             MOVS     R0,#+1
    297            else
    298              return FALSE;
   \                     ??__io_getcharNonBlocking_0: (+1)
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    299          }/* end serialReadByte() */
    300          
    301          /**
    302            * @brief IO getchar prototype 
    303            * @param None
    304            * @retval int: data received
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          int __io_getchar()
    307          {
   \                     __io_getchar: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    308            unsigned char c = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    309            __read(_LLIO_STDIN, &c, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x.... 0x....      BL       __read
    310            return (int)(c);
   \   00000010   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    311          }
    312          
    313          /**
    314            * @}
    315            */
    316          
    317          /** @defgroup  UART_Interrupts_Functions
    318            * @{
    319            */
    320          
    321          /**
    322            * @brief SC1 IRQ handler
    323            * @param None
    324            * @retval None
    325            */

   \                                 In section .text, align 2, keep-with-next
    326          void halSc1Isr(void)
    327          {
   \                     halSc1Isr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    328            uint32_t interrupt;
    329          
    330            /* this read and mask is performed in two steps otherwise the compiler
    331               will complain about undefined order of __IO access */
    332            interrupt = SC1_IT->ISR;
   \   00000002   0x....             LDR.N    R0,??DataTable3  ;; 0x4000a808
    333            interrupt &= SC1_IT->IER;
   \   00000004   0x....             LDR.N    R3,??DataTable3_2  ;; 0x4000c83c
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x6C02             LDR      R2,[R0, #+64]
   \   0000000A   0xEA12 0x0401      ANDS     R4,R2,R1
   \   0000000E   0x....             LDR.N    R1,??DataTable3_4
   \   00000010   0x....             LDR.N    R2,??DataTable3_3
   \   00000012   0xE015             B.N      ??halSc1Isr_0
    334            
    335            while (interrupt != 0) {
    336            
    337              SC1_IT->ISR = interrupt; /* acknowledge the interrupts early */
    338          
    339              /* RX events */
    340              if ( interrupt & (SC_IER_RXNEIE   | /* RX has data */
    341                                SC_IER_OVRIE   | /* RX Overrun error */
    342                                SC_IER_FEIE | /* RX Frame error */
    343                                SC_IER_PEIE ) /* RX Parity error */
    344                 ) {
   \                     ??halSc1Isr_1: (+1)
   \   00000014   0x68DC             LDR      R4,[R3, #+12]
   \   00000016   0x681D             LDR      R5,[R3, #+0]
   \   00000018   0xF014 0x0438      ANDS     R4,R4,#0x38
   \   0000001C   0xD10A             BNE.N    ??halSc1Isr_2
   \   0000001E   0x8894             LDRH     R4,[R2, #+4]
   \   00000020   0x2C7F             CMP      R4,#+127
   \   00000022   0xDA07             BGE.N    ??halSc1Isr_2
   \   00000024   0x8816             LDRH     R6,[R2, #+0]
   \   00000026   0x5475             STRB     R5,[R6, R1]
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \   0000002A   0x1C75             ADDS     R5,R6,#+1
   \   0000002C   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000030   0x8015             STRH     R5,[R2, #+0]
   \   00000032   0x8094             STRH     R4,[R2, #+4]
   \                     ??halSc1Isr_2: (+1)
   \   00000034   0x68DC             LDR      R4,[R3, #+12]
   \   00000036   0x07A4             LSLS     R4,R4,#+30
   \   00000038   0xD4EC             BMI.N    ??halSc1Isr_1
    345                halInternalUart1RxIsr();
    346              }
    347              
    348              /* TX events */
    349              if ( interrupt & (SC_IER_TXEIE | /* TX has room */
    350                                SC_IER_IDLEIE ) /* TX idle (more room) */
    351                 ) {
    352                halInternalUart1TxIsr();
    353              }
    354          
    355              interrupt = SC1_IT->ISR;
   \                     ??halSc1Isr_3: (+1)
   \   0000003A   0x6804             LDR      R4,[R0, #+0]
    356              interrupt &= SC1_IT->IER;
   \   0000003C   0x6C05             LDR      R5,[R0, #+64]
   \   0000003E   0x402C             ANDS     R4,R5,R4
   \                     ??halSc1Isr_0: (+1)
   \   00000040   0xD005             BEQ.N    ??halSc1Isr_4
   \   00000042   0xF246 0x0509      MOVW     R5,#+24585
   \   00000046   0x422C             TST      R4,R5
   \   00000048   0x6004             STR      R4,[R0, #+0]
   \   0000004A   0xD1F3             BNE.N    ??halSc1Isr_2
   \   0000004C   0xE7F5             B.N      ??halSc1Isr_3
    357            }
    358          }
   \                     ??halSc1Isr_4: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4000A808         DC32     0x4000a808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x4000C83C         DC32     0x4000c83c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     rxHead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     rxQ
    359          
    360          /**
    361            * @}
    362            */
    363          
    364          /**
    365            * @}
    366            */
    367          
    368          /**
    369            * @}
    370            */ 
    371          
    372          /**
    373            * @}
    374            */
    375          
    376          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   __io_flush
         0   -> __write
       8   __io_getchar
         8   -> __read
       8   __io_getcharNonBlocking
         8   -> __read
       8   __io_putchar
         8   -> __write
      16   __read
       8   __write
       0   fflush
         0   -> __write
      16   halSc1Isr
      32   uartInit
        32   -> STM_EVAL_COMInit
        32   -> UART_ITConfig
        32   -> UART_TriggerEventConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       8  ?Subroutine0
      14  ?Subroutine1
       2  __io_flush
      22  __io_getchar
      18  __io_getcharNonBlocking
      14  __io_putchar
      72  __read
      64  __write
       2  fflush
      80  halSc1Isr
       6  rxHead
          rxTail
          rxUsed
     128  rxQ
      68  uartInit

 
 134 bytes in section .bss
 384 bytes in section .text
 
 384 bytes of CODE memory
 134 bytes of DATA memory

Errors: none
Warnings: none
