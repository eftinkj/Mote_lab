###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:27:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32_EVAL\MB_SnT_X2\mb_snt_x2.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32_EVAL\MB_SnT_X2\mb_snt_x2.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"mb_snt_x2.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32_EVAL\MB_SnT_X2\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\mb_snt_x2.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\mb_snt_x2.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32_EVAL\MB_SnT_X2\mb_snt_x2.c
      1          /**
      2            ******************************************************************************
      3            * @file    mb851.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides:
      8            *            - set of firmware functions to manage Leds, push-button and COM ports
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */
     28          
     29            
     30          /* Includes ------------------------------------------------------------------*/
     31          #include "mb_snt_x2.h"
     32          
     33          /** @addtogroup Utilities
     34            * @{
     35            */ 
     36          
     37          /** @addtogroup STM32_EVAL
     38            * @{
     39            */ 
     40          
     41          /** @addtogroup MB851
     42            * @{
     43            */   
     44              
     45          /** @defgroup MB851_LOW_LEVEL 
     46            * @brief This file provides firmware functions to manage Leds, push-buttons, 
     47            *        COM ports, I2C EEPROM (M24C64MW1), Mems on SPI and temperature sensor
     48            *        (LTLM20) available on MB851 rev A/B/C boards from STMicroelectronics.
     49            * @{
     50            */ 
     51          
     52          /** @defgroup MB851_LOW_LEVEL_Private_TypesDefinitions
     53            * @{
     54            */
     55          
     56          /* Uncomment the line below according to the MB851 board revision used.
     57            */
     58          
     59          /**
     60            * @}
     61            */ 
     62          
     63          
     64          /** @defgroup MB851_LOW_LEVEL_Private_Defines
     65            * @{
     66            */ 
     67          /**
     68            * @}
     69            */ 
     70          
     71          
     72          /** @defgroup MB851_LOW_LEVEL_Private_Macros
     73            * @{
     74            */ 
     75          /**
     76            * @}
     77            */ 
     78          
     79          
     80          /** @defgroup MB851_LOW_LEVEL_Private_Variables
     81            * @{
     82            */ 

   \                                 In section .data, align 4
     83          GPIO_TypeDef* GPIO_PORT[LEDn] = {LED1_GPIO_PORT, LED3_GPIO_PORT};
   \                     GPIO_PORT:
   \   00000000   0x4000B800         DC32 4000B800H, 4000B800H
   \              0x4000B800   

   \                                 In section .text, align 4, keep-with-next
     84          const uint16_t GPIO_PIN[LEDn] = {LED1_PIN, LED3_PIN};
   \                     GPIO_PIN:
   \   00000000   0x0001 0x0040      DC16 1, 64
     85          
     86          

   \                                 In section .data, align 4
     87          GPIO_TypeDef* BUTTON_PORT[BUTTONn] = {S1_BUTTON_GPIO_PORT}; 
   \                     BUTTON_PORT:
   \   00000000   0x4000B000         DC32 4000B000H
     88          

   \                                 In section .text, align 4, keep-with-next
     89          const uint16_t BUTTON_PIN[BUTTONn] = {S1_BUTTON_PIN}; 
   \                     BUTTON_PIN:
   \   00000000   0x0080             DC16 128
     90          

   \                                 In section .text, align 4, keep-with-next
     91          const uint16_t BUTTON_EXTI_IRQn[BUTTONn] = {S1_BUTTON_EXTI_IRQn};
   \                     BUTTON_EXTI_IRQn:
   \   00000000   0x0020             DC16 32
     92          

   \                                 In section .text, align 4, keep-with-next
     93          const uint16_t BUTTON_EXTI_SOURCE[BUTTONn] = {S1_BUTTON_EXTI_SOURCE};
   \                     BUTTON_EXTI_SOURCE:
   \   00000000   0x0007             DC16 7
     94          								 

   \                                 In section .text, align 4, keep-with-next
     95          const uint16_t BUTTON_IRQn[BUTTONn] = {S1_BUTTON_IRQn};
   \                     BUTTON_IRQn:
   \   00000000   0x000E             DC16 14
     96          

   \                                 In section .data, align 4
     97          SC_UART_TypeDef* COM_UART[COMn] = {EVAL_COM1}; 
   \                     COM_UART:
   \   00000000   0x4000C83C         DC32 4000C83CH
     98          
     99          GPIO_TypeDef* COM_TX_PORT[COMn] = {EVAL_COM1_TX_GPIO_PORT};
   \                     COM_TX_PORT:
   \   00000004   0x4000B400         DC32 4000B400H
    100           
    101          GPIO_TypeDef* COM_RX_PORT[COMn] = {EVAL_COM1_RX_GPIO_PORT};
   \                     COM_RX_PORT:
   \   00000008   0x4000B400         DC32 4000B400H
    102          

   \                                 In section .text, align 4, keep-with-next
    103          const uint16_t COM_TX_PIN[COMn] = {EVAL_COM1_TX_PIN};
   \                     COM_TX_PIN:
   \   00000000   0x0002             DC16 2
    104          

   \                                 In section .text, align 4, keep-with-next
    105          const uint16_t COM_RX_PIN[COMn] = {EVAL_COM1_RX_PIN};
   \                     COM_RX_PIN:
   \   00000000   0x0004             DC16 4
    106          
    107          
    108          /**
    109            * @}
    110            */ 
    111          
    112          
    113          /** @defgroup MB851_LOW_LEVEL_Private_FunctionPrototypes
    114            * @{
    115            */ 
    116          
    117          /**
    118            * @}
    119            */ 
    120          
    121          /** @defgroup MB851_LOW_LEVEL_Private_Functions
    122            * @{
    123            */ 
    124          
    125          /**
    126            * @brief  Configures LED GPIO.
    127            * @param  Led: Specifies the Led to be configured. 
    128            *   This parameter can be one of following parameters:
    129            *     @arg LED1
    130            *     @arg LED3
    131            * @retval None
    132            */

   \                                 In section .text, align 2, keep-with-next
    133          void STM_EVAL_LEDInit(Led_TypeDef Led)
    134          {
   \                     STM_EVAL_LEDInit: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    135            GPIO_InitTypeDef  GPIO_InitStructure;
    136            
    137            /* Configure the GPIO_LED pin */
    138            GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
   \   00000004   0x.... 0x....      ADR.W    R0,GPIO_PIN
    139            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_PP;
    140            GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
   \   00000008   0x....             LDR.N    R6,??DataTable17
   \   0000000A   0xF830 0x5014      LDRH     R5,[R0, R4, LSL #+1]
   \   0000000E   0x9500             STR      R5,[SP, #+0]
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   0000001C   0x.... 0x....      BL       GPIO_Init
    141            GPIO_PORT[Led]->BSR = GPIO_PIN[Led];
   \   00000020   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   00000024   0x6105             STR      R5,[R0, #+16]
    142          }
   \   00000026   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    143          
    144          /**
    145            * @brief  Turns selected LED On.
    146            * @param  Led: Specifies the Led to be set on. 
    147            *   This parameter can be one of following parameters:
    148            *     @arg LED1
    149            *     @arg LED3
    150            * @retval None
    151            */

   \                                 In section .text, align 2, keep-with-next
    152          void STM_EVAL_LEDOn(Led_TypeDef Led)
    153          {
    154            GPIO_PORT[Led]->BRR = GPIO_PIN[Led];
   \                     STM_EVAL_LEDOn: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,GPIO_PIN
   \   00000004   0x....             LDR.N    R2,??DataTable17
   \   00000006   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   0000000A   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   0000000E   0x6141             STR      R1,[R0, #+20]
    155          }
   \   00000010   0x4770             BX       LR               ;; return
    156          
    157          /**
    158            * @brief  Turns selected LED Off.
    159            * @param  Led: Specifies the Led to be set off. 
    160            *   This parameter can be one of following parameters:
    161            *     @arg LED1
    162            *     @arg LED3
    163            * @retval None
    164            */

   \                                 In section .text, align 2, keep-with-next
    165          void STM_EVAL_LEDOff(Led_TypeDef Led)
    166          {
    167            GPIO_PORT[Led]->BSR = GPIO_PIN[Led];
   \                     STM_EVAL_LEDOff: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,GPIO_PIN
   \   00000004   0x....             LDR.N    R2,??DataTable17
   \   00000006   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   0000000A   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    168          }
   \   00000010   0x4770             BX       LR               ;; return
    169          
    170          /**
    171            * @brief  Toggles the selected LED.
    172            * @param  Led: Specifies the Led to be toggled. 
    173            *   This parameter can be one of following parameters:
    174            *     @arg LED1
    175            *     @arg LED3
    176            * @retval None
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          void STM_EVAL_LEDToggle(Led_TypeDef Led)
    179          {
    180            GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
   \                     STM_EVAL_LEDToggle: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17
   \   00000002   0x.... 0x....      ADR.W    R3,GPIO_PIN
   \   00000006   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000000A   0x68CA             LDR      R2,[R1, #+12]
   \   0000000C   0xF833 0x0010      LDRH     R0,[R3, R0, LSL #+1]
   \   00000010   0x4050             EORS     R0,R0,R2
   \   00000012   0x60C8             STR      R0,[R1, #+12]
    181          }
   \   00000014   0x4770             BX       LR               ;; return
    182          
    183          /**
    184            * @brief  Configures Button GPIO and EXTI Line.
    185            * @param  Button: Specifies the Button to be configured.
    186            *   This parameter can be one of following parameters:
    187            *     @arg BUTTON_S1: Push Button  
    188            * @param  Button_Mode: Specifies Button mode.
    189            *   This parameter can be one of following parameters:   
    190            *     @arg BUTTON_MODE_GPIO: Button will be used as simple IO 
    191            *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
    192            *                     generation capability
    193            * @retval None
    194            */

   \                                 In section .text, align 2, keep-with-next
    195          void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
    196          {
   \                     STM_EVAL_PBInit: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    197            GPIO_InitTypeDef GPIO_InitStructure;
    198            EXTI_InitTypeDef EXTI_InitStructure;
    199            NVIC_InitTypeDef NVIC_InitStructure;
    200          
    201            /* Configure Button pin as input */
    202            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PUD;
   \   00000006   0x2008             MOVS     R0,#+8
   \   00000008   0xF88D 0x0010      STRB     R0,[SP, #+16]
   \   0000000C   0x460D             MOV      R5,R1
    203            GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
   \   0000000E   0x.... 0x....      ADR.W    R0,BUTTON_PIN
    204            GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);
   \   00000012   0x....             LDR.N    R7,??DataTable17_1
   \   00000014   0xF830 0x6014      LDRH     R6,[R0, R4, LSL #+1]
   \   00000018   0x9603             STR      R6,[SP, #+12]
   \   0000001A   0xA903             ADD      R1,SP,#+12
   \   0000001C   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \   00000020   0x.... 0x....      BL       GPIO_Init
    205            
    206            /* Set pull-up on button I/O */
    207            GPIO_SetBits(BUTTON_PORT[Button], BUTTON_PIN[Button]);
   \   00000024   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \   00000028   0x4631             MOV      R1,R6
   \   0000002A   0x.... 0x....      BL       GPIO_SetBits
    208            
    209            if (Button_Mode == BUTTON_MODE_EXTI)
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD126             BNE.N    ??STM_EVAL_PBInit_0
    210            {
    211              /* Configure Button EXTI line */
    212              EXTI_InitStructure.EXTI_Source = BUTTON_EXTI_SOURCE[Button];
   \   00000032   0x.... 0x....      ADR.W    R0,BUTTON_EXTI_SOURCE
   \   00000036   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000003A   0x9001             STR      R0,[SP, #+4]
    213              EXTI_InitStructure.EXTI_IRQn = BUTTON_EXTI_IRQn[Button];
   \   0000003C   0x.... 0x....      ADR.W    R0,BUTTON_EXTI_IRQn
   \   00000040   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000044   0xF88D 0x0008      STRB     R0,[SP, #+8]
    214              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling_Edge;
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0xF88D 0x0009      STRB     R0,[SP, #+9]
    215              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF88D 0x000A      STRB     R0,[SP, #+10]
    216              EXTI_InitStructure.EXTI_DigitalFilterCmd = ENABLE;
   \   00000054   0xF88D 0x000B      STRB     R0,[SP, #+11]
    217              EXTI_Init(&EXTI_InitStructure);
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       EXTI_Init
    218          
    219              /* Enable and set Button EXTI Interrupt to the lowest priority */
    220              NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
   \   0000005E   0x.... 0x....      ADR.W    R0,BUTTON_IRQn
   \   00000062   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000066   0xF88D 0x0000      STRB     R0,[SP, #+0]
    221              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
   \   0000006A   0x200F             MOVS     R0,#+15
   \   0000006C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    222              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   00000070   0xF88D 0x0002      STRB     R0,[SP, #+2]
    223              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF88D 0x0003      STRB     R0,[SP, #+3]
    224          
    225              NVIC_Init(&NVIC_InitStructure); 
   \   0000007A   0xA800             ADD      R0,SP,#+0
   \   0000007C   0x.... 0x....      BL       NVIC_Init
    226            }
    227          }
   \                     ??STM_EVAL_PBInit_0: (+1)
   \   00000080   0xB005             ADD      SP,SP,#+20
   \   00000082   0xBDF0             POP      {R4-R7,PC}       ;; return
    228          
    229          /**
    230            * @brief  Returns the selected Button state.
    231            * @param  Button: Specifies the Button to be checked.
    232            *   This parameter can be one of following parameters:
    233            *     @arg BUTTON_S1: Push Button  
    234            * @retval The Button GPIO pin value.
    235            */

   \                                 In section .text, align 2, keep-with-next
    236          uint32_t STM_EVAL_PBGetState(Button_TypeDef Button)
    237          {
    238            /* Return the push button status on MB851 board */
    239            return GPIO_ReadInputDataBit(BUTTON_PORT[Button], BUTTON_PIN[Button]);
   \                     STM_EVAL_PBGetState: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,BUTTON_PIN
   \   00000004   0x....             LDR.N    R2,??DataTable17_1
   \   00000006   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   0000000A   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   0000000E   0x.... 0x....      B.W      GPIO_ReadInputDataBit
    240          }
    241          
    242          /**
    243            * @brief  Configures COM port.
    244            * @param  COM: Specifies the COM port to be configured.
    245            *   This parameter can be one of following parameters:    
    246            *     @arg COM1
    247            * @param  UART_InitStruct: pointer to a UART_InitTypeDef structure that
    248            *   contains the configuration information for the specified UART peripheral.
    249            * @retval None
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          void STM_EVAL_COMInit(COM_TypeDef COM, UART_InitTypeDef* UART_InitStruct)
    252          {
   \                     STM_EVAL_COMInit: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    253            GPIO_InitTypeDef GPIO_InitStructure;
    254            
    255            /* Disable the serial controller interface */
    256            UART_Cmd(COM_UART[COM], DISABLE); 
   \   00000002   0x....             LDR.N    R4,??DataTable17_2
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      BL       UART_Cmd
    257            
    258            /* UART configuration: Set up the parameters specific for the UART operating mode */
    259            UART_Init(COM_UART[COM], UART_InitStruct);  
   \   00000014   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   00000018   0x4631             MOV      R1,R6
   \   0000001A   0x.... 0x....      BL       UART_Init
   \   0000001E   0x.... 0x....      ADR.W    R0,COM_TX_PIN
   \   00000022   0xF830 0x7015      LDRH     R7,[R0, R5, LSL #+1]
   \   00000026   0x9700             STR      R7,[SP, #+0]
    260            
    261            /* Configure UART Tx as alternate function push-pull */
    262            GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
    263            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000028   0x2009             MOVS     R0,#+9
   \   0000002A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    264            GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
   \   0000002E   0xEB04 0x0685      ADD      R6,R4,R5, LSL #+2
   \   00000032   0xA900             ADD      R1,SP,#+0
   \   00000034   0x6870             LDR      R0,[R6, #+4]
   \   00000036   0x.... 0x....      BL       GPIO_Init
    265            /* Set pull-up on UART Tx pin */
    266            GPIO_SetBits(COM_TX_PORT[COM], COM_TX_PIN[COM]);
   \   0000003A   0x6870             LDR      R0,[R6, #+4]
   \   0000003C   0x4639             MOV      R1,R7
   \   0000003E   0x.... 0x....      BL       GPIO_SetBits
   \   00000042   0x.... 0x....      ADR.W    R0,COM_RX_PIN
   \   00000046   0xF830 0x7015      LDRH     R7,[R0, R5, LSL #+1]
   \   0000004A   0x9700             STR      R7,[SP, #+0]
    267            
    268            /* Configure UART Rx as input with pull-up */
    269            GPIO_InitStructure.GPIO_Pin = COM_RX_PIN[COM];
    270            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    271            GPIO_Init(COM_RX_PORT[COM], &GPIO_InitStructure);
   \   00000052   0xA900             ADD      R1,SP,#+0
   \   00000054   0x68B0             LDR      R0,[R6, #+8]
   \   00000056   0x.... 0x....      BL       GPIO_Init
    272            /* Set pull-up on UART Rx pin */
    273            GPIO_SetBits(COM_RX_PORT[COM], COM_RX_PIN[COM]);
   \   0000005A   0x68B0             LDR      R0,[R6, #+8]
   \   0000005C   0x4639             MOV      R1,R7
   \   0000005E   0x.... 0x....      BL       GPIO_SetBits
    274                
    275            /* Enable the UART peripheral */
    276            UART_Cmd(COM_UART[COM], ENABLE);  
   \   00000062   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x.... 0x....      BL       UART_Cmd
    277          }
   \   0000006C   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    278          
    279          /**
    280            * @brief  DeInitializes the Mems Accelerometer (LIS302).
    281            * @param  None
    282            * @retval None
    283            */

   \                                 In section .text, align 2, keep-with-next
    284          void LIS302DL_LowLevel_DeInit(void)
    285          {
   \                     LIS302DL_LowLevel_DeInit: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    286            GPIO_InitTypeDef  GPIO_InitStructure; 
    287             
    288            /* LIS302DL_I2C Peripheral Disable */
    289            I2C_Cmd(LIS302DL_I2C, DISABLE);
   \   00000002   0x....             LDR.N    R4,??DataTable17_3  ;; 0x4000c03c
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       I2C_Cmd
    290           
    291            /* LIS302DL_I2C DeInit */
    292            I2C_DeInit(LIS302DL_I2C);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_DeInit
    293          
    294            /*!< GPIO configuration */  
    295            /*!< Configure LIS302DL_I2C pins: SCL */
    296            GPIO_InitStructure.GPIO_Pin = LIS302DL_I2C_SCL_PIN;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0x9000             STR      R0,[SP, #+0]
    297            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000016   0xF88D 0x0004      STRB     R0,[SP, #+4]
    298            GPIO_Init(LIS302DL_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x.... 0x....      BL       ?Subroutine1
    299          
    300            /*!< Configure LIS302DL_I2C pins: SDA */
    301            GPIO_InitStructure.GPIO_Pin = LIS302DL_I2C_SDA_PIN;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x9000             STR      R0,[SP, #+0]
    302            GPIO_Init(LIS302DL_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x.... 0x....      BL       ??Subroutine1_0
    303          }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000002A   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x....             LDR.N    R4,??DataTable17_7  ;; 0x4000b000
   \                     ??Subroutine1_0: (+1)
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x.... 0x....      B.W      GPIO_Init
    304          
    305          /**
    306            * @brief  Initializes the Mems Accelerometer (LIS302).
    307            * @param  None
    308            * @retval None
    309            */

   \                                 In section .text, align 2, keep-with-next
    310          void LIS302DL_LowLevel_Init(void)
    311          {
   \                     LIS302DL_LowLevel_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    312            GPIO_InitTypeDef  GPIO_InitStructure;
    313            I2C_InitTypeDef  I2C_InitStructure;
    314            
    315            /*!< GPIO configuration */  
    316            /*!< Configure LIS302DL_I2C pins: SCL */
    317            GPIO_InitStructure.GPIO_Pin = LIS302DL_I2C_SCL_PIN;
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x9001             STR      R0,[SP, #+4]
    318            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
   \   00000008   0x200D             MOVS     R0,#+13
   \   0000000A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    319            GPIO_Init(LIS302DL_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   0000000E   0xA901             ADD      R1,SP,#+4
   \   00000010   0x.... 0x....      BL       ?Subroutine1
    320            /* Set pull-up on LIS302DL_I2C SCL pin */
    321            GPIO_SetBits(LIS302DL_I2C_SCL_GPIO_PORT, LIS302DL_I2C_SCL_PIN);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       GPIO_SetBits
    322            
    323            /*!< Configure LIS302DL_I2C pins: SDA */
    324            GPIO_InitStructure.GPIO_Pin = LIS302DL_I2C_SDA_PIN;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x9001             STR      R0,[SP, #+4]
    325            GPIO_Init(LIS302DL_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000020   0xA901             ADD      R1,SP,#+4
   \   00000022   0x.... 0x....      BL       ??Subroutine1_0
    326            /* Set pull-up on LIS302DL_I2C SDA pin */
    327            GPIO_SetBits(LIS302DL_I2C_SDA_GPIO_PORT, LIS302DL_I2C_SDA_PIN);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       GPIO_SetBits
    328            
    329            TIM2->CCER &= 0xFFFFEEEE;
   \   0000002E   0x....             LDR.N    R0,??DataTable17_4  ;; 0x4000f020
   \   00000030   0x....             LDR.N    R2,??DataTable17_5  ;; 0xffffeeee
   \   00000032   0x6801             LDR      R1,[R0, #+0]
    330            /*!< I2C configuration -----------------------------------------------------*/
    331            /* LIS302DL_I2C configuration */
    332            I2C_InitStructure.I2C_ClockRate = 400000;
    333            
    334            /* Apply LIS302DL_I2C configuration after enabling it */
    335            I2C_Init(LIS302DL_I2C, &I2C_InitStructure);
   \   00000034   0x....             LDR.N    R4,??DataTable17_3  ;; 0x4000c03c
   \   00000036   0x4011             ANDS     R1,R2,R1
   \   00000038   0x6001             STR      R1,[R0, #+0]
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x....             LDR.N    R0,??DataTable17_6  ;; 0x61a80
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       I2C_Init
    336          
    337            /* MEMS_I2C Peripheral Enable */
    338            I2C_Cmd(LIS302DL_I2C, ENABLE);
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       I2C_Cmd
    339          }
   \   0000004E   0xBD1F             POP      {R0-R4,PC}       ;; return
    340          
    341          /**
    342            * @brief  DeInitializes the Temperature sensor (STLM20).
    343            * @param  None
    344            * @retval None
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          void STLM20_LowLevel_DeInit(void)
    347          {  
   \                     STLM20_LowLevel_DeInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    348            GPIO_InitTypeDef GPIO_InitStructure;
    349          
    350            /* GPIO configuration */   
    351            GPIO_InitStructure.GPIO_Pin = STLM20_ADC_CHANNEL_PIN; 
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x9000             STR      R0,[SP, #+0]
    352            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    353            GPIO_Init(STLM20_ADC_CHANNEL_GPIO_PORT, &GPIO_InitStructure);  
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x.... 0x....      BL       ?Subroutine0
    354            
    355            /* ADC Disable */  
    356            ADC_Cmd(DISABLE);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       ADC_Cmd
    357            
    358            /* ADC DeInit */  
    359            ADC_DeInit();
   \   00000016   0x.... 0x....      BL       ADC_DeInit
    360          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000004   0x....             LDR.N    R0,??DataTable17_7  ;; 0x4000b000
   \   00000006   0x.... 0x....      B.W      GPIO_Init
    361          
    362          /**
    363            * @brief  Initializes the Temperature sensor (STLM20).
    364            * @param  None
    365            * @retval None
    366            */

   \                                 In section .text, align 2, keep-with-next
    367          void STLM20_LowLevel_Init(void)
    368          {
   \                     STLM20_LowLevel_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    369            GPIO_InitTypeDef GPIO_InitStructure;
    370          
    371            /* GPIO configuration */   
    372            GPIO_InitStructure.GPIO_Pin = STLM20_ADC_CHANNEL_PIN; 
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x9000             STR      R0,[SP, #+0]
    373            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    374            GPIO_Init(STLM20_ADC_CHANNEL_GPIO_PORT, &GPIO_InitStructure);  
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       ?Subroutine0
    375          }
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000010   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     GPIO_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     BUTTON_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     COM_UART

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x4000C03C         DC32     0x4000c03c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x4000F020         DC32     0x4000f020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0xFFFFEEEE         DC32     0xffffeeee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x4000B000         DC32     0x4000b000
    376          
    377          #if defined (USE_MB851_REVC) || defined (USE_MB851_REVD)
    378          /**
    379            * @brief  DeInitializes peripherals used by the I2C EEPROM driver.
    380            * @param  None
    381            * @retval None
    382            */
    383          void sEE_LowLevel_DeInit(void)
    384          {
    385            GPIO_InitTypeDef  GPIO_InitStructure; 
    386             
    387            /* sEE_I2C Peripheral Disable */
    388            I2C_Cmd(sEE_I2C, DISABLE);
    389           
    390            /* sEE_I2C DeInit */
    391            I2C_DeInit(sEE_I2C);
    392          
    393            /*!< GPIO configuration */  
    394            /*!< Configure sEE_I2C pins: SCL */
    395            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
    396            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    397            GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
    398          
    399            /*!< Configure sEE_I2C pins: SDA */
    400            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
    401            GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
    402          }
    403          
    404          /**
    405            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    406            * @param  None
    407            * @retval None
    408            */
    409          void sEE_LowLevel_Init(void)
    410          {
    411            GPIO_InitTypeDef  GPIO_InitStructure;
    412            
    413            /*!< GPIO configuration */  
    414            /*!< Configure sEE_I2C pins: SCL */
    415            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
    416            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
    417            GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
    418            /* Set pull-up on sEE_I2C SCL pin */
    419            GPIO_SetBits(sEE_I2C_SCL_GPIO_PORT, sEE_I2C_SCL_PIN);
    420            
    421            /*!< Configure sEE_I2C pins: SDA */
    422            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
    423            GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
    424            /* Set pull-up on sEE_I2C SDA pin */
    425            GPIO_SetBits(sEE_I2C_SDA_GPIO_PORT, sEE_I2C_SDA_PIN);
    426           
    427            TIM2->CCER &= 0xFFFFEEEE;
    428          }
    429          
    430          #endif /* USE_MB851_REVC or USE_MB851_REVD */
    431          
    432          /**
    433            * @}
    434            */ 
    435          
    436          /**
    437            * @}
    438            */ 
    439          
    440          /**
    441            * @}
    442            */
    443          
    444          /**
    445            * @}
    446            */
    447          
    448          /**
    449            * @}
    450            */ 
    451              
    452          
    453          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LIS302DL_LowLevel_DeInit
        16   -> GPIO_Init
        16   -> I2C_Cmd
        16   -> I2C_DeInit
      24   LIS302DL_LowLevel_Init
        24   -> GPIO_Init
        24   -> GPIO_SetBits
        24   -> I2C_Cmd
        24   -> I2C_Init
      16   STLM20_LowLevel_DeInit
        16   -> ADC_Cmd
        16   -> ADC_DeInit
        16   -> GPIO_Init
      16   STLM20_LowLevel_Init
        16   -> GPIO_Init
      32   STM_EVAL_COMInit
        32   -> GPIO_Init
        32   -> GPIO_SetBits
        32   -> UART_Cmd
        32   -> UART_Init
      24   STM_EVAL_LEDInit
        24   -> GPIO_Init
       0   STM_EVAL_LEDOff
       0   STM_EVAL_LEDOn
       0   STM_EVAL_LEDToggle
       0   STM_EVAL_PBGetState
         0   -> GPIO_ReadInputDataBit
      40   STM_EVAL_PBInit
        40   -> EXTI_Init
        40   -> GPIO_Init
        40   -> GPIO_SetBits
        40   -> NVIC_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
      10  ?Subroutine0
       8  ?Subroutine1
       2  BUTTON_EXTI_IRQn
       2  BUTTON_EXTI_SOURCE
       2  BUTTON_IRQn
       2  BUTTON_PIN
       4  BUTTON_PORT
       2  COM_RX_PIN
       2  COM_TX_PIN
      12  COM_UART
          COM_TX_PORT
          COM_RX_PORT
       4  GPIO_PIN
       8  GPIO_PORT
      44  LIS302DL_LowLevel_DeInit
      80  LIS302DL_LowLevel_Init
      28  STLM20_LowLevel_DeInit
      18  STLM20_LowLevel_Init
     110  STM_EVAL_COMInit
      40  STM_EVAL_LEDInit
      18  STM_EVAL_LEDOff
      18  STM_EVAL_LEDOn
      22  STM_EVAL_LEDToggle
      18  STM_EVAL_PBGetState
     132  STM_EVAL_PBInit

 
  24 bytes in section .data
 594 bytes in section .text
 
 594 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none
