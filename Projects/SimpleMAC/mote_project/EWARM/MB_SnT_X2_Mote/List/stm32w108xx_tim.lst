###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:30:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_tim.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_tim.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"stm32w108xx_tim.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\stm32w108xx_tim.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\stm32w108xx_tim.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32w108xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            + TimeBase management
     10            *            + Output Compare management
     11            *            + Input Capture management
     12            *            + Interrupts management  
     13            *            + Clocks management
     14            *            + Synchronization management
     15            *            + Specific interface management
     16            *            + Specific remapping management      
     17            *              
     18            *  @verbatim  
     19           ===============================================================================
     20                              ##### How to use this driver #####
     21           ===============================================================================
     22              [..] This driver provides functions to configure and program the TIM 
     23                   of all STM32W108xx devices These functions are split in 8 groups: 
     24                   (#) TIM TimeBase management: this group includes all needed functions 
     25                       to configure the TM Timebase unit:
     26                       (++) Set/Get Prescaler.
     27                       (++) Set/Get Autoreload.
     28                       (++) Counter modes configuration.
     29                       (++) Set Clock division.
     30                       (++) Select the One Pulse mode.
     31                       (++) Update Request Configuration.
     32                       (++) Update Disable Configuration.
     33                       (++) Auto-Preload Configuration.
     34                       (++) Enable/Disable the counter.
     35            
     36                   (#) TIM Output Compare management: this group includes all needed 
     37                       functions to configure the Capture/Compare unit used in Output 
     38                       compare mode: 
     39                       (++) Configure each channel, independently, in Output Compare mode.
     40                       (++) Select the output compare modes.
     41                       (++) Select the Polarities of each channel.
     42                       (++) Set/Get the Capture/Compare register values.
     43                       (++) Select the Output Compare Fast mode. 
     44                       (++) Select the Output Compare Forced mode.  
     45                       (++) Output Compare-Preload Configuration. 
     46                       (++) Clear Output Compare Reference.
     47                       (++) Select the OCREF Clear signal.
     48                       (++) Enable/Disable the Capture/Compare Channels.    
     49            
     50                   (#) TIM Input Capture management: this group includes all needed 
     51                       functions to configure the Capture/Compare unit used in 
     52                       Input Capture mode:
     53                       (++) Configure each channel in input capture mode.
     54                       (++) Configure Channel1/2 in PWM Input mode.
     55                       (++) Set the Input Capture Prescaler.
     56                       (++) Get the Capture/Compare values.   
     57            
     58                   (#) Interrupts and flags management functions: this group includes 
     59                       all needed 
     60                       functions to manage interrupts:
     61                       (++) Enables or disables the specified TIM interrupts.
     62                       (++) Configures the TIMx event to be generate by software.
     63                       (++) Checks whether the TIM interrupt has occurred or not.
     64                       (++) Clears the TIMx's interrupt pending bits.
     65                       
     66                   (#) TIM clocks management: this group includes all needed functions 
     67                       to configure the clock controller unit:
     68                       (++) Select internal/External clock.
     69                       (++) Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx.
     70            
     71                   (#) TIM synchronization management: this group includes all needed. 
     72                       functions to configure the Synchronization unit:
     73                       (++) Select Input Trigger.  
     74                       (++) Select Output Trigger.  
     75                       (++) Select Master Slave Mode. 
     76                       (++) ETR Configuration when used as external trigger.   
     77            
     78                   (#) TIM specific interface management, this group includes all 
     79                       needed functions to use the specific TIM interface:
     80                       (++) Encoder Interface Configuration.
     81                       (++) Select Hall Sensor.   
     82            
     83                   (#) TIM specific remapping management includes the Remapping 
     84                       configuration of specific timers
     85            
     86              @endverbatim
     87            *    
     88            ******************************************************************************
     89            * @attention
     90            *
     91            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     92            *
     93            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     94            * You may not use this file except in compliance with the License.
     95            * You may obtain a copy of the License at:
     96            *
     97            *        http://www.st.com/software_license_agreement_liberty_v2
     98            *
     99            * Unless required by applicable law or agreed to in writing, software 
    100            * distributed under the License is distributed on an "AS IS" BASIS, 
    101            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    102            * See the License for the specific language governing permissions and
    103            * limitations under the License.
    104            *
    105            ******************************************************************************
    106            */
    107          
    108          /* Includes ------------------------------------------------------------------*/
    109          #include "stm32w108xx_tim.h"
    110          
    111          /** @addtogroup STM32W108xx_StdPeriph_Driver
    112            * @{
    113            */
    114          /** @defgroup TIM 
    115            * @brief TIM driver modules
    116            * @{
    117            */
    118          
    119          /* Private typedef -----------------------------------------------------------*/
    120          /* Private define ------------------------------------------------------------*/
    121          
    122          /* ---------------------- TIM registers bit mask ------------------------ */
    123          #define SMCR_ETR_MASK               ((uint32_t)0x00FF) 
    124          #define CCMR_OFFSET                 ((uint32_t)0x0018)
    125          #define CCER_CCE_SET                ((uint32_t)0x0001)
    126          #define TIM_ClockMask_Disable       ((uint32_t)0x0000)
    127          #define TIM_ClockMask_Enable        ((uint32_t)0x0004)
    128          
    129          /* Private macro -------------------------------------------------------------*/
    130          /* Private variables ---------------------------------------------------------*/
    131          /* Private function prototypes -----------------------------------------------*/
    132          
    133          static void TI1_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    134                                 uint32_t TIM_ICFilter);
    135          static void TI2_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    136                                 uint32_t TIM_ICFilter);
    137          static void TI3_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    138                                 uint32_t TIM_ICFilter);
    139          static void TI4_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    140                                 uint32_t TIM_ICFilter);
    141          /* Private functions ---------------------------------------------------------*/
    142          
    143          /** @defgroup TIM_Private_Functions
    144            * @{
    145            */
    146          
    147          /** @defgroup TIM_Group1 TimeBase management functions
    148           *  @brief   TimeBase management functions 
    149           *
    150           @verbatim
    151           ===============================================================================
    152                           ##### TimeBase management functions #####
    153           ===============================================================================  
    154                  *** TIM Driver: how to use it in Timing(Time base) Mode ***
    155           ===============================================================================
    156              [..] To use the Timer in Timing(Time base) mode, the following steps are 
    157                   mandatory:
    158                   (#) Fill the TIM_TimeBaseInitStruct with the desired parameters.
    159                   (#) Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure 
    160                       the Time Base unit with the corresponding configuration.
    161                   (#) Enable the NVIC if you need to generate the update interrupt. 
    162                   (#) Enable the corresponding interrupt using the function 
    163                       TIM_ITConfig(TIMx, TIM_IT_Update). 
    164                   (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    165              [..]
    166                  (@) All other functions can be used seperatly to modify, if needed,
    167                      a specific feature of the Timer. 
    168          
    169          @endverbatim
    170            * @{
    171            */
    172          
    173          /**
    174            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    175            * @param  TIMx: where x can be 1 and 2 to select the TIM peripheral.
    176            * @retval None
    177            *   
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          void TIM_DeInit(TIM_TypeDef* TIMx)
    180          {
    181            
    182            /* Check the parameters */
    183            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    184            
    185            TIMx->CR1 = 0x00000000;
   \                     TIM_DeInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    186            TIMx->CR2 = 0x00000000;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    187            TIMx->SMCR = 0x00000000;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    188            TIMx->EGR = 0x00000000;
   \   00000008   0x6141             STR      R1,[R0, #+20]
    189            TIMx->CCMR2 = 0x00000000;     
   \   0000000A   0x61C1             STR      R1,[R0, #+28]
    190            TIMx->CCER = 0x00000000;
   \   0000000C   0x6201             STR      R1,[R0, #+32]
    191            TIMx->CNT = 0x00000000;
   \   0000000E   0x6241             STR      R1,[R0, #+36]
    192            TIMx->PSC = 0x00000000;
   \   00000010   0x6281             STR      R1,[R0, #+40]
    193            TIMx->ARR = 0x0000FFFF;
   \   00000012   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000016   0x62C1             STR      R1,[R0, #+44]
    194            TIMx->CCMR1 = 0x00000000;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    195            TIMx->CCR3 = 0x00000000;
   \   0000001C   0x63C1             STR      R1,[R0, #+60]
    196            TIMx->CCR4 = 0x00000000;
   \   0000001E   0x6401             STR      R1,[R0, #+64]
    197            TIMx->CCR1 = 0x00000000;
   \   00000020   0x6341             STR      R1,[R0, #+52]
    198            TIMx->CCR2 = 0x00000000;
   \   00000022   0x6381             STR      R1,[R0, #+56]
    199            TIMx->OR = 0x00000000;
   \   00000024   0x6501             STR      R1,[R0, #+80]
    200            
    201            if (TIMx == TIM1)
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable1  ;; 0x4000e000
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable1_1  ;; 0x4000a800
   \   0000002E   0x4290             CMP      R0,R2
   \   00000030   0xD10A             BNE.N    ??TIM_DeInit_0
    202            {
    203              TIM1_IT->IER = 0x00000000; 
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6408             STR      R0,[R1, #+64]
    204              TIM1_IT->ISR |= 0x0000005F; 
   \   00000036   0x6808             LDR      R0,[R1, #+0]
   \   00000038   0xF040 0x005F      ORR      R0,R0,#0x5F
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    205              TIM1_IT->IMR |= 0x00001E00; 
   \   0000003E   0x6988             LDR      R0,[R1, #+24]
   \   00000040   0xF440 0x50F0      ORR      R0,R0,#0x1E00
   \   00000044   0x6188             STR      R0,[R1, #+24]
   \   00000046   0x4770             BX       LR
    206            }
    207            else
    208            {
    209              if (TIMx == TIM2)
   \                     ??TIM_DeInit_0: (+1)
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable1_2  ;; 0x4000f000
   \   0000004C   0x4290             CMP      R0,R2
   \   0000004E   0xD109             BNE.N    ??TIM_DeInit_1
    210              {
    211                TIM2_IT->IER = 0x00000000;  
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6448             STR      R0,[R1, #+68]
    212                TIM2_IT->ISR |= 0x0000005F; 
   \   00000054   0x6848             LDR      R0,[R1, #+4]
   \   00000056   0xF040 0x005F      ORR      R0,R0,#0x5F
   \   0000005A   0x6048             STR      R0,[R1, #+4]
    213                TIM2_IT->IMR |= 0x00001E00; 
   \   0000005C   0x69C8             LDR      R0,[R1, #+28]
   \   0000005E   0xF440 0x50F0      ORR      R0,R0,#0x1E00
   \   00000062   0x61C8             STR      R0,[R1, #+28]
    214              }
    215            }
    216          }
   \                     ??TIM_DeInit_1: (+1)
   \   00000064   0x4770             BX       LR               ;; return
    217          
    218          /**
    219            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    220            *         the specified parameters in the TIM_TimeBaseInitStruct.
    221            * @param  TIMx: where x can be 1 and 2 to select the TIM 
    222            *         peripheral.
    223            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    224            *         structure that contains the configuration information for
    225            *         the specified TIM peripheral.
    226            * @retval None
    227            */

   \                                 In section .text, align 2, keep-with-next
    228          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    229          {
    230            uint32_t tmpcr1 = 0;
    231          
    232            /* Check the parameters */
    233            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    234            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    235          
    236            tmpcr1 = TIMx->CR1;  
    237          
    238              /* Select the Counter Mode */
    239              tmpcr1 &= (uint32_t)(~((uint32_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    240              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    241           
    242           
    243          
    244            TIMx->CR1 = tmpcr1;
   \                     TIM_TimeBaseInit: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x684B             LDR      R3,[R1, #+4]
   \   00000004   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x6002             STR      R2,[R0, #+0]
    245          
    246            /* Set the Autoreload value */
    247            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
   \   0000000C   0x688A             LDR      R2,[R1, #+8]
   \   0000000E   0x62C2             STR      R2,[R0, #+44]
    248           
    249            /* Set the Prescaler value */
    250            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x6281             STR      R1,[R0, #+40]
    251              
    252            /* Generate an update event to reload the Prescaler and the Repetition counter
    253               values immediately */
    254            TIMx->EGR = TIM_PSCReloadMode_Immediate;           
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x6141             STR      R1,[R0, #+20]
    255          }
   \   00000018   0x4770             BX       LR               ;; return
    256          
    257          /**
    258            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    259            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    260            *         structure which will be initialized.
    261            * @retval None
    262            */

   \                                 In section .text, align 2, keep-with-next
    263          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    264          {
    265            /* Set the default configuration */
    266            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
   \                     TIM_TimeBaseStructInit: (+1)
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x6081             STR      R1,[R0, #+8]
    267            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
    268            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    269          }
   \   0000000C   0x4770             BX       LR               ;; return
    270          
    271          /**
    272            * @brief  Configures the TIMx Prescaler.
    273            * @param  TIMx: where x can be 1 and 2 to select the TIM peripheral.
    274            * @param  Prescaler: specifies the Prescaler Register value
    275            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    276            *   This parameter can be one of the following values:
    277            *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    278            *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
    279            * @retval None
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint32_t Prescaler, uint32_t TIM_PSCReloadMode)
    282          {
    283            /* Check the parameters */
    284            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    285            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    286            
    287            /* Set the Prescaler value */
    288            TIMx->PSC = Prescaler;
   \                     TIM_PrescalerConfig: (+1)
   \   00000000   0x6281             STR      R1,[R0, #+40]
    289            /* Set or reset the UG Bit */
    290            TIMx->EGR = TIM_PSCReloadMode;
   \   00000002   0x6142             STR      R2,[R0, #+20]
    291          }
   \   00000004   0x4770             BX       LR               ;; return
    292          
    293          /**
    294            * @brief  Specifies the TIMx Counter Mode to be used.
    295            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    296            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    297            *   This parameter can be one of the following values:
    298            *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
    299            *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
    300            *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    301            *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    302            *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    303            * @retval None
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint32_t TIM_CounterMode)
    306          {
    307            uint32_t tmpcr1 = 0;
    308            
    309            /* Check the parameters */
    310            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    311            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    312            
    313            tmpcr1 = TIMx->CR1;
    314            /* Reset the CMS and DIR Bits */
    315            tmpcr1 &= (uint32_t)(~((uint32_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    316            /* Set the Counter Mode */
    317            tmpcr1 |= TIM_CounterMode;
    318            /* Write to TIMx CR1 register */
    319            TIMx->CR1 = tmpcr1;
   \                     TIM_CounterModeConfig: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x....             B.N      ?Subroutine3
    320          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x4311             ORRS     R1,R1,R2
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    321          
    322          /**
    323            * @brief  Sets the TIMx Counter Register value
    324            * @param  TIMx: where x can be 1 and 2 to select the TIM 
    325            *          peripheral.
    326            * @param  Counter: specifies the Counter register new value.
    327            * @retval None
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    330          {
    331            /* Check the parameters */
    332             assert_param(IS_TIM_ALL_PERIPH(TIMx));
    333             
    334            /* Set the Counter Register value */
    335            TIMx->CNT = Counter;
   \                     TIM_SetCounter: (+1)
   \   00000000   0x6241             STR      R1,[R0, #+36]
    336          }
   \   00000002   0x4770             BX       LR               ;; return
    337          
    338          /**
    339            * @brief  Sets the TIMx Autoreload Register value
    340            * @param  TIMx: where x can be 1 and 2 to select the TIM peripheral.
    341            * @param  Autoreload: specifies the Autoreload register new value.
    342            * @retval None
    343            */

   \                                 In section .text, align 2, keep-with-next
    344          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    345          {
    346            /* Check the parameters */
    347            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    348            
    349            /* Set the Autoreload Register value */
    350            TIMx->ARR = Autoreload;
   \                     TIM_SetAutoreload: (+1)
   \   00000000   0x62C1             STR      R1,[R0, #+44]
    351          }
   \   00000002   0x4770             BX       LR               ;; return
    352          
    353          /**
    354            * @brief  Gets the TIMx Counter value.
    355            * @param  TIMx: where x can be 1 and 2 to select the TIM 
    356            *         peripheral.
    357            * @retval Counter Register value.
    358            */

   \                                 In section .text, align 2, keep-with-next
    359          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    360          {
    361            /* Check the parameters */
    362            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    363            
    364            /* Get the Counter Register value */
    365            return TIMx->CNT;
   \                     TIM_GetCounter: (+1)
   \   00000000   0x6A40             LDR      R0,[R0, #+36]
   \   00000002   0x4770             BX       LR               ;; return
    366          }
    367          
    368          /**
    369            * @brief  Gets the TIMx Prescaler value.
    370            * @param  TIMx: where x can be 1 and 2 to select the TIM 
    371            *         peripheral.
    372            * @retval Prescaler Register value.
    373            */

   \                                 In section .text, align 2, keep-with-next
    374          uint32_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    375          {
    376            /* Check the parameters */
    377            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    378            
    379            /* Get the Prescaler Register value */
    380            return TIMx->PSC;
   \                     TIM_GetPrescaler: (+1)
   \   00000000   0x6A80             LDR      R0,[R0, #+40]
   \   00000002   0x4770             BX       LR               ;; return
    381          }
    382          
    383          /**
    384            * @brief  Enables or Disables the TIMx Update event.
    385            * @param  TIMx: where x can be 1 and 2 to select the TIM 
    386            *         peripheral.
    387            * @param  NewState: new state of the TIMx UDIS bit
    388            *   This parameter can be: ENABLE or DISABLE.
    389            * @retval None
    390            */

   \                                 In section .text, align 2, keep-with-next
    391          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    392          {
    393            /* Check the parameters */
    394            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    395            assert_param(IS_FUNCTIONAL_STATE(NewState));
    396            
    397            if (NewState != DISABLE)
   \                     TIM_UpdateDisableConfig: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF041 0x0102      ORRNE    R1,R1,#0x2
   \   0000000A   0xF021 0x0102      BICEQ    R1,R1,#0x2
    398            {
    399              /* Set the Update Disable Bit */
    400              TIMx->CR1 |= TIM_CR1_UDIS;
    401            }
    402            else
    403            {
    404              /* Reset the Update Disable Bit */
    405              TIMx->CR1 &= (uint32_t)~((uint32_t)TIM_CR1_UDIS);
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    406            }
    407          }
   \   00000010   0x4770             BX       LR               ;; return
    408          
    409          /**
    410            * @brief  Configures the TIMx Update Request Interrupt source.
    411            * @param  TIMx: where x can be 1 and 2 to select the TIM 
    412            *         peripheral.
    413            * @param  TIM_UpdateSource: specifies the Update source.
    414            *   This parameter can be one of the following values:
    415            *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
    416                                                 or the setting of UG bit, or an update generation
    417                                                 through the slave mode controller.
    418            *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
    419            * @retval None
    420            */

   \                                 In section .text, align 2, keep-with-next
    421          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint32_t TIM_UpdateSource)
    422          {
    423            /* Check the parameters */
    424            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    425            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
    426            
    427            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   \                     TIM_UpdateRequestConfig: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF041 0x0104      ORRNE    R1,R1,#0x4
   \   0000000A   0xF021 0x0104      BICEQ    R1,R1,#0x4
    428            {
    429              /* Set the URS Bit */
    430              TIMx->CR1 |= TIM_CR1_URS;
    431            }
    432            else
    433            {
    434              /* Reset the URS Bit */
    435              TIMx->CR1 &= (uint32_t)~((uint32_t)TIM_CR1_URS);
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    436            }
    437          }
   \   00000010   0x4770             BX       LR               ;; return
    438          
    439          /**
    440            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    441            * @param  TIMx: where x can be  1 and 2 to select the TIM 
    442            *         peripheral.
    443            * @param  NewState: new state of the TIMx peripheral Preload register
    444            *   This parameter can be: ENABLE or DISABLE.
    445            * @retval None
    446            */

   \                                 In section .text, align 2, keep-with-next
    447          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    448          {
    449            /* Check the parameters */
    450            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    451            assert_param(IS_FUNCTIONAL_STATE(NewState));
    452            
    453            if (NewState != DISABLE)
   \                     TIM_ARRPreloadConfig: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF041 0x0180      ORRNE    R1,R1,#0x80
   \   0000000A   0xF021 0x0180      BICEQ    R1,R1,#0x80
    454            {
    455              /* Set the ARR Preload Bit */
    456              TIMx->CR1 |= TIM_CR1_ARPE;
    457            }
    458            else
    459            {
    460              /* Reset the ARR Preload Bit */
    461              TIMx->CR1 &= (uint32_t)~((uint32_t)TIM_CR1_ARPE);
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    462            }
    463          }
   \   00000010   0x4770             BX       LR               ;; return
    464          
    465          /**
    466            * @brief  Selects the TIMx's One Pulse Mode.
    467            * @param  TIMx: where x can be 1 and 2 to select the TIM 
    468            *         peripheral.
    469            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    470            *   This parameter can be one of the following values:
    471            *     @arg TIM_OPMode_Single
    472            *     @arg TIM_OPMode_Repetitive
    473            * @retval None
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint32_t TIM_OPMode)
    476          {
    477            /* Check the parameters */
    478            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    479            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
    480            
    481            /* Reset the OPM Bit */
    482            TIMx->CR1 &= (uint32_t)~((uint32_t)TIM_CR1_OPM);
   \                     TIM_SelectOnePulseMode: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000006   0x6002             STR      R2,[R0, #+0]
    483            /* Configure the OPM Mode */
    484            TIMx->CR1 |= TIM_OPMode;
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A                      REQUIRE ?Subroutine3
   \   0000000A                      ;; // Fall through to label ?Subroutine3
    485          }
    486          
    487          
    488          /**
    489            * @brief  Enables or disables the specified TIM peripheral.
    490            * @param  TIMx: where x can be 1 and 2 and 17to select the TIMx
    491            *         peripheral.
    492            * @param  NewState: new state of the TIMx peripheral.
    493            *         This parameter can be: ENABLE or DISABLE.
    494            * @retval None
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    497          {
    498            /* Check the parameters */
    499            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    500            assert_param(IS_FUNCTIONAL_STATE(NewState));
    501            
    502            if (NewState != DISABLE)
   \                     TIM_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0x0849             LSREQ    R1,R1,#+1
   \   0000000C   0x0049             LSLEQ    R1,R1,#+1
    503            {
    504              /* Enable the TIM Counter */
    505              TIMx->CR1 |= TIM_CR1_CEN;
    506            }
    507            else
    508            {
    509              /* Disable the TIM Counter */
    510              TIMx->CR1 &= (uint32_t)(~((uint32_t)TIM_CR1_CEN));
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    511            }
    512          }
   \   00000010   0x4770             BX       LR               ;; return
    513             
    514          /**
    515            * @}
    516            */
    517          
    518          /** @defgroup TIM_Group2 Output Compare management functions
    519           *  @brief    Output Compare management functions 
    520           *
    521          @verbatim
    522           ===============================================================================
    523                          ##### Output Compare management functions #####
    524           ===============================================================================
    525                  *** TIM Driver: how to use it in Output Compare Mode ***
    526           ===============================================================================
    527              [..] To use the Timer in Output Compare mode, the following steps are mandatory:
    528                   (#) Configure the TIM pins by configuring the corresponding GPIO pins
    529                   (#) Configure the Time base unit as described in the first part of this 
    530                       driver, if needed, else the Timer will run with the default 
    531                       configuration:
    532                       (++) Autoreload value = 0xFFFF.
    533                       (++) Prescaler value = 0x0000.
    534                       (++) Counter mode = Up counting.
    535                   (#) Fill the TIM_OCInitStruct with the desired parameters including:
    536                       (++) The TIM Output Compare mode: TIM_OCMode.
    537                       (++) TIM Output State: TIM_OutputState.
    538                       (++) TIM Pulse value: TIM_Pulse.
    539                       (++) TIM Output Compare Polarity : TIM_OCPolarity.
    540                   (#) Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired 
    541                       channel with the corresponding configuration.
    542                   (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    543              [..]
    544                  (@) All other functions can be used separately to modify, if needed,
    545                    a specific feature of the Timer.
    546                  (@) In case of PWM mode, this function is mandatory:
    547                      TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE).
    548                  (@) If the corresponding interrupt are needed, the user should:
    549                      (#@) Enable the NVIC to use the TIM interrupts.
    550                      (#@) Enable the corresponding interrupt using the function
    551                           TIM_ITConfig(TIMx, TIM_IT_CCx).
    552          
    553          @endverbatim
    554            * @{
    555            */
    556          
    557          /**
    558            * @brief  Initializes the TIMx Channel1 according to the specified
    559            *         parameters in the TIM_OCInitStruct.
    560            * @param  TIMx: where x can be 1 and 2 to select the TIM peripheral.
    561            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    562            *         that contains the configuration information for the specified TIM 
    563            *         peripheral.
    564            * @retval None
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    567          {
   \                     TIM_OC1Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    568            uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    569             
    570            /* Check the parameters */
    571            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    572            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    573            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    574            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    575           /* Disable the Channel 1: Reset the CC1E Bit */
    576            TIMx->CCER &= (uint32_t)(~(uint32_t)TIM_CCER_CC1E);
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0x.... 0x....      BL       ?Subroutine7
    577            /* Get the TIMx CCER register value */
    578            tmpccer = TIMx->CCER;
    579            /* Get the TIMx CR2 register value */
    580            tmpcr2 =  TIMx->CR2;
    581            
    582            /* Get the TIMx CCMR1 register value */
    583            tmpccmrx = TIMx->CCMR1;
    584              
    585            /* Reset the Output Compare Mode Bits */
    586            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR1_OC1M));
    587            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR1_CC1S));
    588          
    589            /* Select the Output Compare Mode */
    590            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000000C   0x6984             LDR      R4,[R0, #+24]
   \   0000000E   0x680D             LDR      R5,[R1, #+0]
   \   00000010   0xF024 0x0473      BIC      R4,R4,#0x73
   \   00000014   0x432C             ORRS     R4,R5,R4
    591            
    592            /* Reset the Output Polarity level */
    593            tmpccer &= (uint32_t)(~((uint32_t)TIM_CCER_CC1P));
    594            /* Set the Output Compare Polarity */
    595            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    596            
    597            /* Set the Output State */
    598            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
   \   00000016   0x68CD             LDR      R5,[R1, #+12]
   \   00000018   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001C   0x432A             ORRS     R2,R5,R2
   \   0000001E   0x684D             LDR      R5,[R1, #+4]
    599              
    600            /* Write to TIMx CR2 */
    601            TIMx->CR2 = tmpcr2;
   \   00000020   0x6043             STR      R3,[R0, #+4]
    602            
    603            /* Write to TIMx CCMR1 */
    604            TIMx->CCMR1 = tmpccmrx;
   \   00000022   0x6184             STR      R4,[R0, #+24]
   \   00000024   0x432A             ORRS     R2,R5,R2
    605          
    606            /* Set the Capture Compare Register value */
    607            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
   \   00000026   0x6889             LDR      R1,[R1, #+8]
   \   00000028   0x6341             STR      R1,[R0, #+52]
    608           
    609            /* Write to TIMx CCER */
    610            TIMx->CCER = tmpccer;
   \   0000002A   0x6202             STR      R2,[R0, #+32]
    611          }
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x6202             STR      R2,[R0, #+32]
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0x6843             LDR      R3,[R0, #+4]
   \   00000006   0x4770             BX       LR
    612          
    613          /**
    614            * @brief  Initializes the TIMx Channel2 according to the specified
    615            *         parameters in the TIM_OCInitStruct.
    616            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    617            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    618            *         that contains the configuration information for the specified TIM 
    619            *         peripheral.
    620            * @retval None
    621            */

   \                                 In section .text, align 2, keep-with-next
    622          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    623          {
   \                     TIM_OC2Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    624            uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    625             
    626            /* Check the parameters */
    627            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    628            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    629            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    630            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    631             /* Disable the Channel 2: Reset the CC2E Bit */
    632            TIMx->CCER &= (uint32_t)(~((uint32_t)TIM_CCER_CC2E));
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000008   0x.... 0x....      BL       ?Subroutine7
    633            
    634            /* Get the TIMx CCER register value */  
    635            tmpccer = TIMx->CCER;
    636            /* Get the TIMx CR2 register value */
    637            tmpcr2 =  TIMx->CR2;
    638            
    639            /* Get the TIMx CCMR1 register value */
    640            tmpccmrx = TIMx->CCMR1;
    641              
    642            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    643            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR1_OC2M));
    644            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR1_CC2S));
    645            
    646            /* Select the Output Compare Mode */
    647            tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000000C   0x6984             LDR      R4,[R0, #+24]
   \   0000000E   0x.... 0x....      BL       ?Subroutine6
    648            
    649            /* Reset the Output Polarity level */
    650            tmpccer &= (uint32_t)(~((uint32_t)TIM_CCER_CC2P));
    651            /* Set the Output Compare Polarity */
    652            tmpccer |= (uint32_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    653            
    654            /* Set the Output State */
    655            tmpccer |= (uint32_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    656              
    657            /* Write to TIMx CR2 */
    658            TIMx->CR2 = tmpcr2;
    659            
    660            /* Write to TIMx CCMR1 */
    661            TIMx->CCMR1 = tmpccmrx;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000012   0x6184             STR      R4,[R0, #+24]
   \   00000014   0xF022 0x0220      BIC      R2,R2,#0x20
    662          
    663            /* Set the Capture Compare Register value */
    664            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
   \   00000018   0x6889             LDR      R1,[R1, #+8]
   \   0000001A   0x6381             STR      R1,[R0, #+56]
   \   0000001C   0x4335             ORRS     R5,R6,R5
   \   0000001E   0xEA42 0x1205      ORR      R2,R2,R5, LSL #+4
    665            
    666            /* Write to TIMx CCER */
    667            TIMx->CCER = tmpccer;
   \   00000022   0x6202             STR      R2,[R0, #+32]
    668          }
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x680D             LDR      R5,[R1, #+0]
   \   00000002   0x684E             LDR      R6,[R1, #+4]
   \   00000004   0xF424 0x44E6      BIC      R4,R4,#0x7300
   \   00000008   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000000C   0x68CD             LDR      R5,[R1, #+12]
   \   0000000E   0x6043             STR      R3,[R0, #+4]
   \   00000010   0x4770             BX       LR
    669          
    670          /**
    671            * @brief  Initializes the TIMx Channel3 according to the specified
    672            *         parameters in the TIM_OCInitStruct.
    673            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    674            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    675            *         that contains the configuration information for the specified TIM 
    676            *         peripheral.
    677            * @retval None
    678            */

   \                                 In section .text, align 2, keep-with-next
    679          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    680          {
   \                     TIM_OC3Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    681            uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    682             
    683            /* Check the parameters */
    684            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    685            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    686            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    687            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    688            /* Disable the Channel 2: Reset the CC2E Bit */
    689            TIMx->CCER &= (uint32_t)(~((uint32_t)TIM_CCER_CC3E));
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF422 0x7280      BIC      R2,R2,#0x100
   \   00000008   0x.... 0x....      BL       ?Subroutine7
    690            
    691            /* Get the TIMx CCER register value */
    692            tmpccer = TIMx->CCER;
    693            /* Get the TIMx CR2 register value */
    694            tmpcr2 =  TIMx->CR2;
    695            
    696            /* Get the TIMx CCMR2 register value */
    697            tmpccmrx = TIMx->CCMR2;
    698              
    699            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    700            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR2_OC3M));
    701            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR2_CC3S));  
    702            /* Select the Output Compare Mode */
    703            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000000C   0x69C4             LDR      R4,[R0, #+28]
   \   0000000E   0x680D             LDR      R5,[R1, #+0]
    704            
    705            /* Reset the Output Polarity level */
    706            tmpccer &= (uint32_t)(~((uint32_t)TIM_CCER_CC3P));
    707            /* Set the Output Compare Polarity */
    708            tmpccer |= (uint32_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    709            
    710            /* Set the Output State */
    711            tmpccer |= (uint32_t)(TIM_OCInitStruct->TIM_OutputState << 8);
   \   00000010   0x684E             LDR      R6,[R1, #+4]
   \   00000012   0xF024 0x0473      BIC      R4,R4,#0x73
   \   00000016   0x432C             ORRS     R4,R5,R4
   \   00000018   0x68CD             LDR      R5,[R1, #+12]
    712              
    713            /* Write to TIMx CR2 */
    714            TIMx->CR2 = tmpcr2;
   \   0000001A   0x6043             STR      R3,[R0, #+4]
    715            
    716            /* Write to TIMx CCMR2 */
    717            TIMx->CCMR2 = tmpccmrx;
   \   0000001C   0x61C4             STR      R4,[R0, #+28]
   \   0000001E   0xF422 0x7200      BIC      R2,R2,#0x200
    718          
    719            /* Set the Capture Compare Register value */
    720            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
   \   00000022   0x6889             LDR      R1,[R1, #+8]
   \   00000024   0x63C1             STR      R1,[R0, #+60]
   \   00000026   0x4335             ORRS     R5,R6,R5
   \   00000028   0xEA42 0x2205      ORR      R2,R2,R5, LSL #+8
    721            
    722            /* Write to TIMx CCER */
    723            TIMx->CCER = tmpccer;
   \   0000002C   0x6202             STR      R2,[R0, #+32]
    724          }
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    725          
    726          /**
    727            * @brief  Initializes the TIMx Channel4 according to the specified
    728            *         parameters in the TIM_OCInitStruct.
    729            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    730            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    731            *         that contains the configuration information for the specified TIM 
    732            *         peripheral.
    733            * @retval None
    734            */

   \                                 In section .text, align 2, keep-with-next
    735          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    736          {
   \                     TIM_OC4Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    737            uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    738             
    739            /* Check the parameters */
    740            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    741            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    742            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    743            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    744            /* Disable the Channel 2: Reset the CC4E Bit */
    745            TIMx->CCER &= (uint32_t)(~((uint32_t)TIM_CCER_CC4E));
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000008   0x.... 0x....      BL       ?Subroutine7
    746            
    747            /* Get the TIMx CCER register value */
    748            tmpccer = TIMx->CCER;
    749            /* Get the TIMx CR2 register value */
    750            tmpcr2 =  TIMx->CR2;
    751            
    752            /* Get the TIMx CCMR2 register value */
    753            tmpccmrx = TIMx->CCMR2;
    754              
    755            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    756            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR2_OC4M));
    757            tmpccmrx &= (uint32_t)(~((uint32_t)TIM_CCMR2_CC4S));
    758            
    759            /* Select the Output Compare Mode */
    760            tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000000C   0x69C4             LDR      R4,[R0, #+28]
   \   0000000E   0x.... 0x....      BL       ?Subroutine6
    761            
    762            /* Reset the Output Polarity level */
    763            tmpccer &= (uint32_t)(~((uint32_t)TIM_CCER_CC4P));
    764            /* Set the Output Compare Polarity */
    765            tmpccer |= (uint32_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    766            
    767            /* Set the Output State */
    768            tmpccer |= (uint32_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    769              
    770            /* Write to TIMx CR2 */
    771            TIMx->CR2 = tmpcr2;
    772            
    773            /* Write to TIMx CCMR2 */  
    774            TIMx->CCMR2 = tmpccmrx;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000012   0x61C4             STR      R4,[R0, #+28]
   \   00000014   0xF422 0x5200      BIC      R2,R2,#0x2000
    775          
    776            /* Set the Capture Compare Register value */
    777            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
   \   00000018   0x6889             LDR      R1,[R1, #+8]
   \   0000001A   0x6401             STR      R1,[R0, #+64]
   \   0000001C   0x4335             ORRS     R5,R6,R5
   \   0000001E   0xEA42 0x3205      ORR      R2,R2,R5, LSL #+12
    778            
    779            /* Write to TIMx CCER */
    780            TIMx->CCER = tmpccer;
   \   00000022   0x6202             STR      R2,[R0, #+32]
    781          }
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    782          
    783          /**
    784            * @brief  Fills each TIM_OCInitStruct member with its default value.
    785            * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
    786            *         be initialized.
    787            * @retval None
    788            */

   \                                 In section .text, align 2, keep-with-next
    789          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    790          {
    791            /* Set the default configuration */
    792            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
   \                     TIM_OCStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    793            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    794            TIM_OCInitStruct->TIM_Pulse = 0x0000000;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    795            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    796          }
   \   0000000A   0x4770             BX       LR               ;; return
    797          
    798          /**
    799            * @brief  Selects the TIM Output Compare Mode.
    800            * @note   This function disables the selected channel before changing the Output
    801            *         Compare Mode.
    802            *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
    803            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    804            * @param  TIM_Channel: specifies the TIM Channel
    805            *   This parameter can be one of the following values:
    806            *     @arg TIM_Channel_1: TIM Channel 1
    807            *     @arg TIM_Channel_2: TIM Channel 2
    808            *     @arg TIM_Channel_3: TIM Channel 3
    809            *     @arg TIM_Channel_4: TIM Channel 4
    810            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
    811            *   This parameter can be one of the following values:
    812            *     @arg TIM_OCMode_Timing
    813            *     @arg TIM_OCMode_Active
    814            *     @arg TIM_OCMode_Toggle
    815            *     @arg TIM_OCMode_PWM1
    816            *     @arg TIM_OCMode_PWM2
    817            *     @arg TIM_ForcedAction_Active
    818            *     @arg TIM_ForcedAction_InActive
    819            * @retval None
    820            */

   \                                 In section .text, align 2, keep-with-next
    821          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint32_t TIM_Channel, uint32_t TIM_OCMode)
    822          {
   \                     TIM_SelectOCxM: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    823            uint32_t tmp = 0;
    824            uint32_t tmp1 = 0;
    825          
    826            /* Check the parameters */
    827            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    828            assert_param(IS_TIM_OCM(TIM_OCMode));
    829            
    830            tmp = (uint32_t) TIMx;
    831            tmp += CCMR_OFFSET;
    832          
    833            tmp1 = CCER_CCE_SET << (uint32_t)TIM_Channel;
    834          
    835            /* Disable the Channel: Reset the CCxE Bit */
    836            TIMx->CCER &= (uint32_t) ~tmp1;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0x2501             MOVS     R5,#+1
   \   00000006   0x408D             LSLS     R5,R5,R1
   \   00000008   0x43AC             BICS     R4,R4,R5
    837          
    838            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2908             CMPNE    R1,#+8
   \   00000010   0xF100 0x0318      ADD      R3,R0,#+24
   \   00000014   0x6204             STR      R4,[R0, #+32]
   \   00000016   0xD108             BNE.N    ??TIM_SelectOCxM_0
    839            {
    840              tmp += (TIM_Channel>>1);
   \   00000018   0xEB03 0x0051      ADD      R0,R3,R1, LSR #+1
    841          
    842              /* Reset the OCxM bits in the CCMRx register */
    843              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xF021 0x0170      BIC      R1,R1,#0x70
   \   00000022   0x6001             STR      R1,[R0, #+0]
    844             
    845              /* Configure the OCxM bits in the CCMRx register */
    846              *(__IO uint32_t *) tmp |= TIM_OCMode;
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x4311             ORRS     R1,R2,R1
   \   00000028   0xE009             B.N      ??TIM_SelectOCxM_1
    847            }
    848            else
    849            {
    850              tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;
   \                     ??TIM_SelectOCxM_0: (+1)
   \   0000002A   0x1F08             SUBS     R0,R1,#+4
   \   0000002C   0xEB03 0x0050      ADD      R0,R3,R0, LSR #+1
    851          
    852              /* Reset the OCxM bits in the CCMRx register */
    853              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0xF421 0x41E0      BIC      R1,R1,#0x7000
   \   00000036   0x6001             STR      R1,[R0, #+0]
    854              
    855              /* Configure the OCxM bits in the CCMRx register */
    856              *(__IO uint32_t *) tmp |= (uint32_t)(TIM_OCMode << 8);
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??TIM_SelectOCxM_1: (+1)
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    857            }
    858          }
   \   00000040   0xBD30             POP      {R4,R5,PC}       ;; return
    859          
    860          /**
    861            * @brief  Sets the TIMx Capture Compare1 Register value
    862            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    863            * @param  Compare1: specifies the Capture Compare1 register new value.
    864            * @retval None
    865            */

   \                                 In section .text, align 2, keep-with-next
    866          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
    867          {
    868            /* Check the parameters */
    869            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    870            
    871            /* Set the Capture Compare1 Register value */
    872            TIMx->CCR1 = Compare1;
   \                     TIM_SetCompare1: (+1)
   \   00000000   0x6341             STR      R1,[R0, #+52]
    873          }
   \   00000002   0x4770             BX       LR               ;; return
    874          
    875          /**
    876            * @brief  Sets the TIMx Capture Compare2 Register value
    877            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    878            * @param  Compare2: specifies the Capture Compare2 register new value.
    879            * @retval None
    880            */

   \                                 In section .text, align 2, keep-with-next
    881          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
    882          {
    883            /* Check the parameters */
    884            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    885            
    886            /* Set the Capture Compare2 Register value */
    887            TIMx->CCR2 = Compare2;
   \                     TIM_SetCompare2: (+1)
   \   00000000   0x6381             STR      R1,[R0, #+56]
    888          }
   \   00000002   0x4770             BX       LR               ;; return
    889          
    890          /**
    891            * @brief  Sets the TIMx Capture Compare3 Register value
    892            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    893            * @param  Compare3: specifies the Capture Compare3 register new value.
    894            * @retval None
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
    897          {
    898            /* Check the parameters */
    899            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    900            
    901            /* Set the Capture Compare3 Register value */
    902            TIMx->CCR3 = Compare3;
   \                     TIM_SetCompare3: (+1)
   \   00000000   0x63C1             STR      R1,[R0, #+60]
    903          }
   \   00000002   0x4770             BX       LR               ;; return
    904          
    905          /**
    906            * @brief  Sets the TIMx Capture Compare4 Register value
    907            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    908            * @param  Compare4: specifies the Capture Compare4 register new value.
    909            * @retval None
    910            */

   \                                 In section .text, align 2, keep-with-next
    911          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
    912          {
    913            /* Check the parameters */
    914            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    915            
    916            /* Set the Capture Compare4 Register value */
    917            TIMx->CCR4 = Compare4;
   \                     TIM_SetCompare4: (+1)
   \   00000000   0x6401             STR      R1,[R0, #+64]
    918          }
   \   00000002   0x4770             BX       LR               ;; return
    919          
    920          /**
    921            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
    922            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    923            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
    924            *   This parameter can be one of the following values:
    925            *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
    926            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
    927            * @retval None
    928            */

   \                                 In section .text, align 2, keep-with-next
    929          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint32_t TIM_ForcedAction)
    930          {
    931            uint32_t tmpccmr1 = 0;
    932            /* Check the parameters */
    933            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    934            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    935            tmpccmr1 = TIMx->CCMR1;
    936            /* Reset the OC1M Bits */
    937            tmpccmr1 &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
    938            /* Configure The Forced output Mode */
    939            tmpccmr1 |= TIM_ForcedAction;
    940            /* Write to TIMx CCMR1 register */
    941            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_ForcedOC1Config: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x....             B.N      ?Subroutine4
    942          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x4311             ORRS     R1,R1,R2
   \   00000002   0x6181             STR      R1,[R0, #+24]
   \   00000004   0x4770             BX       LR               ;; return
    943           
    944          /**
    945            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
    946            * @param  TIMx: where x can be 1 or 2 to select the TIM 
    947            *   peripheral.
    948            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
    949            *   This parameter can be one of the following values:
    950            *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
    951            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
    952            * @retval None
    953            */

   \                                 In section .text, align 2, keep-with-next
    954          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint32_t TIM_ForcedAction)
    955          {
    956            uint32_t tmpccmr1 = 0;
    957            
    958            /* Check the parameters */
    959            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    960            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    961            
    962            tmpccmr1 = TIMx->CCMR1;
    963            /* Reset the OC2M Bits */
    964            tmpccmr1 &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
    965            /* Configure The Forced output Mode */
    966            tmpccmr1 |= (uint32_t)(TIM_ForcedAction << 8);
    967            /* Write to TIMx CCMR1 register */
    968            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_ForcedOC2Config: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF422 0x42E0      BIC      R2,R2,#0x7000
   \   00000006   0x....             B.N      ?Subroutine1
    969          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000004   0x6181             STR      R1,[R0, #+24]
   \   00000006   0x4770             BX       LR               ;; return
    970          
    971          /**
    972            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
    973            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
    974            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
    975            *   This parameter can be one of the following values:
    976            *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
    977            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
    978            * @retval None
    979            */

   \                                 In section .text, align 2, keep-with-next
    980          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint32_t TIM_ForcedAction)
    981          {
    982            uint32_t tmpccmr2 = 0;
    983            
    984            /* Check the parameters */
    985            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    986            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    987            
    988            tmpccmr2 = TIMx->CCMR2;
    989            /* Reset the OC1M Bits */
    990            tmpccmr2 &= (uint32_t)~((uint32_t)TIM_CCMR2_OC3M);
    991            /* Configure The Forced output Mode */
    992            tmpccmr2 |= TIM_ForcedAction;
    993            /* Write to TIMx CCMR2 register */
    994            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_ForcedOC3Config: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x....             B.N      ?Subroutine5
    995          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4311             ORRS     R1,R1,R2
   \   00000002   0x61C1             STR      R1,[R0, #+28]
   \   00000004   0x4770             BX       LR               ;; return
    996          
    997          /**
    998            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
    999            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1000            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1001            *   This parameter can be one of the following values:
   1002            *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1003            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1004            * @retval None
   1005            */

   \                                 In section .text, align 2, keep-with-next
   1006          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint32_t TIM_ForcedAction)
   1007          {
   1008            uint32_t tmpccmr2 = 0;
   1009            /* Check the parameters */
   1010            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1011            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1012            
   1013            tmpccmr2 = TIMx->CCMR2;
   1014            /* Reset the OC2M Bits */
   1015            tmpccmr2 &= (uint32_t)~((uint32_t)TIM_CCMR2_OC4M);
   1016            /* Configure The Forced output Mode */
   1017            tmpccmr2 |= (uint32_t)(TIM_ForcedAction << 8);
   1018            /* Write to TIMx CCMR2 register */
   1019            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_ForcedOC4Config: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF422 0x42E0      BIC      R2,R2,#0x7000
   \   00000006   0x....             B.N      ?Subroutine2
   1020          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000004   0x61C1             STR      R1,[R0, #+28]
   \   00000006   0x4770             BX       LR               ;; return
   1021          
   1022          /**
   1023            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1024            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1025            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1026            *   This parameter can be one of the following values:
   1027            *     @arg TIM_OCPreload_Enable
   1028            *     @arg TIM_OCPreload_Disable
   1029            * @retval None
   1030            */

   \                                 In section .text, align 2, keep-with-next
   1031          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPreload)
   1032          {
   1033            uint32_t tmpccmr1 = 0;
   1034            /* Check the parameters */
   1035            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1036            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1037            
   1038            tmpccmr1 = TIMx->CCMR1;
   1039            /* Reset the OC1PE Bit */
   1040            tmpccmr1 &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1PE);
   1041            /* Enable or Disable the Output Compare Preload feature */
   1042            tmpccmr1 |= TIM_OCPreload;
   1043            /* Write to TIMx CCMR1 register */
   1044            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC1PreloadConfig: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000006                      REQUIRE ?Subroutine4
   \   00000006                      ;; // Fall through to label ?Subroutine4
   1045          }
   1046          
   1047          /**
   1048            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1049            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1050            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1051            *   This parameter can be one of the following values:
   1052            *     @arg TIM_OCPreload_Enable
   1053            *     @arg TIM_OCPreload_Disable
   1054            * @retval None
   1055            */

   \                                 In section .text, align 2, keep-with-next
   1056          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPreload)
   1057          {
   1058            uint32_t tmpccmr1 = 0;
   1059            /* Check the parameters */
   1060            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1061            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1062            
   1063            tmpccmr1 = TIMx->CCMR1;
   1064            /* Reset the OC2PE Bit */
   1065            tmpccmr1 &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2PE);
   1066            /* Enable or Disable the Output Compare Preload feature */
   1067            tmpccmr1 |= (uint32_t)(TIM_OCPreload << 8);
   1068            /* Write to TIMx CCMR1 register */
   1069            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC2PreloadConfig: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000006                      REQUIRE ?Subroutine1
   \   00000006                      ;; // Fall through to label ?Subroutine1
   1070          }
   1071          
   1072          /**
   1073            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1074            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1075            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1076            *   This parameter can be one of the following values:
   1077            *     @arg TIM_OCPreload_Enable
   1078            *     @arg TIM_OCPreload_Disable
   1079            * @retval None
   1080            */

   \                                 In section .text, align 2, keep-with-next
   1081          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPreload)
   1082          {
   1083            uint32_t tmpccmr2 = 0;
   1084            
   1085            /* Check the parameters */
   1086            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1087            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1088            
   1089            tmpccmr2 = TIMx->CCMR2;
   1090            /* Reset the OC3PE Bit */
   1091            tmpccmr2 &= (uint32_t)~((uint32_t)TIM_CCMR2_OC3PE);
   1092            /* Enable or Disable the Output Compare Preload feature */
   1093            tmpccmr2 |= TIM_OCPreload;
   1094            /* Write to TIMx CCMR2 register */
   1095            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC3PreloadConfig: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000006                      REQUIRE ?Subroutine5
   \   00000006                      ;; // Fall through to label ?Subroutine5
   1096          }
   1097          
   1098          /**
   1099            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1100            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1101            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1102            *   This parameter can be one of the following values:
   1103            *     @arg TIM_OCPreload_Enable
   1104            *     @arg TIM_OCPreload_Disable
   1105            * @retval None
   1106            */

   \                                 In section .text, align 2, keep-with-next
   1107          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPreload)
   1108          {
   1109            uint32_t tmpccmr2 = 0;
   1110            
   1111            /* Check the parameters */
   1112            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1113            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1114            
   1115            tmpccmr2 = TIMx->CCMR2;
   1116            /* Reset the OC4PE Bit */
   1117            tmpccmr2 &= (uint32_t)~((uint32_t)TIM_CCMR2_OC4PE);
   1118            /* Enable or Disable the Output Compare Preload feature */
   1119            tmpccmr2 |= (uint32_t)(TIM_OCPreload << 8);
   1120            /* Write to TIMx CCMR2 register */
   1121            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC4PreloadConfig: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000006                      REQUIRE ?Subroutine2
   \   00000006                      ;; // Fall through to label ?Subroutine2
   1122          }
   1123          
   1124          /**
   1125            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1126            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1127            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1128            *   This parameter can be one of the following values:
   1129            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1130            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1131            * @retval None
   1132            */

   \                                 In section .text, align 2, keep-with-next
   1133          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCFast)
   1134          {
   1135            uint32_t tmpccmr1 = 0;
   1136            
   1137            /* Check the parameters */
   1138            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1139            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1140            
   1141            /* Get the TIMx CCMR1 register value */
   1142            tmpccmr1 = TIMx->CCMR1;
   1143            /* Reset the OC1FE Bit */
   1144            tmpccmr1 &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1FE);
   1145            /* Enable or Disable the Output Compare Fast Bit */
   1146            tmpccmr1 |= TIM_OCFast;
   1147            /* Write to TIMx CCMR1 */
   1148            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC1FastConfig: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000006   0x....             B.N      ?Subroutine4
   1149          }
   1150          
   1151          /**
   1152            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1153            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1154            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1155            *   This parameter can be one of the following values:
   1156            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1157            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1158            * @retval None
   1159            */

   \                                 In section .text, align 2, keep-with-next
   1160          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCFast)
   1161          {
   1162            uint32_t tmpccmr1 = 0;
   1163            
   1164            /* Check the parameters */
   1165            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1166            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1167            
   1168            /* Get the TIMx CCMR1 register value */
   1169            tmpccmr1 = TIMx->CCMR1;
   1170            /* Reset the OC2FE Bit */
   1171            tmpccmr1 &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2FE);
   1172            /* Enable or Disable the Output Compare Fast Bit */
   1173            tmpccmr1 |= (uint32_t)(TIM_OCFast << 8);
   1174            /* Write to TIMx CCMR1 */
   1175            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC2FastConfig: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000006   0x....             B.N      ?Subroutine1
   1176          }
   1177          
   1178          /**
   1179            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1180            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1181            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1182            *   This parameter can be one of the following values:
   1183            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1184            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1185            * @retval None
   1186            */

   \                                 In section .text, align 2, keep-with-next
   1187          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCFast)
   1188          {
   1189            uint32_t tmpccmr2 = 0;
   1190            
   1191            /* Check the parameters */
   1192            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1193            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1194            
   1195            /* Get the TIMx CCMR2 register value */
   1196            tmpccmr2 = TIMx->CCMR2;
   1197            /* Reset the OC3FE Bit */
   1198            tmpccmr2 &= (uint32_t)~((uint32_t)TIM_CCMR2_OC3FE);
   1199            /* Enable or Disable the Output Compare Fast Bit */
   1200            tmpccmr2 |= TIM_OCFast;
   1201            /* Write to TIMx CCMR2 */
   1202            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC3FastConfig: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000006   0x....             B.N      ?Subroutine5
   1203          }
   1204          
   1205          /**
   1206            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1207            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1208            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1209            *   This parameter can be one of the following values:
   1210            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1211            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1212            * @retval None
   1213            */

   \                                 In section .text, align 2, keep-with-next
   1214          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCFast)
   1215          {
   1216            uint32_t tmpccmr2 = 0;
   1217            
   1218            /* Check the parameters */
   1219            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1220            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1221            
   1222            /* Get the TIMx CCMR2 register value */
   1223            tmpccmr2 = TIMx->CCMR2;
   1224            /* Reset the OC4FE Bit */
   1225            tmpccmr2 &= (uint32_t)~((uint32_t)TIM_CCMR2_OC4FE);
   1226            /* Enable or Disable the Output Compare Fast Bit */
   1227            tmpccmr2 |= (uint32_t)(TIM_OCFast << 8);
   1228            /* Write to TIMx CCMR2 */
   1229            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC4FastConfig: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000006   0x....             B.N      ?Subroutine2
   1230          }
   1231          
   1232          /**
   1233            * @brief  Configures the TIMx channel 1 polarity.
   1234            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1235            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1236            *   This parmeter can be one of the following values:
   1237            *     @arg TIM_OCPolarity_High: Output Compare active high
   1238            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1239            * @retval None
   1240            */

   \                                 In section .text, align 2, keep-with-next
   1241          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPolarity)
   1242          {
   1243            uint32_t tmpccer = 0;
   1244            
   1245            /* Check the parameters */
   1246            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1247            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1248            
   1249            tmpccer = TIMx->CCER;
   1250            /* Set or Reset the CC1P Bit */
   1251            tmpccer &= (uint32_t)~((uint32_t)TIM_CCER_CC1P);
   1252            tmpccer |= TIM_OCPolarity;
   1253            /* Write to TIMx CCER register */
   1254            TIMx->CCER = tmpccer;
   \                     TIM_OC1PolarityConfig: (+1)
   \   00000000   0x6A02             LDR      R2,[R0, #+32]
   \   00000002   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6201             STR      R1,[R0, #+32]
   1255          }
   \   0000000A   0x4770             BX       LR               ;; return
   1256          
   1257          /**
   1258            * @brief  Configures the TIMx channel 2 polarity.
   1259            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1260            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1261            *   This parmeter can be one of the following values:
   1262            *     @arg TIM_OCPolarity_High: Output Compare active high
   1263            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1264            * @retval None
   1265            */

   \                                 In section .text, align 2, keep-with-next
   1266          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPolarity)
   1267          {
   1268            uint32_t tmpccer = 0;
   1269            
   1270            /* Check the parameters */
   1271            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1272            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1273            
   1274            tmpccer = TIMx->CCER;
   1275            /* Set or Reset the CC2P Bit */
   1276            tmpccer &= (uint32_t)~((uint32_t)TIM_CCER_CC2P);
   1277            tmpccer |= (uint32_t)(TIM_OCPolarity << 4);
   1278            /* Write to TIMx CCER register */
   1279            TIMx->CCER = tmpccer;
   \                     TIM_OC2PolarityConfig: (+1)
   \   00000000   0x6A02             LDR      R2,[R0, #+32]
   \   00000002   0xF022 0x0220      BIC      R2,R2,#0x20
   \   00000006   0xEA42 0x1101      ORR      R1,R2,R1, LSL #+4
   \   0000000A   0x6201             STR      R1,[R0, #+32]
   1280          }
   \   0000000C   0x4770             BX       LR               ;; return
   1281          
   1282          /**
   1283            * @brief  Configures the TIMx channel 3 polarity.
   1284            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1285            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1286            *   This parmeter can be one of the following values:
   1287            *     @arg TIM_OCPolarity_High: Output Compare active high
   1288            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1289            * @retval None
   1290            */

   \                                 In section .text, align 2, keep-with-next
   1291          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPolarity)
   1292          {
   1293            uint32_t tmpccer = 0;
   1294            
   1295            /* Check the parameters */
   1296            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1297            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1298            
   1299            tmpccer = TIMx->CCER;
   1300            /* Set or Reset the CC3P Bit */
   1301            tmpccer &= (uint32_t)~((uint32_t)TIM_CCER_CC3P);
   1302            tmpccer |= (uint32_t)(TIM_OCPolarity << 8);
   1303            /* Write to TIMx CCER register */
   1304            TIMx->CCER = tmpccer;
   \                     TIM_OC3PolarityConfig: (+1)
   \   00000000   0x6A02             LDR      R2,[R0, #+32]
   \   00000002   0xF422 0x7200      BIC      R2,R2,#0x200
   \   00000006   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   0000000A   0x6201             STR      R1,[R0, #+32]
   1305          }
   \   0000000C   0x4770             BX       LR               ;; return
   1306          
   1307          /**
   1308            * @brief  Configures the TIMx channel 4 polarity.
   1309            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1310            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1311            *   This parmeter can be one of the following values:
   1312            *     @arg TIM_OCPolarity_High: Output Compare active high
   1313            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1314            * @retval None
   1315            */

   \                                 In section .text, align 2, keep-with-next
   1316          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint32_t TIM_OCPolarity)
   1317          {
   1318            uint32_t tmpccer = 0;
   1319            
   1320            /* Check the parameters */
   1321            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1322            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1323            
   1324            tmpccer = TIMx->CCER;
   1325            /* Set or Reset the CC4P Bit */
   1326            tmpccer &= (uint32_t)~((uint32_t)TIM_CCER_CC4P);
   1327            tmpccer |= (uint32_t)(TIM_OCPolarity << 12);
   1328            /* Write to TIMx CCER register */
   1329            TIMx->CCER = tmpccer;
   \                     TIM_OC4PolarityConfig: (+1)
   \   00000000   0x6A02             LDR      R2,[R0, #+32]
   \   00000002   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000006   0xEA42 0x3101      ORR      R1,R2,R1, LSL #+12
   \   0000000A   0x6201             STR      R1,[R0, #+32]
   1330          }
   \   0000000C   0x4770             BX       LR               ;; return
   1331          
   1332          /**
   1333            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1334            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1335            * @param  TIM_Channel: specifies the TIM Channel
   1336            *   This parameter can be one of the following values:
   1337            *     @arg TIM_Channel_1: TIM Channel 1
   1338            *     @arg TIM_Channel_2: TIM Channel 2
   1339            *     @arg TIM_Channel_3: TIM Channel 3
   1340            *     @arg TIM_Channel_4: TIM Channel 4
   1341            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1342            *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1343            * @retval None
   1344            */

   \                                 In section .text, align 2, keep-with-next
   1345          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint32_t TIM_Channel, uint32_t TIM_CCx)
   1346          {
   \                     TIM_CCxCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1347            uint32_t tmp = 0;
   1348          
   1349            /* Check the parameters */
   1350            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
   1351            assert_param(IS_TIM_CCX(TIM_CCx));
   1352          
   1353            tmp = CCER_CCE_SET << TIM_Channel;
   1354          
   1355            /* Reset the CCxE Bit */
   1356            TIMx->CCER &= (uint32_t)~ tmp;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x6203             STR      R3,[R0, #+32]
   1357          
   1358            /* Set or reset the CCxE Bit */ 
   1359            TIMx->CCER |=  (uint32_t)(TIM_CCx << TIM_Channel);
   \   0000000C   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000010   0x6A03             LDR      R3,[R0, #+32]
   \   00000012   0x4319             ORRS     R1,R1,R3
   \   00000014   0x6201             STR      R1,[R0, #+32]
   1360          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1361          
   1362          /**
   1363            * @}
   1364            */
   1365          
   1366          /** @defgroup TIM_Group3 Input Capture management functions
   1367           *  @brief    Input Capture management functions 
   1368           *
   1369          @verbatim
   1370           ===============================================================================
   1371                         ##### Input Capture management functions #####
   1372           ===============================================================================
   1373             
   1374                    *** TIM Driver: how to use it in Input Capture Mode ***
   1375           ===============================================================================
   1376              [..] To use the Timer in Input Capture mode, the following steps are mandatory:
   1377                   (#) Configure the TIM pins by configuring the corresponding GPIO pins.
   1378                   (#) Configure the Time base unit as described in the first part of this 
   1379                       driver, if needed, else the Timer will run with the default configuration:
   1380                       (++) Autoreload value = 0xFFFF.
   1381                       (++) Prescaler value = 0x0000.
   1382                       (++) Counter mode = Up counting.
   1383                   (#) Fill the TIM_ICInitStruct with the desired parameters including:
   1384                       (++) TIM Channel: TIM_Channel.
   1385                       (++) TIM Input Capture polarity: TIM_ICPolarity.
   1386                       (++) TIM Input Capture selection: TIM_ICSelection.
   1387                       (++) TIM Input Capture Prescaler: TIM_ICPrescaler.
   1388                       (++) TIM Input CApture filter value: TIM_ICFilter.
   1389                   (#) Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired 
   1390                       channel with the corresponding configuration and to measure only 
   1391                       frequency or duty cycle of the input signal,or, Call 
   1392                       TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) to configure the desired 
   1393                       channels with the corresponding configuration and to measure the 
   1394                       frequency and the duty cycle of the input signal.
   1395                   (#) Enable the NVIC to read the measured frequency.
   1396                   (#) Enable the corresponding interrupt to read 
   1397                       the Captured value, using the function TIM_ITConfig(TIMx, TIM_IT_CCx).
   1398                   (#) Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1399                   (#) Use TIM_GetCapturex(TIMx); to read the captured value.
   1400              [..]
   1401                  (@) All other functions can be used separately to modify, if needed,
   1402                      a specific feature of the Timer. 
   1403          
   1404          @endverbatim
   1405            * @{
   1406            */
   1407          
   1408          /**
   1409            * @brief  Initializes the TIM peripheral according to the specified
   1410            *         parameters in the TIM_ICInitStruct.
   1411            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1412            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   1413            *         that contains the configuration information for the specified TIM 
   1414            *         peripheral.
   1415            * @retval None
   1416            */

   \                                 In section .text, align 2, keep-with-next
   1417          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1418          {
   \                     TIM_ICInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
   1419            /* Check the parameters */
   1420            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1421            assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
   1422            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   1423            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   1424            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   1425            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   1426          
   1427            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \   00000006   0x6869             LDR      R1,[R5, #+4]
   \   00000008   0x68AA             LDR      R2,[R5, #+8]
   \   0000000A   0x692B             LDR      R3,[R5, #+16]
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0xB938             CBNZ.N   R0,??TIM_ICInit_0
   1428            {
   1429              /* TI1 Configuration */
   1430              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1431                         TIM_ICInitStruct->TIM_ICSelection,
   1432                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       TI1_Config
   1433              /* Set the Input Capture Prescaler value */
   1434              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000016   0x68E9             LDR      R1,[R5, #+12]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000001E   0x....             B.N      TIM_SetIC1Prescaler
   1435            }
   1436            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ICInit_0: (+1)
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xD107             BNE.N    ??TIM_ICInit_1
   1437            {
   1438              /* TI2 Configuration */
   1439              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1440                         TIM_ICInitStruct->TIM_ICSelection,
   1441                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       TI2_Config
   1442              /* Set the Input Capture Prescaler value */
   1443              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000002A   0x68E9             LDR      R1,[R5, #+12]
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000032   0x....             B.N      TIM_SetIC2Prescaler
   1444            }
   1445            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   \                     ??TIM_ICInit_1: (+1)
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0x6A20             LDR      R0,[R4, #+32]
   \   00000038   0xD116             BNE.N    ??TIM_ICInit_2
   1446            {
   1447              /* TI3 Configuration */
   1448              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1449                         TIM_ICInitStruct->TIM_ICSelection,
   1450                         TIM_ICInitStruct->TIM_ICFilter);
   \   0000003A   0xF420 0x7080      BIC      R0,R0,#0x100
   \   0000003E   0x6220             STR      R0,[R4, #+32]
   \   00000040   0x69E0             LDR      R0,[R4, #+28]
   \   00000042   0x6A26             LDR      R6,[R4, #+32]
   \   00000044   0xF020 0x00F3      BIC      R0,R0,#0xF3
   \   00000048   0x4310             ORRS     R0,R2,R0
   \   0000004A   0xEA40 0x1003      ORR      R0,R0,R3, LSL #+4
   \   0000004E   0x61E0             STR      R0,[R4, #+28]
   \   00000050   0xF426 0x7000      BIC      R0,R6,#0x200
   \   00000054   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000058   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000005C   0x6220             STR      R0,[R4, #+32]
   1451              /* Set the Input Capture Prescaler value */
   1452              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x68E9             LDR      R1,[R5, #+12]
   \   00000062   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000066   0x....             B.N      TIM_SetIC3Prescaler
   1453            }
   1454            else
   1455            {
   1456              /* TI4 Configuration */
   1457              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1458                         TIM_ICInitStruct->TIM_ICSelection,
   1459                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_ICInit_2: (+1)
   \   00000068   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   0000006C   0x6220             STR      R0,[R4, #+32]
   \   0000006E   0x69E0             LDR      R0,[R4, #+28]
   \   00000070   0x6A26             LDR      R6,[R4, #+32]
   \   00000072   0xF420 0x4073      BIC      R0,R0,#0xF300
   \   00000076   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \   0000007A   0xEA40 0x3003      ORR      R0,R0,R3, LSL #+12
   \   0000007E   0x61E0             STR      R0,[R4, #+28]
   \   00000080   0xF426 0x7000      BIC      R0,R6,#0x200
   \   00000084   0xEA40 0x3001      ORR      R0,R0,R1, LSL #+12
   \   00000088   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000008C   0x6220             STR      R0,[R4, #+32]
   1460              /* Set the Input Capture Prescaler value */
   1461              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x68E9             LDR      R1,[R5, #+12]
   \   00000092   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000096   0x....             B.N      TIM_SetIC4Prescaler
   1462            }
   1463          }
   1464          
   1465          /**
   1466            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1467            * @param  TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure which will
   1468            *         be initialized.
   1469            * @retval None
   1470            */

   \                                 In section .text, align 2, keep-with-next
   1471          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1472          {
   1473            /* Set the default configuration */
   1474            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   \                     TIM_ICStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1475            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000004   0x6041             STR      R1,[R0, #+4]
   1476            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x6081             STR      R1,[R0, #+8]
   1477            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1478            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   \   0000000E   0x6101             STR      R1,[R0, #+16]
   1479          }
   \   00000010   0x4770             BX       LR               ;; return
   1480          
   1481          /**
   1482            * @brief  Configures the TIM peripheral according to the specified
   1483            *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
   1484            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1485            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   1486            *         that contains the configuration information for the specified TIM 
   1487            *         peripheral.
   1488            * @retval None
   1489            */

   \                                 In section .text, align 2, keep-with-next
   1490          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1491          {
   \                     TIM_PWMIConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
   1492            uint32_t icoppositepolarity = TIM_ICPolarity_Rising;
   1493            uint32_t icoppositeselection = TIM_ICSelection_DirectTI;
   1494            /* Check the parameters */
   1495            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1496            /* Select the Opposite Input Polarity */
   1497            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   \   00000006   0x6869             LDR      R1,[R5, #+4]
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2701             MOVS     R7,#+1
   \   0000000C   0xB901             CBNZ.N   R1,??TIM_PWMIConfig_0
   1498            {
   1499              icoppositepolarity = TIM_ICPolarity_Falling;
   \   0000000E   0x2602             MOVS     R6,#+2
   1500            }
   1501            else
   1502            {
   1503              icoppositepolarity = TIM_ICPolarity_Rising;
   1504            }
   1505            /* Select the Opposite Input */
   1506            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   \                     ??TIM_PWMIConfig_0: (+1)
   \   00000010   0x68AA             LDR      R2,[R5, #+8]
   1507            {
   1508              icoppositeselection = TIM_ICSelection_IndirectTI;
   1509            }
   1510            else
   1511            {
   1512              icoppositeselection = TIM_ICSelection_DirectTI;
   1513            }
   1514            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x692B             LDR      R3,[R5, #+16]
   \   00000016   0x2A01             CMP      R2,#+1
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2702             MOVEQ    R7,#+2
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xD110             BNE.N    ??TIM_PWMIConfig_1
   1515            {
   1516              /* TI1 Configuration */
   1517              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1518                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000022   0x.... 0x....      BL       TI1_Config
   1519              /* Set the Input Capture Prescaler value */
   1520              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000026   0x68E9             LDR      R1,[R5, #+12]
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       TIM_SetIC1Prescaler
   1521              /* TI2 Configuration */
   1522              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   0000002E   0x692B             LDR      R3,[R5, #+16]
   \   00000030   0x463A             MOV      R2,R7
   \   00000032   0x4631             MOV      R1,R6
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       TI2_Config
   1523              /* Set the Input Capture Prescaler value */
   1524              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000003A   0x68E9             LDR      R1,[R5, #+12]
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000042   0x....             B.N      TIM_SetIC2Prescaler
   1525            }
   1526            else
   1527            { 
   1528              /* TI2 Configuration */
   1529              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1530                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_PWMIConfig_1: (+1)
   \   00000044   0x.... 0x....      BL       TI2_Config
   1531              /* Set the Input Capture Prescaler value */
   1532              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000048   0x68E9             LDR      R1,[R5, #+12]
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       TIM_SetIC2Prescaler
   1533              /* TI1 Configuration */
   1534              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   00000050   0x692B             LDR      R3,[R5, #+16]
   \   00000052   0x463A             MOV      R2,R7
   \   00000054   0x4631             MOV      R1,R6
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       TI1_Config
   1535              /* Set the Input Capture Prescaler value */
   1536              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000005C   0x68E9             LDR      R1,[R5, #+12]
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000064   0x....             B.N      TIM_SetIC1Prescaler
   1537            }
   1538          }
   1539          
   1540          /**
   1541            * @brief  Gets the TIMx Input Capture 1 value.
   1542            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1543            * @retval Capture Compare 1 Register value.
   1544            */

   \                                 In section .text, align 2, keep-with-next
   1545          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   1546          {
   1547            /* Check the parameters */
   1548            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1549            
   1550            /* Get the Capture 1 Register value */
   1551            return TIMx->CCR1;
   \                     TIM_GetCapture1: (+1)
   \   00000000   0x6B40             LDR      R0,[R0, #+52]
   \   00000002   0x4770             BX       LR               ;; return
   1552          }
   1553          
   1554          /**
   1555            * @brief  Gets the TIMx Input Capture 2 value.
   1556            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1557            * @retval Capture Compare 2 Register value.
   1558            */

   \                                 In section .text, align 2, keep-with-next
   1559          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   1560          {
   1561            /* Check the parameters */
   1562            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1563            
   1564            /* Get the Capture 2 Register value */
   1565            return TIMx->CCR2;
   \                     TIM_GetCapture2: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   1566          }
   1567          
   1568          /**
   1569            * @brief  Gets the TIMx Input Capture 3 value.
   1570            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1571            * @retval Capture Compare 3 Register value.
   1572            */

   \                                 In section .text, align 2, keep-with-next
   1573          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   1574          {
   1575            /* Check the parameters */
   1576            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1577            
   1578            /* Get the Capture 3 Register value */
   1579            return TIMx->CCR3;
   \                     TIM_GetCapture3: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1580          }
   1581          
   1582          /**
   1583            * @brief  Gets the TIMx Input Capture 4 value.
   1584            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1585            * @retval Capture Compare 4 Register value.
   1586            */

   \                                 In section .text, align 2, keep-with-next
   1587          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   1588          {
   1589            /* Check the parameters */
   1590            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1591            
   1592            /* Get the Capture 4 Register value */
   1593            return TIMx->CCR4;
   \                     TIM_GetCapture4: (+1)
   \   00000000   0x6C00             LDR      R0,[R0, #+64]
   \   00000002   0x4770             BX       LR               ;; return
   1594          }
   1595          
   1596          /**
   1597            * @brief  Sets the TIMx Input Capture 1 prescaler.
   1598            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1599            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   1600            *   This parameter can be one of the following values:
   1601            *     @arg TIM_ICPSC_DIV1: no prescaler
   1602            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1603            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1604            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1605            * @retval None
   1606            */

   \                                 In section .text, align 2, keep-with-next
   1607          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint32_t TIM_ICPSC)
   1608          {
   1609            /* Check the parameters */
   1610            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1611            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1612            
   1613            /* Reset the IC1PSC Bits */
   1614            TIMx->CCMR1 &= (uint32_t)~((uint32_t)TIM_CCMR1_IC1PSC);
   \                     TIM_SetIC1Prescaler: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000006   0x6182             STR      R2,[R0, #+24]
   1615            /* Set the IC1PSC value */
   1616            TIMx->CCMR1 |= TIM_ICPSC;
   \   00000008   0x6982             LDR      R2,[R0, #+24]
   \   0000000A   0x....             B.N      ?Subroutine4
   1617          }
   1618          
   1619          /**
   1620            * @brief  Sets the TIMx Input Capture 2 prescaler.
   1621            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1622            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   1623            *   This parameter can be one of the following values:
   1624            *     @arg TIM_ICPSC_DIV1: no prescaler
   1625            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1626            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1627            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1628            * @retval None
   1629            */

   \                                 In section .text, align 2, keep-with-next
   1630          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint32_t TIM_ICPSC)
   1631          {
   1632            /* Check the parameters */
   1633            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1634            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1635            
   1636            /* Reset the IC2PSC Bits */
   1637            TIMx->CCMR1 &= (uint32_t)~((uint32_t)TIM_CCMR1_IC2PSC);
   \                     TIM_SetIC2Prescaler: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xF422 0x6240      BIC      R2,R2,#0xC00
   \   00000006   0x6182             STR      R2,[R0, #+24]
   1638            /* Set the IC2PSC value */
   1639            TIMx->CCMR1 |= (uint32_t)(TIM_ICPSC << 8);
   \   00000008   0x6982             LDR      R2,[R0, #+24]
   \   0000000A   0x....             B.N      ?Subroutine1
   1640          }
   1641          
   1642          /**
   1643            * @brief  Sets the TIMx Input Capture 3 prescaler.
   1644            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1645            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   1646            *   This parameter can be one of the following values:
   1647            *     @arg TIM_ICPSC_DIV1: no prescaler
   1648            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1649            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1650            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1651            * @retval None
   1652            */

   \                                 In section .text, align 2, keep-with-next
   1653          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint32_t TIM_ICPSC)
   1654          {
   1655            /* Check the parameters */
   1656            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1657            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1658            
   1659            /* Reset the IC3PSC Bits */
   1660            TIMx->CCMR2 &= (uint32_t)~((uint32_t)TIM_CCMR2_IC3PSC);
   \                     TIM_SetIC3Prescaler: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000006   0x61C2             STR      R2,[R0, #+28]
   1661            /* Set the IC3PSC value */
   1662            TIMx->CCMR2 |= TIM_ICPSC;
   \   00000008   0x69C2             LDR      R2,[R0, #+28]
   \   0000000A   0x....             B.N      ?Subroutine5
   1663          }
   1664          
   1665          /**
   1666            * @brief  Sets the TIMx Input Capture 4 prescaler.
   1667            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1668            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   1669            *   This parameter can be one of the following values:
   1670            *     @arg TIM_ICPSC_DIV1: no prescaler
   1671            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1672            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1673            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1674            * @retval None
   1675            */

   \                                 In section .text, align 2, keep-with-next
   1676          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint32_t TIM_ICPSC)
   1677          {  
   1678            /* Check the parameters */
   1679            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1680            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   1681            
   1682            /* Reset the IC4PSC Bits */
   1683            TIMx->CCMR2 &= (uint32_t)~((uint32_t)TIM_CCMR2_IC4PSC);
   \                     TIM_SetIC4Prescaler: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF422 0x6240      BIC      R2,R2,#0xC00
   \   00000006   0x61C2             STR      R2,[R0, #+28]
   1684            /* Set the IC4PSC value */
   1685            TIMx->CCMR2 |= (uint32_t)(TIM_ICPSC << 8);
   \   00000008   0x69C2             LDR      R2,[R0, #+28]
   \   0000000A   0x....             B.N      ?Subroutine2
   1686          }
   1687          
   1688          /**
   1689            * @}
   1690            */
   1691          
   1692          /** @defgroup TIM_Group4 Interrupts and flags management functions
   1693           *  @brief    Interrupts and flags management functions 
   1694           *
   1695          @verbatim
   1696           ===============================================================================
   1697                    ##### Interrupts and flags management functions #####
   1698           ===============================================================================
   1699          
   1700          @endverbatim
   1701            * @{
   1702            */
   1703          
   1704          /**
   1705            * @brief  Enables or disables the specified TIM interrupts.
   1706            * @param  TIMx_IT: where x can be 1 or 2 to select the TIMx peripheral.
   1707            * @param  TIM_ITRPT: specifies the TIM interrupts sources to be enabled or disabled.
   1708            *   This parameter can be any combination of the following values:
   1709            *     @arg TIM_IT_Update: TIM update Interrupt source
   1710            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   1711            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   1712            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   1713            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   1714            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source    
   1715            * @param  NewState: new state of the TIM interrupts.
   1716            *   This parameter can be: ENABLE or DISABLE.
   1717            * @retval None
   1718            */

   \                                 In section .text, align 2, keep-with-next
   1719          void TIM_ITConfig(TIM_IT_TypeDef* TIMx_IT, uint32_t TIM_ITRPT, FunctionalState NewState)
   1720          {  
   1721            /* Check the parameters */
   1722            assert_param(IS_TIM_IT_ALL_PERIPH(TIMx_IT));
   1723            assert_param(IS_TIM_ITRPT(TIM_ITRPT));
   1724            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1725            
   1726            if (NewState != DISABLE)
   \                     TIM_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6C02             LDR      R2,[R0, #+64]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0xEA22 0x0101      BICEQ    R1,R2,R1
   1727            {
   1728              /* Enable the Interrupt sources */
   1729              TIMx_IT->IER |= TIM_ITRPT;
   1730            }
   1731            else
   1732            {
   1733              /* Disable the Interrupt sources */
   1734              TIMx_IT->IER &= (uint32_t)~TIM_ITRPT;
   \   0000000C   0x6401             STR      R1,[R0, #+64]
   1735            }
   1736          }
   \   0000000E   0x4770             BX       LR               ;; return
   1737          
   1738          /**
   1739            * @brief  Configures the TIMx event to be generate by software.
   1740            * @param  TIMx: where x can be 1 or 2 to select the 
   1741            *         TIM peripheral.
   1742            * @param  TIM_EventSource: specifies the event source.
   1743            *   This parameter can be one or more of the following values:  
   1744            *     @arg TIM_EventSource_Update: Timer update Event source
   1745            *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   1746            *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   1747            *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   1748            *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source 
   1749            *     @arg TIM_EventSource_Trigger: Timer Trigger Event source         
   1750            * @retval None
   1751            */

   \                                 In section .text, align 2, keep-with-next
   1752          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint32_t TIM_EventSource)
   1753          { 
   1754            /* Check the parameters */
   1755            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1756            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
   1757            /* Set the event sources */
   1758            TIMx->EGR = TIM_EventSource;
   \                     TIM_GenerateEvent: (+1)
   \   00000000   0x6141             STR      R1,[R0, #+20]
   1759          }
   \   00000002   0x4770             BX       LR               ;; return
   1760          
   1761          /**
   1762            * @brief  Checks whether the TIM interrupt has occurred or not.
   1763            * @param  TIMx_IT: where x can be 1 or 2 to select the TIM peripheral.
   1764            * @param  TIM_ITRPT: specifies the TIM interrupt source to check.
   1765            *   This parameter can be one of the following values:
   1766            *     @arg TIM_IT_Update: TIM update Interrupt source
   1767            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   1768            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   1769            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   1770            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   1771            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   1772            * @retval The new state of the TIM_IT(SET or RESET).
   1773            */

   \                                 In section .text, align 2, keep-with-next
   1774          ITStatus TIM_GetITStatus(TIM_IT_TypeDef* TIMx_IT, uint32_t TIM_ITRPT)
   1775          {
   1776            ITStatus bitstatus = RESET;  
   1777            uint32_t itstatus = 0x0, itenable = 0x0;
   1778            
   1779            /* Check the parameters */
   1780            assert_param(IS_TIM_IT_ALL_PERIPH(TIMx_IT));
   1781            assert_param(IS_TIM_GET_IT(TIM_ITRPT));
   1782            
   1783            
   1784            itstatus = TIMx_IT->ISR & TIM_ITRPT;  
   \                     TIM_GetITStatus: (+1)
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   1785            itenable = TIMx_IT->IER & TIM_ITRPT;
   \   00000002   0x6C00             LDR      R0,[R0, #+64]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4008             ANDS     R0,R1,R0
   1786            
   1787            if ((itstatus != (uint32_t)RESET) && (itenable != (uint32_t)RESET))
   \   00000008   0x420B             TST      R3,R1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x2800             CMPNE    R0,#+0
   \   0000000E   0x2201             MOVNE    R2,#+1
   1788            {
   1789              bitstatus = SET;
   1790            }
   1791            else
   1792            {
   1793              bitstatus = RESET;
   1794            }
   1795            return bitstatus;
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR               ;; return
   1796          }
   1797          
   1798          /**
   1799            * @brief  Clears the TIMx's interrupt pending bits.
   1800            * @param  TIMx_IT: where x can be 1 or 2 to select the TIM peripheral.
   1801            * @param  TIM_ITRPT: specifies the pending bit to clear.
   1802            *   This parameter can be any combination of the following values:
   1803            *     @arg TIM_IT_Update: TIM1 update Interrupt source
   1804            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   1805            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   1806            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   1807            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   1808            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   1809            * @retval None
   1810            */

   \                                 In section .text, align 2, keep-with-next
   1811          void TIM_ClearITPendingBit(TIM_IT_TypeDef* TIMx_IT, uint32_t TIM_ITRPT)
   1812          {
   1813            /* Check the parameters */
   1814            assert_param(IS_TIM_IT_ALL_PERIPH(TIMx_IT));
   1815            assert_param(IS_TIM_ITRPT(TIM_ITRPT));
   1816            
   1817            /* Clear the IT pending Bit */
   1818          
   1819              TIMx_IT->ISR = TIM_ITRPT;
   \                     TIM_ClearITPendingBit: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   1820          }
   \   00000002   0x4770             BX       LR               ;; return
   1821          
   1822          /**
   1823            * @}
   1824            */
   1825          
   1826          /** @defgroup TIM_Group5 Clocks management functions
   1827           *  @brief    Clocks management functions
   1828           *
   1829          @verbatim
   1830           ===============================================================================
   1831                               ##### Clocks management functions #####
   1832           ===============================================================================
   1833          
   1834          @endverbatim
   1835            * @{
   1836            */
   1837          
   1838          /**
   1839            * @brief  Configures the TIMx internal Clock
   1840            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1841            * @retval None
   1842            */

   \                                 In section .text, align 2, keep-with-next
   1843          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   1844          {
   1845            /* Check the parameters */
   1846            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1847            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1848            TIMx->SMCR &=  (uint32_t)(~((uint32_t)TIM_SMCR_SMS));
   \                     TIM_InternalClockConfig: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x08C9             LSRS     R1,R1,#+3
   \   00000004   0x00C9             LSLS     R1,R1,#+3
   \   00000006   0x6081             STR      R1,[R0, #+8]
   1849          }
   \   00000008   0x4770             BX       LR               ;; return
   1850          
   1851          /**
   1852            * @brief  Configures the TIMx Internal Trigger as External Clock
   1853            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1854            * @param  TIM_InputTriggerSource: Trigger source.
   1855            *   This parameter can only be:
   1856            *   @arg  TIM_TS_ITR0: Internal Trigger 0
   1857            * @retval None
   1858            */

   \                                 In section .text, align 2, keep-with-next
   1859          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint32_t TIM_InputTriggerSource)
   1860          {
   \                     TIM_ITRxExternalClockConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1861            /* Check the parameters */
   1862            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1863            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1864            /* Select the Internal Trigger */
   1865            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   \   00000004   0x.... 0x....      BL       TIM_SelectInputTrigger
   1866            /* Select the External clock mode1 */
   1867            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0xF040 0x0007      ORR      R0,R0,#0x7
   \   0000000E   0x60A0             STR      R0,[R4, #+8]
   1868          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1869          
   1870          /**
   1871            * @brief  Configures the TIMx Trigger as External Clock
   1872            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1873            * @param  TIM_TIxExternalCLKSource: Trigger source.
   1874            *   This parameter can be one of the following values:
   1875            *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   1876            *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   1877            *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   1878            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   1879            *   This parameter can be one of the following values:
   1880            *     @arg TIM_ICPolarity_Rising
   1881            *     @arg TIM_ICPolarity_Falling
   1882            * @param  ICFilter : specifies the filter value.
   1883            *   This parameter must be a value between 0x0 and 0xF.
   1884            * @retval None
   1885            */

   \                                 In section .text, align 2, keep-with-next
   1886          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint32_t TIM_TIxExternalCLKSource,
   1887                                          uint32_t TIM_ICPolarity, uint32_t ICFilter)
   1888          {
   \                     TIM_TIxExternalClockConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   1889            /* Check the parameters */
   1890            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1891            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   1892            assert_param(IS_TIM_IC_FILTER(ICFilter));
   1893            
   1894            /* Configure the Timer Input Clock Source */
   1895            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   \   00000004   0x2D60             CMP      R5,#+96
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4611             MOV      R1,R2
   \   0000000A   0xD103             BNE.N    ??TIM_TIxExternalClockConfig_0
   1896            {
   1897              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x.... 0x....      BL       TI2_Config
   \   00000012   0xE002             B.N      ??TIM_TIxExternalClockConfig_1
   1898            }
   1899            else
   1900            {
   1901              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \                     ??TIM_TIxExternalClockConfig_0: (+1)
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x.... 0x....      BL       TI1_Config
   1902            }
   1903            /* Select the Trigger source */
   1904            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   \                     ??TIM_TIxExternalClockConfig_1: (+1)
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       TIM_SelectInputTrigger
   1905            /* Select the External clock mode1 */
   1906            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0xF040 0x0007      ORR      R0,R0,#0x7
   \   00000028   0x60A0             STR      R0,[R4, #+8]
   1907          }
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1908          
   1909          /**
   1910            * @brief  Configures the External clock Mode1
   1911            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1912            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1913            *   This parameter can be one of the following values:
   1914            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1915            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1916            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1917            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1918            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1919            *   This parameter can be one of the following values:
   1920            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1921            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1922            * @param  ExtTRGFilter: External Trigger Filter.
   1923            *   This parameter must be a value between 0x00 and 0x0F
   1924            * @retval None
   1925            */

   \                                 In section .text, align 2, keep-with-next
   1926          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler, uint32_t TIM_ExtTRGPolarity,
   1927                                       uint32_t ExtTRGFilter)
   1928          {
   \                     TIM_ETRClockMode1Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1929            uint32_t tmpsmcr = 0;
   1930            
   1931            /* Check the parameters */
   1932            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1933            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1934            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1935            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1936            
   1937            /* Configure the ETR Clock source */
   1938            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   00000004   0x.... 0x....      BL       TIM_ETRConfig
   1939            
   1940            /* Get the TIMx SMCR register value */
   1941            tmpsmcr = TIMx->SMCR;
   1942            /* Reset the SMS Bits */
   1943            tmpsmcr &= (uint32_t)(~((uint32_t)TIM_SMCR_SMS));
   1944            /* Select the External clock mode1 */
   1945            tmpsmcr |= TIM_SlaveMode_External1;
   1946            /* Select the Trigger selection : ETRF */
   1947            tmpsmcr &= (uint32_t)(~((uint32_t)TIM_SMCR_TS));
   1948            tmpsmcr |= TIM_TS_ETRF;
   1949            /* Write to TIMx SMCR */
   1950            TIMx->SMCR = tmpsmcr;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0xF040 0x0077      ORR      R0,R0,#0x77
   \   0000000E   0x60A0             STR      R0,[R4, #+8]
   1951          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1952          
   1953          /**
   1954            * @brief  Configures the External clock Mode2
   1955            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   1956            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1957            *   This parameter can be one of the following values:
   1958            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1959            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1960            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1961            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1962            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1963            *   This parameter can be one of the following values:
   1964            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1965            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1966            * @param  ExtTRGFilter: External Trigger Filter.
   1967            *   This parameter must be a value between 0x00 and 0x0F
   1968            * @retval None
   1969            */

   \                                 In section .text, align 2, keep-with-next
   1970          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler, 
   1971                                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   1972          {
   \                     TIM_ETRClockMode2Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1973            /* Check the parameters */
   1974            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1975            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1976            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1977            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1978            
   1979            /* Configure the ETR Clock source */
   1980            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   00000004   0x.... 0x....      BL       TIM_ETRConfig
   1981            /* Enable the External clock mode2 */
   1982            TIMx->SMCR |= TIM_SMCR_ECE;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000000E   0x60A0             STR      R0,[R4, #+8]
   1983          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1984          
   1985          /**
   1986            * @}
   1987            */
   1988          
   1989          /** @defgroup TIM_Group6 Synchronization management functions
   1990           *  @brief    Synchronization management functions 
   1991           *
   1992          @verbatim
   1993           ===============================================================================
   1994                         ##### Synchronization management functions #####
   1995           ===============================================================================
   1996                  *** TIM Driver: how to use it in synchronization Mode ***
   1997           ===============================================================================
   1998              [..] Case of two/several Timers
   1999                   (#) Configure the Master Timers using the following functions:
   2000                       (++) void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx,
   2001                            uint32_t TIM_TRGOSource).
   2002                       (++) void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx,
   2003                            uint32_t TIM_MasterSlaveMode);  
   2004                   (#) Configure the Slave Timers using the following functions: 
   2005                       (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, 
   2006                            uint32_t TIM_InputTriggerSource);  
   2007                       (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint32_t TIM_SlaveMode);
   2008              [..] Case of Timers and external trigger(ETR pin)
   2009                   (#) Configure the Etrenal trigger using this function:
   2010                       (++) void TIM_ETRConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   2011                            uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
   2012                   (#) Configure the Slave Timers using the following functions:
   2013                       (++) void TIM_SelectInputTrigger(TIM_TypeDef* TIMx,
   2014                            uint32_t TIM_InputTriggerSource);
   2015                       (++) void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint32_t TIM_SlaveMode);
   2016          
   2017          @endverbatim
   2018            * @{
   2019            */
   2020          /**
   2021            * @brief  Selects the Input Trigger source
   2022            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2023            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2024            *   This parameter can be one of the following values:
   2025            *     @arg TIM_TS_ITR0: Internal Trigger 0
   2026            *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   2027            *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   2028            *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   2029            *     @arg TIM_TS_ETRF: External Trigger input
   2030            * @retval None
   2031            */

   \                                 In section .text, align 2, keep-with-next
   2032          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint32_t TIM_InputTriggerSource)
   2033          {
   2034            uint32_t tmpsmcr = 0;
   2035          
   2036            /* Check the parameters */
   2037            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
   2038            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2039          
   2040            /* Get the TIMx SMCR register value */
   2041            tmpsmcr = TIMx->SMCR;
   2042            /* Reset the TS Bits */
   2043            tmpsmcr &= (uint32_t)(~((uint32_t)TIM_SMCR_TS));
   2044            /* Set the Input Trigger source */
   2045            tmpsmcr |= TIM_InputTriggerSource;
   2046            /* Write to TIMx SMCR */
   2047            TIMx->SMCR = tmpsmcr;
   \                     TIM_SelectInputTrigger: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x....             B.N      ??Subroutine0_0
   2048          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6082             STR      R2,[R0, #+8]
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \                     ??Subroutine0_0: (+1)
   \   00000004   0x4311             ORRS     R1,R1,R2
   \   00000006   0x6081             STR      R1,[R0, #+8]
   \   00000008   0x4770             BX       LR               ;; return
   2049          
   2050          /**
   2051            * @brief  Selects the TIMx Trigger Output Mode.
   2052            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2053            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2054            *   This paramter can be one of the following values:
   2055            *
   2056            *   For all TIMx
   2057            *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
   2058            *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
   2059            *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
   2060            *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2061            *                              is to be set, as soon as a capture or compare match occurs (TRGO).
   2062            *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
   2063            *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
   2064            *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
   2065            *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
   2066            *
   2067            * @retval None
   2068            */

   \                                 In section .text, align 2, keep-with-next
   2069          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint32_t TIM_TRGOSource)
   2070          {
   2071            /* Check the parameters */
   2072            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2073            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2074          
   2075            /* Reset the MMS Bits */
   2076            TIMx->CR2 &= (uint32_t)~((uint32_t)TIM_CR2_MMS);
   \                     TIM_SelectOutputTrigger: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x6042             STR      R2,[R0, #+4]
   2077            /* Select the TRGO source */
   2078            TIMx->CR2 |=  TIM_TRGOSource;
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x4311             ORRS     R1,R1,R2
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   2079          }
   \   0000000E   0x4770             BX       LR               ;; return
   2080          
   2081          /**
   2082            * @brief  Selects the TIMx Slave Mode.
   2083            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2084            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2085            *   This paramter can be one of the following values:
   2086            *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
   2087            *                               the counter and triggers an update of the registers.
   2088            *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
   2089            *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
   2090            *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
   2091            * @retval None
   2092            */

   \                                 In section .text, align 2, keep-with-next
   2093          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint32_t TIM_SlaveMode)
   2094          {
   2095            /* Check the parameters */
   2096            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
   2097            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2098            
   2099            /* Reset the SMS Bits */
   2100            TIMx->SMCR &= (uint32_t)~((uint32_t)TIM_SMCR_SMS);
   \                     TIM_SelectSlaveMode: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0x08D2             LSRS     R2,R2,#+3
   \   00000004   0x00D2             LSLS     R2,R2,#+3
   \   00000006   0x....             B.N      ?Subroutine0
   2101            /* Select the Slave Mode */
   2102            TIMx->SMCR |= TIM_SlaveMode;
   2103          }
   2104          
   2105          /**
   2106            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2107            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2108            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2109            *   This paramter can be one of the following values:
   2110            *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2111            *                                      and its slaves (through TRGO).
   2112            *     @arg TIM_MasterSlaveMode_Disable: No action
   2113            * @retval None
   2114            */

   \                                 In section .text, align 2, keep-with-next
   2115          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint32_t TIM_MasterSlaveMode)
   2116          {
   2117            /* Check the parameters */
   2118            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2119            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2120            
   2121            /* Reset the MSM Bit */
   2122            TIMx->SMCR &= (uint32_t)~((uint32_t)TIM_SMCR_MSM);
   \                     TIM_SelectMasterSlaveMode: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000006                      REQUIRE ?Subroutine0
   \   00000006                      ;; // Fall through to label ?Subroutine0
   2123            
   2124            /* Set or Reset the MSM Bit */
   2125            TIMx->SMCR |= TIM_MasterSlaveMode;
   2126          }
   2127          
   2128          /**
   2129            * @brief  Configures the TIMx External Trigger (ETR).
   2130            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2131            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2132            *   This parameter can be one of the following values:
   2133            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2134            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2135            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2136            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2137            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2138            *   This parameter can be one of the following values:
   2139            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2140            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2141            * @param  ExtTRGFilter: External Trigger Filter.
   2142            *   This parameter must be a value between 0x00 and 0x0F
   2143            * @retval None
   2144            */

   \                                 In section .text, align 2, keep-with-next
   2145          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler, uint32_t TIM_ExtTRGPolarity,
   2146                             uint32_t ExtTRGFilter)
   2147          {
   \                     TIM_ETRConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2148            uint32_t tmpsmcr = 0;
   2149            
   2150            /* Check the parameters */
   2151            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2152            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2153            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2154            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2155            
   2156            tmpsmcr = TIMx->SMCR;
   2157            /* Reset the ETR Bits */
   2158            tmpsmcr &= SMCR_ETR_MASK;
   2159            /* Set the Prescaler, the Filter value and the Polarity */
   2160            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (uint32_t)(TIM_ExtTRGPolarity | (uint32_t)(ExtTRGFilter << (uint32_t)8)));
   2161            /* Write to TIMx SMCR */
   2162            TIMx->SMCR = tmpsmcr;
   \   00000002   0x6884             LDR      R4,[R0, #+8]
   \   00000004   0xB2E4             UXTB     R4,R4
   \   00000006   0x4321             ORRS     R1,R1,R4
   \   00000008   0x4311             ORRS     R1,R2,R1
   \   0000000A   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   0000000E   0x6081             STR      R1,[R0, #+8]
   2163          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   2164          
   2165          /**
   2166            * @}
   2167            */
   2168          
   2169          /** @defgroup TIM_Group7 Specific interface management functions
   2170           *  @brief    Specific interface management functions 
   2171           *
   2172          @verbatim
   2173           ===============================================================================
   2174                       ##### Specific interface management functions #####
   2175           ===============================================================================
   2176          
   2177          @endverbatim
   2178            * @{
   2179            */
   2180          
   2181          /**
   2182            * @brief  Configures the TIMx Encoder Interface.
   2183            * @param  TIMx: where x can be  1 or 2 to select the TIM peripheral.
   2184            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   2185            *   This parameter can be one of the following values:
   2186            *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   2187            *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   2188            *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   2189            *                                on the level of the other input.
   2190            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   2191            *   This parmeter can be one of the following values:
   2192            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2193            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2194            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   2195            *   This parmeter can be one of the following values:
   2196            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2197            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2198            * @retval None
   2199            */

   \                                 In section .text, align 2, keep-with-next
   2200          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint32_t TIM_EncoderMode,
   2201                                          uint32_t TIM_IC1Polarity, uint32_t TIM_IC2Polarity)
   2202          {
   \                     TIM_EncoderInterfaceConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2203            uint32_t tmpsmcr = 0;
   2204            uint32_t tmpccmr1 = 0;
   2205            uint32_t tmpccer = 0;
   2206              
   2207            /* Check the parameters */
   2208            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2209            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   2210            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   2211            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   2212            
   2213            /* Get the TIMx SMCR register value */
   2214            tmpsmcr = TIMx->SMCR;
   \   00000002   0x6884             LDR      R4,[R0, #+8]
   2215            /* Get the TIMx CCMR1 register value */
   2216            tmpccmr1 = TIMx->CCMR1;
   \   00000004   0x6985             LDR      R5,[R0, #+24]
   2217            /* Get the TIMx CCER register value */
   2218            tmpccer = TIMx->CCER;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   2219            /* Set the encoder Mode */
   2220            tmpsmcr &= (uint32_t)(~((uint32_t)TIM_SMCR_SMS));
   2221            tmpsmcr |= TIM_EncoderMode;
   2222            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2223            tmpccmr1 &= (uint32_t)(((uint32_t)~((uint32_t)TIM_CCMR1_CC1S)) & (uint32_t)(~((uint32_t)TIM_CCMR1_CC2S)));
   2224            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   2225            /* Set the TI1 and the TI2 Polarities */
   2226            tmpccer &= (uint32_t)(((uint32_t)~((uint32_t)TIM_CCER_CC1P)) & ((uint32_t)~((uint32_t)TIM_CCER_CC2P)));
   2227             tmpccer |= (uint32_t)(TIM_IC1Polarity | (uint32_t)(TIM_IC2Polarity << (uint32_t)4));
   2228            /* Write to TIMx SMCR */
   2229            TIMx->SMCR = tmpsmcr;
   \   00000008   0x08E4             LSRS     R4,R4,#+3
   \   0000000A   0xEA41 0x01C4      ORR      R1,R1,R4, LSL #+3
   \   0000000E   0x6081             STR      R1,[R0, #+8]
   2230            /* Write to TIMx CCMR1 */
   2231            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0xF240 0x1401      MOVW     R4,#+257
   \   00000014   0x....             LDR.N    R1,??DataTable1_3  ;; 0xfffffcfc
   \   00000016   0x4029             ANDS     R1,R1,R5
   \   00000018   0x4321             ORRS     R1,R4,R1
   \   0000001A   0x6181             STR      R1,[R0, #+24]
   2232            /* Write to TIMx CCER */
   2233            TIMx->CCER = tmpccer;
   \   0000001C   0xF026 0x0122      BIC      R1,R6,#0x22
   \   00000020   0x4311             ORRS     R1,R2,R1
   \   00000022   0xEA41 0x1103      ORR      R1,R1,R3, LSL #+4
   \   00000026   0x6201             STR      R1,[R0, #+32]
   2234          }
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   2235          
   2236          /**
   2237            * @brief  Enables or disables the TIMx's Hall sensor interface.
   2238            * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
   2239            * @param  NewState: new state of the TIMx Hall sensor interface.
   2240            *   This parameter can be: ENABLE or DISABLE.
   2241            * @retval None
   2242            */

   \                                 In section .text, align 2, keep-with-next
   2243          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2244          {
   2245            /* Check the parameters */
   2246            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2247            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2248            
   2249            if (NewState != DISABLE)
   \                     TIM_SelectHallSensor: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF041 0x0180      ORRNE    R1,R1,#0x80
   \   0000000A   0xF021 0x0180      BICEQ    R1,R1,#0x80
   2250            {
   2251              /* Set the TI1S Bit */
   2252              TIMx->CR2 |= TIM_CR2_TI1S;
   2253            }
   2254            else
   2255            {
   2256              /* Reset the TI1S Bit */
   2257              TIMx->CR2 &= (uint32_t)~((uint32_t)TIM_CR2_TI1S);
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   2258            }
   2259          }
   \   00000010   0x4770             BX       LR               ;; return
   2260          
   2261          /**
   2262            * @}
   2263            */
   2264          
   2265          /** @defgroup TIM_Group8 Specific remapping management function
   2266           *  @brief   Specific remapping management function
   2267           *
   2268          @verbatim
   2269           ===============================================================================
   2270                         ##### Specific remapping management function #####
   2271           ===============================================================================
   2272          
   2273          @endverbatim
   2274            * @{
   2275            */
   2276            
   2277          /**
   2278            * @brief  Selects the TIMx Extenal trigger used in external clock mode 2.
   2279            * @param TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2280            * @param NewState: new state of the TIMx CLKMSKEN bit
   2281            *   This parameter can be: ENABLE or DISABLE.
   2282            * @retval : None
   2283            */

   \                                 In section .text, align 2, keep-with-next
   2284          void TIM_ClockMaskConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   2285          {  
   2286            /* Check the parameters */
   2287            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2288            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2289          
   2290            if (NewState != DISABLE)
   \                     TIM_ClockMaskConfig: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6D01             LDR      R1,[R0, #+80]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF041 0x0104      ORRNE    R1,R1,#0x4
   \   0000000A   0x2100             MOVEQ    R1,#+0
   2291            {
   2292            /* Enable the clock mask */
   2293            TIMx->OR |=  TIM_ClockMask_Enable;
   2294            }
   2295            else
   2296            {
   2297              /* Disable the clock mask */
   2298             TIMx->OR &=  TIM_ClockMask_Disable; 
   \   0000000C   0x6501             STR      R1,[R0, #+80]
   2299            }
   2300          }
   \   0000000E   0x4770             BX       LR               ;; return
   2301          
   2302          /**
   2303            * @brief  Selects the TIMx Extenal trigger used in external clock mode 2.
   2304            * @param TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2305            * @param TIM_EXTRIGCLK: specifies the TIM input reampping source.
   2306            *   This parameter can be one of the following values:
   2307            *   @arg TIM_EXTRIGPCLK: PCLK.
   2308            *   @arg TIM_EXTRIG1KHCLK:  calibrated 1 kHz clock.
   2309            *   @arg TIM_EXTRIG32KHCLK: 32 kHz reference clock (if available).
   2310            *   @arg TIM_EXTRIGTIMxCLK: TIMxCLK pin.
   2311            * @retval : None
   2312            */

   \                                 In section .text, align 2, keep-with-next
   2313          void TIM_SelectExternalTriggerClock(TIM_TypeDef* TIMx, uint32_t TIM_EXTRIGCLK)
   2314          {
   2315           /* Check the parameters */
   2316            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2317            assert_param(IS_TIM_EXTRIGCLK(TIM_EXTRIGCLK));
   2318          
   2319            /* Set the Timer remapping configuration */
   2320            TIMx->OR |=  TIM_EXTRIGCLK;
   \                     TIM_SelectExternalTriggerClock: (+1)
   \   00000000   0x6D02             LDR      R2,[R0, #+80]
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x6501             STR      R1,[R0, #+80]
   2321          }
   \   00000006   0x4770             BX       LR               ;; return
   2322          
   2323          /**
   2324            * @brief  Configures the TIM2 Remapping input Capabilities.
   2325            * @param TIMx: where x can be 2 to select the TIM peripheral.
   2326            * @param TIM_Remap: specifies the TIM input reampping source.
   2327            *   This parameter can be one of the following values:
   2328            *   @arg TIM_REMAPC1: TIM2 Channel 1 is connected to GPIOA (PA0) or to GPIOB (PB1).
   2329            *   @arg TIM_REMAPC2: TIM2 Channel 2 is connected to GPIOA (PA3) or to GPIOB (PB2).
   2330            *   @arg TIM_REMAPC3: TIM2 Channel 3 is connected to GPIOA (PA1) or to GPIOB (PB3).
   2331            *   @arg TIM_REMAPC4: TIM2 Channel 4 is connected to GPIOA (PA2) or to GPIOB (PB4).
   2332            * @param  NewState: new state of the TIMx TIM2_OR_REMAPCy bit (y can be 1..4).
   2333            *   This parameter can be: ENABLE or DISABLE.  
   2334            * @retval : None
   2335            */

   \                                 In section .text, align 2, keep-with-next
   2336          void TIM_RemapCmd(TIM_TypeDef* TIMx, uint32_t TIM_Remap, FunctionalState NewState)
   2337          {
   2338           /* Check the parameters */
   2339            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2340            assert_param(IS_TIM_REMAP(TIM_Remap));
   2341            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2342          
   2343            if (NewState != DISABLE)
   \                     TIM_RemapCmd: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0xEA22 0x0101      BICEQ    R1,R2,R1
   2344            {
   2345            /* Set the Timer remapping configuration */
   2346            TIMx->OR |=  TIM_Remap;
   2347            }
   2348            else
   2349            {
   2350              TIMx->OR &= (uint32_t)~TIM_Remap;
   \   0000000C   0x6501             STR      R1,[R0, #+80]
   2351            }
   2352          }
   \   0000000E   0x4770             BX       LR               ;; return
   2353          
   2354          /**
   2355            * @}
   2356            */
   2357            
   2358          /**
   2359            * @brief  Configure the TI1 as Input.
   2360            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2361            * @param  TIM_ICPolarity : The Input Polarity.
   2362            *   This parameter can be one of the following values:
   2363            *     @arg TIM_ICPolarity_Rising:
   2364            *     @arg TIM_ICPolarity_Falling:
   2365            * @param  TIM_ICSelection: specifies the input to be used.
   2366            *   This parameter can be one of the following values:
   2367            *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   2368            *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   2369            *     @arg TIM_ICSelection_TRGI: TIM Input 1 is selected to be connected to TRGI.
   2370            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2371            *   This parameter must be a value between 0x00 and 0x0F.
   2372            * @retval None
   2373            */

   \                                 In section .text, align 2, keep-with-next
   2374          static void TI1_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   2375                                 uint32_t TIM_ICFilter)
   2376          {
   \                     TI1_Config: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   2377          
   2378            uint32_t tmpccmr1 = 0, tmpccer = 0;
   2379            /* Disable the Channel 1: Reset the CC1E Bit */
   2380            TIMx->CCER &= (uint32_t)~((uint32_t)TIM_CCER_CC1E);
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0x0864             LSRS     R4,R4,#+1
   \   00000006   0x0064             LSLS     R4,R4,#+1
   \   00000008   0x6204             STR      R4,[R0, #+32]
   2381            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6984             LDR      R4,[R0, #+24]
   2382            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   2383            /* Select the Input and set the filter */
   2384            tmpccmr1 &= (uint32_t)(((uint32_t)~((uint32_t)TIM_CCMR1_CC1S)) & ((uint32_t)~((uint32_t)TIM_CCMR1_IC1F)));
   2385            tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)(TIM_ICFilter << (uint32_t)4));
   2386           
   2387            /* Select the Polarity and set the CC1E Bit */
   2388            tmpccer &= (uint32_t)~((uint32_t)(TIM_CCER_CC1P));
   2389            tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
   2390            /* Write to TIMx CCMR1 and CCER registers */
   2391            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0xF024 0x04F3      BIC      R4,R4,#0xF3
   \   00000012   0x4322             ORRS     R2,R2,R4
   \   00000014   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \   00000018   0x6182             STR      R2,[R0, #+24]
   2392            TIMx->CCER = tmpccer;
   \   0000001A   0xF025 0x0202      BIC      R2,R5,#0x2
   \   0000001E   0x4311             ORRS     R1,R1,R2
   \   00000020   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000024   0x6201             STR      R1,[R0, #+32]
   2393          }
   \   00000026   0xBD30             POP      {R4,R5,PC}       ;; return
   2394          
   2395          /**
   2396            * @brief  Configure the TI2 as Input.
   2397            * @param  TIMx: where x can be 1 or 2 to select the TIM peripheral.
   2398            * @param  TIM_ICPolarity : The Input Polarity.
   2399            *   This parameter can be one of the following values:
   2400            *     @arg TIM_ICPolarity_Rising
   2401            *     @arg TIM_ICPolarity_Falling
   2402            * @param  TIM_ICSelection: specifies the input to be used.
   2403            *   This parameter can be one of the following values:
   2404            *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   2405            *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   2406            *     @arg TIM_ICSelection_TRGI: TIM Input 2 is selected to be connected to TRGI.
   2407            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2408            *   This parameter must be a value between 0x00 and 0x0F.
   2409            * @retval None
   2410            */

   \                                 In section .text, align 2, keep-with-next
   2411          static void TI2_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   2412                                 uint32_t TIM_ICFilter)
   2413          {
   \                     TI2_Config: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   2414            uint32_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   2415            /* Disable the Channel 2: Reset the CC2E Bit */
   2416            TIMx->CCER &= (uint32_t)~((uint32_t)TIM_CCER_CC2E);
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0xF024 0x0410      BIC      R4,R4,#0x10
   \   00000008   0x6204             STR      R4,[R0, #+32]
   2417            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6984             LDR      R4,[R0, #+24]
   2418            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   2419            tmp = (uint32_t)(TIM_ICPolarity << 4);
   2420            /* Select the Input and set the filter */
   2421            tmpccmr1 &= (uint32_t)(((uint32_t)~((uint32_t)TIM_CCMR1_CC2S)) & ((uint32_t)~((uint32_t)TIM_CCMR1_IC2F)));
   2422            tmpccmr1 |= (uint32_t)(TIM_ICFilter << 12);
   2423            tmpccmr1 |= (uint32_t)(TIM_ICSelection << 8); 
   2424            /* Select the Polarity and set the CC2E Bit */
   2425            tmpccer &= (uint32_t)~((uint32_t)(TIM_CCER_CC2P));
   2426            tmpccer |= (uint32_t)(tmp | (uint32_t)TIM_CCER_CC2E);  
   2427            /* Write to TIMx CCMR1 and CCER registers */
   2428            TIMx->CCMR1 = tmpccmr1 ;
   \   0000000E   0xF424 0x4473      BIC      R4,R4,#0xF300
   \   00000012   0xEA44 0x3303      ORR      R3,R4,R3, LSL #+12
   \   00000016   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \   0000001A   0x6182             STR      R2,[R0, #+24]
   2429            TIMx->CCER = tmpccer;
   \   0000001C   0xF025 0x0220      BIC      R2,R5,#0x20
   \   00000020   0xEA42 0x1101      ORR      R1,R2,R1, LSL #+4
   \   00000024   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000028   0x6201             STR      R1,[R0, #+32]
   2430          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x4000E000         DC32     0x4000e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x4000A800         DC32     0x4000a800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x4000F000         DC32     0x4000f000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc
   2431          
   2432          /**
   2433            * @brief  Configure the TI3 as Input.
   2434            * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
   2435            * @param  TIM_ICPolarity : The Input Polarity.
   2436            *   This parameter can be one of the following values:
   2437            *     @arg TIM_ICPolarity_Rising
   2438            *     @arg TIM_ICPolarity_Falling
   2439            * @param  TIM_ICSelection: specifies the input to be used.
   2440            *   This parameter can be one of the following values:
   2441            *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   2442            *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   2443            *     @arg TIM_ICSelection_TRGI: TIM Input 3 is selected to be connected to TRGI.
   2444            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2445            *   This parameter must be a value between 0x00 and 0x0F.
   2446            * @retval None
   2447            */
   2448          static void TI3_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   2449                                 uint32_t TIM_ICFilter)
   2450          {
   2451            uint32_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2452            /* Disable the Channel 3: Reset the CC3E Bit */
   2453            TIMx->CCER &= (uint32_t)~((uint32_t)TIM_CCER_CC3E);
   2454            tmpccmr2 = TIMx->CCMR2;
   2455            tmpccer = TIMx->CCER;
   2456            tmp = (uint32_t)(TIM_ICPolarity << 8);
   2457            /* Select the Input and set the filter */
   2458            tmpccmr2 &= (uint32_t)(((uint32_t)~((uint32_t)TIM_CCMR2_CC3S)) & ((uint32_t)~((uint32_t)TIM_CCMR2_IC3F)));
   2459            tmpccmr2 |= (uint32_t)(TIM_ICSelection | (uint32_t)(TIM_ICFilter << (uint32_t)4));
   2460            /* Select the Polarity and set the CC3E Bit */
   2461            tmpccer &= (uint32_t)~((uint32_t)(TIM_CCER_CC3P));
   2462            tmpccer |= (uint32_t)(tmp | (uint32_t)TIM_CCER_CC3E);  
   2463            /* Write to TIMx CCMR2 and CCER registers */
   2464            TIMx->CCMR2 = tmpccmr2;
   2465            TIMx->CCER = tmpccer;
   2466          }
   2467          
   2468          /**
   2469            * @brief  Configure the TI4 as Input.
   2470            * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
   2471            * @param  TIM_ICPolarity : The Input Polarity.
   2472            *   This parameter can be one of the following values:
   2473            *     @arg TIM_ICPolarity_Rising
   2474            *     @arg TIM_ICPolarity_Falling
   2475            * @param  TIM_ICSelection: specifies the input to be used.
   2476            *   This parameter can be one of the following values:
   2477            *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   2478            *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   2479            *     @arg TIM_ICSelection_TRGI: TIM Input 4 is selected to be connected to TRGI.
   2480            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2481            *   This parameter must be a value between 0x00 and 0x0F.
   2482            * @retval None
   2483            */
   2484          static void TI4_Config(TIM_TypeDef* TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   2485                                 uint32_t TIM_ICFilter)
   2486          {
   2487            uint32_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2488          
   2489             /* Disable the Channel 4: Reset the CC4E Bit */
   2490            TIMx->CCER &= (uint32_t)~((uint32_t)TIM_CCER_CC4E);
   2491            tmpccmr2 = TIMx->CCMR2;
   2492            tmpccer = TIMx->CCER;
   2493            tmp = (uint32_t)(TIM_ICPolarity << 12);
   2494            /* Select the Input and set the filter */
   2495            tmpccmr2 &= (uint32_t)((uint32_t)(~(uint32_t)TIM_CCMR2_CC4S) & ((uint32_t)~((uint32_t)TIM_CCMR2_IC4F)));
   2496            tmpccmr2 |= (uint32_t)(TIM_ICSelection << 8);
   2497            tmpccmr2 |= (uint32_t)(TIM_ICFilter << 12);  
   2498            /* Select the Polarity and set the CC4E Bit */
   2499            tmpccer &= (uint32_t)~((uint32_t)(TIM_CCER_CC3P));
   2500            tmpccer |= (uint32_t)(tmp | (uint32_t)TIM_CCER_CC4E);
   2501            /* Write to TIMx CCMR2 and CCER registers */
   2502            TIMx->CCMR2 = tmpccmr2;
   2503            TIMx->CCER = tmpccer;
   2504          }
   2505          
   2506          /**
   2507            * @}
   2508            */
   2509          
   2510          /**
   2511            * @}
   2512            */
   2513          
   2514          /**
   2515            * @}
   2516            */
   2517            
   2518          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   TI1_Config
      12   TI2_Config
       0   TIM_ARRPreloadConfig
       8   TIM_CCxCmd
       0   TIM_ClearITPendingBit
       0   TIM_ClockMaskConfig
       0   TIM_Cmd
       0   TIM_CounterModeConfig
       0   TIM_DeInit
       8   TIM_ETRClockMode1Config
         8   -> TIM_ETRConfig
       8   TIM_ETRClockMode2Config
         8   -> TIM_ETRConfig
       8   TIM_ETRConfig
      16   TIM_EncoderInterfaceConfig
       0   TIM_ForcedOC1Config
       0   TIM_ForcedOC2Config
       0   TIM_ForcedOC3Config
       0   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
        16   -> TI1_Config
        16   -> TI2_Config
         0   -> TIM_SetIC1Prescaler
         0   -> TIM_SetIC2Prescaler
         0   -> TIM_SetIC3Prescaler
         0   -> TIM_SetIC4Prescaler
       0   TIM_ICStructInit
       0   TIM_ITConfig
       8   TIM_ITRxExternalClockConfig
         8   -> TIM_SelectInputTrigger
       0   TIM_InternalClockConfig
       0   TIM_OC1FastConfig
      12   TIM_OC1Init
       0   TIM_OC1PolarityConfig
       0   TIM_OC1PreloadConfig
       0   TIM_OC2FastConfig
      16   TIM_OC2Init
       0   TIM_OC2PolarityConfig
       0   TIM_OC2PreloadConfig
       0   TIM_OC3FastConfig
      16   TIM_OC3Init
       0   TIM_OC3PolarityConfig
       0   TIM_OC3PreloadConfig
       0   TIM_OC4FastConfig
      16   TIM_OC4Init
       0   TIM_OC4PolarityConfig
       0   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
         0   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC1Prescaler
         0   -> TIM_SetIC2Prescaler
        24   -> TIM_SetIC2Prescaler
       0   TIM_PrescalerConfig
       0   TIM_RemapCmd
       0   TIM_SelectExternalTriggerClock
       0   TIM_SelectHallSensor
       0   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
      12   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      16   TIM_TIxExternalClockConfig
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TIM_SelectInputTrigger
       0   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
      10  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
      18  ?Subroutine6
       8  ?Subroutine7
      40  TI1_Config
      44  TI2_Config
      18  TIM_ARRPreloadConfig
      24  TIM_CCxCmd
       4  TIM_ClearITPendingBit
      16  TIM_ClockMaskConfig
      18  TIM_Cmd
       8  TIM_CounterModeConfig
     102  TIM_DeInit
      18  TIM_ETRClockMode1Config
      18  TIM_ETRClockMode2Config
      18  TIM_ETRConfig
      42  TIM_EncoderInterfaceConfig
       8  TIM_ForcedOC1Config
       8  TIM_ForcedOC2Config
       8  TIM_ForcedOC3Config
       8  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       4  TIM_GetCapture4
       4  TIM_GetCounter
      20  TIM_GetITStatus
       4  TIM_GetPrescaler
     152  TIM_ICInit
      18  TIM_ICStructInit
      16  TIM_ITConfig
      18  TIM_ITRxExternalClockConfig
      10  TIM_InternalClockConfig
       8  TIM_OC1FastConfig
      46  TIM_OC1Init
      12  TIM_OC1PolarityConfig
       6  TIM_OC1PreloadConfig
       8  TIM_OC2FastConfig
      38  TIM_OC2Init
      14  TIM_OC2PolarityConfig
       6  TIM_OC2PreloadConfig
       8  TIM_OC3FastConfig
      48  TIM_OC3Init
      14  TIM_OC3PolarityConfig
       6  TIM_OC3PreloadConfig
       8  TIM_OC4FastConfig
      38  TIM_OC4Init
      14  TIM_OC4PolarityConfig
       6  TIM_OC4PreloadConfig
      12  TIM_OCStructInit
     102  TIM_PWMIConfig
       6  TIM_PrescalerConfig
      16  TIM_RemapCmd
       8  TIM_SelectExternalTriggerClock
      18  TIM_SelectHallSensor
       8  TIM_SelectInputTrigger
       6  TIM_SelectMasterSlaveMode
      66  TIM_SelectOCxM
      10  TIM_SelectOnePulseMode
      16  TIM_SelectOutputTrigger
       8  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       4  TIM_SetCompare4
       4  TIM_SetCounter
      12  TIM_SetIC1Prescaler
      12  TIM_SetIC2Prescaler
      12  TIM_SetIC3Prescaler
      12  TIM_SetIC4Prescaler
      44  TIM_TIxExternalClockConfig
      26  TIM_TimeBaseInit
      14  TIM_TimeBaseStructInit
      18  TIM_UpdateDisableConfig
      18  TIM_UpdateRequestConfig

 
 1 498 bytes in section .text
 
 1 498 bytes of CODE memory

Errors: none
Warnings: none
