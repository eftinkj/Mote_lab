###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:28:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_MMCR.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_MMCR.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"routing_MMCR.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\routing_MMCR.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\routing_MMCR.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing_MMCR.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2009-2008 Maciej Zawodniok, Priya Kasirajan. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          
     17          #include "defs/esnl_pub.h"
     18          
     19          #ifdef FEAT_ENABLE_MMCR
     20          
     21          #include "routing.h"
     22          #include "routing_MMCR.h"
     23          #include "routing_MMCR_MPR_select.h"
     24          
     25          #ifdef _ARM_
     26          	#include "FEAT_STM32W/STM32W_Radio.h"
     27          #endif // _ARM_
     28          
     29          #include "network_hardware_ADFS.h"
     30          #include "common.h"
     31          #include "FEAT_Xbee_API/AT_scripts.h"
     32          #include "FEAT_Queuing/Queuing.h"
     33          #include "FEAT_Networking/tsp_common_pub.h"
     34          #include "Application.h"
     35          #include "FEAT_Networking/Phy_layer.h"
     36          #include "packet.h"
     37          #include "FEAT_Scheduler/sch_basic_pub.h"
     38          
     39          ///////////////////////////////////////////////
     40          ///////////////////////////////////////////////

   \                                 In section .data, align 1
     41          uint8_t	mmcr_pkt_id = 0xFF;
   \                     mmcr_pkt_id:
   \   00000000   0xFF               DC8 255
     42          
     43          //uint8_t mmcr_state_; // state of the routing agent (e.g. IDLE, routing in-progress)
     44          
     45          //Counters for the Routing Energy Analysis
     46          //unsigned char XDATA mmcr_Hello_counter;
     47          //unsigned char XDATA mmcr_ACK_MMCR_counter;
     48          //unsigned char XDATA mmcr_DAT_MMCR_counter;
     49          
     50          
     51          //uint16_t mmcr_len_sample;
     52          
     53          unsigned char XDATA mmcr_ch_counter;
     54          

   \                                 In section .bss, align 1
     55          unsigned char XDATA mmcr_return_ch;
   \                     mmcr_return_ch:
   \   00000000                      DS8 1
     56          
     57          uint8_t ch_sw_TIDX; /// Timer ID for channel switching request
     58          
     59          ///////////////////////////////////////////////
     60          
     61          
     62          IAR_PACKED struct RENTRY
     63          {
     64          	uint16_t ID;
     65          	unsigned int NextHopID;
     66          	uint32_t NextHopCost;
     67          	unsigned int AltNextHopID;
     68          	uint32_t AltNextHopCost;
     69          };
     70          
     71          
     72          IAR_PACKED struct
     73          {
     74          	char length;
     75          	struct RENTRY rentry[MMCR_MAX_RTABLE_LEN];

   \                                 In section .bss, align 4
     76          } rtable;
   \                     rtable:
   \   00000000                      DS8 184

   \                                 In section .data, align 4
   \                     mmcr_ch_counter:
   \   00000000   0x00               DC8 0
   \                     ch_sw_TIDX:
   \   00000001   0x00               DC8 0
   \   00000002   0x00 0x00          DC8 0, 0
     77          
     78          
     79          extern void timer_cb_test1(uint8_t *x);
     80          extern void timer_cb_test2(uint8_t *x);
     81          
     82          char str_LED_BLINK_1[]="LED1";
     83          char str_LED_BLINK_2[]="LED2";
     84          char str_RTR_CH_SWITCH[] = "RTR_CH_SWITCH_MMCR";
   \                     str_RTR_CH_SWITCH:
   \   00000004   0x52 0x54          DC8 "RTR_CH_SWITCH_MMCR"
   \              0x52 0x5F    
   \              0x43 0x48    
   \              0x5F 0x53    
   \              0x57 0x49    
   \              0x54 0x43    
   \              0x48 0x5F    
   \              0x4D 0x4D    
   \              0x43 0x52    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .data, align 4
   \                     str_LED_BLINK_1:
   \   00000000   0x4C 0x45          DC8 "LED1"
   \              0x44 0x31    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     85          
     86          char str_TEST[] = "TEST 1\n";
   \                     str_TEST:
   \   00000008   0x54 0x45          DC8 "TEST 1\012"
   \              0x53 0x54    
   \              0x20 0x31    
   \              0x0A 0x00    

   \                                 In section .data, align 4
   \                     str_LED_BLINK_2:
   \   00000000   0x4C 0x45          DC8 "LED2"
   \              0x44 0x32    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     87          

   \                                 In section .text, align 2, keep-with-next
     88          void timer_cb_test1(uint8_t *x)
     89          {
   \                     timer_cb_test1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     90          	SET_LED(YLED);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       STM_EVAL_LEDOn
     91          	sch_create_timeout(rtc_get_ticks()+1000, timer_cb_test2, 0, str_LED_BLINK_2);
   \   00000008   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000000C   0xE8BD 0x5000      POP      {R12,LR}
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable9
   \   00000014   0x.... 0x....      ADR.W    R1,timer_cb_test2
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x....             B.N      ?Subroutine0
     92          //	mmcr_age_tables(); // Increases the costs in neighbors and routing tables - to remove nodes over time
     93          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xF500 0x707A      ADD      R0,R0,#+1000
   \   00000004   0x.... 0x....      B.W      sch_create_timeout

   \                                 In section .text, align 4, keep-with-next
     94          void timer_cb_test2(uint8_t *x)
     95          {
   \                     timer_cb_test2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     96          	CLEAR_LED(YLED);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       STM_EVAL_LEDOff
     97          	//send_PONG(MAC_BROADCAST);
     98          	//sendSerialData( strlen(str_TEST), str_TEST );
     99          	sendPacketData( strlen(str_TEST), str_TEST, MAC_BROADCAST );
                 	                ^
Warning[Pe223]: function "strlen" declared implicitly
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable9_1
   \   0000000C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000010   0x.... 0x....      BL       strlen
   \   00000014   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000018   0xF104 0x0108      ADD      R1,R4,#+8
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x.... 0x....      BL       sendPacketData
    100          	sch_create_timeout(rtc_get_ticks()+1000, timer_cb_test1, 0, str_LED_BLINK_1);
   \   00000022   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000026   0x4623             MOV      R3,R4
   \   00000028   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002C   0xF05F 0x0200      MOVS.W   R2,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \   00000034                      REQUIRE ?Subroutine0
   \   00000034                      ;; // Fall through to label ?Subroutine0
    101          }
    102          ///////////////////////////////////////////////
    103          /**
    104            * routing_init - performs initial setup of routing
    105            */

   \                                 In section .text, align 2, keep-with-next
    106          void routing_init_MMCR()
    107          {
   \                     routing_init_MMCR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    108          //	mmcr_route_search_BS_ = MY_DEST;	// address of the target node (BS)
    109          //	AODVcounter_update = 1;
    110          //	mmcr_Hello_counter = 0;
    111          //	mmcr_ACK_MMCR_counter = 0;
    112          //	mmcr_DAT_MMCR_counter = 0;
    113          //	mmcr_Hello_countdown_=0;
    114          
    115          	mmcr_state_=MMCR_STATE_IDLE;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    116          	
    117          	mmcr_pkt_id = 0xFF;
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    118          
    119          	enableDataTx_ = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    120          
    121          
    122          	mmcr_init_rtable_from_topology();
   \   0000001A   0x.... 0x....      BL       mmcr_init_rtable_from_topology
    123          
    124          	///sch_add_loop(( sch_loop_func_t )mmcr_loop );
    125          	timer_cb_test1(0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE8BD 0x4002      POP      {R1,LR}
   \   00000024   0x....             B.N      timer_cb_test1
    126          }
    127          
    128          ///////////////////////////////////////////////
    129          /**
    130            * mmcr_init_rtable_from_topology - performs initial setup of topology
    131            */

   \                                 In section .text, align 2, keep-with-next
    132          void mmcr_init_rtable_from_topology()
    133          {
   \                     mmcr_init_rtable_from_topology: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    134          	uint8_t x;
    135          	/* init routing table */
    136          	rtable.length = Neighborhood.TwoHopNodes;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable9_6
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable9_7
   \   0000000A   0xF8D1 0x213A      LDR      R2,[R1, #+314]
   \   0000000E   0x7002             STRB     R2,[R0, #+0]
    137          	for (x = 0; x < rtable.length; x++)
   \   00000010   0xF04F 0x33FF      MOV      R3,#-1
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000001A   0xE013             B.N      ??mmcr_init_rtable_from_topology_0
    138          	{
    139          		rtable.rentry[x].ID = Neighborhood.TwoHop[x].ID;
   \                     ??mmcr_init_rtable_from_topology_1: (+1)
   \   0000001C   0xEB02 0x0642      ADD      R6,R2,R2, LSL #+1
   \   00000020   0x1876             ADDS     R6,R6,R1
   \   00000022   0x2512             MOVS     R5,#+18
   \   00000024   0xFB05 0x0502      MLA      R5,R5,R2,R0
   \   00000028   0xF8B6 0x6118      LDRH     R6,[R6, #+280]
   \   0000002C   0xF8A5 0x6001      STRH     R6,[R5, #+1]
    140          		rtable.rentry[x].NextHopID = RTR_NO_ROUTE;
   \   00000030   0xF8C5 0x4003      STR      R4,[R5, #+3]
    141          		rtable.rentry[x].NextHopCost = 0xFFFFFFFF;
   \   00000034   0xF8C5 0x3007      STR      R3,[R5, #+7]
    142          		rtable.rentry[x].AltNextHopID = RTR_NO_ROUTE;
   \   00000038   0xF8C5 0x400B      STR      R4,[R5, #+11]
    143          		rtable.rentry[x].AltNextHopCost = 0xFFFFFFFF;
    144          	}
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   \   0000003E   0xF8C5 0x300F      STR      R3,[R5, #+15]
   \   00000042   0xB2D2             UXTB     R2,R2
   \                     ??mmcr_init_rtable_from_topology_0: (+1)
   \   00000044   0x7805             LDRB     R5,[R0, #+0]
   \   00000046   0x42AA             CMP      R2,R5
   \   00000048   0xDBE8             BLT.N    ??mmcr_init_rtable_from_topology_1
    145          }
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    146          
    147          #define ROUTE_COST_AGE_STEP	10000
    148          
    149          /**
    150          *
    151          *  Increases the costs in neighbors and routing tables - to remove nodes over time
    152          */

   \                                 In section .text, align 2, keep-with-next
    153          void mmcr_age_tables()
    154          {
   \                     mmcr_age_tables: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    155          	for (uint8_t x = 0; x < rtable.length; x++)
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000C   0xF242 0x7210      MOVW     R2,#+10000
   \   00000010   0x....             LDR.N    R3,??DataTable9_8  ;; 0xffffd8ef
   \   00000012   0x....             LDR.N    R4,??DataTable9_7
   \   00000014   0xE023             B.N      ??mmcr_age_tables_0
    156          	{
    157          //		rtable.rentry[x].ID = Neighborhood.TwoHop[x].ID;
    158          		if ( 0xFFFFFFFF - ROUTE_COST_AGE_STEP > rtable.rentry[x].NextHopCost )
   \                     ??mmcr_age_tables_1: (+1)
   \   00000016   0x2612             MOVS     R6,#+18
   \   00000018   0xFB06 0x4605      MLA      R6,R6,R5,R4
   \   0000001C   0xF8D6 0x7007      LDR      R7,[R6, #+7]
   \   00000020   0x429F             CMP      R7,R3
   \   00000022   0xD20A             BCS.N    ??mmcr_age_tables_2
    159          		{
    160          			rtable.rentry[x].NextHopCost += ROUTE_COST_AGE_STEP;
   \   00000024   0x19D7             ADDS     R7,R2,R7
   \   00000026   0xF8C6 0x7007      STR      R7,[R6, #+7]
    161          		}
    162          		else
    163          		{
    164          			// rtable record spotted -> clear next hop
    165          			rtable.rentry[x].NextHopID = rtable.rentry[x].AltNextHopID;
    166          			rtable.rentry[x].NextHopCost = rtable.rentry[x].AltNextHopCost;
    167          			rtable.rentry[x].AltNextHopID = RTR_NO_ROUTE;
    168          			rtable.rentry[x].AltNextHopCost = 0xFFFFFFFF;			
    169          		}
    170          		if ( 0xFFFFFFFF - ROUTE_COST_AGE_STEP > rtable.rentry[x].AltNextHopCost )
   \   0000002A   0xF8D6 0x700F      LDR      R7,[R6, #+15]
   \   0000002E   0x429F             CMP      R7,R3
   \   00000030   0xD20F             BCS.N    ??mmcr_age_tables_3
    171          		{
    172          			rtable.rentry[x].AltNextHopCost += ROUTE_COST_AGE_STEP;
   \   00000032   0x19D7             ADDS     R7,R2,R7
   \   00000034   0xF8C6 0x700F      STR      R7,[R6, #+15]
   \   00000038   0xE00F             B.N      ??mmcr_age_tables_4
    173          		}
   \                     ??mmcr_age_tables_2: (+1)
   \   0000003A   0xF8D6 0x700B      LDR      R7,[R6, #+11]
   \   0000003E   0xF8C6 0x7003      STR      R7,[R6, #+3]
   \   00000042   0xF8D6 0x700F      LDR      R7,[R6, #+15]
   \   00000046   0xF8C6 0x7007      STR      R7,[R6, #+7]
   \   0000004A   0xF8C6 0x100B      STR      R1,[R6, #+11]
   \   0000004E   0xF8C6 0x000F      STR      R0,[R6, #+15]
    174          		else
    175          		{
    176          			rtable.rentry[x].AltNextHopCost = 0xFFFFFFFF;
   \                     ??mmcr_age_tables_3: (+1)
   \   00000052   0xF8C6 0x000F      STR      R0,[R6, #+15]
    177          			rtable.rentry[x].AltNextHopID = RTR_NO_ROUTE;
   \   00000056   0xF8C6 0x100B      STR      R1,[R6, #+11]
    178          		}
    179          	}
   \                     ??mmcr_age_tables_4: (+1)
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
   \   0000005C   0xB2ED             UXTB     R5,R5
   \                     ??mmcr_age_tables_0: (+1)
   \   0000005E   0x7826             LDRB     R6,[R4, #+0]
   \   00000060   0x42B5             CMP      R5,R6
   \   00000062   0xDBD8             BLT.N    ??mmcr_age_tables_1
    180          }
   \   00000064   0xBDF0             POP      {R4-R7,PC}       ;; return
    181          ///////////////////////////////////////////////
    182          
    183          
    184          ///////////////////////////////////////////////
    185          ///////////////////////////////////////////////
    186          
    187          
    188          
    189          ///////////////////////////////////////////////
    190          ///////////////////////////////////////////////
    191          
    192          ///////////////////////////////////////////////
    193          ///////////////////////////////////////////////
    194          /**
    195            * oedsr_start_routing - re-starts the route discovery for DST_ID
    196            *
    197            *
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          void mmcr_start_routing( uint16_t dst_id )
    200          {
    201          	// MMCR is proactive routing protocol thus it is "always" running
    202          	return;
   \                     mmcr_start_routing: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    203          }
    204          
    205          ///////////////////////////////////////////////
    206          ///////////////////////////////////////////////
    207          
    208          /**
    209          *	mmcr_recv_routing_msg()
    210          */

   \                                 In section .text, align 2, keep-with-next
    211          uint8_t	mmcr_recv_routing_msg(pkt_t XDATA *pkt)
    212          {
   \                     mmcr_recv_routing_msg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    213          	switch (pkt->flags)
   \   00000002   0x7841             LDRB     R1,[R0, #+1]
   \   00000004   0x296A             CMP      R1,#+106
   \   00000006   0xD007             BEQ.N    ??mmcr_recv_routing_msg_0
   \   00000008   0xD313             BCC.N    ??mmcr_recv_routing_msg_1
   \   0000000A   0x296C             CMP      R1,#+108
   \   0000000C   0xD00B             BEQ.N    ??mmcr_recv_routing_msg_2
   \   0000000E   0xD307             BCC.N    ??mmcr_recv_routing_msg_3
   \   00000010   0x296E             CMP      R1,#+110
   \   00000012   0xD003             BEQ.N    ??mmcr_recv_routing_msg_4
   \   00000014   0xD30A             BCC.N    ??mmcr_recv_routing_msg_5
   \   00000016   0xE00C             B.N      ??mmcr_recv_routing_msg_1
    214          	{
    215          		case FLAG_HELLO_MMCR:
    216           			mmcr_recvHELLO ( ( hpkt_mmcr_t XDATA * ) pkt );
   \                     ??mmcr_recv_routing_msg_0: (+1)
   \   00000018   0x.... 0x....      BL       mmcr_recvHELLO
    217          			break;
    218          		case FLAG_ACK_MMCR:
    219          //			if ( ( 0 < route_search_on_ ) || ( 0 < route_search_count_ ) )
    220          			{
    221          				mmcr_recvACK ( (apkt_t_mmcr*)pkt );				
    222          			}
    223          			break;
    224          		case FLAG_TC_MMCR:
    225          			mmcr_recvTC ( (tpkt_t_mmcr*)pkt );
    226          			break;
    227          			
    228          		case FLAG_CHSW_MMCR:
    229          			mmcr_recvCHSW ( (tpkt_t_mmcr*)pkt );
    230          			break;
    231          
    232          		case FLAG_SELECT_MMCR:
    233          			//mmcr_recvSelect ( pkt );
    234          			break;
    235          		///////////////////////////////////////////////
    236          		// Packet unknown -> was not processed by the routing implementation
    237          		default:
    238          			return RTR_NOT_DONE;
    239          	}
    240          	// Channel switch
    241          /* // Causes to return to original RF channel too quickly
    242          	if (mmcr_ch_counter == 15)
    243          	{
    244          		phy_set_RF_channel(mmcr_return_ch);
    245          		routing_init_MMCR();
    246          		mmcr_ch_counter = 0; //01/17/2011
    247          
    248          	}
    249          */
    250          	return RTR_DONE;
   \                     ??mmcr_recv_routing_msg_4: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   \                     ??mmcr_recv_routing_msg_3: (+1)
   \   00000020   0x.... 0x....      BL       mmcr_recvACK
   \   00000024   0xE7FA             B.N      ??mmcr_recv_routing_msg_4
   \                     ??mmcr_recv_routing_msg_2: (+1)
   \   00000026   0x.... 0x....      BL       mmcr_recvTC
   \   0000002A   0xE7F7             B.N      ??mmcr_recv_routing_msg_4
   \                     ??mmcr_recv_routing_msg_5: (+1)
   \   0000002C   0x.... 0x....      BL       mmcr_recvCHSW
   \   00000030   0xE7F4             B.N      ??mmcr_recv_routing_msg_4
   \                     ??mmcr_recv_routing_msg_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD02             POP      {R1,PC}
    251          }
    252          
    253          ///////////////////////////////////////////////
    254          ///////////////////////////////////////////////
    255          
    256          ///////////////////////////////////////////////
    257          ///////////////////////////////////////////////
    258          /**
    259            * mmcr_rf_ch_sw - send channel switch message
    260            *
    261            */
    262          

   \                                 In section .text, align 2, keep-with-next
    263          void mmcr_rf_ch_sw ( uint8_t *channel_id )
    264          {
   \                     mmcr_rf_ch_sw: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    265          
    266          //	int len = PKT_HEADER_LENGTH; // size of the packet header (start + flag + dst(2) + src(2) + len)
    267          
    268          	tpkt_t_mmcr XDATA *tpkt = ( ( tpkt_t_mmcr XDATA * ) packet);
    269          
    270          	tpkt->start = 0xAA;
   \   00000004   0x....             LDR.N    R5,??DataTable9_9
    271          	tpkt->flags = FLAG_CHSW_MMCR;  // TC packet
    272          	tpkt->mac_dst = MAC_BROADCAST; // Broadcast
    273          	tpkt->mac_src = ENDIAN16(MY_ADDR);
    274          
    275          
    276          	tpkt->length = RTR_MMCR_TC_PKT_SIZE - PKT_HEADER_LENGTH; // of the packet'd data
    277          
    278          	// FILL END-TO-END ADDRESSING
    279          	tpkt->dst_id = 0xFF;
    280          	tpkt->src_id = ENDIAN16(MY_ADDR); // ENDIAN MAY RESULT IN WRONG PART USED (high byte)
    281          
    282          	tpkt->energy=ENDIAN32(my_energy_);
    283          	tpkt->channel=MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL);
    284          	// FILL the CHECKSUM
    285          	// TODO: calculate checksum
    286          	tpkt->mpr_count = 0; //no extra info included
    287          	tpkt->mpr_list = 0x4141; //last byte
    288          
    289          ///////////////////////////////// 12-22-2010 For Channel switching
    290          //	mmcr_ch_counter = 0;
    291          	if (mmcr_ch_counter<15)
   \   00000006   0x....             LDR.N    R6,??DataTable9_10
   \   00000008   0x20AA             MOVS     R0,#+170
   \   0000000A   0x7028             STRB     R0,[R5, #+0]
   \   0000000C   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000010   0x206D             MOVS     R0,#+109
   \   00000012   0x7068             STRB     R0,[R5, #+1]
   \   00000014   0x806A             STRH     R2,[R5, #+2]
   \   00000016   0x....             LDR.N    R0,??DataTable9_11
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0200             LSLS     R0,R0,#+8
   \   0000001C   0x80A8             STRH     R0,[R5, #+4]
   \   0000001E   0x2009             MOVS     R0,#+9
   \   00000020   0x71A8             STRB     R0,[R5, #+6]
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x71E8             STRB     R0,[R5, #+7]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7228             STRB     R0,[R5, #+8]
   \   0000002A   0x....             LDR.N    R0,??DataTable9_12
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0A01             LSRS     R1,R0,#+8
   \   00000030   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   00000034   0x0203             LSLS     R3,R0,#+8
   \   00000036   0xEA41 0x6110      ORR      R1,R1,R0, LSR #+24
   \   0000003A   0xF403 0x037F      AND      R3,R3,#0xFF0000
   \   0000003E   0x4319             ORRS     R1,R3,R1
   \   00000040   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000044   0xF8C5 0x0009      STR      R0,[R5, #+9]
   \   00000048   0x2015             MOVS     R0,#+21
   \   0000004A   0x7368             STRB     R0,[R5, #+13]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x73A8             STRB     R0,[R5, #+14]
   \   00000050   0xF244 0x1041      MOVW     R0,#+16705
   \   00000054   0xF8A5 0x000F      STRH     R0,[R5, #+15]
   \   00000058   0x7830             LDRB     R0,[R6, #+0]
   \   0000005A   0x280F             CMP      R0,#+15
   \   0000005C   0xDA10             BGE.N    ??mmcr_rf_ch_sw_0
    292          	{
    293          		sendPriorityPacket ( tpkt->length+PKT_HEADER_LENGTH, (sint8_t XDATA*) tpkt, MAC_BROADCAST );//ap->mac_dst );
   \   0000005E   0x4629             MOV      R1,R5
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0x.... 0x....      BL       sendPriorityPacket
    294          	 	mmcr_ch_counter++;
   \   00000066   0x7830             LDRB     R0,[R6, #+0]
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x7030             STRB     R0,[R6, #+0]
    295          		// Schedule next
    296          		ch_sw_TIDX = sch_create_timeout(rtc_get_ticks()+MMCR_CHANNEL_SWITCH_REQ_INTERVAL, mmcr_rf_ch_sw, channel_id, str_RTR_CH_SWITCH);
   \   0000006C   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000070   0x1D33             ADDS     R3,R6,#+4
   \   00000072   0x4622             MOV      R2,R4
   \   00000074   0x....             LDR.N    R1,??DataTable9_13
   \   00000076   0x1D40             ADDS     R0,R0,#+5
   \   00000078   0x.... 0x....      BL       sch_create_timeout
   \   0000007C   0x7070             STRB     R0,[R6, #+1]
   \   0000007E   0xBD70             POP      {R4-R6,PC}
    297          	}
    298          	else
    299          	{	// after last request - switch myself
    300          		phy_set_RF_channel(tpkt->channel);
   \                     ??mmcr_rf_ch_sw_0: (+1)
   \   00000080   0x2015             MOVS     R0,#+21
   \   00000082   0x.... 0x....      BL       phy_set_RF_channel
    301          		(*channel_id) = tpkt->channel;
   \   00000086   0x7B68             LDRB     R0,[R5, #+13]
   \   00000088   0x7020             STRB     R0,[R4, #+0]
    302          	}
    303          }
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    304          
    305          /////////////////////////////////
    306          /**
    307            * mmcr_recvCHSW - switch channel
    308            *
    309            */

   \                                 In section .text, align 2, keep-with-next
    310          uint8_t mmcr_recvCHSW ( tpkt_t_mmcr* pkt )
    311          {
   \                     mmcr_recvCHSW: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    312          //	tp->channel=MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL);
    313          //	tp->channel=MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL); // Workaround for compiler issue
    314          //	tp->channel=MMCR_SWITCH_CHANNEL(DEFAULT_RF_CHANNEL);
    315          	phy_set_RF_channel(pkt->channel);
   \   00000002   0x7B40             LDRB     R0,[R0, #+13]
   \   00000004   0x.... 0x....      BL       phy_set_RF_channel
    316          	return 1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    317          }
    318          ///////////////////////////////////////////////
    319          ///////////////////////////////////////////////
    320          
    321          ///////////////////////////////////////////////
    322          ///////////////////////////////////////////////
    323          
    324          ///////////////////////////////////////////////
    325          ///////////////////////////////////////////////
    326          /**
    327            * mmcr_set_route - adds or updates a route to "dst_id"
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          int mmcr_set_route ( uint16_t dst_id, uint16_t next_hop, uint32_t metric )
    330          {
   \                     mmcr_set_route: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    331          	int i;
    332          #ifndef BS_NEIGHBOR
    333          	if (BS_ADDR == next_hop) // Prevent node from adding BS as next hop (neighbor) if it is not supposed to be one
    334          	{
    335          		return 0;
    336          	}
    337          #endif
    338          	//mpr_select();
    339          	for (i = 0; i < rtable.length; i++)
   \   00000002   0x....             LDR.N    R4,??DataTable9_7
   \   00000004   0x7827             LDRB     R7,[R4, #+0]
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2512             MOVS     R5,#+18
   \   0000000A   0xE000             B.N      ??mmcr_set_route_0
   \                     ??mmcr_set_route_1: (+1)
   \   0000000C   0x1C76             ADDS     R6,R6,#+1
   \                     ??mmcr_set_route_0: (+1)
   \   0000000E   0x42BE             CMP      R6,R7
   \   00000010   0xDA33             BGE.N    ??mmcr_set_route_2
    340          	{
    341          		if (rtable.rentry[i].ID == dst_id)
   \   00000012   0xFB05 0x4306      MLA      R3,R5,R6,R4
   \   00000016   0xF8B3 0xC001      LDRH     R12,[R3, #+1]
   \   0000001A   0x4584             CMP      R12,R0
   \   0000001C   0xD1F6             BNE.N    ??mmcr_set_route_1
    342          		{
    343          			// rtable record spotted -> set next hop
    344          			if (rtable.rentry[i].NextHopID == RTR_NO_ROUTE)
   \   0000001E   0xF8D3 0x0003      LDR      R0,[R3, #+3]
   \   00000022   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000026   0x42A0             CMP      R0,R4
   \   00000028   0xD010             BEQ.N    ??mmcr_set_route_3
    345          			{
    346          				rtable.rentry[i].NextHopID = next_hop;
    347          				rtable.rentry[i].NextHopCost = metric;
    348          				return 1; 	//successfully added route
    349          			}
    350          			else if (rtable.rentry[i].NextHopID == next_hop)
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xBF08             IT       EQ 
   \   0000002E   0xF8C3 0x2007      STREQ    R2,[R3, #+7]
    351          			{
    352          				rtable.rentry[i].NextHopCost = metric;
    353          				return 1; 	//successfully updated route
   \   00000032   0xD03F             BEQ.N    ??mmcr_set_route_4
    354          			}
    355          			else if (metric < rtable.rentry[i].NextHopCost) // If new is better
   \   00000034   0xF8D3 0x0007      LDR      R0,[R3, #+7]
   \   00000038   0x4282             CMP      R2,R0
   \   0000003A   0xD20C             BCS.N    ??mmcr_set_route_5
    356          			{
    357          				rtable.rentry[i].AltNextHopID = rtable.rentry[i].NextHopID;
   \   0000003C   0xF8D3 0x0003      LDR      R0,[R3, #+3]
   \   00000040   0xF8C3 0x000B      STR      R0,[R3, #+11]
    358          				rtable.rentry[i].AltNextHopCost = rtable.rentry[i].NextHopCost;
   \   00000044   0xF8D3 0x0007      LDR      R0,[R3, #+7]
   \   00000048   0xF8C3 0x000F      STR      R0,[R3, #+15]
    359          				rtable.rentry[i].NextHopID = next_hop;
   \                     ??mmcr_set_route_3: (+1)
   \   0000004C   0xF8C3 0x1003      STR      R1,[R3, #+3]
    360          				rtable.rentry[i].NextHopCost = metric;
   \   00000050   0xF8C3 0x2007      STR      R2,[R3, #+7]
    361          				return 1; 	//successfully added route			
   \   00000054   0xE02E             B.N      ??mmcr_set_route_4
    362          			}
    363          			// if not better then First choice
    364          			else if (rtable.rentry[i].AltNextHopID == RTR_NO_ROUTE)
   \                     ??mmcr_set_route_5: (+1)
   \   00000056   0xF8D3 0x000B      LDR      R0,[R3, #+11]
   \   0000005A   0x42A0             CMP      R0,R4
   \   0000005C   0xD008             BEQ.N    ??mmcr_set_route_6
    365          			{
    366          				rtable.rentry[i].AltNextHopID = next_hop;
    367          				rtable.rentry[i].AltNextHopCost = metric;
    368          				return 1; 	//successfully added route
    369          			}
    370          			else if (rtable.rentry[i].AltNextHopID == next_hop)
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xBF08             IT       EQ 
   \   00000062   0xF8C3 0x200F      STREQ    R2,[R3, #+15]
    371          			{
    372          				rtable.rentry[i].AltNextHopCost = metric;
    373          				return 1; 	//successfully updated route
   \   00000066   0xD025             BEQ.N    ??mmcr_set_route_4
    374          			}
    375          			else if (metric < rtable.rentry[i].AltNextHopCost) // If new is better
   \   00000068   0xF8D3 0x000F      LDR      R0,[R3, #+15]
   \   0000006C   0x4282             CMP      R2,R0
   \   0000006E   0xD223             BCS.N    ??mmcr_set_route_7
    376          			{
    377          				rtable.rentry[i].AltNextHopID = next_hop;
   \                     ??mmcr_set_route_6: (+1)
   \   00000070   0xF8C3 0x100B      STR      R1,[R3, #+11]
    378          				rtable.rentry[i].AltNextHopCost = metric;			
   \   00000074   0xF8C3 0x200F      STR      R2,[R3, #+15]
    379          				return 1; 	//successfully added route
   \   00000078   0xE01C             B.N      ??mmcr_set_route_4
    380          			}
    381          			// Found record but nothing has been updated - existing routes are better
    382          			return 0;
    383          		}
    384          	}
    385          	// Have not found entry - is the routing table full?
    386          	if (MMCR_MAX_RTABLE_LEN > rtable.length)
   \                     ??mmcr_set_route_2: (+1)
   \   0000007A   0x2F0A             CMP      R7,#+10
   \   0000007C   0xDA1C             BGE.N    ??mmcr_set_route_7
    387          	{
    388          		rtable.rentry[rtable.length].ID = dst_id;
   \   0000007E   0xFB05 0x4307      MLA      R3,R5,R7,R4
   \   00000082   0xF8A3 0x0001      STRH     R0,[R3, #+1]
    389          		rtable.rentry[rtable.length].NextHopID = next_hop;
   \   00000086   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000008A   0xF8C0 0x1003      STR      R1,[R0, #+3]
    390          		rtable.rentry[rtable.length].NextHopCost = metric;
    391          		rtable.rentry[rtable.length].AltNextHopID = RTR_NO_ROUTE;
   \   0000008E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000092   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000096   0xF8C0 0x2007      STR      R2,[R0, #+7]
   \   0000009A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000009E   0xF8C0 0x100B      STR      R1,[R0, #+11]
    392          		rtable.rentry[rtable.length].AltNextHopCost = 0xFFFFFFFF;
   \   000000A2   0xF04F 0x31FF      MOV      R1,#-1
   \   000000A6   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000AA   0xF8C0 0x100F      STR      R1,[R0, #+15]
    393          		rtable.length++;
   \   000000AE   0x7820             LDRB     R0,[R4, #+0]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0x7020             STRB     R0,[R4, #+0]
    394          		return 1; // Successfully added new routing entry
   \                     ??mmcr_set_route_4: (+1)
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xBDF0             POP      {R4-R7,PC}
    395          	}
    396          	else
    397          	{
    398          		// Define how to remove stale ones
    399          		return 0;
   \                     ??mmcr_set_route_7: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xBDF0             POP      {R4-R7,PC}       ;; return
    400          	}
    401          	//return 0; // two hop id not found!!!
    402          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x7820             LDRB     R0,[R4, #+0]
   \   00000002   0xFB05 0x4000      MLA      R0,R5,R0,R4
   \   00000006   0x4770             BX       LR
    403          ///////////////////////////////////////////////
    404          ///////////////////////////////////////////////
    405          /**
    406            * neighbor_analyse - performs analysis of the neighbor table
    407          		and selects the best node
    408            */

   \                                 In section .text, align 2, keep-with-next
    409          uint16_t mmcr_neighbor_analyse(uint16_t dst_id)
    410          {
   \                     mmcr_neighbor_analyse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    411          	unsigned int i, result = RTR_NO_ROUTE;	// by default FFFF indicating lack of route
   \   00000002   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000006   0x4611             MOV      R1,R2
    412          	
    413          	/* check if dst_id is a one hop neighbor */
    414          	for (i = 0; i < Neighborhood.OneHopNodes; i++)
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x....             LDR.N    R4,??DataTable9_6
   \   0000000C   0xE007             B.N      ??mmcr_neighbor_analyse_0
   \                     ??mmcr_neighbor_analyse_1: (+1)
   \   0000000E   0x251C             MOVS     R5,#+28
   \   00000010   0xFB05 0x4503      MLA      R5,R5,R3,R4
   \   00000014   0x882D             LDRH     R5,[R5, #+0]
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x4629             MOVEQ    R1,R5
    415          	{
    416          		if (Neighborhood.OneHop[i].ID == dst_id)
    417          			result = Neighborhood.OneHop[i].ID;
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??mmcr_neighbor_analyse_0: (+1)
   \   0000001E   0xF8D4 0x5136      LDR      R5,[R4, #+310]
   \   00000022   0x42AB             CMP      R3,R5
   \   00000024   0xD3F3             BCC.N    ??mmcr_neighbor_analyse_1
    418          	}
    419          	/* check if dst_id is a two hop neighbor */
    420          	for (i = 0; i < rtable.length; i++)
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x....             LDR.N    R3,??DataTable9_7
   \   0000002A   0xE005             B.N      ??mmcr_neighbor_analyse_2
    421          	{
    422          		if (rtable.rentry[i].ID == dst_id)
    423          		{
    424          			if ((rtable.rentry[i].NextHopID == RTR_NO_ROUTE) && (rtable.rentry[i].AltNextHopID == RTR_NO_ROUTE))
    425          				result = RTR_NO_ROUTE;
    426          			else if ((rtable.rentry[i].NextHopCost <= rtable.rentry[i].AltNextHopCost) && (rtable.rentry[i].NextHopID != RTR_NO_ROUTE))
    427          				result = rtable.rentry[i].NextHopID;
    428          			else if (rtable.rentry[i].AltNextHopID != RTR_NO_ROUTE)
   \                     ??mmcr_neighbor_analyse_3: (+1)
   \   0000002C   0xF8D5 0x500B      LDR      R5,[R5, #+11]
   \   00000030   0x4295             CMP      R5,R2
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x4629             MOVNE    R1,R5
    429          				result = rtable.rentry[i].AltNextHopID;
   \                     ??mmcr_neighbor_analyse_4: (+1)
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   \                     ??mmcr_neighbor_analyse_2: (+1)
   \   00000038   0x781D             LDRB     R5,[R3, #+0]
   \   0000003A   0x42AC             CMP      R4,R5
   \   0000003C   0xD21B             BCS.N    ??mmcr_neighbor_analyse_5
   \   0000003E   0x2512             MOVS     R5,#+18
   \   00000040   0xFB05 0x3504      MLA      R5,R5,R4,R3
   \   00000044   0xF8B5 0x6001      LDRH     R6,[R5, #+1]
   \   00000048   0x4286             CMP      R6,R0
   \   0000004A   0xD1F4             BNE.N    ??mmcr_neighbor_analyse_4
   \   0000004C   0xF8D5 0x6003      LDR      R6,[R5, #+3]
   \   00000050   0x4296             CMP      R6,R2
   \   00000052   0xBF02             ITTT     EQ 
   \   00000054   0xF8D5 0x600B      LDREQ    R6,[R5, #+11]
   \   00000058   0x4296             CMPEQ    R6,R2
   \   0000005A   0x4611             MOVEQ    R1,R2
   \   0000005C   0xD0EB             BEQ.N    ??mmcr_neighbor_analyse_4
   \   0000005E   0xF8D5 0x600F      LDR      R6,[R5, #+15]
   \   00000062   0xF8D5 0x7007      LDR      R7,[R5, #+7]
   \   00000066   0x42BE             CMP      R6,R7
   \   00000068   0xD3E0             BCC.N    ??mmcr_neighbor_analyse_3
   \   0000006A   0xF8D5 0x6003      LDR      R6,[R5, #+3]
   \   0000006E   0x4296             CMP      R6,R2
   \   00000070   0xD0DC             BEQ.N    ??mmcr_neighbor_analyse_3
   \   00000072   0x4631             MOV      R1,R6
   \   00000074   0xE7DF             B.N      ??mmcr_neighbor_analyse_4
    430          		}
    431          	}
    432          	return result;
   \                     ??mmcr_neighbor_analyse_5: (+1)
   \   00000076   0xB288             UXTH     R0,R1
   \   00000078   0xBDF0             POP      {R4-R7,PC}       ;; return
    433          }
    434          
    435          ///////////////////////////////////////////////
    436          /**
    437            * sendDATA - handles a sending of DATA packet
    438            * 1) check if buffer ready then passes packet
    439            * 2) else temporarly stores
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          char MMCR_send_DATA_base ( uint16_t base )
    442          {
   \                     MMCR_send_DATA_base: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    443          	unsigned int mac_d;
    444          	pkt_t * XDATA pkt = ( pkt_t* ) ( & ( buffer0[ base] ) ); //&(QBUFF_ACCESS(base,0));
    445          
    446          
    447          //	if (enableDataTx_)
    448          	//if (1)
    449          	{
    450          	  if (0xFF == pkt->dst_id)
   \   00000002   0x....             LDR.N    R1,??DataTable9_14
   \   00000004   0x1844             ADDS     R4,R0,R1
   \   00000006   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000000A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD10B             BNE.N    ??MMCR_send_DATA_base_0
    451          	  {
    452          		mac_d = MAC_BROADCAST;
   \   00000010   0x4628             MOV      R0,R5
    453          	  }
    454          	  else
    455          	  {
    456          		mac_d = mmcr_neighbor_analyse ( pkt->dst_id );
    457          		if ( ( RTR_NO_ROUTE == mac_d ))// || ( 0 == enableDataTx_ ) )
    458          		{
    459          			// if the route search returned 0xFFFF then there is no route!!!
    460          			// then start new one and drop the packet
    461          			mmcr_startRouteSearch(&(pkt->dst_id));// MY_DEST); //2010-12-13 Reset network after losting link
    462          			//MZ: for multiple destinations that makes no sense:
    463          			//enableDataTx_ = 0; // do not pass date anymore
    464          			// return the packet to queue
    465          //			app_drop_pkt ( base, MODULE_RTR, REASON_NOROUTE, EVENT_DSEND );
    466          			return ROUTING_BEGAN_ROUTE_DISCOVERY;
    467          		}
    468          	  }
    469          		pkt->mac_dst = ENDIAN16(mac_d);
   \                     ??MMCR_send_DATA_base_1: (+1)
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x0200             LSLS     R0,R0,#+8
   \   00000016   0xEA40 0x2011      ORR      R0,R0,R1, LSR #+8
   \   0000001A   0x8060             STRH     R0,[R4, #+2]
    470          		pkt->mac_src = ENDIAN16(MY_ADDR);
   \   0000001C   0x....             LDR.N    R0,??DataTable9_11
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0200             LSLS     R0,R0,#+8
   \   00000022   0x80A0             STRH     R0,[R4, #+4]
    471          
    472          	}
    473          //	else
    474          //	{
    475          //		APPEND_LOG ( NODE_ID_STR, NODE_ID_STR_LEN );
    476          //		APPEND_LOG ( "DROP DATA\r", 10 );
    477          		// drop the packet
    478          //		return 0;
    479          //	}
    480          	return 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??MMCR_send_DATA_base_0: (+1)
   \   00000028   0x.... 0x....      BL       mmcr_neighbor_analyse
   \   0000002C   0x42A8             CMP      R0,R5
   \   0000002E   0xD1F0             BNE.N    ??MMCR_send_DATA_base_1
   \   00000030   0x1DE0             ADDS     R0,R4,#+7
   \   00000032   0x.... 0x....      BL       mmcr_startRouteSearch
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
    481          }
    482          
    483          ///////////////////////////////////////////////
    484          ///////////////////////////////////////////////
    485          /**
    486            * recvAcceptData - handles a received ACCEPT DATA packet from BS
    487            * 1) enables data transmission
    488            * 2)
    489            */

   \                                 In section .text, align 2, keep-with-next
    490          uint8_t mmcr_recvAcceptData ( sint8_t *pkt )
    491          {
    492          	pkt_t XDATA *p = ( ( pkt_t XDATA * ) pkt);
    493          
    494          	// analyse ACK packet
    495          	if ( 0xFFFF == ENDIAN16(p->mac_dst) )
   \                     mmcr_recvAcceptData: (+1)
   \   00000000   0x8840             LDRH     R0,[R0, #+2]
   \   00000002   0x0A01             LSRS     R1,R0,#+8
   \   00000004   0x0200             LSLS     R0,R0,#+8
   \   00000006   0xF400 0x407F      AND      R0,R0,#0xFF00
   \   0000000A   0x4308             ORRS     R0,R0,R1
   \   0000000C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD103             BNE.N    ??mmcr_recvAcceptData_0
    496          	{
    497          		// enable DATA transmission
    498          		enableDataTx_ = 1;
   \   00000014   0x....             LDR.N    R1,??DataTable9_5
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    499          
    500          
    501          		APPEND_LOG ( NODE_ID_STR, NODE_ID_STR_LEN );
    502          		APPEND_LOG ( "DATA - OK\r\r\r", 12 );
    503          
    504          		return 1;
   \   0000001A   0x4770             BX       LR
    505          	}
    506          
    507          
    508          	// wrong trasmitter
    509          	return 0;
   \                     ??mmcr_recvAcceptData_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    510          }
    511          
    512          /////////////////////////////////
    513          /**
    514            * mmcr_dropped_link(??) - the link failed (after few retransmissions??) - update routing
    515            *    and optionally restart route discovery
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          void mmcr_dropped_link(uint16_t hop_id)
    518          {
   \                     mmcr_dropped_link: (+1)
   \   00000000   0xE92D 0x46F8      PUSH     {R3-R7,R9,R10,LR}
   \   00000004   0x4604             MOV      R4,R0
    519          	int i;
    520          	if (MAC_BROADCAST == hop_id)
   \   00000006   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000000A   0x42AC             CMP      R4,R5
   \   0000000C   0xD03A             BEQ.N    ??mmcr_dropped_link_0
    521          		return;
    522          	for (i = 0; i < rtable.length; i++)
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0xF04F 0x39FF      MOV      R9,#-1
   \   00000014   0x....             LDR.N    R7,??DataTable9_7
   \   00000016   0xE032             B.N      ??mmcr_dropped_link_1
    523          	{
    524          		if (rtable.rentry[i].ID == hop_id)
   \                     ??mmcr_dropped_link_2: (+1)
   \   00000018   0x2012             MOVS     R0,#+18
   \   0000001A   0xFB00 0x7A06      MLA      R10,R0,R6,R7
   \   0000001E   0xF8BA 0x0001      LDRH     R0,[R10, #+1]
   \   00000022   0x42A0             CMP      R0,R4
   \   00000024   0xD112             BNE.N    ??mmcr_dropped_link_3
    525          		{
    526          			// rtable record spotted -> clear next hop
    527          			rtable.rentry[i].NextHopID = rtable.rentry[i].AltNextHopID;
   \   00000026   0xF8DA 0x000B      LDR      R0,[R10, #+11]
   \   0000002A   0xF8CA 0x0003      STR      R0,[R10, #+3]
    528          			rtable.rentry[i].NextHopCost = rtable.rentry[i].AltNextHopCost;
   \   0000002E   0xF8DA 0x000F      LDR      R0,[R10, #+15]
   \   00000032   0xF8CA 0x0007      STR      R0,[R10, #+7]
    529          			rtable.rentry[i].AltNextHopID = RTR_NO_ROUTE;
   \   00000036   0xF8CA 0x500B      STR      R5,[R10, #+11]
    530          			rtable.rentry[i].AltNextHopCost = 0xFFFFFFFF;
   \   0000003A   0xF8CA 0x900F      STR      R9,[R10, #+15]
    531          			if ( RTR_NO_ROUTE == rtable.rentry[i].NextHopID )
   \   0000003E   0xF8DA 0x0003      LDR      R0,[R10, #+3]
   \   00000042   0x42A8             CMP      R0,R5
   \   00000044   0xBF04             ITT      EQ 
   \   00000046   0x2000             MOVEQ    R0,#+0
   \   00000048   0x.... 0x....      BLEQ     mmcr_startRouteSearch
    532          				mmcr_startRouteSearch(0);
    533          		}
    534          		if (rtable.rentry[i].NextHopID == hop_id)
   \                     ??mmcr_dropped_link_3: (+1)
   \   0000004C   0xF8DA 0x0003      LDR      R0,[R10, #+3]
   \   00000050   0x42A0             CMP      R0,R4
   \   00000052   0xD10B             BNE.N    ??mmcr_dropped_link_4
    535          		{
    536          			// rtable record spotted -> clear next hop
    537          			rtable.rentry[i].NextHopID = rtable.rentry[i].AltNextHopID;
   \   00000054   0xF8DA 0x000B      LDR      R0,[R10, #+11]
   \   00000058   0xF8CA 0x0003      STR      R0,[R10, #+3]
    538          			rtable.rentry[i].NextHopCost = rtable.rentry[i].AltNextHopCost;
   \   0000005C   0xF8DA 0x000F      LDR      R0,[R10, #+15]
   \   00000060   0xF8CA 0x0007      STR      R0,[R10, #+7]
    539          			rtable.rentry[i].AltNextHopID = RTR_NO_ROUTE;
   \   00000064   0xF8CA 0x500B      STR      R5,[R10, #+11]
    540          			rtable.rentry[i].AltNextHopCost = 0xFFFFFFFF;
   \   00000068   0xF8CA 0x900F      STR      R9,[R10, #+15]
    541          		}
    542          		if (rtable.rentry[i].AltNextHopID == hop_id)
   \                     ??mmcr_dropped_link_4: (+1)
   \   0000006C   0xF8DA 0x000B      LDR      R0,[R10, #+11]
   \   00000070   0x42A0             CMP      R0,R4
   \   00000072   0xBF04             ITT      EQ 
   \   00000074   0xF8CA 0x500B      STREQ    R5,[R10, #+11]
   \   00000078   0xF8CA 0x900F      STREQ    R9,[R10, #+15]
    543          		{
    544          			// rtable record spotted -> clear alternative next hop
    545          			//rtable.rentry[i].NextHopID = rtable.rentry[i].AltNextHopID;
    546          			//rtable.rentry[i].NextHopCost = rtable.rentry[i].AltNextHopCost;
    547          			rtable.rentry[i].AltNextHopID = RTR_NO_ROUTE;
    548          			rtable.rentry[i].AltNextHopCost = 0xFFFFFFFF;
    549          		}
    550          	}
   \   0000007C   0x1C76             ADDS     R6,R6,#+1
   \                     ??mmcr_dropped_link_1: (+1)
   \   0000007E   0x7838             LDRB     R0,[R7, #+0]
   \   00000080   0x4286             CMP      R6,R0
   \   00000082   0xDBC9             BLT.N    ??mmcr_dropped_link_2
    551          }
   \                     ??mmcr_dropped_link_0: (+1)
   \   00000084   0xE8BD 0x86F1      POP      {R0,R4-R7,R9,R10,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     str_LED_BLINK_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     str_LED_BLINK_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     timer_cb_test1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     mmcr_state_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     mmcr_pkt_id

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     enableDataTx_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     Neighborhood

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     rtable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0xFFFFD8EF         DC32     0xffffd8ef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     packet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     mmcr_ch_counter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     my_addr8_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     my_energy_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     mmcr_rf_ch_sw

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     buffer0
    552          
    553          
    554          
    555          
    556          /*
    557          void copyOneHop(uint8_t idx_src, idx_dst)
    558          {
    559          	Neighborhood		uint16_t 	ID;
    560          	union {hop_flags_t flags; 	uint8_t flags_u8;};	// flags for one hop node
    561          	uint16_t	Link[10]; // point to index (ID) of the second hop node
    562          	char	Links;
    563          	uint32_t LinkCost;
    564          }
    565          
    566          void removeOneHop(uint16_t id)
    567          {
    568          }
    569          */
    570          
    571          #endif /* FEAT_ENABLE_MMCR */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MMCR_send_DATA_base
        16   -> mmcr_neighbor_analyse
        16   -> mmcr_startRouteSearch
      20   mmcr_age_tables
      32   mmcr_dropped_link
      16   mmcr_init_rtable_from_topology
      20   mmcr_neighbor_analyse
       0   mmcr_recvAcceptData
       8   mmcr_recvCHSW
         8   -> phy_set_RF_channel
       8   mmcr_recv_routing_msg
         8   -> mmcr_recvACK
         8   -> mmcr_recvCHSW
         8   -> mmcr_recvHELLO
         8   -> mmcr_recvTC
      16   mmcr_rf_ch_sw
        16   -> halCommonGetInt32uMillisecondTick
        16   -> phy_set_RF_channel
        16   -> sch_create_timeout
        16   -> sendPriorityPacket
      20   mmcr_set_route
       0   mmcr_start_routing
       8   routing_init_MMCR
         8   -> mmcr_init_rtable_from_topology
         0   -> timer_cb_test1
       8   timer_cb_test1
         8   -> STM_EVAL_LEDOn
         8   -> halCommonGetInt32uMillisecondTick
         0   -> sch_create_timeout
       8   timer_cb_test2
         8   -> STM_EVAL_LEDOff
         8   -> halCommonGetInt32uMillisecondTick
         0   -> sch_create_timeout
         8   -> sendPacketData
         8   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       8  ?Subroutine0
       8  ?Subroutine1
      58  MMCR_send_DATA_base
     102  mmcr_age_tables
      24  mmcr_ch_counter
          ch_sw_TIDX
          str_RTR_CH_SWITCH
     136  mmcr_dropped_link
      76  mmcr_init_rtable_from_topology
     122  mmcr_neighbor_analyse
       1  mmcr_pkt_id
      32  mmcr_recvAcceptData
      12  mmcr_recvCHSW
      54  mmcr_recv_routing_msg
       1  mmcr_return_ch
     140  mmcr_rf_ch_sw
     188  mmcr_set_route
       2  mmcr_start_routing
      38  routing_init_MMCR
     184  rtable
      16  str_LED_BLINK_1
          str_TEST
       8  str_LED_BLINK_2
      28  timer_cb_test1
      52  timer_cb_test2

 
   185 bytes in section .bss
    49 bytes in section .data
 1 116 bytes in section .text
 
 1 116 bytes of CODE memory
   234 bytes of DATA memory

Errors: none
Warnings: 1
