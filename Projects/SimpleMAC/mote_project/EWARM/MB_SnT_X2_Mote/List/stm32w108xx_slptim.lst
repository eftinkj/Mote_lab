###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:30:25
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_slptim.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_slptim.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"stm32w108xx_slptim.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\stm32w108xx_slptim.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\stm32w108xx_slptim.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_slptim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32w108xx_slptim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides firmware functions to manage the Sleep Timer 
      8            *          peripheral.     
      9            *
     10            *  @verbatim
     11            *  
     12           =============================================================================== 
     13                                    ##### SLPTIM features #####  
     14           ===============================================================================
     15              [..]  The sleep timer is dedicated to system timing and waking from sleep at 
     16                    specific times.
     17              [..]  The sleep timer can use either the calibrated 1 kHz reference(CLK1K), 
     18                    or the 32 kHz crystal clock (CLK32K). The default clock source is 
     19                    the internal 1 kHz clock.
     20              [..]  The sleep timer has a prescaler that allows for very long periods of 
     21                    sleep to be timed.
     22              [..]  The timer provides two compare outputs and wrap detection, all of which 
     23                    can be used to generate an interrupt or a wake up event.
     24              [..]  The sleep timer is paused when the debugger halts the ARM Cortex-M3.
     25              
     26              
     27                              ##### How to use this driver #####
     28           ===============================================================================
     29              [..] This driver provides functions to configure and program the Sleep Timer 
     30                   These functions are split in 2 groups:
     31                   (#) SLPTIM management functions: this group includes all needed functions 
     32                       to configure the Sleep Timer.
     33                       (++) Enable/Disable the counter.
     34                       (++) Get counter.
     35                       (++) Select clock to be used as reference.
     36                       (++) Set/Get compare (A or B) values.
     37                   (#) Interrupts and flags management functions: this group includes all needed 
     38                       functions to manage interrupts:
     39                       (++) Enables or disables the specified SLPTIM interrupts.
     40                       (++) Checks whether the specified SLPTIM flag is set or not.
     41                       (++) Clears the specified SLPTIM flag.
     42                   
     43              @endverbatim
     44            *    
     45            ******************************************************************************
     46            * @attention
     47            *
     48            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     49            *
     50            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     51            * You may not use this file except in compliance with the License.
     52            * You may obtain a copy of the License at:
     53            *
     54            *        http://www.st.com/software_license_agreement_liberty_v2
     55            *
     56            * Unless required by applicable law or agreed to in writing, software 
     57            * distributed under the License is distributed on an "AS IS" BASIS, 
     58            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     59            * See the License for the specific language governing permissions and
     60            * limitations under the License.
     61            *
     62            ******************************************************************************
     63            */
     64          
     65          /* Includes ------------------------------------------------------------------*/
     66          #include "stm32w108xx_slptim.h"
     67          
     68          /** @addtogroup STM32W108xx_StdPeriph_Driver
     69            * @{
     70            */
     71          
     72          /** @defgroup SLPTIM 
     73            * @brief SLPTIM driver modules
     74            * @{
     75            */
     76          
     77          /* Private typedef -----------------------------------------------------------*/
     78          /* Private define ------------------------------------------------------------*/
     79          /* Private macro -------------------------------------------------------------*/
     80          /* Private variables ---------------------------------------------------------*/
     81          /* Private function prototypes -----------------------------------------------*/
     82          /* Private functions ---------------------------------------------------------*/
     83          
     84          /** @defgroup SLPTIM_Private_Functions
     85            * @{
     86            */
     87          
     88          /** @defgroup SLPTIM_Group1 SLPTIM management functions
     89           *  @brief   SLPTIM management functions 
     90           *
     91          @verbatim
     92           ===============================================================================
     93                           ##### SLPTIM management functions #####
     94           ===============================================================================
     95              [..]  To use the Sleep Timer:
     96                   (#) Fill the SLPTIM_InitStruct with the desired parameters.
     97                       This must be done while the sleep timer is disabled. 
     98                   (#) Call the SLPTIM_Cmd(ENABLE) function to enable the TIM counter.
     99                   (#) Enable the clock to be used as reference by calling SLPTIM_ClockConfig()
    100                       function.
    101                    
    102              [..] 
    103                  (@) All other functions can be used seperatly to set compareA or compareB value, 
    104                      to get counter value... 
    105                    
    106          @endverbatim
    107            * @{
    108            */
    109            
    110          /**
    111            * @brief  Deinitializes the SLPTIM peripheral registers to their default reset values.
    112            * @retval None
    113            *   
    114            */

   \                                 In section .text, align 2, keep-with-next
    115          void SLPTIM_DeInit(void)
    116          {
    117            SLPTMR->CR = 0x00000400;
   \                     SLPTIM_DeInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10  ;; 0x4000600c
   \   00000002   0xF44F 0x6180      MOV      R1,#+1024
   \   00000006   0x6001             STR      R1,[R0, #+0]
    118            SLPTMR->CMPAL = 0x0000FFFF;
   \   00000008   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000C   0x6101             STR      R1,[R0, #+16]
    119            SLPTMR->CMPAH = 0x0000FFFF;
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    120            SLPTMR->CMPBL = 0x0000FFFF;
   \   00000010   0x6181             STR      R1,[R0, #+24]
    121            SLPTMR->CMPBH = 0x0000FFFF;
   \   00000012   0x6141             STR      R1,[R0, #+20]
    122            SLPTMR->ISR = 0x00000007;
   \   00000014   0x2107             MOVS     R1,#+7
   \   00000016   0x....             LDR.N    R0,??DataTable10_1  ;; 0x4000a014
   \   00000018   0x6001             STR      R1,[R0, #+0]
    123            SLPTMR->IER = 0x00000000;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6401             STR      R1,[R0, #+64]
    124          }
   \   0000001E   0x4770             BX       LR               ;; return
    125          
    126          /**
    127            * @brief  Initializes the SLPTIM Time peripheral according to 
    128            *         the specified parameters in the SLPTIM_InitStruct.
    129            * @param  SLPTIM_InitStruct: pointer to a SLPTIM_InitTypeDef
    130            *         structure that contains the configuration information for
    131            *         the specified TIM peripheral.
    132            * @retval None
    133            */

   \                                 In section .text, align 2, keep-with-next
    134          void SLPTIM_Init(SLPTIM_InitTypeDef* SLPTIM_InitStruct)
    135          {
    136            uint32_t tmpcr = 0;
    137          
    138            /* Check the parameters */
    139            assert_param(IS_SLPTIM_COUNTER_MODE(SLPTIM_InitStruct->SLPTIM_CounterMode));
    140            assert_param(IS_SLPTIM_GET_CLKSEL(SLPTIM_InitStruct->SLPTIM_Clock));
    141            assert_param(IS_SLPTIM_CLKDIV(SLPTIM_InitStruct->SLPTIM_Prescaler));
    142            assert_param(IS_SLPTIM_DBGMODE(SLPTIM_InitStruct->SLPTIM_DebugMode));
    143            
    144            tmpcr = SLPTMR->CR;  
   \                     SLPTIM_Init: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10  ;; 0x4000600c
   \   00000002   0x680A             LDR      R2,[R1, #+0]
    145            
    146            /* Set the Sleep Timer Clock */
    147              tmpcr &= (uint32_t)~SLPTMR_CR_CLKSEL;
    148              tmpcr |= (uint32_t)SLPTIM_InitStruct->SLPTIM_Clock;
    149                
    150            /* Set the Prescaler value */
    151             tmpcr &= (uint32_t)~SLPTMR_CR_PSC; 
    152             tmpcr |= (uint32_t)SLPTIM_InitStruct->SLPTIM_Prescaler;
    153              
    154             /* Selects the timer's mode during debug */
    155             tmpcr &= (uint32_t)~SLPTMR_CR_DBGP; 
    156             tmpcr |= (uint32_t)SLPTIM_InitStruct->SLPTIM_DebugMode;
    157          
    158              /* Selects the Counter Mode */
    159              tmpcr &= (uint32_t)~SLPTMR_CR_REVERSE;
    160              tmpcr |= (uint32_t)SLPTIM_InitStruct->SLPTIM_CounterMode;
    161               
    162              SLPTMR->CR = tmpcr;
   \   00000004   0x6803             LDR      R3,[R0, #+0]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0xEA43 0x0242      ORR      R2,R3,R2, LSL #+1
   \   0000000C   0x6843             LDR      R3,[R0, #+4]
   \   0000000E   0xF022 0x02F0      BIC      R2,R2,#0xF0
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x6883             LDR      R3,[R0, #+8]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000022   0x....             B.N      ??Subroutine0_1
    163          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_1  ;; 0x4000a014
   \                     ??Subroutine0_0: (+1)
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \                     ??Subroutine0_1: (+1)
   \   00000004   0x4310             ORRS     R0,R0,R2
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
    164          
    165          /**
    166            * @brief  Fills each SLPTIM_InitStruct member with its default value.
    167            * @param  SLPTIM_InitStruct : pointer to a SLPTIM_InitTypeDef
    168            *         structure which will be initialized.
    169            * @retval None
    170            */

   \                                 In section .text, align 2, keep-with-next
    171          void SLPTIM_StructInit(SLPTIM_InitTypeDef* SLPTIM_InitStruct)
    172          {
    173            /* Set the default configuration */
    174            SLPTIM_InitStruct->SLPTIM_Clock = SLPTIM_CLK_1KHZ;
   \                     SLPTIM_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    175            SLPTIM_InitStruct->SLPTIM_Prescaler = SLPTIM_CLK_DIV0;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    176            SLPTIM_InitStruct->SLPTIM_DebugMode = SLPTIM_DBGRUN;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    177            SLPTIM_InitStruct->SLPTIM_CounterMode = SLPTIM_CountForward;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    178          }
   \   0000000A   0x4770             BX       LR               ;; return
    179          
    180          /**
    181            * @brief  Enables or disables the Sleep Timer.
    182            * @param  NewState: new state of the Sleep Timer.
    183            *   This parameter can be: ENABLE or DISABLE.
    184            * @retval None
    185            */

   \                                 In section .text, align 2, keep-with-next
    186          void SLPTIM_Cmd(FunctionalState NewState)
    187          {  
    188            /* Check the parameters */
    189            assert_param(IS_FUNCTIONAL_STATE(NewState));
    190            
    191              if (NewState != DISABLE)
   \                     SLPTIM_Cmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10  ;; 0x4000600c
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xBF14             ITE      NE 
   \   00000008   0xF440 0x6000      ORRNE    R0,R0,#0x800
   \   0000000C   0xF420 0x6000      BICEQ    R0,R0,#0x800
    192              {
    193                /* Enable the Sleep Timer */
    194                SLPTMR->CR |= (uint32_t)SLPTMR_CR_EN;
    195              }
    196              else
    197              {
    198                /* Disable the clock */
    199                SLPTMR->CR &= (uint32_t)~SLPTMR_CR_EN;
   \   00000010   0x6008             STR      R0,[R1, #+0]
    200              }
    201          } 
   \   00000012   0x4770             BX       LR               ;; return
    202              
    203          /**
    204            * @brief  Sets the SLPTIM Compare A Register value
    205            * @param  CompareA: specifies the Compare A register new value.
    206            * @retval None
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          void SLPTIM_SetCompareA(uint32_t CompareA)
    209          {
    210            /* Set the Compare A Register value */
    211            SLPTMR->CMPAL = (uint32_t)(CompareA & 0x0000FFFF);
   \                     SLPTIM_SetCompareA: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40006018
   \   00000002   0x....             B.N      ?Subroutine1
    212            SLPTMR->CMPAH = (uint32_t)((CompareA >> 16) & 0x0000FFFF);
    213          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xB282             UXTH     R2,R0
   \   00000002   0x604A             STR      R2,[R1, #+4]
   \   00000004   0x0C00             LSRS     R0,R0,#+16
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
    214          
    215          /**
    216            * @brief  Sets the SLPTIM Compare B Register value
    217            * @param  CompareB: specifies the Compare B register new value.
    218            * @retval None
    219            */

   \                                 In section .text, align 2, keep-with-next
    220          void SLPTIM_SetCompareB(uint32_t CompareB)
    221          {
    222            /* Set the Compare B Register value */
    223            SLPTMR->CMPBL = (uint32_t)(CompareB & 0x0000FFFF);
   \                     SLPTIM_SetCompareB: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_3  ;; 0x40006020
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1
    224            SLPTMR->CMPBH = (uint32_t)((CompareB >> 16) & 0x0000FFFF);
    225          }
    226          
    227          /**
    228            * @brief  Gets the SLPTIM Counter value.
    229            * @retval Counter Register value.
    230            */

   \                                 In section .text, align 2, keep-with-next
    231          uint32_t SLPTIM_GetCounter(void)
    232          {
    233            uint32_t counter = 0;
    234            
    235            /* Get the Counter Register value */
    236            counter = (uint32_t)(SLPTMR->CNTH << 16);
   \                     SLPTIM_GetCounter: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_4  ;; 0x40006010
   \   00000002   0x6801             LDR      R1,[R0, #+0]
    237            counter |= (uint32_t)SLPTMR->CNTL;
   \   00000004   0x6840             LDR      R0,[R0, #+4]
    238            
    239            return counter;
   \   00000006   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   0000000A   0x4770             BX       LR               ;; return
    240          }
    241          
    242          /**
    243            * @brief  Gets the SLPTIM Counter high value.
    244            * @retval Counter Register high value.
    245            */

   \                                 In section .text, align 2, keep-with-next
    246          uint32_t SLPTIM_GetCounterHigh(void)
    247          {
   \                     SLPTIM_GetCounterHigh: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    248            __IO uint32_t counter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    249            
    250            /* Get the Counter Register value */
    251            counter = (uint32_t)SLPTMR->CNTH;
   \   00000006   0x....             LDR.N    R0,??DataTable10_4  ;; 0x40006010
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x....             B.N      ?Subroutine2
    252            
    253            return counter;
    254          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0xB001             ADD      SP,SP,#+4
   \   00000006   0x4770             BX       LR               ;; return
    255          
    256          /**
    257            * @brief  Gets the SLPTIM Counter low value.
    258            * @retval Counter Register low value.
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          uint32_t SLPTIM_GetCounterLow(void)
    261          {
   \                     SLPTIM_GetCounterLow: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    262            __IO uint32_t counter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    263            
    264            /* Get the Counter Register value */
    265            counter = (uint32_t)SLPTMR->CNTH;
   \   00000006   0x....             LDR.N    R0,??DataTable10_4  ;; 0x40006010
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x9100             STR      R1,[SP, #+0]
    266            counter = (uint32_t)SLPTMR->CNTL;
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E                      REQUIRE ?Subroutine2
   \   0000000E                      ;; // Fall through to label ?Subroutine2
    267            
    268            return counter;
    269          }
    270          
    271          /**
    272            * @}
    273            */
    274          
    275          /** @defgroup SLPTIM_Group2 Interrupts and flags management functions
    276           *  @brief    Interrupts and flags management functions 
    277           *
    278          @verbatim
    279           ===============================================================================
    280                    ##### Interrupts and flags management functions #####
    281           ===============================================================================
    282          
    283          @endverbatim
    284            * @{
    285            */
    286          
    287          /**
    288            * @brief  Forces the specified SLPTIM interrupts.
    289            * @param  SLPTIM_IT: specifies the SLPTIM interrupts sources to be generated.
    290            *   This parameter can be any combination of the following values:
    291            *     @arg SLPTIM_IT_WRAP: Sleep timer overflow
    292            *     @arg SLPTIM_IT_CMPA: Sleep timer compare A
    293            *     @arg SLPTIM_IT_CMPB: Sleep timer compare B  
    294            * @retval None
    295            */

   \                                 In section .text, align 2, keep-with-next
    296          void SLPTIM_ForceIT(uint32_t SLPTIM_IT)
    297          {  
    298            /* Check the parameters */
    299            assert_param(IS_SLPTIM_IT(SLPTIM_IT));
    300            
    301            /* Force the Interrupt by setting the dedicated interrupt in the IFR register */
    302            SLPTMR->IFR |= SLPTIM_IT;
   \                     SLPTIM_ForceIT: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable10_5  ;; 0x4000a020
   \   00000002   0x....             B.N      ??Subroutine0_0
    303          }
    304          
    305          /**
    306            * @brief  Enables or disables the specified SLPTIM interrupts.
    307            * @param  SLPTIM_IT: specifies the SLPTIM interrupts sources to be enabled or disabled.
    308            *   This parameter can be any combination of the following values:
    309            *     @arg SLPTIM_IT_WRAP: Sleep timer overflow
    310            *     @arg SLPTIM_IT_CMPA: Sleep timer compare A
    311            *     @arg SLPTIM_IT_CMPB: Sleep timer compare B  
    312            * @param  NewState: new state of the SLPTIM interrupts.
    313            *   This parameter can be: ENABLE or DISABLE.
    314            * @retval None
    315            */

   \                                 In section .text, align 2, keep-with-next
    316          void SLPTIM_ITConfig(uint32_t SLPTIM_IT, FunctionalState NewState)
    317          {  
    318            /* Check the parameters */
    319            assert_param(IS_SLPTIM_IT(SLPTIM_IT));
    320            assert_param(IS_FUNCTIONAL_STATE(NewState));
    321            
    322              if (NewState != DISABLE)
   \                     SLPTIM_ITConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10_6  ;; 0x4000a054
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x6811             LDR      R1,[R2, #+0]
   \   00000006   0xBF14             ITE      NE 
   \   00000008   0x4308             ORRNE    R0,R0,R1
   \   0000000A   0xEA21 0x0000      BICEQ    R0,R1,R0
    323              {
    324                /* Enable the Interrupt sources */
    325                SLPTMR->IER |= SLPTIM_IT;
    326              }
    327              else
    328              {
    329                /* Disable the Interrupt sources */
    330                SLPTMR->IER &= (uint32_t)~SLPTIM_IT;
   \   0000000E   0x6010             STR      R0,[R2, #+0]
    331              }
    332          }
   \   00000010   0x4770             BX       LR               ;; return
    333          
    334          /**
    335            * @brief  Checks whether the specified SLPTIM flag is set or not.
    336            * @param  SLPTIM_FLAG: specifies the flag to check.
    337            *   This parameter can be one of the following values:
    338            *     @arg SLPTIM_FLAG_WRAP: Sleep timer overflow
    339            *     @arg SLPTIM_FLAG_CMPA: Sleep timer compare A
    340            *     @arg SLPTIM_FLAG_CMPB: Sleep timer compare B
    341            * @note        
    342            * @retval The new state of SLPTIM_FLAG (SET or RESET).
    343            */

   \                                 In section .text, align 2, keep-with-next
    344          FlagStatus SLPTIM_GetFlagStatus(uint32_t SLPTIM_FLAG)
    345          { 
    346            ITStatus bitstatus = RESET; 
    347            
    348            /* Check the parameters */
    349            assert_param(IS_SLPTIM_FLAG(SLPTIM_FLAG));
    350            
    351              if ((SLPTMR->ISR & SLPTIM_FLAG) != (uint32_t)RESET)
   \                     SLPTIM_GetFlagStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10_1  ;; 0x4000a014
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x4202             TST      R2,R0
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2101             MOVNE    R1,#+1
    352              {
    353                bitstatus = SET;
    354              }
    355              else
    356              {
    357                bitstatus = RESET;
    358              }
    359              return bitstatus;
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    360            }
    361          
    362          /**
    363            * @brief  Clears the specified SLPTIM flag.
    364            * @param  SLPTIM_FLAG: specifies the flag to clear.
    365            *   This parameter can be one of the following values:
    366            *     @arg SLPTIM_FLAG_WRAP: Sleep timer overflow
    367            *     @arg SLPTIM_FLAG_CMPA: Sleep timer compare A
    368            *     @arg SLPTIM_FLAG_CMPB: Sleep timer compare B
    369            * @note        
    370            * @retval The new state of SLPTIM_FLAG (SET or RESET).
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          void SLPTIM_ClearFlag(uint32_t SLPTIM_FLAG)
    373          {
    374            /* Check the parameters */
    375            assert_param(IS_SLPTIM_FLAG(SLPTIM_FLAG));
    376            
    377            /* Clear the flags */  
    378            SLPTMR->ISR |= (uint32_t)SLPTIM_FLAG;
   \                     SLPTIM_ClearFlag: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    379          }
    380          
    381          /**
    382            * @brief  Checks whether the specified SLPTMR pending interrupt has occurred or not
    383            * @param  SLPTIM_IT: specifies the flag to check.
    384            *         This parameter can be one of the following values:
    385            *   This parameter can be one of the following values:
    386            *     @arg SLPTIM_FLAG_WRAP: Sleep timer overflow
    387            *     @arg SLPTIM_FLAG_CMPA: Sleep timer compare A
    388            *     @arg SLPTIM_FLAG_CMPB: Sleep timer compare B
    389            * @retval The new state of SLPTIM_IT (SET or RESET).
    390            */

   \                                 In section .text, align 2, keep-with-next
    391          ITStatus SLPTIM_GetITStatus(uint32_t SLPTIM_IT)
    392          {
    393            ITStatus bitstatus = RESET;
    394            uint32_t enablestatus = 0;
    395            /* Check the parameters */
    396            assert_param(IS_SLPTIM_IT(SLPTIM_IT));
    397          
    398            enablestatus = (uint32_t)(SLPTMR->IER & SLPTIM_IT);
   \                     SLPTIM_GetITStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable10_1  ;; 0x4000a014
   \   00000002   0x6C13             LDR      R3,[R2, #+64]
    399            if (((SLPTMR->ISR & SLPTIM_IT) != (uint32_t)RESET) && enablestatus) 
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4003             ANDS     R3,R0,R3
   \   0000000A   0x4202             TST      R2,R0
   \   0000000C   0xBF1C             ITT      NE 
   \   0000000E   0x2B00             CMPNE    R3,#+0
   \   00000010   0x2101             MOVNE    R1,#+1
    400            {
    401              bitstatus = SET;
    402            }
    403            else
    404            {
    405              bitstatus = RESET;
    406            }
    407            return  bitstatus;
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x4770             BX       LR               ;; return
    408          }
    409          
    410          /**
    411            * @brief  Clears the specified SLPTIM flag.
    412            * @param  SLPTIM_IT: specifies the flag to clear.
    413            *   This parameter can be one of the following values:
    414            *     @arg SLPTIM_FLAG_WRAP: Sleep timer overflow
    415            *     @arg SLPTIM_FLAG_CMPA: Sleep timer compare A
    416            *     @arg SLPTIM_FLAG_CMPB: Sleep timer compare B
    417            * @note        
    418            * @retval The new state of SLPTIM_FLAG (SET or RESET).
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          void SLPTIM_ClearITPendingBit(uint32_t SLPTIM_IT)
   \                     SLPTIM_ClearITPendingBit: (+1)
   \   00000000   0xBF00             Nop      
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_SLPTIM_IT(SLPTIM_IT));
    424            
    425            /* Clear the pending interrupt */  
    426            SLPTMR->ISR |= (uint32_t)SLPTIM_IT;
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x4000600C         DC32     0x4000600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x4000A014         DC32     0x4000a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40006018         DC32     0x40006018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40006020         DC32     0x40006020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x40006010         DC32     0x40006010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x4000A020         DC32     0x4000a020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x4000A054         DC32     0x4000a054
    427          }
    428          
    429          /**
    430            * @}
    431            */
    432            
    433          /**
    434            * @}
    435            */
    436            
    437          /**
    438            * @}
    439            */
    440            
    441          /**
    442            * @}
    443            */
    444            
    445          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SLPTIM_ClearFlag
       0   SLPTIM_ClearITPendingBit
       0   SLPTIM_Cmd
       0   SLPTIM_DeInit
       0   SLPTIM_ForceIT
       0   SLPTIM_GetCounter
       4   SLPTIM_GetCounterHigh
       4   SLPTIM_GetCounterLow
       0   SLPTIM_GetFlagStatus
       0   SLPTIM_GetITStatus
       0   SLPTIM_ITConfig
       0   SLPTIM_Init
       0   SLPTIM_SetCompareA
       0   SLPTIM_SetCompareB
       0   SLPTIM_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
      10  ?Subroutine0
      10  ?Subroutine1
       8  ?Subroutine2
       2  SLPTIM_ClearFlag
       2  SLPTIM_ClearITPendingBit
      20  SLPTIM_Cmd
      32  SLPTIM_DeInit
       4  SLPTIM_ForceIT
      12  SLPTIM_GetCounter
      12  SLPTIM_GetCounterHigh
      14  SLPTIM_GetCounterLow
      16  SLPTIM_GetFlagStatus
      22  SLPTIM_GetITStatus
      18  SLPTIM_ITConfig
      36  SLPTIM_Init
       4  SLPTIM_SetCompareA
       2  SLPTIM_SetCompareB
      12  SLPTIM_StructInit

 
 264 bytes in section .text
 
 264 bytes of CODE memory

Errors: none
Warnings: none
