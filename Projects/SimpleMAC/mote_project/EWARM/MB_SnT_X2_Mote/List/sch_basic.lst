###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        22/Feb/2015  21:25:48
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Scheduler\sch_basic.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Scheduler\sch_basic.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"sch_basic.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Scheduler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\sch_basic.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\sch_basic.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Scheduler\sch_basic.c
      1          #include "defs/esnl_pub.h"
      2          
      3          #ifdef _ENABLE_SCH_BASIC_
      4          
      5          #include "sch_basic_prv.h"
      6          #include "sch_basic_pub.h"
      7          
      8          
      9          //#include "API_frames.h"
     10          //#include "tsp_common_pub.h"
     11          //#include "Application.h"
     12          
     13          #include "sys_func.h"
     14          
     15          
     16          //#define _SCH_DEBUG_ENABLE_
     17          #undef _SCH_DEBUG_ENABLE_
     18          #define _SCH_DEBUG_LEVEL_
     19          
     20          #include "stm32w108xx_gpio.h"
     21          #include "..\HW_LIB\RTC.h"
     22          
     23          
     24          
     25          /****************************************************************************
     26          **	Constants, definies and typedefs  (PUBLIC)
     27          ****************************************************************************/
     28          
     29          /****************************************************************************
     30          **	Variables definition (PRIVATE)
     31          ****************************************************************************/
     32          
     33          //extern uint8_t		truck_state_test;

   \                                 In section .bss, align 4
     34          rtc_tick_t	XDATA	sch_timeout_ticks[MAX_TIMEOUTS];
   \                     sch_timeout_ticks:
   \   00000000                      DS8 120

   \                                 In section .bss, align 4
     35          uint8_t		XDATA	sch_timeout_state[MAX_TIMEOUTS];
   \                     sch_timeout_state:
   \   00000000                      DS8 32
     36          list_size_t	XDATA	sch_timeout_count;
     37          
     38          list_index_t	XDATA	sch_timeout_order[MAX_TIMEOUTS];
     39          list_index_t	XDATA	sch_tout_head;
     40          list_index_t	XDATA	sch_tout_free;
     41          sch_cb_func_t	XDATA	sch_callback_funcs[MAX_TIMEOUTS];
     42          uint8_t XDATA *	XDATA	sch_callback_context[MAX_TIMEOUTS];
     43          char *	sch_callback_name[MAX_TIMEOUTS];
     44          
     45          //sch_loop_func_t	xdata	sch_loop_funcs[MAX_LOOPS];
     46          sch_loop_func_t sch_loop_funcs[MAX_LOOPS];
     47          uint8_t sch_loop_funcs_on[MAX_LOOPS];
   \                     sch_loop_funcs_on:
   \   00000020                      DS8 12
   \                     sch_loop_funcs:
   \   0000002C                      DS8 40

   \                                 In section .bss, align 4
   \                     sch_timeout_order:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
   \                     sch_callback_context:
   \   00000000                      DS8 120

   \                                 In section .bss, align 4
   \                     sch_callback_name:
   \   00000000                      DS8 120

   \                                 In section .bss, align 4
     48          uint32_t start_time_diff[MAX_TIMEOUTS];
   \                     start_time_diff:
   \   00000000                      DS8 120

   \                                 In section .bss, align 4
     49          uint32_t end_time_diff[MAX_TIMEOUTS];
   \                     end_time_diff:
   \   00000000                      DS8 120
     50          uint32_t dummy = 0;
     51          
     52          
     53          
     54          /****************************************************************************
     55          **	Variables definition (PUBLIC)
     56          ****************************************************************************/
     57          

   \                                 In section .text, align 2, keep-with-next
     58          void sch_default_callback( uint8_t tid)
     59          #ifndef _TEMP_ARM_
     60          	TASK_FUNC
     61          #endif // _TEMP_ARM_
     62          {
     63          	//Do default handling HERE
     64          }
   \                     sch_default_callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     65          
     66          /****************************************************************************
     67          **	Functions implementation (PUBLIC)
     68          ****************************************************************************/
     69          
     70          #define SCH_FUNC_OFF	0
     71          #define SCH_FUNC_ON		1
     72          
     73          char str_NONE[] = "NONE";
     74          
     75          /**
     76            * sch_power_up () - power up (tasks/system) SCHEDULING module
     77            */

   \                                 In section .text, align 2, keep-with-next
     78          void sch_power_up ( void )
     79          {
   \                     sch_power_up: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     80          	uint8_t i;
     81              
     82              GPIO_InitTypeDef  GPIO_InitStructure;
     83          	/* Configure the GPIO_LED pin */
     84          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x9000             STR      R0,[SP, #+0]
     85          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_PP;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF88D 0x0004      STRB     R0,[SP, #+4]
     86          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x....             LDR.N    R4,??DataTable11  ;; 0x4000b400
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       GPIO_Init
     87          	//GPIOB->BSR = GPIO_Pin_3; // Set pin (1)
     88          	//GPIOB->BRR = GPIO_Pin_3; // Reset pin (0)
     89              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
   \   00000018   0x2010             MOVS     R0,#+16
   \   0000001A   0x9000             STR      R0,[SP, #+0]
     90              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       GPIO_Init
     91              
     92          	//sch_timeout_ticks[MAX_TIMEOUTS];
     93          	for(i=0; i< MAX_TIMEOUTS; i++)
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x....             LDR.N    R3,??DataTable11_1
   \   00000028   0x....             LDR.N    R4,??DataTable11_2
   \   0000002A   0x....             LDR.N    R5,??DataTable11_3
   \   0000002C   0x....             LDR.N    R1,??DataTable11_4
   \   0000002E   0x....             LDR.N    R0,??DataTable11_5
     94          	{
     95          		sch_timeout_state[i] = SCH_STATE_IDLE;
   \                     ??sch_power_up_0: (+1)
   \   00000030   0x2600             MOVS     R6,#+0
   \   00000032   0x5416             STRB     R6,[R2, R0]
     96          		sch_timeout_order[i] = (i+1)%MAX_TIMEOUTS;
   \   00000034   0x271E             MOVS     R7,#+30
   \   00000036   0x1C56             ADDS     R6,R2,#+1
   \   00000038   0xFB96 0xF7F7      SDIV     R7,R6,R7
   \   0000003C   0xF04F 0x0C1E      MOV      R12,#+30
   \   00000040   0xFB0C 0x6617      MLS      R6,R12,R7,R6
   \   00000044   0x5456             STRB     R6,[R2, R1]
     97          		sch_callback_funcs[i] = (sch_cb_func_t)NULL; //sch_default_callback;
   \   00000046   0x2700             MOVS     R7,#+0
   \   00000048   0x....             LDR.N    R6,??DataTable11_6
   \   0000004A   0xEB06 0x0C82      ADD      R12,R6,R2, LSL #+2
   \   0000004E   0xF8CC 0x7008      STR      R7,[R12, #+8]
     98          		sch_callback_name[i] = str_NONE;
   \   00000052   0xF106 0x0784      ADD      R7,R6,#+132
   \   00000056   0xF845 0x7022      STR      R7,[R5, R2, LSL #+2]
     99                          start_time_diff[i] = 0;
   \   0000005A   0x2700             MOVS     R7,#+0
   \   0000005C   0xF844 0x7022      STR      R7,[R4, R2, LSL #+2]
    100                          end_time_diff[i] = 0;
   \   00000060   0xF843 0x7022      STR      R7,[R3, R2, LSL #+2]
    101          	}
   \   00000064   0x1C52             ADDS     R2,R2,#+1
   \   00000066   0x2A1E             CMP      R2,#+30
   \   00000068   0xDBE2             BLT.N    ??sch_power_up_0
    102          	sch_timeout_order[MAX_TIMEOUTS - 1] = SCH_NO_TIMEOUT_ID; // last points to nothing
   \   0000006A   0x22FF             MOVS     R2,#+255
   \   0000006C   0x774A             STRB     R2,[R1, #+29]
    103          	sch_timeout_count = MAX_TIMEOUTS; // initially all empty
    104          	sch_tout_head = SCH_NO_TIMEOUT_ID; // empty
   \   0000006E   0x7072             STRB     R2,[R6, #+1]
    105          	sch_tout_free = 0; // first empty ID
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x70B1             STRB     R1,[R6, #+2]
    106          
    107          
    108          
    109          	for(i=0; i< MAX_LOOPS; i++)
   \   00000074   0x460A             MOV      R2,R1
    110          	{
    111          		sch_loop_funcs[i] = SCH_NO_FUNC_ID;
   \                     ??sch_power_up_1: (+1)
   \   00000076   0xEB00 0x0381      ADD      R3,R0,R1, LSL #+2
   \   0000007A   0x62DA             STR      R2,[R3, #+44]
    112          		sch_loop_funcs_on[i] = SCH_FUNC_OFF;
   \   0000007C   0x180B             ADDS     R3,R1,R0
    113          	}
   \   0000007E   0x1C49             ADDS     R1,R1,#+1
   \   00000080   0x290A             CMP      R1,#+10
   \   00000082   0xF883 0x2020      STRB     R2,[R3, #+32]
   \   00000086   0xDBF6             BLT.N    ??sch_power_up_1
    114          	sch_timeout_count = 0; // empty
   \   00000088   0x7032             STRB     R2,[R6, #+0]
    115          
    116              
    117              
    118          }
   \   0000008A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    119          
    120          /**
    121            * sch_init () - sets up (tasks/system) SCHEDULING module
    122            */

   \                                 In section .text, align 2, keep-with-next
    123          void sch_init ( void )
    124          {
    125          	// Any initializations - e.g. periodic scheduler job/task
    126          
    127          }
   \                     sch_init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    128          
    129          
    130          
    131          /**
    132          * sch_test() - tests SCHEDULING operation (e.g. RTC correctness)
    133          */

   \                                 In section .text, align 2, keep-with-next
    134          uint8_t sch_test()
    135          {
    136          	return 0;
   \                     sch_test: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    137          }

   \                                 In section .data, align 4
   \                     sch_timeout_count:
   \   00000000   0x00               DC8 0
   \                     sch_tout_head:
   \   00000001   0x00               DC8 0
   \                     sch_tout_free:
   \   00000002   0x00               DC8 0
    138          
    139          uint8_t current_loop_idx;
   \                     current_loop_idx:
   \   00000003   0x00               DC8 0
    140          uint8_t timeout_idx;
   \                     timeout_idx:
   \   00000004   0x00               DC8 0
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \                     sch_callback_funcs:
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     dummy:
   \   00000080   0x00000000         DC32 0
   \                     str_NONE:
   \   00000084   0x4E 0x4F          DC8 "NONE"
   \              0x4E 0x45    
   \              0x00         
   \   00000089   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    141          /**
    142            * sch_loop() - executes main loop block (BUT DOES NOT LOOP ITSELF!!!)
    143            */

   \                                 In section .text, align 2, keep-with-next
    144          void sch_loop( void )
    145          {
   \                     sch_loop: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    146              GPIO_SetBits(GPIOB, GPIO_Pin_3);
   \   00000002   0x....             LDR.N    R4,??DataTable11  ;; 0x4000b400
   \   00000004   0x2108             MOVS     R1,#+8
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       GPIO_SetBits
    147          
    148              
    149              for(current_loop_idx=0; current_loop_idx< MAX_LOOPS; current_loop_idx++)
   \   0000000C   0x....             LDR.N    R5,??DataTable11_6
   \   0000000E   0x....             LDR.N    R6,??DataTable11_5
   \   00000010   0x....             LDR.N    R7,??DataTable11_7
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x70E8             STRB     R0,[R5, #+3]
   \                     ??sch_loop_0: (+1)
   \   00000016   0x78E8             LDRB     R0,[R5, #+3]
   \   00000018   0x1981             ADDS     R1,R0,R6
   \   0000001A   0xF891 0x1020      LDRB     R1,[R1, #+32]
   \   0000001E   0x2901             CMP      R1,#+1
   \   00000020   0xD103             BNE.N    ??sch_loop_1
    150          	{
    151                      
    152                  if (sch_loop_funcs_on[current_loop_idx] == SCH_FUNC_ON)
    153          		{
    154          			(sch_loop_funcs[current_loop_idx])();			
   \   00000022   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \   00000026   0x6AC0             LDR      R0,[R0, #+44]
   \   00000028   0x4780             BLX      R0
    155          		}      
    156                      
    157          	}
   \                     ??sch_loop_1: (+1)
   \   0000002A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x70E8             STRB     R0,[R5, #+3]
   \   00000030   0xB2C0             UXTB     R0,R0
   \   00000032   0x280A             CMP      R0,#+10
   \   00000034   0xDBEF             BLT.N    ??sch_loop_0
    158              
    159          
    160          
    161          	while ( (SCH_NO_TIMEOUT_ID != sch_tout_head )
    162          		&& (sch_timeout_ticks[sch_tout_head ] < rtc_get_ticks()) )
   \                     ??sch_loop_2: (+1)
   \   00000036   0x7868             LDRB     R0,[R5, #+1]
   \   00000038   0x28FF             CMP      R0,#+255
   \   0000003A   0xD03C             BEQ.N    ??sch_loop_3
   \   0000003C   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000040   0x7869             LDRB     R1,[R5, #+1]
   \   00000042   0xF857 0x2021      LDR      R2,[R7, R1, LSL #+2]
   \   00000046   0x4282             CMP      R2,R0
   \   00000048   0xD22E             BCS.N    ??sch_loop_4
    163          	{
    164          
    165                  // Remove from head for the purpose of consistency
    166          		ATOMIC(
    167          			   	timeout_idx = sch_tout_head ;
    168          				sch_tout_head  = sch_timeout_order[sch_tout_head ];
    169          				sch_timeout_order[timeout_idx] = 0xEE;//sch_tout_free;
    170          				sch_timeout_count--;
    171          				)
   \   0000004A   0xF3EF 0x8011      MRS      R0,BASEPRI
   \   0000004E   0x2160             MOVS     R1,#+96
   \   00000050   0xF381 0x8811      MSR      BASEPRI,R1
   \   00000054   0x7869             LDRB     R1,[R5, #+1]
   \   00000056   0x....             LDR.N    R2,??DataTable11_4
   \   00000058   0x7129             STRB     R1,[R5, #+4]
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x5C8B             LDRB     R3,[R1, R2]
   \   0000005E   0x706B             STRB     R3,[R5, #+1]
   \   00000060   0x23EE             MOVS     R3,#+238
   \   00000062   0x548B             STRB     R3,[R1, R2]
   \   00000064   0x7829             LDRB     R1,[R5, #+0]
   \   00000066   0x1E49             SUBS     R1,R1,#+1
   \   00000068   0x7029             STRB     R1,[R5, #+0]
   \   0000006A   0xF380 0x8811      MSR      BASEPRI,R0
    172          		// Execute
    173                          start_time_diff[timeout_idx] = rtc_get_ticks() - sch_timeout_ticks[timeout_idx];
   \   0000006E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000072   0x7929             LDRB     R1,[R5, #+4]
   \   00000074   0xF857 0x2021      LDR      R2,[R7, R1, LSL #+2]
   \   00000078   0x1A80             SUBS     R0,R0,R2
   \   0000007A   0x....             LDR.N    R2,??DataTable11_2
   \   0000007C   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    174          		(sch_callback_funcs[timeout_idx ])(sch_callback_context[timeout_idx] );
   \   00000080   0x....             LDR.N    R0,??DataTable11_8
   \   00000082   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000086   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \   0000008A   0x6889             LDR      R1,[R1, #+8]
   \   0000008C   0x4788             BLX      R1
    175          		// Free the Timer slot for others to use
    176          		sch_timeout_state[timeout_idx] = SCH_STATE_IDLE;
   \   0000008E   0x7929             LDRB     R1,[R5, #+4]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x5588             STRB     R0,[R1, R6]
    177                          end_time_diff[timeout_idx] = rtc_get_ticks() - sch_timeout_ticks[timeout_idx];
   \   00000094   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000098   0x7929             LDRB     R1,[R5, #+4]
   \   0000009A   0xF857 0x2021      LDR      R2,[R7, R1, LSL #+2]
   \   0000009E   0x1A80             SUBS     R0,R0,R2
   \   000000A0   0x....             LDR.N    R2,??DataTable11_1
   \   000000A2   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   000000A6   0xE7C6             B.N      ??sch_loop_2
    178                
    179          	}
    180              
    181                  if(SCH_NO_TIMEOUT_ID != sch_tout_head)
   \                     ??sch_loop_4: (+1)
   \   000000A8   0x29FF             CMP      R1,#+255
   \   000000AA   0xD004             BEQ.N    ??sch_loop_3
    182                  {
    183                      dummy++;
   \   000000AC   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0xF8C5 0x0080      STR      R0,[R5, #+128]
    184                  }
    185              
    186              GPIO_ResetBits(GPIOB, GPIO_Pin_3);
   \                     ??sch_loop_3: (+1)
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000000BC   0x2108             MOVS     R1,#+8
   \   000000BE   0x.... 0x....      B.W      GPIO_ResetBits
    187          }
    188          
    189          

   \                                 In section .text, align 2, keep-with-next
    190          void sch_remove_timeout(uint8_t tidx, char*name)
    191          {
   \                     sch_remove_timeout: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    192          	uint8_t temp = sch_tout_head;
   \   00000002   0x....             LDR.N    R3,??DataTable11_6
   \   00000004   0x785C             LDRB     R4,[R3, #+1]
    193          	if (SCH_NO_TIMEOUT_ID == temp) {printf("ERROR DELETING TO 255\n"); return;} // not found anything (maybe JUST executed)
   \   00000006   0x2CFF             CMP      R4,#+255
   \   00000008   0xD105             BNE.N    ??sch_remove_timeout_0
   \   0000000A   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      B.W      printf
    194          	//printf("SCH_TO_DEL= %d,%s (r=%s)\n\d", temp, sch_callback_name[temp], name);
    195          	//print_timeouts();
    196          	if (  sch_callback_name[tidx] != name ) 
   \                     ??sch_remove_timeout_0: (+1)
   \   00000016   0x....             LDR.N    R5,??DataTable11_3
   \   00000018   0x4602             MOV      R2,R0
   \   0000001A   0xF855 0x6022      LDR      R6,[R5, R2, LSL #+2]
   \   0000001E   0x428E             CMP      R6,R1
   \   00000020   0xD00A             BEQ.N    ??sch_remove_timeout_1
    197          	{
    198          		printf("ERROR DELETING wrong name %d,%s (req=%s)\n", temp, sch_callback_name[temp], name); 
   \   00000022   0xF855 0x2024      LDR      R2,[R5, R4, LSL #+2]
   \   00000026   0x.... 0x....      ADR.W    R0,?_1
   \   0000002A   0x460B             MOV      R3,R1
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0xB001             ADD      SP,SP,#+4
   \   00000030   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000034   0x.... 0x....      B.W      printf
    199          		return; // wrong removal
    200          	}
    201          	sch_timeout_count--;
   \                     ??sch_remove_timeout_1: (+1)
   \   00000038   0x7819             LDRB     R1,[R3, #+0]
    202          	if (tidx == temp) // TIDX is the HEAD
   \   0000003A   0x....             LDR.N    R5,??DataTable11_5
   \   0000003C   0x....             LDR.N    R6,??DataTable11_4
   \   0000003E   0x1E49             SUBS     R1,R1,#+1
   \   00000040   0x42A2             CMP      R2,R4
   \   00000042   0x7019             STRB     R1,[R3, #+0]
   \   00000044   0xD103             BNE.N    ??sch_remove_timeout_2
    203          	{
    204          		sch_tout_head = sch_timeout_order[tidx]; // remove timeout from ORDERED list
   \   00000046   0x5D90             LDRB     R0,[R2, R6]
   \   00000048   0x7058             STRB     R0,[R3, #+1]
    205          		sch_timeout_order[tidx] = 0xEE;//sch_tout_free;
   \   0000004A   0xE007             B.N      ??sch_remove_timeout_3
    206          		sch_timeout_state[tidx] = SCH_STATE_IDLE; // free timeout record
    207          		return;
    208          	}
    209          	// Find the previous item in the list to skip/remove the TIDX
    210          	while (SCH_NO_TIMEOUT_ID != sch_timeout_order[temp])
    211          	{
    212          		if ( tidx == sch_timeout_order[temp])
    213          		{
    214          		// Remove from the list
    215          			//		ATOMIC(
    216          			   	sch_timeout_order[temp] = sch_timeout_order[tidx]; // skip the TIDX
    217          				sch_timeout_order[tidx] = 0xEE;//sch_tout_free;
    218          				sch_timeout_state[tidx] = SCH_STATE_IDLE; // free timeout record
    219          //				)
    220          				return;
    221          		}
    222          		temp = sch_timeout_order[temp]; // go to next
   \                     ??sch_remove_timeout_4: (+1)
   \   0000004C   0x463C             MOV      R4,R7
   \                     ??sch_remove_timeout_2: (+1)
   \   0000004E   0x5DA7             LDRB     R7,[R4, R6]
   \   00000050   0x2FFF             CMP      R7,#+255
   \   00000052   0xD008             BEQ.N    ??sch_remove_timeout_5
   \   00000054   0x42B8             CMP      R0,R7
   \   00000056   0xD1F9             BNE.N    ??sch_remove_timeout_4
   \   00000058   0x5D90             LDRB     R0,[R2, R6]
   \   0000005A   0x55A0             STRB     R0,[R4, R6]
   \                     ??sch_remove_timeout_3: (+1)
   \   0000005C   0x20EE             MOVS     R0,#+238
   \   0000005E   0x5590             STRB     R0,[R2, R6]
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x5550             STRB     R0,[R2, R5]
   \   00000064   0xBDF1             POP      {R0,R4-R7,PC}
    223          	}
    224          	// NOT FOUND
    225          	sch_timeout_count++; // revert to original count
   \                     ??sch_remove_timeout_5: (+1)
   \   00000066   0x1C48             ADDS     R0,R1,#+1
   \   00000068   0x7018             STRB     R0,[R3, #+0]
    226          }
   \   0000006A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    227          
    228          /**
    229            * sch_correct_time_shift (offset) - updates schedule timeouts to accomodate
    230            *		for the RTC shift due to clock (re-)synchronization (e.g. from BEAM pkt)
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          void sch_correct_time_shift ( int32_t offset)
    233          {
    234          	// TODO: handle case when the RTC has been set to a new value (large change)
    235          	// 		this will require shift in all timeouts
    236          }
   \                     sch_correct_time_shift: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    237          
    238          /**
    239            * sch_create_timeout (timeout, callback_func) - sets a new timeout at "timoeut"
    240            *		RTC ticks (absolute value). When timeout expires, the "callback_func" is
    241            *		executed (function has to be REENTRANT and accept timeout ID as param)
    242            *	RETURNS: timeout ID or "SCH_NO_TIMEOUT_ID" if unsuccesful
    243            */

   \                                 In section .text, align 2, keep-with-next
    244          uint8_t sch_create_timeout( rtc_tick_t timeout, sch_cb_func_t callback_func, uint8_t* t_context, char*name)
    245          {
   \                     sch_create_timeout: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    246          	list_index_t tidx;
    247          	list_index_t order_idx = sch_tout_head;
   \   00000004   0x....             LDR.N    R5,??DataTable11_6
   \   00000006   0x786E             LDRB     R6,[R5, #+1]
   \   00000008   0x4680             MOV      R8,R0
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0x4691             MOV      R9,R2
   \   0000000E   0x469A             MOV      R10,R3
    248          	// TODO: find a free timeout ID
    249          	tidx = get_free_timeout();
   \   00000010   0x.... 0x....      BL       get_free_timeout
   \   00000014   0x4607             MOV      R7,R0
    250          // DEBUG
    251          	printf("SCH_TO_SET= %d,%s #\n", tidx, name);
   \   00000016   0x4652             MOV      R2,R10
   \   00000018   0x4639             MOV      R1,R7
   \   0000001A   0x.... 0x....      ADR.W    R0,?_2
   \   0000001E   0x.... 0x....      BL       printf
    252          	if (SCH_NO_TIMEOUT_ID == tidx)
   \   00000022   0x2FFF             CMP      R7,#+255
   \   00000024   0xBF08             IT       EQ 
   \   00000026   0x20FF             MOVEQ    R0,#+255
    253          	{
    254          		return SCH_NO_TIMEOUT_ID;
   \   00000028   0xD029             BEQ.N    ??sch_create_timeout_0
    255          	}
    256          	//		then, set the timeout
    257          	sch_timeout_count++;
   \   0000002A   0x7828             LDRB     R0,[R5, #+0]
    258          	sch_timeout_ticks[tidx] = timeout;
    259          	sch_timeout_state[tidx] = SCH_STATE_PENDING;
   \   0000002C   0x....             LDR.N    R2,??DataTable11_5
    260          	sch_callback_funcs[tidx] = callback_func;
    261          	sch_callback_context[tidx] = t_context;
    262          	sch_callback_name[tidx] = name;
    263          
    264          	//		then, insert into the timeouts' list
    265          	if ((SCH_NO_TIMEOUT_ID == sch_tout_head) || (timeout < sch_timeout_ticks[sch_tout_head]))
   \   0000002E   0x....             LDR.N    R3,??DataTable11_4
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x7028             STRB     R0,[R5, #+0]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x....             LDR.N    R0,??DataTable11_7
   \   00000038   0xF840 0x8027      STR      R8,[R0, R7, LSL #+2]
   \   0000003C   0x54B9             STRB     R1,[R7, R2]
   \   0000003E   0xEB05 0x0187      ADD      R1,R5,R7, LSL #+2
   \   00000042   0x608C             STR      R4,[R1, #+8]
   \   00000044   0x....             LDR.N    R1,??DataTable11_8
   \   00000046   0xF841 0x9027      STR      R9,[R1, R7, LSL #+2]
   \   0000004A   0x....             LDR.N    R1,??DataTable11_3
   \   0000004C   0xF841 0xA027      STR      R10,[R1, R7, LSL #+2]
   \   00000050   0x7869             LDRB     R1,[R5, #+1]
   \   00000052   0x460A             MOV      R2,R1
   \   00000054   0x2AFF             CMP      R2,#+255
   \   00000056   0xD003             BEQ.N    ??sch_create_timeout_1
   \   00000058   0xF850 0x2022      LDR      R2,[R0, R2, LSL #+2]
   \   0000005C   0x4590             CMP      R8,R2
   \   0000005E   0xD203             BCS.N    ??sch_create_timeout_2
    266          	{
    267          		sch_timeout_order[tidx] = sch_tout_head; // put as first
   \                     ??sch_create_timeout_1: (+1)
   \   00000060   0x54F9             STRB     R1,[R7, R3]
    268          		sch_tout_head = tidx;
   \   00000062   0x706F             STRB     R7,[R5, #+1]
   \   00000064   0xE00A             B.N      ??sch_create_timeout_3
    269          	}
    270          	else
    271          	{
    272          		// Until the current item is last (next is empty)
    273          		//		OR until next item in the list is later than the new timeout
    274          		while ((SCH_NO_TIMEOUT_ID != sch_timeout_order[order_idx])
    275          			   && (timeout > sch_timeout_ticks[sch_timeout_order[order_idx]]))
    276          		{
    277          			order_idx = sch_timeout_order[order_idx];
   \                     ??sch_create_timeout_4: (+1)
   \   00000066   0x460E             MOV      R6,R1
    278          		}
   \                     ??sch_create_timeout_2: (+1)
   \   00000068   0x5CF1             LDRB     R1,[R6, R3]
   \   0000006A   0x460A             MOV      R2,R1
   \   0000006C   0x2AFF             CMP      R2,#+255
   \   0000006E   0xD003             BEQ.N    ??sch_create_timeout_5
   \   00000070   0xF850 0x2022      LDR      R2,[R0, R2, LSL #+2]
   \   00000074   0x4542             CMP      R2,R8
   \   00000076   0xD3F6             BCC.N    ??sch_create_timeout_4
    279          		sch_timeout_order[tidx] = sch_timeout_order[order_idx]; // inherit the next in list
   \                     ??sch_create_timeout_5: (+1)
   \   00000078   0x54F9             STRB     R1,[R7, R3]
    280          		sch_timeout_order[order_idx] = tidx; // connect to the previous item (earlier event)
   \   0000007A   0x54F7             STRB     R7,[R6, R3]
    281          		
    282          	}
    283          	return tidx;
   \                     ??sch_create_timeout_3: (+1)
   \   0000007C   0x4638             MOV      R0,R7
   \                     ??sch_create_timeout_0: (+1)
   \   0000007E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    284          }
    285          
    286          
    287          
    288          
    289          /**
    290            * sch_add_loop( sch_loop_func_t loop_func) - sets a new loop function to
    291            *		be executed every time in the main loop
    292            *	RETURNS: loop function ID or "SCH_NO_FUNC_ID" if unsuccesful
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          uint8_t sch_add_loop( sch_loop_func_t loop_func)
    295          {
    296          	uint8_t i = SCH_NO_TIMEOUT_ID;
    297          	for( i= 0; i < MAX_LOOPS; i++)
   \                     sch_add_loop: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable11_5
    298          	{
    299          		if (sch_loop_funcs_on[i] == SCH_FUNC_OFF)
   \                     ??sch_add_loop_0: (+1)
   \   00000004   0x188B             ADDS     R3,R1,R2
   \   00000006   0xF893 0x3020      LDRB     R3,[R3, #+32]
   \   0000000A   0xB11B             CBZ.N    R3,??sch_add_loop_1
    300          		{
    301          			break;
    302          		}
    303          	}
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x290A             CMP      R1,#+10
   \   00000012   0xDBF7             BLT.N    ??sch_add_loop_0
    304          	if (MAX_LOOPS > i)
   \                     ??sch_add_loop_1: (+1)
   \   00000014   0x290A             CMP      R1,#+10
   \   00000016   0xDA08             BGE.N    ??sch_add_loop_2
    305          	{
    306          		sch_loop_funcs[i] = loop_func;
   \   00000018   0xEB02 0x0381      ADD      R3,R2,R1, LSL #+2
    307          		sch_loop_funcs_on[i] = SCH_FUNC_ON;
   \   0000001C   0x188A             ADDS     R2,R1,R2
   \   0000001E   0x62D8             STR      R0,[R3, #+44]
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF882 0x0020      STRB     R0,[R2, #+32]
    308          		return i;
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x4770             BX       LR
    309          	}
    310          	// else not found free space
    311          	return 	SCH_NO_TIMEOUT_ID;
   \                     ??sch_add_loop_2: (+1)
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x4770             BX       LR               ;; return
    312          }
    313          
    314          /****************************************************************************
    315          **	Functions implementation (PRIVATE)
    316          ****************************************************************************/
    317          
    318          
    319          /**
    320          *  sch_init_timeout_list () - (re)sets the timeout list
    321          */

   \                                 In section .text, align 2, keep-with-next
    322          void sch_init_timeout_list()
    323          {
    324          
    325          }
   \                     sch_init_timeout_list: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    326          
    327          /**
    328          *  get_free_timeout () - finds free slot in timeout tables,
    329          *       RETURN: "index", or SCH_NO_TIMEOUT_ID if no space left
    330          *		NOTE: Sets state of timer to SCH_STATE_BUSY
    331          */

   \                                 In section .text, align 2, keep-with-next
    332          list_index_t get_free_timeout()
    333          {
   \                     get_free_timeout: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    334          	list_index_t i;
    335          	for(i=0; i < MAX_TIMEOUTS; i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable11_5
    336          	{
    337          		if ( SCH_STATE_IDLE == sch_timeout_state[i] )
   \                     ??get_free_timeout_0: (+1)
   \   00000006   0x5C43             LDRB     R3,[R0, R1]
   \   00000008   0xB913             CBNZ.N   R3,??get_free_timeout_1
    338          		{
    339          			sch_timeout_state[i]= SCH_STATE_BUSY;
   \   0000000A   0x2303             MOVS     R3,#+3
   \   0000000C   0x5443             STRB     R3,[R0, R1]
    340          			return i;
   \   0000000E   0xBD02             POP      {R1,PC}
    341          		}
    342          	}
   \                     ??get_free_timeout_1: (+1)
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x281E             CMP      R0,#+30
   \   00000016   0xDBF6             BLT.N    ??get_free_timeout_0
    343          	printf("NO TIMEOUTS LEFT = %d\n", sch_timeout_count);
   \   00000018   0x....             LDR.N    R0,??DataTable11_6
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0x.... 0x....      ADR.W    R0,?_3
   \   00000020   0x.... 0x....      BL       printf
    344          	return SCH_NO_TIMEOUT_ID;
   \   00000024   0x20FF             MOVS     R0,#+255
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    345          }
    346          
    347          /**
    348          *  print_timeouts () - prints state of the timeout table,
    349          *       uses STDOUT (mostly serial interface UART)
    350          */

   \                                 In section .text, align 2, keep-with-next
    351          void print_timeouts()
    352          {
   \                     print_timeouts: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    353          	list_index_t i;
    354          	for(i=0; i < MAX_TIMEOUTS-20; i++)
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x.... 0x....      ADR.W    R5,?_4
   \   0000000A   0x....             LDR.N    R6,??DataTable11_5
   \   0000000C   0x....             LDR.N    R7,??DataTable11_4
   \   0000000E   0x.... 0x....      LDR.W    R8,??DataTable11_3
    355          	{
    356          		printf(" %d/%d,/%s\n" 
    357          			   , sch_timeout_state[i]
    358          				   , sch_timeout_order[i]
    359          				   , sch_callback_name[i]);
   \                     ??print_timeouts_0: (+1)
   \   00000012   0xF858 0x3024      LDR      R3,[R8, R4, LSL #+2]
   \   00000016   0x5DE2             LDRB     R2,[R4, R7]
   \   00000018   0x5DA1             LDRB     R1,[R4, R6]
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       printf
    360          	}	
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \   00000022   0x2C0A             CMP      R4,#+10
   \   00000024   0xDBF5             BLT.N    ??print_timeouts_0
    361          }
   \   00000026   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x4000B400         DC32     0x4000b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     end_time_diff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     start_time_diff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     sch_callback_name

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     sch_timeout_order

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     sch_timeout_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     sch_timeout_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     sch_timeout_ticks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     sch_callback_context

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x45 0x52          DC8 "ERROR DELETING TO 255\012"
   \              0x52 0x4F    
   \              0x52 0x20    
   \              0x44 0x45    
   \              0x4C 0x45    
   \              0x54 0x49    
   \              0x4E 0x47    
   \              0x20 0x54    
   \              0x4F 0x20    
   \              0x32 0x35    
   \              0x35 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x52          DC8 "ERROR DELETING wrong name %d,%s (req=%s)\012"
   \              0x52 0x4F    
   \              0x52 0x20    
   \              0x44 0x45    
   \              0x4C 0x45    
   \              0x54 0x49    
   \              0x4E 0x47    
   \              0x20 0x77    
   \              0x72 0x6F    
   \              0x6E 0x67    
   \              0x20 0x6E    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x25 0x64    
   \              0x2C 0x25    
   \              0x73 0x20    
   \              0x28 0x72    
   \              0x65 0x71    
   \              0x3D 0x25    
   \              0x73 0x29    
   \              0x0A 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x53 0x43          DC8 "SCH_TO_SET= %d,%s #\012"
   \              0x48 0x5F    
   \              0x54 0x4F    
   \              0x5F 0x53    
   \              0x45 0x54    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x2C 0x25    
   \              0x73 0x20    
   \              0x23 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x4E 0x4F          DC8 "NO TIMEOUTS LEFT = %d\012"
   \              0x20 0x54    
   \              0x49 0x4D    
   \              0x45 0x4F    
   \              0x55 0x54    
   \              0x53 0x20    
   \              0x4C 0x45    
   \              0x46 0x54    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x20 0x25          DC8 " %d/%d,/%s\012"
   \              0x64 0x2F    
   \              0x25 0x64    
   \              0x2C 0x2F    
   \              0x25 0x73    
   \              0x0A 0x00    
    362          
    363          // ############################################################################
    364          // ############################################################################
    365          
    366          
    367          
    368          
    369          // ############################################################################
    370          // ############################################################################
    371          // Spacers
    372          // ############################################################################
    373          // ############################################################################
    374          
    375          
    376          
    377          #endif // _ENABLE_NEM_UTILITIES_01_
    378          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   get_free_timeout
         8   -> printf
      24   print_timeouts
        24   -> printf
       0   sch_add_loop
       0   sch_correct_time_shift
      32   sch_create_timeout
        32   -> get_free_timeout
        32   -> printf
       0   sch_default_callback
       0   sch_init
       0   sch_init_timeout_list
      24   sch_loop
        24   -- Indirect call
         0   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> halCommonGetInt32uMillisecondTick
      32   sch_power_up
        32   -> GPIO_Init
      24   sch_remove_timeout
         0   -> printf
       0   sch_test


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
      24  ?_0
      44  ?_1
      24  ?_2
      24  ?_3
      12  ?_4
     120  end_time_diff
      40  get_free_timeout
      42  print_timeouts
      46  sch_add_loop
     120  sch_callback_context
     120  sch_callback_name
       2  sch_correct_time_shift
     130  sch_create_timeout
       2  sch_default_callback
       2  sch_init
       2  sch_init_timeout_list
     194  sch_loop
     140  sch_power_up
     108  sch_remove_timeout
       4  sch_test
     140  sch_timeout_count
          sch_tout_head
          sch_tout_free
          current_loop_idx
          timeout_idx
          sch_callback_funcs
          dummy
          str_NONE
      32  sch_timeout_order
      84  sch_timeout_state
          sch_loop_funcs_on
          sch_loop_funcs
     120  sch_timeout_ticks
     120  start_time_diff

 
 716 bytes in section .bss
 140 bytes in section .data
 876 bytes in section .text
 
 876 bytes of CODE memory
 856 bytes of DATA memory

Errors: none
Warnings: none
