###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:26:05
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\Application.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\Application.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"Application.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\Application.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\Application.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\Application.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          
     17          #include "defs/esnl_pub.h"
     18          
     19          #include "common.h"
     20          #include "Application.h"
     21          #include "FEAT_Queuing/Queuing.h"
     22          #include "HW_LIB/RTC.h"
     23          //#include "HW_LIB/adc_0.h"
     24          //#include "HW_LIB/new_adc_0_pub.h"
     25          #include "packet.h"
     26          #include "FEAT_Scheduler/sch_basic_pub.h"
     27          
     28          #include "FEAT_Routing/routing.h"
     29          #ifdef _ENABLE_OEDSR_
     30          	#include "FEAT_Routing/routing_OEDSR.h"
     31          #endif
     32          #ifdef _ARM_
     33          	#include "FEAT_STM32W/STM32W_Radio.h"
     34          #endif // _ARM_
     35          #include "FEAT_Networking/Phy_layer.h"
     36          #include "FEAT_XBee_API/AT_scripts.h"
     37          
     38          //#define FEAT_XBee_API
     39          #ifdef _ENABLE_APP_MOD_
     40          
     41          
     42          #ifdef FEAT_ENABLE_CC
     43          #include "congestionControl.h"
     44          #endif
     45          
     46          
     47          unsigned char XDATA app_tx_data_mode_ = APP_DEFAULT_TX_DATA_MODE;
     48          //bit app_send_data = 0;
     49          uint8_t app_generate_pkt_ = 0;
     50          unsigned char XDATA n_samples_per_packet_ = SAMPLES_PER_PACKET;	// samples per packet

   \                                 In section .bss, align 1
     51          unsigned char XDATA last_config_rssi_rcv_;
   \                     last_config_rssi_rcv_:
   \   00000000                      DS8 1
     52          
     53          unsigned int XDATA app_count_drop_pkts_;	// Dropped packets
     54          unsigned int XDATA app_count_lost_pkts_;	// Lost during TX packets
     55          unsigned int XDATA app_count_sent_pkts_;	// Sent out succesfully
     56          unsigned int XDATA app_count_recv_pkts_;	// Received from other nodes
     57          unsigned int XDATA app_count_gen_pkts_;	// Generated by this node
     58          
     59          unsigned int XDATA app_beam_count_; // Count received beams
     60          unsigned int XDATA app_beacon_count_;	// Received beacon messages
     61          
     62          rtc_tick_t XDATA app_last_BS_contact_;
     63          uint8_t app_repeat_beam;
     64          uint16_t XDATA app_beam_seq;
     65          
     66          /**
     67            * app_init() - resets app counters and variables
     68            */

   \                                 In section .text, align 2, keep-with-next
     69          void app_init()
     70          {
     71          	app_count_drop_pkts_ = 0;	// Dropped packets
   \                     app_init: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14
     72          	app_count_lost_pkts_ = 0;	// Lost during TX packets
     73          	app_count_sent_pkts_ = 0;	// Sent out succesfully
     74          	app_count_recv_pkts_ = 0;	// Received from other nodes
     75          	app_count_gen_pkts_ = 0;	// Generated by this node
     76          	app_beam_count_ 	= 0;	// Received beam messages
     77          	app_beacon_count_ 	= 0;	// Received beacon messages
     78          
     79          	app_last_BS_contact_ = 0;
     80          	app_repeat_beam = BEAM_REPEAT_DEFAULT_ACTION;
     81          	app_beam_seq = 0xFFFF; // first time always repeat and syncronize with BS
     82          
     83          	// Disable data generation
     84          //	app_send_data = 0;
     85          	app_generate_pkt_ = 0;
     86          	// reset counter
     87          	sequence_no_ = 1;
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable14_1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   \   0000000E   0x6101             STR      R1,[R0, #+16]
   \   00000010   0x6141             STR      R1,[R0, #+20]
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0x61C1             STR      R1,[R0, #+28]
   \   00000016   0x6201             STR      R1,[R0, #+32]
   \   00000018   0x6241             STR      R1,[R0, #+36]
   \   0000001A   0x70C1             STRB     R1,[R0, #+3]
   \   0000001C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000020   0x80C1             STRH     R1,[R0, #+6]
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x7041             STRB     R1,[R0, #+1]
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x7011             STRB     R1,[R2, #+0]
     88          
     89          	app_tx_data_mode_ = 3;//APP_DEFAULT_TX_DATA_MODE;
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x7001             STRB     R1,[R0, #+0]
     90          	n_samples_per_packet_ = SAMPLES_PER_PACKET;
   \   0000002E   0x215A             MOVS     R1,#+90
   \   00000030   0x7081             STRB     R1,[R0, #+2]
     91          
     92          #if defined (_ENABLE_ADC_MODULE_) //|| defined (_ENABLE_NEW_ADC_MODULE_)
     93          	app_suspendADC();
     94          #endif // _ENABLE_ADC_MODULE_
     95          
     96          	sch_add_loop((sch_loop_func_t)app_loop);
   \   00000032   0x.... 0x....      ADR.W    R0,app_loop
   \   00000036   0x.... 0x....      B.W      sch_add_loop
     97          }
     98          
     99          
    100          
    101          
    102          /**
    103           *  app_loop() - executes main loop block (BUT DOES NOT LOOP ITSELF!!!)
    104           */

   \                                 In section .text, align 4, keep-with-next
    105          void app_loop( void )
    106          {
   \                     app_loop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    107          #ifdef _ENABLE_APP_MOD_
    108          		switch ( network_search_mode_ )
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14
   \   00000006   0x7920             LDRB     R0,[R4, #+4]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2803             CMPNE    R0,#+3
   \   0000000E   0xD108             BNE.N    ??app_loop_0
    109          		{
    110          			case SEARCH_OFF:
    111          				break;
    112          			case SEARCH_BEACON_BS_SWITCHING:
    113          				// Do nothing since the BS is switching
    114          				break;
    115          			case SEARCH_BEACON_NODE_SWITCHING:
    116          				// Switch to a new channel
    117          				if ( rtc_get_ticks() > switch_timeout_ )
    118          				{
    119          					app_search_switch_channel();
    120          				}
    121          				break;
    122          			case SEARCH_OEDSR_HELLO:
    123          				if ( rtc_get_ticks() > switch_timeout_ )
   \   00000010   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000014   0x6AA1             LDR      R1,[R4, #+40]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xBF3C             ITT      CC 
    124          				{
    125          					app_search_switch_channel();
   \   0000001A   0xE8BD 0x4010      POPCC    {R4,LR}
   \   0000001E   0x.... 0x....      BCC.W    app_search_switch_channel
    126          				}
    127          				break;
    128          			default:
    129          				// ERROR
    130          				break;
    131          		}
    132          #endif // _ENABLE_APP_MOD_
    133          
    134          }
   \                     ??app_loop_0: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    135          
    136          
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void app_recvStopData ( pkt_t *p )
    139          {
    140          #ifdef SOURCE
    141          	// stop data transmission
    142          	if ( ( 0xFFFF == p->mac_dst ) || ( MY_ADDR == p->mac_dst ) )
   \                     app_recvStopData: (+1)
   \   00000000   0x8840             LDRH     R0,[R0, #+2]
   \   00000002   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xBF1E             ITTT     NE 
   \   0000000A   0x.... 0x....      LDRNE.W  R1,??DataTable14_2
   \   0000000E   0x7809             LDRBNE   R1,[R1, #+0]
   \   00000010   0x4281             CMPNE    R1,R0
   \   00000012   0xD107             BNE.N    ??app_recvStopData_0
    143          	{
    144          //		app_send_data = 0;
    145          		app_generate_pkt_ = 0;
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x7048             STRB     R0,[R1, #+1]
    146          		// reset counter
    147          		sequence_no_ = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    148          #if defined (_ENABLE_ADC_MODULE_) //|| defined (_ENABLE_NEW_ADC_MODULE_)
    149          		app_suspendADC();
    150          #endif // _ENABLE_ADC_MODULE_
    151          	}
    152          #endif
    153          #if defined(_ENABLE_SRC_DUMMY_) || defined (_ENABLE_SSN_8BIT_)
    154          	ssn_stop_burst();
                 	^
Warning[Pe223]: function "ssn_stop_burst" declared implicitly
   \                     ??app_recvStopData_0: (+1)
   \   00000024   0x.... 0x....      B.W      ssn_stop_burst
    155          #endif // _ENABLE_SRC_DUMMY_
    156          }
    157          
    158          
    159          

   \                                 In section .text, align 2, keep-with-next
    160          void app_recvStartData ( pkt_t *p )
    161          {
    162          #ifdef SOURCE
    163          #if defined (_ENABLE_ADC_MODULE_) //|| defined (_ENABLE_NEW_ADC_MODULE_)
    164          	// start data transmission
    165          	if ( ( 0xFFFF == p->mac_dst ) || ( MY_ADDR == p->mac_dst ) )
    166          	{
    167          //		app_send_data = 1;
    168          		app_generate_pkt_ = 1;
    169          		// reset counter
    170          		sequence_no_ = 1;
    171          		app_resumeADC();
    172          	}
    173          #endif // #if defined (_ENABLE_ADC_MODULE_) || defined (_ENABLE_NEW_ADC_MODULE_)
    174          
    175          #if defined(_ENABLE_SRC_DUMMY_) || defined (_ENABLE_SSN_8BIT_)
    176          	ssn_start_burst(10000);
                 	^
Warning[Pe223]: function "ssn_start_burst" declared implicitly
   \                     app_recvStartData: (+1)
   \   00000000   0xF242 0x7010      MOVW     R0,#+10000
   \   00000004   0x.... 0x....      B.W      ssn_start_burst
    177          #endif // _ENABLE_SRC_DUMMY_
    178          	
    179          #endif
    180          }
    181          
    182          //#define MAX_CONFIG_PKT_SIZE 50
    183          
    184          

   \                                 In section .text, align 2, keep-with-next
    185          void app_sendConfigSensor()
    186          {
   \                     app_sendConfigSensor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    187          //	uint8_t XDATA temp[MAX_CONFIG_PKT_SIZE];
    188          	uint8_t XDATA temp[CONFIG_LEN];
    189          	conpkt_t XDATA *pkt = (conpkt_t XDATA*)temp;
    190          	//Refill the packet and send out the response
    191          	pkt->start = START_BYTE;
    192          	pkt->flags = FLAG_CONFIG_RESP;
    193          	pkt->mac_dst = BS_ADDR;
    194          	pkt->mac_src = MY_ADDR;
    195          	pkt->length = 28;
    196          	pkt->dst_id = BS_ADDR;
    197          	pkt->src_id = MY_ADDR;
    198          
    199          
    200          	//Section for Sampling Settings
    201          	pkt->data_mode = app_tx_data_mode_;
    202          #ifdef _ENABLE_ADC_MODULE_
    203          	pkt->divider = adc_sample_rate_divider_;
    204          	pkt->averager = adc_sample_averaging_;
    205          	pkt->data_size = n_samples_per_packet_;
    206          	pkt->num_adc_chan = number_of_channels_;
    207          #else	// _ENABLE_ADC_MODULE_
    208          	pkt->divider = 0xFF;
    209          	pkt->averager = 0xFF;
    210          	pkt->data_size = n_samples_per_packet_;
    211          	pkt->num_adc_chan = 0x00;
    212          #endif // else _ENABLE_ADC_MODULE_
    213          	//Section for RF Settings
    214          	pkt->current_RF_chan = my_rf_channel_;
    215          	pkt->power_control_scheme = 0x00; //Hardcoded for future use, currenly no controller online
    216          	pkt->power_level = my_tx_power_;
    217          	pkt->RSSI_thresh = my_rssi_threshold_;
    218          
    219          	//Settings for OEDSR
    220          	pkt->distance = my_distance_;
    221          	pkt->energy = my_energy_;
    222          	pkt->RF_TX_retries = my_RF_retries_;
    223          
    224          	//Settings for Protocol Selection
    225          	pkt->protocol = my_protocol_;
    226          	pkt->scheduling_protocol = my_scheduling_;
    227          
    228          	//Section for Scheduling Settings
    229          	pkt->src_weight = 0;//my_source_weight_;
    230          	pkt->node_weight = 0;//my_weight_;
    231          
    232          	//Clustering Settings
    233          	pkt->current_CH = my_CH_;
    234          
    235          	//For Recieved Config packet RSSI Feedback
    236          	pkt->rssi = last_config_rssi_rcv_;
    237          
    238          	//Place Stop Byte
    239          	pkt->crc = STOP_BYTE;
    240          
    241          	phy_set_power_level ( MAX_POWER_LEVEL );
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x.... 0x....      BL       phy_set_power_level
    242          #ifdef _ENABLE_XBEE_API_
    243          	api_send_packet16 ( (char *)temp, CONFIG_LEN, BS_ADDR );
    244          #endif // _ENABLE_XBEE_API_
    245          	phy_set_power_level ( my_tx_power_ );
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000012   0x.... 0x....      B.W      phy_set_power_level
    246          
    247          }
    248          

   \                                 In section .text, align 4, keep-with-next
    249          void app_recvConfigSensor ( pkt_t *p , unsigned char rssi )
    250          {
   \                     app_recvConfigSensor: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    251          //#ifdef SOURCE
    252          #ifdef _ARM_
    253          //	return; // Causes node to become disabled
    254          //uint16_t temp_rate=500;
    255          #endif // _ARM_
    256          	//unsigned char offset = 0;
    257          	uint32_t offset = 0;
    258          	config_generic_t *cfg_gen = ( config_generic_t * ) ( ( ( char* ) p ) + ISN_APP_NEW_CONFIG_OFFSET_FROM_CUSTOM_HEADER );
   \   00000004   0xF100 0x0609      ADD      R6,R0,#+9
   \   00000008   0x4688             MOV      R8,R1
    259          	unsigned char flag = cfg_gen->config_flag;
   \   0000000A   0x7830             LDRB     R0,[R6, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R11,??DataTable14_4
   \   00000010   0x....             LDR.N    R4,??DataTable14_5
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable14_6
   \   00000016   0x.... 0x....      LDR.W    R10,??DataTable14_7
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xE003             B.N      ??app_recvConfigSensor_1
    260          
    261          	while ( ISN_APP_CONFIG_FLAG_END != flag )
    262          	{
    263          		switch ( flag )
    264          		{
    265          			case ISN_APP_CONFIG_FLAG_SAMPLING:
    266          				{
    267          					//config_sampling_t *cp = ( config_sampling_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    268          					offset = ISN_APP_CONFIG_LEN_SAMPLING;
   \                     ??app_recvConfigSensor_2: (+1)
   \   0000001E   0x2507             MOVS     R5,#+7
    269          					// transmission mode
    270          #if defined(_ARM_) && defined(_ENABLE_SRC_DUMMY_)
    271          					temp_rate = 10000/(cp->adc_sample_rate_divider * cp->adc_sample_averaging);
    272          					if (1>temp_rate) temp_rate=1;
    273          					if (1000<temp_rate) temp_rate=1000;
    274          					src_set_rate(temp_rate);
    275          #else // _ARM_
    276          #ifdef _ENABLE_ADC_MODULE_
    277          					app_tx_data_mode_ = cp->tx_data_mode;
    278          					// samples rate divider
    279          					adc_sample_rate_divider_ = cp->adc_sample_rate_divider;
    280          					// sample averaging over "N"
    281          					adc_sample_averaging_ = cp->adc_sample_averaging;
    282          					// No. of samples per packet
    283          					// use max of dictated number and max SAMPLES PER PACKET
    284          					if ( cp->n_samples_per_packet > SAMPLES_PER_PACKET )
    285          					{
    286          						n_samples_per_packet_ = SAMPLES_PER_PACKET;
    287          					}
    288          					else
    289          					{
    290          						n_samples_per_packet_ = cp->n_samples_per_packet;
    291          					}
    292          					set_number_of_channels ( cp->num_of_channels );
    293          #endif // _ENABLE_ADC_MODULE_
    294          #if defined (_ENABLE_NEW_ADC_MODULE_)
    295          					app_tx_data_mode_ = cp->tx_data_mode;
    296          					// samples rate divider
    297          					adc_set_rate_divider(cp->adc_sample_rate_divider);
    298          					// No. of samples per packet
    299          					// use max of dictated number and max SAMPLES PER PACKET
    300          					if ( cp->n_samples_per_packet > SAMPLES_PER_PACKET )
    301          					{
    302          						n_samples_per_packet_ = SAMPLES_PER_PACKET;
    303          					}
    304          					else
    305          					{
    306          						n_samples_per_packet_ = cp->n_samples_per_packet;
    307          					}	
    308          #endif // defined (_ENABLE_NEW_ADC_MODULE_)
    309          #endif // else _ARM_
    310          				}
    311          				break;
    312          			case ISN_APP_CONFIG_FLAG_SAMPLING_MAP:
    313          				{
    314          #ifdef _ENABLE_ADC_MODULE_
    315          					config_sampling_map_t *cp = ( config_sampling_map_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    316          					offset = ISN_APP_CONFIG_LEN_SAMPLING_MAP + cp->num_of_channels;
    317          					// sets number of channels for ADC
    318          					set_number_of_channels ( cp->num_of_channels );
    319          #endif // _ENABLE_ADC_MODULE_
    320          				}
    321          				break;
    322          			case ISN_APP_CONFIG_FLAG_RF:
    323          				{
    324          					config_rf_t *cp = ( config_rf_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    325          					offset = ISN_APP_CONFIG_LEN_RF;
    326          					// radio channel to be used (0 - 0xB, 1 - 0xC, ... 15 - 0x1A)
    327          					phy_set_RF_channel ( cp->channel );
    328          					// power control scheme
    329          					// cp->power_control_scheme;
    330          					// default TX power level to be used
    331          #ifndef _ARM_
    332          					my_tx_power_ = cp->default_power_level;
    333          					phy_set_power_level ( cp->default_power_level );  //This line is error, see the phy_set_power_level for explanation
    334          #endif // not _ARM_
    335          					// set RSSI threshold for accepting incomming packets
    336          					my_rssi_threshold_ = cp->rssi_threshold;
    337          
    338          				}
    339          
    340          				break;
    341          			case ISN_APP_CONFIG_FLAG_OEDSR:
    342          				{
    343          					config_oedsr_t *cp = ( config_oedsr_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    344          					offset = ISN_APP_CONFIG_LEN_OEDSR;
    345          					// Set distance to BS
    346          					my_distance_ = cp->distance;
    347          					// Set battery energy
    348          					if (ENERGY_IGNORE_VALUE != cp->energy)
    349          					{
    350          						my_energy_ = cp->energy;
    351          					}
    352          					// number of RF retries
    353          					if ( NO_CHANGE_RF_RETRIES != cp->rf_retries )
    354          					{
    355          						my_RF_retries_ = cp->rf_retries;
    356          #ifdef _ENABLE_XBEE_API_
    357          						api_send_at ( "RR", ( char* ) &my_RF_retries_, 1 );
    358          #endif // _ENABLE_XBEE_API_
    359          					}
    360          				}
    361          				break;
    362          			case ISN_APP_CONFIG_FLAG_MMCR:
    363          				{
    364          					config_mmcr_t *cp = ( config_mmcr_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    365          					offset = ISN_APP_CONFIG_LEN_MMCR;
    366          					
    367          					// Set battery energy
    368          					if (ENERGY_IGNORE_VALUE != cp->energy)
    369          					{
    370          						my_energy_ = cp->energy;
    371          					}
    372          					// number of RF retries
    373          					if ( NO_CHANGE_RF_RETRIES != cp->rf_retries )
    374          					{
    375          						my_RF_retries_ = cp->rf_retries;
    376          #ifdef _ENABLE_XBEE_API_
    377          						api_send_at ( "RR", ( char* ) &my_RF_retries_, 1 );
    378          #endif // _ENABLE_XBEE_API_
    379          					}
    380          				}
    381          				break;
    382          			case ISN_APP_CONFIG_FLAG_PROTOCOLS:
    383          				{
    384          					//config_protocols_t *cp = ( config_protocols_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    385          					offset = ISN_APP_CONFIG_LEN_PROTOCOLS;
    386          #ifndef _ARM_
    387          					my_protocol_ = cp->routing;
    388          					// = cp->scheduling;
    389          					//Select the Correct Protocols that are availible
    390          					routing_set_routing_protocol(); // my_protocol_ has correct value
    391          					//Select the Correct Protocols that are availible
    392          					switch ( cp->scheduling )
    393          					{
    394          							// Default (droptail + no_backoff)
    395          						case PROTOCOL_SCHEDULING_NONE:
    396          							my_scheduling_ = cp->scheduling;
    397          							phy_change_backoff ( PHY_BACKOFF_DISABLE );
    398          							que_switch_protocol ( QUEUE_DROPTAIL );
    399          							break;
    400          #ifdef FEAT_ENABLE_SFQ
    401          						// ADFS (sfq) + no_backoff
    402          						case PROTOCOL_SCHEDULING_ADFS:
    403          							my_scheduling_ = cp->scheduling;
    404          							phy_change_backoff ( PHY_BACKOFF_DISABLE );
    405          							que_switch_protocol ( QUEUE_SFQ );
    406          							Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
    407          							break;
    408          #endif // FEAT_ENABLE_SFQ
    409          
    410          #ifdef FEAT_ENABLE_SFQ
    411          						// DFS (sfq) + no_backoff
    412          						case PROTOCOL_SCHEDULING_DFS:
    413          							my_scheduling_ = cp->scheduling;
    414          							phy_change_backoff (PHY_BACKOFF_DISABLE);
    415          							que_switch_protocol(QUEUE_SFQ);
    416          							// MZ_DFS begin
    417          							Q_SFQ_set_version(SFQ_FIXED_WEIGHT_DFS);
    418          							//OR!!!!!!!!!!!!!1111
    419          							//Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
    420          							// MZ_DFS end							
    421          							
    422          							break;
    423          #endif // FEAT_ENABLE_SFQ
    424          
    425          						// DROPTAIL (fifo) + BACKOFF
    426          						case PROTOCOL_SCHEDULING_NONE_BO:
    427          							my_scheduling_ = cp->scheduling;
    428          							que_switch_protocol(QUEUE_DROPTAIL);
    429          							phy_change_backoff (PHY_BACKOFF_EXPONENTIAL);
    430          							break;
    431          #ifdef FEAT_ENABLE_SFQ
    432          							// ADFS with wieghted BACKOFF
    433          						case PROTOCOL_SCHEDULING_ADFS_BO:
    434          							my_scheduling_ = cp->scheduling;
    435          							phy_change_backoff (PHY_BACKOFF_ADFS);
    436          							que_switch_protocol(QUEUE_SFQ);
    437          							// MZ_DFS begin
    438          							//Q_SFQ_set_version(SFQ_FIXED_WEIGHT_DFS);
    439          							//OR!!!!!!!!!!!!!1111
    440          							Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
    441          							// MZ_DFS end
    442          							break;
    443          #endif // FEAT_ENABLE_SFQ
    444          
    445          
    446          #ifdef FEAT_ENABLE_SFQ
    447          						// DFS with wieghted BACKOFF
    448          						case PROTOCOL_SCHEDULING_DFS_BO:
    449          							my_scheduling_ = cp->scheduling;
    450          							phy_change_backoff (PHY_BACKOFF_ADFS);
    451          							que_switch_protocol(QUEUE_SFQ);
    452          							// MZ_DFS begin
    453          							Q_SFQ_set_version(SFQ_FIXED_WEIGHT_DFS);
    454          							//OR!!!!!!!!!!!!!1111
    455          							//Q_SFQ_set_version(SFQ_WEIGHT_UPDATE_ADFS);
    456          							// MZ_DFS end
    457          							break;
    458          #endif // FEAT_ENABLE_SFQ
    459          
    460          
    461          						// Default (droptail + no_backoff)
    462          						default:
    463          							my_scheduling_ = PROTOCOL_SCHEDULING_NONE;
    464          							phy_change_backoff ( PHY_BACKOFF_DISABLE );
    465          							// set Queuing scheme
    466          							que_switch_protocol ( QUEUE_DROPTAIL );
    467          					}
    468          #endif // not _ARM_
    469          				}
    470          				break;
    471          #ifdef ENABLE_ADFS
    472          			case ISN_APP_CONFIG_FLAG_SCHEDULING:
    473          				{
    474          					config_scheduling_t *cp = ( config_scheduling_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    475          					offset = ISN_APP_CONFIG_LEN_SCHEDULING;
    476          					// Set distance to BS
    477          					if ( SCHEDULING_WEIGHT_NO_CHANGE != cp->source_weight )
    478          					{
    479          						my_source_weight_ = cp->source_weight;
    480          					}
    481          					// Set battery energy
    482          					if ( SCHEDULING_WEIGHT_NO_CHANGE != cp->node_weight )
    483          					{
    484          						my_weight_ = cp->node_weight;
    485          					}
    486          				}
    487          #ifdef FEAT_ENABLE_SFQ
    488          						Q_SFQ_set_weights (my_weight_, my_source_weight_);
    489          #endif // FEAT_ENABLE_SFQ
    490          				break;
    491          #endif // ENABLE_ADFS
    492          			case ISN_APP_CONFIG_FLAG_CLUSTERING:
    493          				{
    494          					config_clustering_t *cp = ( config_clustering_t * ) ( ( ( char* ) cfg_gen ) + ISN_APP_CONFIG_LEN_OVERHEAD );
    495          					offset = ISN_APP_CONFIG_LEN_CLUSTERING;
    496          					// Cluster Head id
    497          					if ( CLUSTERING_I_AM_CH == cp->CH )
    498          					{
    499          						// SET MYSELF AS CLUSTER HEAD
    500          						// ?????
    501          						my_CH_ = cp->CH;
    502          					}
    503          					else if ( CLUSTERING_NO_CHANGE != cp->CH )
    504          					{
    505          						// THE CHANGE of CH WAS REQUESTED
    506          						my_CH_ = cp->CH;
    507          						// TODO:
    508          						// cluster_join( my_CH_ );
    509          					}
    510          				}
    511          
    512          				break;
    513          
    514          			default:
    515          				return; // exit if the FLAG is unknown (possibly incorrect config packet)
    516          				break;
    517          		}
    518          		// move the header to next option (or end of packet)
    519          		cfg_gen = ( config_generic_t * ) ( ( ( char* ) cfg_gen ) + offset );
   \                     ??app_recvConfigSensor_3: (+1)
   \   00000020   0x19AE             ADDS     R6,R5,R6
    520          		offset = 0;
   \   00000022   0x2500             MOVS     R5,#+0
    521          		flag = cfg_gen->config_flag;
   \   00000024   0x7830             LDRB     R0,[R6, #+0]
   \                     ??app_recvConfigSensor_1: (+1)
   \   00000026   0x2841             CMP      R0,#+65
   \   00000028   0xD03A             BEQ.N    ??app_recvConfigSensor_4
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0x2807             CMP      R0,#+7
   \   0000002E   0xD83A             BHI.N    ??app_recvConfigSensor_5
   \   00000030   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??app_recvConfigSensor_0:
   \   00000034   0x04 0x05          DC8      0x4,0x5,0x6,0xF
   \              0x06 0x0F    
   \   00000038   0x29 0x39          DC8      0x29,0x39,0x2B,0x1F
   \              0x2B 0x1F    
   \                     ??app_recvConfigSensor_6: (+1)
   \   0000003C   0xE7EF             B.N      ??app_recvConfigSensor_2
   \                     ??app_recvConfigSensor_7: (+1)
   \   0000003E   0xE7EF             B.N      ??app_recvConfigSensor_3
   \                     ??app_recvConfigSensor_8: (+1)
   \   00000040   0x1CB7             ADDS     R7,R6,#+2
   \   00000042   0x2506             MOVS     R5,#+6
   \   00000044   0x7838             LDRB     R0,[R7, #+0]
   \   00000046   0x.... 0x....      BL       phy_set_RF_channel
   \   0000004A   0x78F8             LDRB     R0,[R7, #+3]
   \   0000004C   0x....             LDR.N    R1,??DataTable14_8
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   \   00000050   0xE7E6             B.N      ??app_recvConfigSensor_3
   \                     ??app_recvConfigSensor_9: (+1)
   \   00000052   0x1CB0             ADDS     R0,R6,#+2
   \   00000054   0x250B             MOVS     R5,#+11
   \   00000056   0x6841             LDR      R1,[R0, #+4]
   \   00000058   0xF8CB 0x1000      STR      R1,[R11, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF111 0x0F01      CMN      R1,#+1
   \   00000062   0xBF18             IT       NE 
   \   00000064   0xF8C9 0x1000      STRNE    R1,[R9, #+0]
   \   00000068   0x7A00             LDRB     R0,[R0, #+8]
   \                     ??app_recvConfigSensor_10: (+1)
   \   0000006A   0x280F             CMP      R0,#+15
   \   0000006C   0xD0D8             BEQ.N    ??app_recvConfigSensor_3
   \   0000006E   0x7020             STRB     R0,[R4, #+0]
   \   00000070   0xE7D6             B.N      ??app_recvConfigSensor_3
   \                     ??app_recvConfigSensor_11: (+1)
   \   00000072   0x1CB0             ADDS     R0,R6,#+2
   \   00000074   0x2507             MOVS     R5,#+7
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF111 0x0F01      CMN      R1,#+1
   \   0000007C   0xBF18             IT       NE 
   \   0000007E   0xF8C9 0x1000      STRNE    R1,[R9, #+0]
   \   00000082   0x7900             LDRB     R0,[R0, #+4]
   \   00000084   0xE7F1             B.N      ??app_recvConfigSensor_10
   \                     ??app_recvConfigSensor_12: (+1)
   \   00000086   0x2504             MOVS     R5,#+4
   \   00000088   0xE7CA             B.N      ??app_recvConfigSensor_3
   \                     ??app_recvConfigSensor_13: (+1)
   \   0000008A   0x1CB0             ADDS     R0,R6,#+2
   \   0000008C   0x2507             MOVS     R5,#+7
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x28FD             CMP      R0,#+253
   \   00000092   0xD102             BNE.N    ??app_recvConfigSensor_14
   \                     ??app_recvConfigSensor_15: (+1)
   \   00000094   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \   00000098   0xE7C2             B.N      ??app_recvConfigSensor_3
   \                     ??app_recvConfigSensor_14: (+1)
   \   0000009A   0x28FF             CMP      R0,#+255
   \   0000009C   0xD0C0             BEQ.N    ??app_recvConfigSensor_3
   \   0000009E   0xE7F9             B.N      ??app_recvConfigSensor_15
    522          	}
    523          
    524          	//Update the Last RSSI recieved for a config
    525          	last_config_rssi_rcv_ = rssi;
   \                     ??app_recvConfigSensor_4: (+1)
   \   000000A0   0x....             LDR.N    R0,??DataTable14_9
   \   000000A2   0xF880 0x8000      STRB     R8,[R0, #+0]
    526          	// report what you have changed
    527          //	app_sendConfigSensor();
    528          //#endif
    529          }
   \                     ??app_recvConfigSensor_5: (+1)
   \   000000A6   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    530          
    531          
    532          
    533          
    534          

   \                                 In section .text, align 2, keep-with-next
    535          void app_recvBEAM ( sint8_t *pkt )
    536          {
   \                     app_recvBEAM: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    537          	bpkt_t *beam = ( bpkt_t * ) pkt;
    538          	// Set time only once to avoid "backward time travels"
    539          //	if (0 == app_beam_count_)
    540          	{
    541          		rtc_time_set ( beam->hour, beam->minute, beam->second, ENDIAN16(beam->msecond) );
   \   00000004   0xF8B4 0x000F      LDRH     R0,[R4, #+15]
   \   00000008   0x7BA2             LDRB     R2,[R4, #+14]
   \   0000000A   0x0201             LSLS     R1,R0,#+8
   \   0000000C   0xEA41 0x2310      ORR      R3,R1,R0, LSR #+8
   \   00000010   0x7B61             LDRB     R1,[R4, #+13]
   \   00000012   0x7B20             LDRB     R0,[R4, #+12]
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x.... 0x....      BL       rtc_time_set
    542          	}
    543          	if (1 == app_repeat_beam)
   \   0000001A   0x....             LDR.N    R5,??DataTable14
   \   0000001C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD117             BNE.N    ??app_recvBEAM_0
    544          	{
    545          		uint16_t bseq = beam->seq;
   \   00000022   0x7CA0             LDRB     R0,[R4, #+18]
    546          		if (app_beam_seq >= beam->seq) bseq+=256;
   \   00000024   0x88EA             LDRH     R2,[R5, #+6]
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x4282             CMP      R2,R0
   \   0000002A   0xBF24             ITT      CS 
   \   0000002C   0xF501 0x7180      ADDCS    R1,R1,#+256
   \   00000030   0xB289             UXTHCS   R1,R1
    547          		if (app_beam_seq+APP_BEAM_WINDOW > bseq)
   \   00000032   0x32E6             ADDS     R2,R2,#+230
   \   00000034   0x4291             CMP      R1,R2
   \   00000036   0xDA0C             BGE.N    ??app_recvBEAM_0
    548          		{
    549          			app_beam_seq = beam->seq;
   \   00000038   0x80E8             STRH     R0,[R5, #+6]
    550          			beam->mac_src = ENDIAN16((uint16_t)MY_ADDR);
    551          			beam->hops_from_bs++;
    552          #ifdef _ARM_
    553          			sendPriorityPacket( BEAM_PACKET_LENGTH, (sint8_t*)pkt, MAC_BROADCAST);
   \   0000003A   0xF64F 0x72FF      MOVW     R2,#+65535
   \   0000003E   0x.... 0x....      BL       ?Subroutine0
    554          #else // _ARM_
    555          			api_send_packet16 ( pkt, BEAM_PACKET_LENGTH, MAC_BROADCAST);
    556          #endif // else _ARM)
    557          		}
    558          	}
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000042   0x80A0             STRH     R0,[R4, #+4]
   \   00000044   0x4621             MOV      R1,R4
   \   00000046   0x7C60             LDRB     R0,[R4, #+17]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x7460             STRB     R0,[R4, #+17]
   \   0000004C   0x2014             MOVS     R0,#+20
   \   0000004E   0x.... 0x....      BL       sendPriorityPacket
    559          	app_last_BS_contact_ = rtc_get_ticks();
   \                     ??app_recvBEAM_0: (+1)
   \   00000052   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000056   0x6268             STR      R0,[R5, #+36]
    560          	app_beam_count_++;
   \   00000058   0x69E8             LDR      R0,[R5, #+28]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x61E8             STR      R0,[R5, #+28]
    561          }
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x0200             LSLS     R0,R0,#+8
   \   00000006   0x4770             BX       LR
    562          
    563          
    564          
    565          #if defined (_ENABLE_ADC_MODULE_) || defined (_ENABLE_NEW_ADC_MODULE_)
    566          
    567          void app_suspendADC()
    568          {
    569          #ifndef _ARM_
    570          #ifdef _SFRPAGE_EXIST_
    571          	SFRPAGE   = TMR2_PAGE;
    572          #endif // _SFRPAGE_EXIST_
    573          	//	TMR2CN = 0x05; // bit 2 - timer enable; bit 0 - capture mode
    574          	TMR2CN &= 0xFB;//~0x04; // bit 2 - timer disabled(=0); bit 0 - capture mode
    575          #else // _ARM_
    576                  // stop ADC reading
    577          #endif // _ARM_
    578          }
    579          
    580          void app_resumeADC()
    581          {
    582          #ifndef _ARM_
    583          #ifdef _SFRPAGE_EXIST_
    584          	SFRPAGE   = TMR2_PAGE;
    585          #endif // _SFRPAGE_EXIST_
    586          	TMR2CN |= 0x04; // bit 2 - timer enable; bit 0 - capture mode
    587          	//	TMR2CN = 0x01; // bit 2 - timer disabled(=0); bit 0 - capture mode
    588          #else // _ARM_
    589                  // stop ADC reading
    590          #endif // _ARM_
    591          }
    592          
    593          
    594          #endif // #if defined (_ENABLE_ADC_MODULE_) || defined (_ENABLE_NEW_ADC_MODULE_)
    595          
    596          
    597          
    598          ///////////////////////////////////////////////
    599          

   \                                 In section .text, align 2, keep-with-next
    600          void NodeConfigure ( char *p )
    601          {
   \                     NodeConfigure: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    602          	unsigned char temp_power;
    603          	conpkt_t *pkt = ( conpkt_t * ) p;
    604          	//conpkt_t *pkt2 = ;
    605          
    606          	//Assign the Global Variables to the Correct Variables
    607          	my_energy_ = ENDIAN32(pkt->energy);
   \   00000006   0x1CA5             ADDS     R5,R4,#+2
   \   00000008   0x....             LDR.N    R6,??DataTable14_6
   \   0000000A   0x6928             LDR      R0,[R5, #+16]
    608          	my_distance_ = ENDIAN32(pkt->distance);
   \   0000000C   0x....             LDR.N    R7,??DataTable14_4
    609          	my_protocol_ = pkt->protocol;
   \   0000000E   0x.... 0x....      LDR.W    R8,??DataTable14_10
   \   00000012   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000016   0x6030             STR      R0,[R6, #+0]
   \   00000018   0x6968             LDR      R0,[R5, #+20]
   \   0000001A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000001E   0x6038             STR      R0,[R7, #+0]
    610          	my_rssi_threshold_ = pkt->rssi;
   \   00000020   0x....             LDR.N    R1,??DataTable14_8
   \   00000022   0x7E68             LDRB     R0,[R5, #+25]
   \   00000024   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000028   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    611          
    612          	phy_set_power_level ( pkt->power_level );
   \   0000002E   0x7BA8             LDRB     R0,[R5, #+14]
   \   00000030   0x.... 0x....      BL       phy_set_power_level
    613          
    614          	//my_cost_fun_=pkt->cost_function;
    615          	/*
    616          		if (13 < pkt->length)
    617          		{
    618          			//unsigned char data_mode;
    619          			adc_sample_rate_divider_ = pkt->divider;
    620          			// Averaging samples over N readings
    621          			adc_sample_averaging_ = pkt->averager;
    622          			if ( pkt->data_size > SAMPLES_PER_PACKET )
    623          			{
    624          				n_samples_per_packet_ = SAMPLES_PER_PACKET;
    625          			}
    626          			else
    627          			{
    628          				n_samples_per_packet_ = pkt->data_size;
    629          			}
    630          		}
    631          	*/
    632          
    633          	//Select the Correct Protocols that are availible
    634          	routing_set_routing_protocol(); // my_protocol_ has correct value
   \   00000034   0x.... 0x....      BL       routing_set_routing_protocol
    635          
    636          
    637          	//Refill the packet and send out the response
    638          	pkt->start = START_BYTE;
   \   00000038   0x2042             MOVS     R0,#+66
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    639          	pkt->flags = FLAG_CONFIG_RESP;
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x7060             STRB     R0,[R4, #+1]
    640          	pkt->mac_dst = ENDIAN16(BS_ADDR);
   \   00000040   0xF44F 0x407E      MOV      R0,#+65024
   \   00000044   0x8060             STRH     R0,[R4, #+2]
    641          	pkt->mac_src = ENDIAN16(MY_ADDR);
   \   00000046   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000004A   0x8068             STRH     R0,[R5, #+2]
    642          	//pkt->dst_id=BS_ADDR;
    643          	//pkt->src_id=MY_ADDR;
    644          	pkt->length = 17;
   \   0000004C   0x2011             MOVS     R0,#+17
   \   0000004E   0x7128             STRB     R0,[R5, #+4]
    645          	pkt->protocol = my_protocol_;
   \   00000050   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000054   0x7668             STRB     R0,[R5, #+25]
    646          	pkt->distance = ENDIAN32(my_distance_);
   \   00000056   0x6838             LDR      R0,[R7, #+0]
   \   00000058   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000005C   0x6168             STR      R0,[R5, #+20]
    647          	pkt->energy = ENDIAN32(my_energy_);
   \   0000005E   0x6830             LDR      R0,[R6, #+0]
   \   00000060   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000064   0x6128             STR      R0,[R5, #+16]
    648          	pkt->crc = STOP_BYTE;
   \   00000066   0x2041             MOVS     R0,#+65
   \   00000068   0xF884 0x0023      STRB     R0,[R4, #+35]
    649          
    650          	temp_power = my_tx_power_;
   \   0000006C   0x....             LDR.N    R0,??DataTable14_3
   \   0000006E   0x7805             LDRB     R5,[R0, #+0]
    651          	phy_set_power_level ( MAX_POWER_LEVEL );
   \   00000070   0x2004             MOVS     R0,#+4
   \   00000072   0x.... 0x....      BL       phy_set_power_level
    652          #ifdef _ARM_
    653          	sendPriorityPacket( CONFIG_LEN, p, BS_ADDR);
   \   00000076   0x22FE             MOVS     R2,#+254
   \   00000078   0x4621             MOV      R1,R4
   \   0000007A   0x2024             MOVS     R0,#+36
   \   0000007C   0x.... 0x....      BL       sendPriorityPacket
    654          #else // _ARM_
    655          	#ifdef _ENABLE_XBEE_API_
    656          		api_send_packet16 ( p, CONFIG_LEN, BS_ADDR );
    657          	#endif // _ENABLE_XBEE_API_
    658          #endif // else _ARM)
    659          	phy_set_power_level ( temp_power );
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000086   0x.... 0x....      B.W      phy_set_power_level
    660          
    661          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x0A01             LSRS     R1,R0,#+8
   \   00000002   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   00000006   0x0202             LSLS     R2,R0,#+8
   \   00000008   0xEA41 0x6110      ORR      R1,R1,R0, LSR #+24
   \   0000000C   0xF402 0x027F      AND      R2,R2,#0xFF0000
   \   00000010   0x4311             ORRS     R1,R2,R1
   \   00000012   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000016   0x4770             BX       LR
    662          ///////////////////////////////////////////////
    663          
    664          
    665          ///////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    666          void disable_node ( unsigned char address )
    667          {
   \                     disable_node: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    668          	gbpkt_t *gby = ( gbpkt_t * ) packet;
    669          	//int result; // length of received result string
    670          	//unsigned int uint_value = 0;
    671          //	float f = 0.222;
    672          
    673          //Set the Node Address
    674          	//uint_value = address;
    675          
    676          	if ( 1 == energy_depleted_control_ )
   \   00000002   0x....             LDR.N    R4,??DataTable14_11
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD021             BEQ.N    ??disable_node_0
    677          	{
    678          		return;
    679          	}
    680          
    681          
    682          	//Assemble Routing Type Packet with the RREQ Flag
    683          	gby->start = START_BYTE;
   \   0000000A   0x....             LDR.N    R1,??DataTable14_12
   \   0000000C   0x2042             MOVS     R0,#+66
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    684          	gby->flags = FLAG_GOODBYE;
   \   00000010   0x2077             MOVS     R0,#+119
   \   00000012   0x7048             STRB     R0,[R1, #+1]
    685          	gby->mac_dst = ENDIAN16(BS_ADDR); //MAC_BROADCAST;
   \   00000014   0xF44F 0x407E      MOV      R0,#+65024
   \   00000018   0x8048             STRH     R0,[R1, #+2]
    686          	gby->mac_src = ENDIAN16(MY_ADDR);
   \   0000001A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000001E   0x8088             STRH     R0,[R1, #+4]
    687          	gby->crc = STOP_BYTE;
   \   00000020   0x2041             MOVS     R0,#+65
   \   00000022   0x7188             STRB     R0,[R1, #+6]
    688          #ifdef _ARM_
    689          	sendPriorityPacket(GOODBYE_LEN, packet, ENDIAN16(gby->mac_dst) );
   \   00000024   0x8848             LDRH     R0,[R1, #+2]
   \   00000026   0x0202             LSLS     R2,R0,#+8
   \   00000028   0xEA42 0x2210      ORR      R2,R2,R0, LSR #+8
   \   0000002C   0xB292             UXTH     R2,R2
   \   0000002E   0x2007             MOVS     R0,#+7
   \   00000030   0x.... 0x....      BL       sendPriorityPacket
    690          #else // _ARM_
    691          	#ifdef _ENABLE_XBEE_API_
    692          		api_send_packet16 ( ( char* ) packet, GOODBYE_LEN, gby->mac_dst );
    693          	#endif // _ENABLE_XBEE_API_
    694          #endif // _ARM_
    695          #ifdef FEAT_ENABLE_AODV
    696          	if ( AODVcounter_update )
   \   00000034   0x....             LDR.N    R0,??DataTable14_13
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xB118             CBZ.N    R0,??disable_node_1
    697          	{
    698          		RREQ_counter++;
   \   0000003A   0x....             LDR.N    R0,??DataTable14_14
   \   0000003C   0x7801             LDRB     R1,[R0, #+0]
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   \   00000040   0x7001             STRB     R1,[R0, #+0]
    699          	}
    700          	my_energy_ = my_energy_ -GOODBYE_LEN;
   \                     ??disable_node_1: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable14_6
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0x1FC9             SUBS     R1,R1,#+7
   \   00000048   0x6001             STR      R1,[R0, #+0]
    701          #endif // FEAT_ENABLE_AODV
    702          
    703          #ifdef _ENABLE_XBEE_API_
    704          	api_send_at ( "MY", ( char* ) &uint_value, 2 );
    705          	for ( result = 0; result < 100; result++ )
    706          	{
    707          		f = 1.0 / f;
    708          	}
    709          #endif // _ENABLE_XBEE_API_
    710          	energy_depleted_control_ = 1;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
    711          }
   \                     ??disable_node_0: (+1)
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    712          ///////////////////////////////////////////////
    713          ///////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    714          void enable_node ( char *p )
    715          {
    716          	enpkt_t *pkt = ( enpkt_t * ) p;
    717          
    718          
    719          	//int result; // length of received result string
    720          	unsigned int uint_value;
                 	             ^
Warning[Pe550]: variable "uint_value" was set but never used
    721          	//float f = 0.222;
    722          //Set the Node Address
    723          	uint_value = MY_ADDR;
    724          #ifdef _ENABLE_XBEE_API_
    725          	api_send_at ( "MY", ( char* ) &uint_value, 2 );
    726          	for ( result = 0; result < 100; result++ )
    727          	{
    728          		f = 1.0 / f;
    729          	}
    730          	packet[0] = 'R';
    731          	packet[1] = 'E';
    732          	packet[2] = 'C';
    733          	packet[3] = 'H';
    734          	packet[4] = 'G';
    735          	packet[5] = MY_ADDR;
    736          	packet[6] = '\r';
    737          
    738          	api_send_packet16 ( packet , 6, 0xFFFF );
    739          	for ( result = 0; result < 1000; result++ )
    740          	{
    741          		f = 1.0 / f;
    742          	}
    743          #endif // _ENABLE_XBEE_API_
    744          	energy_depleted_control_ = 0;
   \                     enable_node: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable14_11
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7011             STRB     R1,[R2, #+0]
    745          	my_energy_ = ENDIAN32(pkt->energy);
   \   00000006   0xF8D0 0x0006      LDR      R0,[R0, #+6]
   \   0000000A   0x0A01             LSRS     R1,R0,#+8
   \   0000000C   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   00000010   0x0202             LSLS     R2,R0,#+8
   \   00000012   0xEA41 0x6110      ORR      R1,R1,R0, LSR #+24
   \   00000016   0xF402 0x027F      AND      R2,R2,#0xFF0000
   \   0000001A   0x4311             ORRS     R1,R2,R1
   \   0000001C   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000020   0x....             LDR.N    R1,??DataTable14_6
   \   00000022   0x6008             STR      R0,[R1, #+0]
    746          
    747          }
   \   00000024   0x4770             BX       LR               ;; return
    748          ///////////////////////////////////////////////
    749          
    750          /**
    751            * app_drop_pkt(base,module_name, reason, event) - handles packet dropping
    752            *     possible actions are - counting errors, rescheduling packet for retransmission
    753            */

   \                                 In section .text, align 2, keep-with-next
    754          void app_drop_pkt ( unsigned int base, module_t module, reason_t reason, event_t event )
    755          {
    756          	app_count_drop_pkts_++;
   \                     app_drop_pkt: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14
   \   00000002   0x6881             LDR      R1,[R0, #+8]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x6081             STR      R1,[R0, #+8]
    757          
    758          #ifdef FEAT_ENABLE_CC
    759          	cc_drop_pkts_ ++;
    760          #endif
    761          
    762          	// app_count_drop_pkts_;	// Dropped packets
    763          	// app_count_lost_pkts_;	// Lost during TX packets
    764          //	unsigned int XDATA app_count_sent_pkts_;	// Sent out succesfully
    765          //	unsigned int XDATA app_count_recv_pkts_;	// Received from other nodes
    766          //	unsigned int XDATA app_count_gen_pkts_;	// Generated by this node
    767          }
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .data, align 4
   \                     app_tx_data_mode_:
   \   00000000   0x00               DC8 0
   \                     app_generate_pkt_:
   \   00000001   0x00               DC8 0
   \                     n_samples_per_packet_:
   \   00000002   0x5A               DC8 90
   \                     app_repeat_beam:
   \   00000003   0x00               DC8 0
    768          
    769          
    770          
    771          
    772          ///////////////////////////////////////////////
    773          unsigned char XDATA network_search_mode_ = SEARCH_OFF;
   \                     network_search_mode_:
   \   00000004   0x00               DC8 0
   \   00000005   0x00               DC8 0
   \                     app_beam_seq:
   \   00000006   0x00 0x00          DC8 0, 0
   \                     app_count_drop_pkts_:
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     app_count_lost_pkts_:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     app_count_sent_pkts_:
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     app_count_recv_pkts_:
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     app_count_gen_pkts_:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     app_beam_count_:
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     app_beacon_count_:
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     app_last_BS_contact_:
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    774          unsigned long XDATA switch_timeout_;
   \                     switch_timeout_:
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    775          unsigned long XDATA switch_start_time_;
   \                     switch_start_time_:
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    776          
    777          
    778          #define ROTATE_CHANNEL(c) (c>=MAX_RF_CHANNEL)?MIN_RF_CHANNEL:c+1
    779          
    780          /**
    781            * app_start_search_channel(packet) - handles request for channel search
    782            *     it switches to particular (given in packet) channel in starts the search
    783            *		using one of the available methods (given in packet)
    784            */

   \                                 In section .text, align 2, keep-with-next
    785          void app_start_search_channel ( pkt_t * p )
    786          {
   \                     app_start_search_channel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    787          	switchpkt_t *pkt = ( switchpkt_t* ) p;
    788          	phy_set_RF_channel ( pkt->channel ); //  channel to be used as a starting point
   \   00000004   0x7A60             LDRB     R0,[R4, #+9]
   \   00000006   0x.... 0x....      BL       phy_set_RF_channel
    789          	network_search_mode_ = pkt->search_mode;
   \   0000000A   0x....             LDR.N    R5,??DataTable14
   \   0000000C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000000E   0x7128             STRB     R0,[R5, #+4]
    790          	switch_start_time_ = rtc_get_ticks();
   \   00000010   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000014   0x62E8             STR      R0,[R5, #+44]
   \   00000016   0x7929             LDRB     R1,[R5, #+4]
   \   00000018   0x2903             CMP      R1,#+3
   \   0000001A   0xD105             BNE.N    ??app_start_search_channel_0
    791          
    792          	if ( SEARCH_OEDSR_HELLO == network_search_mode_ )
    793          	{
    794          		switch_timeout_ = switch_start_time_ + SEARCH_OEDSR_HELLO_SWITCH_INTERVAL;
   \   0000001C   0x3064             ADDS     R0,R0,#+100
   \   0000001E   0x62A8             STR      R0,[R5, #+40]
    795          		// send HELLO!!
    796          #ifdef _ENABLE_OEDSR_
    797          		sendHELLO();
   \   00000020   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000024   0x.... 0x....      B.W      sendHELLO
    798          #endif
    799          	}
    800          	else if ( SEARCH_BEACON_NODE_SWITCHING == network_search_mode_ )
   \                     ??app_start_search_channel_0: (+1)
   \   00000028   0x2902             CMP      R1,#+2
   \   0000002A   0xBF04             ITT      EQ 
   \   0000002C   0xF200 0x401A      ADDWEQ   R0,R0,#+1050
   \   00000030   0x62A8             STREQ    R0,[R5, #+40]
    801          	{
    802          		switch_timeout_ = switch_start_time_ + SEARCH_BEACON_SWITCH_INTERVAL;
    803          	}
    804          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    805          
    806          
    807          /**
    808            * app_search_switch_channel() - handles switching between channels while searching
    809            *     for the BS/network
    810            */

   \                                 In section .text, align 2, keep-with-next
    811          void app_search_switch_channel()
    812          {
   \                     app_search_switch_channel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    813          	phy_set_RF_channel ( ROTATE_CHANNEL ( my_rf_channel_ ) );
   \   00000002   0x....             LDR.N    R0,??DataTable14_15
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x281A             CMP      R0,#+26
   \   00000008   0xBFAC             ITE      GE 
   \   0000000A   0x200B             MOVGE    R0,#+11
   \   0000000C   0x1C40             ADDLT    R0,R0,#+1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x.... 0x....      BL       phy_set_RF_channel
    814          
    815          	if ( SEARCH_OEDSR_HELLO == network_search_mode_ )
   \   00000014   0x....             LDR.N    R4,??DataTable14
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD107             BNE.N    ??app_search_switch_channel_0
    816          	{
    817          		switch_timeout_ = rtc_get_ticks() + SEARCH_OEDSR_HELLO_SWITCH_INTERVAL;
   \   0000001C   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000020   0x3064             ADDS     R0,R0,#+100
   \   00000022   0x62A0             STR      R0,[R4, #+40]
    818          		// send HELLO!!
    819          #ifdef _ENABLE_OEDSR_
    820          		sendHELLO();
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      sendHELLO
    821          #endif //
    822          	}
    823          	else if ( SEARCH_BEACON_NODE_SWITCHING == network_search_mode_ )
   \                     ??app_search_switch_channel_0: (+1)
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD104             BNE.N    ??app_search_switch_channel_1
    824          	{
    825          		switch_timeout_ = rtc_get_ticks() + SEARCH_BEACON_SWITCH_INTERVAL;
   \   00000030   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000034   0xF200 0x401A      ADDW     R0,R0,#+1050
   \   00000038   0x62A0             STR      R0,[R4, #+40]
    826          	}
    827          
    828          }
   \                     ??app_search_switch_channel_1: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    829          
    830          
    831          /**
    832            * app_received_beacon(packet) - handles reception of beacon packet
    833            *     changes to the specified channel thus "joining" the network
    834            */

   \                                 In section .text, align 2, keep-with-next
    835          void app_received_beacon ( pkt_t * p )
    836          {
   \                     app_received_beacon: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    837          	bcpkt_t *pkt = ( bcpkt_t * ) p;
    838          
    839          	app_send_join ( pkt->dst_id, pkt->channel, network_search_mode_ );
   \   00000002   0x....             LDR.N    R4,??DataTable14
   \   00000004   0x7A41             LDRB     R1,[R0, #+9]
   \   00000006   0x7922             LDRB     R2,[R4, #+4]
   \   00000008   0x79C0             LDRB     R0,[R0, #+7]
   \   0000000A   0x.... 0x....      BL       app_send_join
    840          	app_beacon_count_++;
   \   0000000E   0x6A20             LDR      R0,[R4, #+32]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x6220             STR      R0,[R4, #+32]
    841          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    842          
    843          
    844          
    845          
    846          /**
    847            * app_send_join(dst_id, channel, mode) - sends JOIN packet to agiven node (dst_id)
    848            *     additionally it stops the channel search and sets the particular channel
    849            */

   \                                 In section .text, align 2, keep-with-next
    850          void app_send_join ( unsigned char dst_id, unsigned char channel, unsigned char mode )
    851          {
   \                     app_send_join: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    852          	unsigned char temp_power = my_tx_power_;
   \   00000006   0x....             LDR.N    R0,??DataTable14_3
    853          	char XDATA temp_pkt[JOIN_PKT_SIZE];
    854          	jpkt_t XDATA *pkt = ( jpkt_t XDATA* ) temp_pkt;
    855          	// Turn off the channel search
    856          	network_search_mode_ = SEARCH_OFF;
   \   00000008   0x....             LDR.N    R7,??DataTable14
   \   0000000A   0xF890 0x8000      LDRB     R8,[R0, #+0]
   \   0000000E   0xB085             SUB      SP,SP,#+20
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7138             STRB     R0,[R7, #+4]
   \   00000014   0x460D             MOV      R5,R1
   \   00000016   0x4616             MOV      R6,R2
    857          	// switch to correct channel
    858          	phy_set_RF_channel ( channel );
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       phy_set_RF_channel
    859          	// Make the JOIN packet
    860          	pkt->start = START_BYTE;
   \   0000001E   0x2042             MOVS     R0,#+66
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
    861          	pkt->flags = FLAG_JOIN;
    862          	pkt->mac_dst = ENDIAN16(( unsigned int ) dst_id);
    863          	pkt->mac_src = ENDIAN16(MY_ADDR);
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x2014             MOVS     R0,#+20
   \   00000028   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000002C   0xEA4F 0x2904      LSL      R9,R4,#+8
   \   00000030   0x....             LDR.N    R0,??DataTable14_2
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0xF8AD 0x9002      STRH     R9,[SP, #+2]
   \   00000038   0x0202             LSLS     R2,R0,#+8
   \   0000003A   0x808A             STRH     R2,[R1, #+4]
    864          	pkt->length = JOIN_PKT_LENGTH; // of the packet'd data
    865          	pkt->dst_id = dst_id; // part of DATA field (dest_id) - actual length depends on "length"
   \   0000003C   0xF88D 0x4007      STRB     R4,[SP, #+7]
   \   00000040   0x2209             MOVS     R2,#+9
   \   00000042   0xF88D 0x2006      STRB     R2,[SP, #+6]
    866          	pkt->src_id = MY_ADDR; // part of DATA field
   \   00000046   0x7208             STRB     R0,[R1, #+8]
    867          	pkt->channel = channel; //  channel to be used as a starting point
   \   00000048   0x724D             STRB     R5,[R1, #+9]
    868          	pkt->search_mode = mode; // search algorithm
   \   0000004A   0xF88D 0x600A      STRB     R6,[SP, #+10]
    869          	pkt->duration = ENDIAN32(rtc_get_ticks() - switch_start_time_); // search algorithm
   \   0000004E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000052   0x4606             MOV      R6,R0
   \   00000054   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000058   0x4604             MOV      R4,R0
   \   0000005A   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000005E   0x4605             MOV      R5,R0
   \   00000060   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000064   0x6AF9             LDR      R1,[R7, #+44]
   \   00000066   0x1A63             SUBS     R3,R4,R1
   \   00000068   0x0A1B             LSRS     R3,R3,#+8
   \   0000006A   0x1A72             SUBS     R2,R6,R1
   \   0000006C   0xF403 0x437F      AND      R3,R3,#0xFF00
   \   00000070   0xEA43 0x6212      ORR      R2,R3,R2, LSR #+24
   \   00000074   0x1A6B             SUBS     R3,R5,R1
   \   00000076   0x021B             LSLS     R3,R3,#+8
   \   00000078   0xF403 0x037F      AND      R3,R3,#0xFF0000
   \   0000007C   0x431A             ORRS     R2,R3,R2
   \   0000007E   0x1A40             SUBS     R0,R0,R1
   \   00000080   0xEA42 0x6000      ORR      R0,R2,R0, LSL #+24
   \   00000084   0xF8CD 0x000B      STR      R0,[SP, #+11]
    870          	pkt->crc = STOP_BYTE;
   \   00000088   0x2041             MOVS     R0,#+65
   \   0000008A   0xF88D 0x000F      STRB     R0,[SP, #+15]
    871          
    872          	// Send the JOIN packet using MAX power
    873          	phy_set_power_level ( MAX_POWER_LEVEL );
   \   0000008E   0x2004             MOVS     R0,#+4
   \   00000090   0x.... 0x....      BL       phy_set_power_level
    874          #ifdef _ARM_
    875          	sendPriorityPacket ( JOIN_PKT_SIZE, temp_pkt, ENDIAN16 ((uint16_t)dst_id) );
   \   00000094   0x464A             MOV      R2,R9
   \   00000096   0xA900             ADD      R1,SP,#+0
   \   00000098   0x2010             MOVS     R0,#+16
   \   0000009A   0x.... 0x....      BL       sendPriorityPacket
    876          #else // _ARM_
    877          	#ifdef _ENABLE_XBEE_API_
    878          		api_send_packet16 ( ( char* ) temp_pkt, JOIN_PKT_SIZE, ( unsigned int ) dst_id );
    879          	#endif // _ENABLE_XBEE_API_
    880          #endif // _ARM_
    881          	phy_set_power_level ( temp_power );
   \   0000009E   0x4640             MOV      R0,R8
   \   000000A0   0x.... 0x....      BL       phy_set_power_level
    882          }
   \   000000A4   0xB005             ADD      SP,SP,#+20
   \   000000A6   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     app_tx_data_mode_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     sequence_no_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     my_addr8_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     my_tx_power_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     my_distance_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     my_RF_retries_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     my_energy_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     my_CH_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     my_rssi_threshold_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     last_config_rssi_rcv_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     my_protocol_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x........         DC32     energy_depleted_control_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     packet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     AODVcounter_update

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x........         DC32     RREQ_counter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x........         DC32     my_rf_channel_
    883          
    884          #endif // _ENABLE_MAIN_

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   NodeConfigure
         0   -> phy_set_power_level
        24   -> phy_set_power_level
        24   -> routing_set_routing_protocol
        24   -> sendPriorityPacket
       0   app_drop_pkt
       0   app_init
         0   -> sch_add_loop
       8   app_loop
         8   -> app_search_switch_channel
         8   -> halCommonGetInt32uMillisecondTick
       8   app_received_beacon
         8   -> app_send_join
      16   app_recvBEAM
        16   -> halCommonGetInt32uMillisecondTick
        16   -> rtc_time_set
        16   -> sendPriorityPacket
      40   app_recvConfigSensor
        40   -> phy_set_RF_channel
       0   app_recvStartData
         0   -> ssn_start_burst
       0   app_recvStopData
         0   -> ssn_stop_burst
       8   app_search_switch_channel
         8   -> halCommonGetInt32uMillisecondTick
         8   -> phy_set_RF_channel
         0   -> sendHELLO
       8   app_sendConfigSensor
         0   -> phy_set_power_level
         8   -> phy_set_power_level
      48   app_send_join
        48   -> halCommonGetInt32uMillisecondTick
        48   -> phy_set_RF_channel
        48   -> phy_set_power_level
        48   -> sendPriorityPacket
      16   app_start_search_channel
        16   -> halCommonGetInt32uMillisecondTick
        16   -> phy_set_RF_channel
         0   -> sendHELLO
       8   disable_node
         8   -> sendPriorityPacket
       0   enable_node


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       8  ?Subroutine0
      24  ?Subroutine1
     138  NodeConfigure
      10  app_drop_pkt
      58  app_init
      36  app_loop
      22  app_received_beacon
      96  app_recvBEAM
     170  app_recvConfigSensor
       8  app_recvStartData
      40  app_recvStopData
      60  app_search_switch_channel
      22  app_sendConfigSensor
     170  app_send_join
      52  app_start_search_channel
      48  app_tx_data_mode_
          app_generate_pkt_
          n_samples_per_packet_
          app_repeat_beam
          network_search_mode_
          app_beam_seq
          app_count_drop_pkts_
          app_count_lost_pkts_
          app_count_sent_pkts_
          app_count_recv_pkts_
          app_count_gen_pkts_
          app_beam_count_
          app_beacon_count_
          app_last_BS_contact_
          switch_timeout_
          switch_start_time_
      80  disable_node
      38  enable_node
       1  last_config_rssi_rcv_

 
     1 byte  in section .bss
    48 bytes in section .data
 1 096 bytes in section .text
 
 1 096 bytes of CODE memory
    49 bytes of DATA memory

Errors: none
Warnings: 3
