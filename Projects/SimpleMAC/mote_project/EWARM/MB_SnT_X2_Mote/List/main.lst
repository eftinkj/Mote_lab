###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:27:08
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\main.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\main.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"main.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\main.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\main.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\main.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          // main.c for the ARM implementation
     17          
     18          
     19          #include "defs/esnl_pub.h"
     20          
     21          #include "common.h"
     22          
     23          #include "sys_func.h"
     24          
     25          
     26          //#include "definitions.h"
     27          //#include "HW_LIB/uart_0.h"
     28          //#include "HW_LIB/adc_0.h"
     29          //#include "HW_LIB/new_adc_0_pub.h"
     30          #include "HW_LIB/RTC.h"
     31          
     32          #include "packet.h"
     33          //#include "at_cmd.h"
     34          #ifdef _ENABLE_XBEE_API_
     35          	#include "FEAT_XBee_API/API_frames.h"
     36          	#include "FEAT_Xbee_API/AT_scripts.h"
     37          #endif // _ENABLE_XBEE_API_
     38          
     39          #include "FEAT_Networking/Phy_layer.h"
     40          
     41          //#ifdef _ENABLE_APP_MOD_
     42          	#include "Application.h"
     43          //#endif // _ENABLE_APP_MOD_
     44          
     45          
     46          
     47          
     48          #ifdef _ENABLE_ROUTING_
     49          	#include "FEAT_Routing/packet_AODV.h"
     50          	//#include "network_hardware.h"
     51          	#include "FEAT_Routing/routing.h"
     52          	#include "FEAT_Routing/routing_OEDSR.h"
     53          	#include "FEAT_Routing/routing_AODV.h"
     54          #endif // _ENABLE_ROUTING_
     55          
     56          
     57          #ifdef _ENABLE_NETWORK_STACK_
     58          	#include "FEAT_Networking/tsp_common_pub.h"
     59          #endif // _ENABLE_NETWORK_STACK_
     60          
     61          #ifdef _ENABLE_QUEUING_
     62          	#include "FEAT_Queuing/Queuing.h"
     63          #endif // _ENABLE_QUEUING_
     64          
     65          #ifdef _ENABLE_ROBOTICS_01_
     66          	#include "PRJ_Robotics_01/truck_basic_control_pub.h"
     67          #endif // _ENABLE_ROBOTICS_01_
     68          
     69          #ifdef _ENABLE_ROBOTICS_02_
     70          	#include "robotics_02/bot_basic_control_pub.h"
     71          #endif //_ENABLE_ROBOTICS_02_
     72          
     73          #ifdef _ENABLE_ROBOTICS_03_
     74          	#include "robotics_03/qrhelo_basic_control_pub.h"
     75          #endif //_ENABLE_ROBOTICS_03_
     76          
     77          #ifdef _ENABLE_ROBOTICS_04_
     78          	#include "PRJ_Robotics_04/vex_tank_basic_control_pub.h"
     79          #endif //_ENABLE_ROBOTICS_04_
     80          
     81          #ifdef _ENABLE_NEM_UTILITIES_01_
     82          	#include "PRJ_NEM_Utilities_01/mon_power_basic_pub.h"
     83          #endif // _ENABLE_NEM_UTILITIES_01_
     84          
     85          #if defined(_ENABLE_CAMT_HEADSET_01_) || defined(_ENABLE_CAMT_HEADSET_02_)
     86          	#include "PRJ_CAMT_Headset_01/hset_basic_pub.h"
     87          #endif // _ENABLE_CAMT_HEADSET_01_
     88          
     89          #ifdef _ENABLE_LOGISTICS_01_
     90          	#include "FEAT_LGS_01/lgs_basic_prv.h"
     91          #endif // _ENABLE_LOGISTICS_01_
     92          
     93          #ifdef _ENABLE_F1_MOTE_TEST_01_
     94          	#include "HW_F1_Mote_01/hw_f1_mote_basic_pub.h"
     95          #endif // _ENABLE_F1_MOTE_TEST_01_
     96          
     97          #ifdef FEAT_ENABLE_CC
     98          	#include "FEAT_Networking/CongestionControl.h"
     99          #endif // FEAT_ENABLE_CC
    100          
    101          #ifdef FEAT_ENABLE_CH_SWITCHING
    102          	#include "FEAT_Networking/ChannelSwitching.h"
    103          #endif
    104          
    105          #ifdef _ENABLE_SPI_MODULE_
    106          	#include "HW_LIB/spi_pub.h"
    107          #endif // _ENABLE_SPI_MODULE_
    108          
    109          #ifdef _ENABLE_SCH_BASIC_
    110          	#include "FEAT_Scheduler/sch_basic_pub.h"
    111          #endif // _ENABLE_SCH_BASIC_
    112          
    113          #ifdef ENABLE_HIO_XBEE
    114          	#include "FEAT_HIO/hio_xbee_pub.h"
    115          #endif // ENABLE_HIO_XBEE
    116          
    117          #ifdef _ENABLE_FLA_BASIC_
    118          	#include "FEAT_Flash_Access/fla_basic_pub.h"
    119          #endif // _ENABLE_FLA_BASIC_
    120          
    121          #ifdef _ENABLE_SSN_BASIC_
    122          	#include "FEAT_SigProc/ssn_basic_pub.h"
    123          #endif // _ENABLE_SSN_BASIC_
    124          
    125          #ifdef _ENABLE_SSN_8BIT_
    126          	#include "FEAT_SigProc/ssn_8bit_pub.h"
    127          #endif // _ENABLE_SSN_8BIT_
    128          
    129          
    130          
    131          #ifdef _ENABLE_SRC_DUMMY_
    132          	#include "FEAT_SigProc/src_dummy_pub.h"
    133          #endif // _ENABLE_SRC_DUMMY_
    134          
    135          
    136          #if defined(_ENABLE_RTLS_BEACON_)
    137                  #include "FEAT_CogNet/rtls_beacon.h"
    138          #endif // #if defined(_ENABLE_RTLS_BEACON_)
    139          
    140          #if defined(_ENABLE_MICROSTRAIN_)
    141                  #include "FEAT_CogNet/microstrain.h"
    142          #endif // #if defined(_ENABLE_MICROSTRAIN_)
    143          
    144          #if defined(_ENABLE_APP_TEMP_1WIRE_)
    145          	#include "APP_TEMP_1WIRE/app_temp_1wire_main.h"
    146          #endif // #if defined(_ENABLE_APP_TEMP_1WIRE_)
    147          
    148          #include "FEAT_STM32W/STM32W_Radio.h"
    149          
    150          
    151          #include "stm32w108xx_sc.h"
    152          #define LCD_I2C_ADDR	(0x7c)
    153          extern void lcd_cmd ( uint8_t x );
    154          extern void lcd_printStr ( const char * s );
    155          extern void lcd_setCursor ( uint8_t x , uint8_t y );
    156          
    157          
    158          #ifdef _ENABLE_MAIN_
    159          
    160          
    161          
    162          /**
    163            * Definition of the global variable declared in the "common.h"
    164            */

   \                                 In section .bss, align 4
    165          int8_t XDATA short_packet[SHORT_PACKET_SIZE];
   \                     short_packet:
   \   00000000                      DS8 20
    166          

   \                                 In section .bss, align 4
    167          int XDATA dist_approx_on_ = 0;
   \                     dist_approx_on_:
   \   00000000                      DS8 4
    168          
    169          //char xdata rx_needs_to_send; // when the RX buffer have to be sent via TX
    170          //int next_rx_state = RX_IDLE;
    171          
    172          //unsigned char pkt_to_sent_len;

   \                                 In section .bss, align 4
    173          char *pkt_to_sent;
   \                     pkt_to_sent:
   \   00000000                      DS8 4
    174          

   \                                 In section .bss, align 2
    175          uint16_t XDATA mac_dest;
   \                     mac_dest:
   \   00000000                      DS8 2
    176          
    177          
    178          char XDATA enableDataTx_;
    179          
    180          
    181          unsigned long int XDATA my_energy_;

   \                                 In section .bss, align 4
    182          unsigned long int XDATA my_delay_;
   \                     my_delay_:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
   \                     enableDataTx_:
   \   00000000   0x00               DC8 0
    183          unsigned long int XDATA my_distance_;
    184          
    185          unsigned char XDATA my_protocol_ = PROTOCOL_ROUTING_OEDSR ;
   \                     my_protocol_:
   \   00000001   0x00               DC8 0
    186          unsigned char XDATA my_scheduling_ = PROTOCOL_SCHEDULING_NONE;
   \                     my_scheduling_:
   \   00000002   0x00               DC8 0
    187          unsigned char XDATA my_backoff_ = PHY_BACKOFF_DISABLE;
   \                     my_backoff_:
   \   00000003   0x00               DC8 0
    188          //uint16_t XDATA my_weight_ = DEFAULT_NODE_WEIGHT;
    189          //uint16_t XDATA my_source_weight_ = DEFAULT_SOURCE_WEIGHT;
    190          //unsigned char xdata my_CH_ = CLUSTERING_I_AM_CH;
    191          uint16_t XDATA my_CH_ = DEFAULT_MY_CH;
    192          
    193          unsigned char XDATA my_rssi_threshold_ ;
   \                     my_rssi_threshold_:
   \   00000004   0x00               DC8 0
    194          
    195          uint32_t XDATA my_tx_timeout_ = DEFAULT_TX_TIMEOUT; // Timeout for receiveing confirmation of packet TX (expires if no reponse from Radio)
    196          
    197          
    198          unsigned char XDATA my_RF_retries_ = DEFAULT_RF_RETRIES;
   \                     my_RF_retries_:
   \   00000005   0x02               DC8 2
    199          
    200          unsigned char XDATA energy_depleted_control_ = 0;
   \                     energy_depleted_control_:
   \   00000006   0x00               DC8 0
    201          
    202          
    203          
    204          
    205          unsigned char XDATA sent_DATA_ = 0;
   \                     sent_DATA_:
   \   00000007   0x00               DC8 0
    206          
    207          
    208          // For delayed transmission with dequeueing
    209          unsigned char XDATA pkt_to_sent_id = 0xFF;
   \                     pkt_to_sent_id:
   \   00000008   0xFF               DC8 255
    210          unsigned char XDATA pkt_to_sent_len = 0;
   \                     pkt_to_sent_len:
   \   00000009   0x00               DC8 0
    211          //char * xdata pkt_to_sent;
    212          
    213          
    214          unsigned char XDATA last_successful_frame_id_ = 1;
   \                     last_successful_frame_id_:
   \   0000000A   0x01               DC8 1
   \   0000000B   0x00               DC8 0
   \                     my_CH_:
   \   0000000C   0x00FD             DC16 253
   \   0000000E   0x00 0x00          DC8 0, 0
   \                     my_energy_:
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     my_distance_:
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     my_tx_timeout_:
   \   00000018   0x000000FA         DC32 250
    215          
    216          
    217          
    218          
    219          #endif // _ENABLE_MAIN_
    220          
    221          //////////////////////////////////////////////////////////////////////////////////////////////
    222          
    223          //////////////////////////////////////////////////////////////////////////////////////////////
    224          //////////////////////////////////////////////////////////////////////////////////////////////
    225          //Main Loop

   \                                 In section .data, align 4
    226          uint32_t temp_tick = RTC_MAX_TIMER_VALUE;
   \                     temp_tick:
   \   00000000   0x05265BFF         DC32 86399999
    227          //////////////////////////////////////////////////////////////////////////////////////////////
    228          //////////////////////////////////////////////////////////////////////////////////////////////
    229          
    230          #if defined(_ENABLE_ADC_MODULE_) && defined(_ENABLE_NEW_ADC_MODULE_)
    231          	#error BOTH ADC Modules are enabled!! - ONLY ONE CAN BE ACTIVE AT THE SAME TIME!!
    232          #endif
    233          
    234          

   \                                 In section .text, align 2, keep-with-next
    235          void main_power_up()
    236          {
   \                     main_power_up: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    237          // ***************************************************************************
    238          // ************************* Global Variables Init ***************************
    239          // ***************************************************************************
    240          	CLEAR_LED(RLED);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       STM_EVAL_LEDOff
    241          	CLEAR_LED(YLED);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       STM_EVAL_LEDOff
    242                  
    243          	my_protocol_ = PROTOCOL_ROUTING_OEDSR ;
   \   0000000E   0x....             LDR.N    R0,??DataTable5
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7041             STRB     R1,[R0, #+1]
    244          	my_scheduling_ = PROTOCOL_SCHEDULING_NONE;
   \   00000014   0x7081             STRB     R1,[R0, #+2]
    245          	my_backoff_ = PHY_BACKOFF_DISABLE;
   \   00000016   0x70C1             STRB     R1,[R0, #+3]
    246          //	my_weight_ = DEFAULT_NODE_WEIGHT;
    247          //	my_source_weight_ = DEFAULT_SOURCE_WEIGHT;
    248          	//unsigned char xdata my_CH_ = CLUSTERING_I_AM_CH;
    249          	my_CH_ = DEFAULT_MY_CH;
   \   00000018   0x21FD             MOVS     R1,#+253
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    250          	my_tx_timeout_ = DEFAULT_TX_TIMEOUT; // Timeout for receiveing confirmation of packet TX (expires if no reponse from Radio)
   \   0000001C   0x21FA             MOVS     R1,#+250
   \   0000001E   0x6181             STR      R1,[R0, #+24]
    251          	my_RF_retries_ = DEFAULT_RF_RETRIES;
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x7141             STRB     R1,[R0, #+5]
    252          	energy_depleted_control_ = 0;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x7181             STRB     R1,[R0, #+6]
    253          	sent_DATA_ = 0;
   \   00000028   0x71C1             STRB     R1,[R0, #+7]
    254          	// For delayed transmission with dequeueing
    255          	pkt_to_sent_id = 0xFF;
   \   0000002A   0x21FF             MOVS     R1,#+255
   \   0000002C   0x7201             STRB     R1,[R0, #+8]
    256          	pkt_to_sent_len = 0;
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x7241             STRB     R1,[R0, #+9]
    257          	last_successful_frame_id_ = 1;
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x7281             STRB     R1,[R0, #+10]
    258          
    259          
    260          ///////////////////////////////////////////////
    261          	// initially disable DATA transmission
    262          	enableDataTx_ = 0;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x7001             STRB     R1,[R0, #+0]
    263          	my_distance_ = DEFAULT_DISTANCE;
   \   0000003A   0xF240 0x51DC      MOVW     R1,#+1500
   \   0000003E   0x6141             STR      R1,[R0, #+20]
    264          	my_energy_ = DEFAULT_ENERGY;
   \   00000040   0xF06F 0x0101      MVN      R1,#+1
   \   00000044   0x6101             STR      R1,[R0, #+16]
    265          	my_rssi_threshold_ = RSSI_THRESH_DEFAULT;
   \   00000046   0x2164             MOVS     R1,#+100
   \   00000048   0x7101             STRB     R1,[R0, #+4]
    266          
    267          // ***************************************************************************
    268          // ************************* Power Up Functions ******************************
    269          // ***************************************************************************
    270          	
    271          #if defined(_ENABLE_ARM_ADC_)
    272          // || defined(_ENABLE_SRC_8BIT_ADC_)
    273          	aadc_powerup ();
    274          #endif // _ENABLE_ARM_ADC_
    275          
    276          #if defined(_ENABLE_SRC_8BIT_ADC_)
    277          	src_8bit_powerup();
                 	^
Warning[Pe223]: function "src_8bit_powerup" declared implicitly
   \   0000004A   0x.... 0x....      BL       src_8bit_powerup
    278          #endif // _ENABLE_ARM_ADC_
    279          	
    280          	rtc_init();		// Real-Time Clock/Counter setup
   \   0000004E   0x.... 0x....      BL       rtc_init
    281          	
    282          #ifdef _ENABLE_SCH_BASIC_
    283          	sch_power_up ();	// Scheduler Setup
   \   00000052   0x.... 0x....      BL       sch_power_up
    284          #endif // _ENABLE_SCH_BASIC_
    285          		
    286          	sys_init(NULL); // system error indicatio handling
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       sys_init
    287          
    288          	
    289          // ***************************************************************************
    290          // **************** Power Up Other Application Features **********************
    291          // ***************************************************************************
    292          #ifdef _ENABLE_SPI_MODULE_
    293          	spi_init_sw ( );
    294          #endif // _ENABLE_SPI_MODULE_
    295          
    296          #ifdef _ENABLE_ROBOTICS_01_
    297          	truck_init ();
    298          #endif // _ENABLE_ROBOTICS_01_
    299          
    300          #ifdef _ENABLE_ROBOTICS_02_
    301          	bot_init ();
    302          #endif // _ENABLE_ROBOTICS_02_
    303          
    304          #ifdef _ENABLE_ROBOTICS_03_
    305          	qrhelo_init ();
    306          #endif // _ENABLE_ROBOTICS_03_
    307          
    308          
    309          #ifdef _ENABLE_XBEE_API_
    310          #ifdef FEAT_ENABLE_XBEE_RECOVERY_CONFIG
    311          	// Setup XBee module lines
    312          	XBEE_RESET_NOT = 0;	// reset XBee
    313          	{ unsigned char i = 0; while ( i++ < 10 ); }
    314          	XBEE_RESET_NOT = 1; // Start XBee (not-reset!!!)
    315          	XBEE_DTR_NOT = 0;
    316          
    317          	fix_XBee_baudrate();
    318          #endif
    319          
    320          #ifndef _TEMP_ARM_
    321          	XBEE_RESET_NOT = 1; // Start XBee (not-reset!!!)
    322          	XBEE_DTR_NOT = 0;
    323          #endif // _TEMP_ARM_
    324          
    325          #endif //_ENABLE_XBEE_API_
    326          
    327          
    328          #ifdef _ENABLE_NETWORK_STACK_
    329          	phy_init_scan_params();
   \   0000005C   0x.... 0x....      BL       phy_init_scan_params
    330          #endif // _ENABLE_NETWORK_STACK_
    331          
    332          #ifdef _ENABLE_QUEUING_
    333          	que_init();
   \   00000060   0x.... 0x....      BL       que_init
    334          #endif // _ENABLE_QUEUING_
    335          
    336          #ifdef _ENABLE_ROUTING_
    337          	routing_init();
   \   00000064   0x.... 0x....      BL       routing_init
    338          #endif // _ENABLE_ROUTING_
    339          
    340          #ifdef _ENABLE_APP_MOD_
    341          	app_init();
   \   00000068   0x.... 0x....      BL       app_init
    342          #endif // _ENABLE_APP_MOD_
    343          
    344          #ifdef FEAT_ENABLE_CC
    345          	cc_init ( 1 );
    346          #endif
    347          
    348          #ifdef FEAT_ENABLE_CH_SWITCHING
    349          	cs_power_up( );
   \   0000006C   0x.... 0x....      BL       cs_power_up
    350          #endif
    351          
    352          #ifdef _ENABLE_NETWORK_STACK_
    353          	tsp_init();
   \   00000070   0x.... 0x....      BL       tsp_init
    354          #endif // _ENABLE_NETWORK_STACK_
    355          
    356          #ifdef _ENABLE_SSN_BASIC_
    357          	ssn_init ( );
    358          #endif // _ENABLE_SSN_BASIC_
    359          
    360          #ifdef _ENABLE_SSN_8BIT_
    361          	ssn_init ( );
   \   00000074   0x.... 0x....      BL       ssn_init
    362          #endif // _ENABLE_SSN_8BIT_
    363          
    364          #ifdef _ENABLE_SRC_DUMMY_
    365          	src_init();
    366          #endif // _ENABLE_SRC_DUMMY_
    367          
    368          #if defined(_ENABLE_RFID_SKYETEK_)
    369          	rfid_skyetek_power_up();
    370          #endif // defined(_ENABLE_RFID_SKYETEK_)
    371          	
    372          #if defined(_ENABLE_I2C_)
    373          	sht_power_up(); // Humidity and temp sensor via I2C
    374          #endif // defined(_ENABLE_I2C_)
    375          
    376          #if defined(_ENABLE_RTLS_BEACON_)
    377          	rtls_beacon_power_up();
    378          #endif // #if defined(_ENABLE_RTLS_BEACON_)
    379          
    380          #if defined(_ENABLE_MICROSTRAIN_)
    381              microstrain_power_up();
    382          #endif // #if defined(_ENABLE_MICROSTRAIN_)
    383          
    384          #if defined(_ENABLE_APP_TEMP_1WIRE_)
    385          	app_temp_1wire_init();
   \   00000078   0xE8BD 0x4001      POP      {R0,LR}
   \   0000007C   0x.... 0x....      B.W      app_temp_1wire_init
    386          #endif // #if defined (_ENABLE_APP_TEMP_1WIRE_)
    387          
    388          #if defined(_ENABLE_LCD_CHAR_2x8_)
    389          	lcd28_init ( );
    390          #endif 
    391          
    392          }
    393          
    394          // Start CMD exchange

   \                                 In section .bss, align 4
    395          int i2c_timeout_event = 0;
   \                     i2c_timeout_event:
   \   00000000                      DS8 4
    396          
    397          #define LCD_CMD_00	0x00

   \                                 In section .text, align 2, keep-with-next
    398          void lcd_cmd ( uint8_t x ) {
   \                     lcd_cmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    399          	uint8_t Address = LCD_I2C_ADDR;
    400          	I2C_GenerateSTART(SC2_I2C);
   \   00000004   0x....             LDR.N    R5,??DataTable5_1  ;; 0x4000c03c
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       I2C_GenerateSTART
    401          	/* Wait until CMDFIN flag is set */
    402          	int countdown = 100;
   \   0000000C   0x2664             MOVS     R6,#+100
    403          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_CMDFIN) != SET)
   \                     ??lcd_cmd_0: (+1)
   \   0000000E   0x2108             MOVS     R1,#+8
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ.N    ??CrossCallReturnLabel_11
    404          	{
    405          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   0000001A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000001E   0xD1F6             BNE.N    ??lcd_cmd_0
   \   00000020   0x.... 0x....      BL       ?Subroutine3
    406          	}
    407          
    408          	I2C_Send7bitAddress(SC2_I2C, Address, I2C_Direction_Transmitter); // I2C_Direction_Transmitter or I2C_Direction_Receiver
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x217C             MOVS     R1,#+124
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       I2C_Send7bitAddress
    409          	countdown = 100;
   \   0000002E   0x2664             MOVS     R6,#+100
    410          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_BTF) != SET)
   \                     ??lcd_cmd_1: (+1)
   \   00000030   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD004             BEQ.N    ??CrossCallReturnLabel_12
    411          	{
    412          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   00000038   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000003C   0xD1F8             BNE.N    ??lcd_cmd_1
   \   0000003E   0x.... 0x....      BL       ?Subroutine3
    413          	}
    414          //   Wire . write ( 0b00000000 ) ; // CO = 0,RS = 0
    415          //   Wire . write ( x ) ;
    416          	I2C_SendData(SC2_I2C, LCD_CMD_00);
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       I2C_SendData
    417          		countdown = 100;
   \   0000004A   0x2664             MOVS     R6,#+100
    418          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_BTF) != SET)
   \                     ??lcd_cmd_2: (+1)
   \   0000004C   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD004             BEQ.N    ??CrossCallReturnLabel_13
    419          	{
    420          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   00000054   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000058   0xD1F8             BNE.N    ??lcd_cmd_2
   \   0000005A   0x.... 0x....      BL       ?Subroutine3
    421          	}
    422          	I2C_SendData(SC2_I2C, x);
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000005E   0x4621             MOV      R1,R4
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       I2C_SendData
    423          		countdown = 100;
   \   00000066   0x2464             MOVS     R4,#+100
    424          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_BTF) != SET)
   \                     ??lcd_cmd_3: (+1)
   \   00000068   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD005             BEQ.N    ??CrossCallReturnLabel_14
    425          	{
    426          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x1E44             SUBS     R4,R0,#+1
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD1F7             BNE.N    ??lcd_cmd_3
   \   00000078   0x.... 0x....      BL       ?Subroutine3
    427          	}
    428          	//Data=I2C_ReceiveData(SC2_I2C);
    429          //   Wire . endTransmission ( ) ;
    430          	I2C_GenerateSTOP(SC2_I2C);
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000007C   0x4628             MOV      R0,R5
   \   0000007E   0x.... 0x....      BL       I2C_GenerateSTOP
    431          	countdown = 100;
   \   00000082   0x2464             MOVS     R4,#+100
    432          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_CMDFIN) != SET)
   \                     ??lcd_cmd_4: (+1)
   \   00000084   0x2108             MOVS     R1,#+8
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD005             BEQ.N    ??CrossCallReturnLabel_15
    433          	{
    434          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x1E44             SUBS     R4,R0,#+1
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1F5             BNE.N    ??lcd_cmd_4
   \   00000098   0x.... 0x....      BL       ?Subroutine3
    435          	}
    436          }
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_2
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x4628             MOV      R0,R5
   \   00000004   0x.... 0x....      B.W      I2C_GetFlagStatus

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x4630             MOV      R0,R6
   \   00000002   0x1E46             SUBS     R6,R0,#+1
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0x4770             BX       LR
    437          
    438          #define LCD_DATA_CONT	( 0xC0 )
    439          //( 0b11000000 )
    440          #define LCD_DATA_END	( 0x40 )
    441          //( 0b01000000 )

   \                                 In section .text, align 2, keep-with-next
    442           void lcd_printStr ( const char * s ) {
   \                     lcd_printStr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
    443          	I2C_GenerateSTART(SC2_I2C);
   \   00000004   0x....             LDR.N    R4,??DataTable5_1  ;; 0x4000c03c
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       I2C_GenerateSTART
    444          	int countdown = 100;
   \   0000000C   0x2764             MOVS     R7,#+100
   \   0000000E   0x....             LDR.N    R5,??DataTable5_2
    445          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_CMDFIN) != SET)
   \                     ??lcd_printStr_0: (+1)
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ.N    ??CrossCallReturnLabel_16
    446          	{
    447          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   0000001C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000020   0xD1F6             BNE.N    ??lcd_printStr_0
   \   00000022   0x.... 0x....      BL       ?Subroutine4
    448          	}
    449          	I2C_Send7bitAddress(SC2_I2C, LCD_I2C_ADDR, I2C_Direction_Transmitter); // I2C_Direction_Transmitter or I2C_Direction_Receiver
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x217C             MOVS     R1,#+124
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       I2C_Send7bitAddress
   \   00000030   0xE01C             B.N      ??lcd_printStr_1
    450          	while ( * s ) {
    451          		if ( * ( s + 1 ) ) {
    452          			//lcd_contdata ( * s ) ;
    453          			I2C_SendData(SC2_I2C, LCD_DATA_CONT);
    454          	countdown = 100;
    455          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_BTF) != SET)
    456          	{
    457          		if((countdown--) == 0) { i2c_timeout_event++; break; }
    458          	}
    459          			I2C_SendData(SC2_I2C, *s);
    460          	countdown = 100;
    461          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_BTF) != SET)
    462          	{
    463          		if((countdown--) == 0) { i2c_timeout_event++; break; }
    464          	}
    465          		} else {
    466          			//lcd_lastdata ( * s ) ;
    467          			I2C_SendData(SC2_I2C, LCD_DATA_END);
   \                     ??lcd_printStr_2: (+1)
   \   00000032   0x2140             MOVS     R1,#+64
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       I2C_SendData
    468          	countdown = 100;
   \   0000003A   0x2764             MOVS     R7,#+100
    469          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_BTF) != SET)
   \                     ??lcd_printStr_3: (+1)
   \   0000003C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD004             BEQ.N    ??CrossCallReturnLabel_17
    470          	{
    471          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   00000044   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000048   0xD1F8             BNE.N    ??lcd_printStr_3
   \   0000004A   0x.... 0x....      BL       ?Subroutine4
    472          	}
    473          			I2C_SendData(SC2_I2C, *s);		}
   \                     ??CrossCallReturnLabel_17: (+1)
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x7831             LDRB     R1,[R6, #+0]
   \   00000052   0x.... 0x....      BL       I2C_SendData
    474          	countdown = 100;
   \                     ??lcd_printStr_4: (+1)
   \   00000056   0x2764             MOVS     R7,#+100
    475          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_BTF) != SET)
   \                     ??lcd_printStr_5: (+1)
   \   00000058   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD004             BEQ.N    ??CrossCallReturnLabel_18
    476          	{
    477          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   00000060   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_24: (+1)
   \   00000064   0xD1F8             BNE.N    ??lcd_printStr_5
   \   00000066   0x.... 0x....      BL       ?Subroutine4
    478          	}
    479          		s ++ ;
   \                     ??CrossCallReturnLabel_18: (+1)
   \   0000006A   0x1C76             ADDS     R6,R6,#+1
   \                     ??lcd_printStr_1: (+1)
   \   0000006C   0x7830             LDRB     R0,[R6, #+0]
   \   0000006E   0xB1F8             CBZ.N    R0,??lcd_printStr_6
   \   00000070   0x7870             LDRB     R0,[R6, #+1]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD0DD             BEQ.N    ??lcd_printStr_2
   \   00000076   0x21C0             MOVS     R1,#+192
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       I2C_SendData
   \   0000007E   0x2764             MOVS     R7,#+100
   \                     ??lcd_printStr_7: (+1)
   \   00000080   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD004             BEQ.N    ??CrossCallReturnLabel_19
   \   00000088   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_25: (+1)
   \   0000008C   0xD1F8             BNE.N    ??lcd_printStr_7
   \   0000008E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x7831             LDRB     R1,[R6, #+0]
   \   00000096   0x.... 0x....      BL       I2C_SendData
   \   0000009A   0x2764             MOVS     R7,#+100
   \                     ??lcd_printStr_8: (+1)
   \   0000009C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   000000A0   0x2801             CMP      R0,#+1
   \   000000A2   0xD0D8             BEQ.N    ??lcd_printStr_4
   \   000000A4   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_26: (+1)
   \   000000A8   0xD1F8             BNE.N    ??lcd_printStr_8
   \   000000AA   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_20: (+1)
   \   000000AE   0xE7D2             B.N      ??lcd_printStr_4
    480          	}
    481          	I2C_GenerateSTOP(SC2_I2C);
   \                     ??lcd_printStr_6: (+1)
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       I2C_GenerateSTOP
    482          	countdown = 100;
   \   000000B6   0x2664             MOVS     R6,#+100
    483          	while (I2C_GetFlagStatus(SC2_I2C, I2C_FLAG_CMDFIN) != SET)
   \                     ??lcd_printStr_9: (+1)
   \   000000B8   0x2108             MOVS     R1,#+8
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD004             BEQ.N    ??CrossCallReturnLabel_21
    484          	{
    485          		if((countdown--) == 0) { i2c_timeout_event++; break; }
   \   000000C4   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_10: (+1)
   \   000000C8   0xD1F6             BNE.N    ??lcd_printStr_9
   \   000000CA   0x.... 0x....      BL       ?Subroutine4
    486          	}
    487          } 
   \                     ??CrossCallReturnLabel_21: (+1)
   \   000000CE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4638             MOV      R0,R7
   \   00000002   0x1E47             SUBS     R7,R0,#+1
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x6828             LDR      R0,[R5, #+0]
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \   00000004   0x6028             STR      R0,[R5, #+0]
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x.... 0x....      B.W      I2C_GetFlagStatus
    488          /*
    489          void lcd_contdata ( byte x ) {
    490             Wire . write ( 0b11000000 ) ; // CO = 1, RS = 1
    491             Wire . write ( x ) ;
    492          }
    493           
    494          void lcd_lastdata ( byte x ) {
    495             Wire . write ( 0b01000000 ) ; // CO = 0, RS = 1
    496             Wire . write ( x ) ;
    497          }
    498          */
    499           
    500          
    501          // 

   \                                 In section .text, align 2, keep-with-next
    502          void lcd_setCursor ( uint8_t x , uint8_t y ) {
    503             lcd_cmd ( 0x80 | ( y * 0x40 + x ) ) ;
   \                     lcd_setCursor: (+1)
   \   00000000   0xEB00 0x1081      ADD      R0,R0,R1, LSL #+6
   \   00000004   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x....             B.N      lcd_cmd
    504          } 
    505          

   \                                 In section .text, align 2, keep-with-next
    506          void main_init()
    507          {
   \                     main_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    508          
    509            
    510          #ifdef _ENABLE_ARM_ADC_
    511          	aadc_init ();
    512          #endif // _ENABLE_ARM_ADC_
    513          
    514          #ifdef _ENABLE_SRC_8BIT_ADC_
    515          	src_8bit_adc_init ();
                 	^
Warning[Pe223]: function "src_8bit_adc_init" declared implicitly
   \   00000002   0x.... 0x....      BL       src_8bit_adc_init
    516          #endif // _ENABLE_SRC_8BIT_ADC_
    517          
    518          #ifdef _ENABLE_SCH_BASIC_
    519          	sch_init();
   \   00000006   0x.... 0x....      BL       sch_init
    520          #endif // _ENABLE_SCH_BASIC_
    521          	
    522          	///////////////////////////////////////////////
    523          #ifdef _ENABLE_APP_MOD_
    524          #ifdef _ENABLE_ADC_MODULE_
    525          	app_suspendADC();
    526          #endif // _ENABLE_ADC_MODULE_
    527          #endif // _ENABLE_APP_MOD_
    528          ///////////////////////////////////////////////'
    529          
    530          #ifdef _ENABLE_NEM_UTILITIES_01_
    531          	mon_power_init();
    532          	mon_power_test();
    533          #endif
    534          
    535          #if defined(_ENABLE_CAMT_HEADSET_01_) || defined(_ENABLE_CAMT_HEADSET_02_)
    536          	hset_init();
    537          #endif // _ENABLE_CAMT_HEADSET_01_
    538          
    539          #ifdef _ENABLE_F1_MOTE_TEST_01_
    540          	hw_f1_mote_init ( );
    541          #endif // _ENABLE_F1_MOTE_TEST_01_
    542          
    543          #ifdef _ENABLE_ROBOTICS_04_
    544          	vex_tank_init ();
    545          #endif // _ENABLE_ROBOTICS_04_
    546          
    547          #ifdef ENABLE_HIO_XBEE
    548          	hio_xbee_init();
   \   0000000A   0x.... 0x....      BL       hio_xbee_init
    549          #endif // ENABLE_HIO_XBEE
    550          
    551          #ifdef FEAT_ENABLE_CH_SWITCHING
    552          	cs_init( );
   \   0000000E   0x.... 0x....      BL       cs_init
    553          #endif
    554          
    555          #ifdef _ENABLE_LOGISTICS_01_
    556          	lgs_init ( );
    557          #endif // _ENABLE_LOGISTICS_01_
    558          
    559          
    560          #ifdef _ENABLE_FLA_BASIC_
    561          	fla_init();
    562          #endif // _ENABLE_FLA_BASIC_
    563          
    564          #ifndef _TEMP_ARM_
    565          	// Discard any byte received so far
    566          	RI0 = 0;
    567          #endif // _TEMP_ARM_
    568          
    569          
    570          	// #############################
    571          	// AT commands in a batch test
    572          #ifdef _ENABLE_XBEE_API_
    573          	AT_GT_set();
    574          #endif // _ENABLE_XBEE_API_
    575          
    576          	CLEAR_LED(RLED);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       STM_EVAL_LEDOff
    577          	CLEAR_LED(YLED);
   \   00000018   0xE8BD 0x4002      POP      {R1,LR}
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      B.W      STM_EVAL_LEDOff
    578          
    579          #if defined(_ENABLE_RFID_SKYETEK_)
    580          	 rfid_skyetek_init();
    581          #endif // defined(_ENABLE_RFID_SKYETEK_)
    582          	
    583          #if defined(_ENABLE_I2C_)
    584          	sht_init();
    585          #endif // defined(_ENABLE_I2C_)
    586                  
    587          #if defined(_ENABLE_RTLS_BEACON_)
    588          	rtls_beacon_init();
    589          #endif // #if defined(_ENABLE_RTLS_BEACON_)
    590          
    591          #if defined(_ENABLE_MICROSTRAIN_)
    592          	microstrain_init();
    593          #endif // #if defined(_ENABLE_MICROSTRAIN_)
    594          	
    595          }
    596          
    597          
    598          
    599          
    600          /**
    601          *	main / main_arm - the main function of the Mote code
    602          */

   \                                 In section .text, align 2, keep-with-next
    603          int main_arm( void )
    604          {
   \                     main_arm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    605          
    606          ///////////////////////////////////////////////
    607          // Already called in ARM's "main()" function -> "mote.c" file
    608            //	main_power_up();
    609          ///////////////////////////////////////////////
    610          
    611          ///////////////////////////////////////////////
    612          	main_init();
   \   00000002   0x.... 0x....      BL       main_init
   \   00000006   0x....             LDR.N    R4,??DataTable5_3
   \   00000008   0x....             LDR.N    R5,??DataTable5_4
   \   0000000A   0x....             LDR.N    R6,??DataTable5_5
   \   0000000C   0x....             LDR.N    R7,??DataTable5_6
    613          ///////////////////////////////////////////////
    614          
    615          #ifndef NO_UART_OUT
    616          //	printf ("Ended initialization; Loop starts now...\r\n");
    617          #endif
    618          	
    619          //Main Loop
    620          ///////////////////////////////////////////////
    621          	while ( 1 )
    622          	{
    623          	///////////////////////////////////////////////
    624          		//TOGGLE_LED(RLED);
    625          		// Periodically adjust RTC time drift
    626          		rtc_make_adjustment();
   \                     ??main_arm_0: (+1)
   \   0000000E   0x7838             LDRB     R0,[R7, #+0]
   \   00000010   0x282A             CMP      R0,#+42
   \   00000012   0xDB0C             BLT.N    ??main_arm_1
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7030             STRB     R0,[R6, #+0]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x7038             STRB     R0,[R7, #+0]
   \   0000001C   0x7828             LDRB     R0,[R5, #+0]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x7028             STRB     R0,[R5, #+0]
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x283A             CMP      R0,#+58
   \   00000026   0xDB02             BLT.N    ??main_arm_1
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7030             STRB     R0,[R6, #+0]
   \   0000002C   0x7028             STRB     R0,[R5, #+0]
   \                     ??main_arm_1: (+1)
   \   0000002E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000032   0x....             LDR.N    R1,??DataTable5_7  ;; 0x5265c00
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xBF24             ITT      CS 
   \   00000038   0x2001             MOVCS    R0,#+1
   \   0000003A   0x7020             STRBCS   R0,[R4, #+0]
    627          	///////////////////////////////////////////////
    628          
    629          	///////////////////////////////////////////////
    630          	//	SCHEDULER main loop function
    631          	//		Handles timeouts and dynamic loop functions
    632          	///////////////////////////////////////////////
    633          	#ifdef _ENABLE_SCH_BASIC_
    634          		sch_loop( );
   \   0000003C   0x.... 0x....      BL       sch_loop
   \   00000040   0xE7E5             B.N      ??main_arm_0
    635          	#endif // _ENABLE_SCH_BASIC_
    636          
    637          
    638          	} // while (1)
    639          
    640          }
    641          ///////////////////////////////////////////////
    642          //End Main Loop
    643          ///////////////////////////////////////////////
    644          
    645          
    646          
    647          
    648          //////////////////////////////////////////////////////////////////////////////////////////////
    649          //Function Calls
    650          
    651          
    652          
    653          
    654          
    655          
    656          
    657          
    658          /**
    659            * release_pkt_in_tx() - releases packet that is being transmited
    660            *		this includes buffer freeing and reseting "pkt_to_sent_*" variables
    661            */

   \                                 In section .text, align 2, keep-with-next
    662          void release_pkt_in_tx()
    663          {
   \                     release_pkt_in_tx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    664          	// packet is no longer needed -> free the buffer slot
    665          #ifdef _ENABLE_QUEUING_
    666          	que_make_empty_buffer ( pkt_to_sent_id );
   \   00000002   0x....             LDR.N    R4,??DataTable5
   \   00000004   0x7A20             LDRB     R0,[R4, #+8]
   \   00000006   0x.... 0x....      BL       que_make_empty_buffer
    667          #endif // _ENABLE_QUEUING_
    668          	pkt_to_sent_len = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7260             STRB     R0,[R4, #+9]
    669          	pkt_to_sent_id = 0xFF;
   \   0000000E   0x20FF             MOVS     R0,#+255
   \   00000010   0x7220             STRB     R0,[R4, #+8]
    670          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     enableDataTx_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x4000C03C         DC32     0x4000c03c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     i2c_timeout_event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     rtc_zero_tickers_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     rtc_adjust_long

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     rtc_skip_tick

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     rtc_adjust

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x05265C00         DC32     0x5265c00
    671          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   lcd_cmd
        16   -> I2C_GenerateSTART
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetFlagStatus
        16   -> I2C_Send7bitAddress
        16   -> I2C_SendData
      24   lcd_printStr
        24   -> I2C_GenerateSTART
        24   -> I2C_GenerateSTOP
        24   -> I2C_GetFlagStatus
        24   -> I2C_Send7bitAddress
        24   -> I2C_SendData
       0   lcd_setCursor
         0   -> lcd_cmd
      24   main_arm
        24   -> halCommonGetInt32uMillisecondTick
        24   -> main_init
        24   -> sch_loop
       8   main_init
         0   -> STM_EVAL_LEDOff
         8   -> STM_EVAL_LEDOff
         8   -> cs_init
         8   -> hio_xbee_init
         8   -> sch_init
         8   -> src_8bit_adc_init
       8   main_power_up
         8   -> STM_EVAL_LEDOff
         8   -> app_init
         0   -> app_temp_1wire_init
         8   -> cs_power_up
         8   -> phy_init_scan_params
         8   -> que_init
         8   -> routing_init
         8   -> rtc_init
         8   -> sch_power_up
         8   -> src_8bit_powerup
         8   -> ssn_init
         8   -> sys_init
         8   -> tsp_init
       8   release_pkt_in_tx
         8   -> que_make_empty_buffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       8  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      10  ?Subroutine3
       8  ?Subroutine4
       8  ?Subroutine5
       4  dist_approx_on_
      28  enableDataTx_
          my_protocol_
          my_scheduling_
          my_backoff_
          my_rssi_threshold_
          my_RF_retries_
          energy_depleted_control_
          sent_DATA_
          pkt_to_sent_id
          pkt_to_sent_len
          last_successful_frame_id_
          my_CH_
          my_energy_
          my_distance_
          my_tx_timeout_
       4  i2c_timeout_event
     158  lcd_cmd
     208  lcd_printStr
      12  lcd_setCursor
       2  mac_dest
      66  main_arm
      34  main_init
     128  main_power_up
       4  my_delay_
       4  pkt_to_sent
      20  release_pkt_in_tx
      20  short_packet
       4  temp_tick

 
  38 bytes in section .bss
  32 bytes in section .data
 708 bytes in section .text
 
 708 bytes of CODE memory
  70 bytes of DATA memory

Errors: none
Warnings: 2
