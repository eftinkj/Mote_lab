###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:27:46
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\nvm.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\nvm.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"nvm.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\nvm.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\nvm.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\nvm.c
      1          /**
      2            ******************************************************************************
      3            * @file    nvm.c
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012
      7            * @brief   Cortex-M3 Non-Volatile Memory data storage system.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          /* Includes ------------------------------------------------------------------*/
     28          
     29          /** @addtogroup HAL
     30            * @{
     31            */
     32          
     33          /** @defgroup nvm
     34            * @{
     35            */
     36          
     37          #include PLATFORM_HEADER
     38          #include "error.h"
     39          
     40          #ifdef NVM_RAM_EMULATION
     41          
     42          static uint16_t calibrationData[32+2]={
     43             0xFFFF, 0xFFFF,
     44             0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
     45             0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
     46             0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
     47             0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
     48          };
     49          
     50          /* Private typedef -----------------------------------------------------------*/
     51          /* Private macros ------------------------------------------------------------*/
     52          /* Private variables ---------------------------------------------------------*/
     53          /* Private function prototypes -----------------------------------------------*/
     54          
     55          /* Private functions ---------------------------------------------------------*/
     56          
     57          /** @addtogroup HAL
     58            * @{
     59            */
     60          
     61          /** @defgroup nvm_Private_Functions
     62            * @{
     63            */
     64          
     65          /**
     66            * @brief  Copy the NVM data from flash into the provided RAM location.
     67            *         It is illegal for the offset to be greater than NVM_DATA_SIZE_B.
     68            * @param  data    A (RAM) pointer to where the data should be copied.
     69            * @param  offset  The location from which the data should be copied.  Must be
     70            *                16bit aligned.
     71            * @param  length  The length of the data in bytes.  Must be 16bit aligned. 
     72            * @retval An StStatus value indicating the success of the function.
     73            *         - ST_SUCCESS if the read completed cleanly.
     74            *         - ST_ERR_FATAL if the NVM storage management indicated an invalid
     75            *         state.  The function will return entirely 0xFF in the data parameter.
     76            */
     77          uint8_t halCommonReadFromNvm(void *data, uint32_t offset, uint16_t length)
     78          {
     79           halCommonMemCopy(data, ((uint8_t *) calibrationData) + offset, length); 
     80            return ST_SUCCESS;
     81          }
     82          
     83          /**
     84            * @brief  Write the NVM data from the provided location RAM into flash.
     85            *         It is illegal for the offset to be greater than NVM_DATA_SIZE_B.
     86            * @param  data    A (RAM) pointer from where the data should be taken.
     87            * @param  offset  The location to which the data should be written.  Must be
     88            *                16bit aligned.
     89            * @param  length  The length of the data in bytes.  Must be 16bit aligned.
     90            * @retval An StStatus value indicating the success of the function.
     91            *         - ST_SUCCESS if the write completed cleanly.
     92            *         - Any other status value is an error code generated by the low level
     93            *         flash erase and write API.  Refer to hal_flash.h for details.
     94            */
     95          uint8_t halCommonWriteToNvm(const void *data, uint32_t offset, uint16_t length)
     96          {
     97            halCommonMemCopy(((uint8_t *) calibrationData) + offset, data, length);
     98            return ST_SUCCESS;
     99          }
    100          
    101          #else
    102          
    103          /* hal_flash.h gives access to halInternalFlashErase and halInternalFlashWrite. */
    104          #include "hal_flash.h"
    105          /* nvm.h includes memmap.h.  These two headers define the key parameters:
    106             MFB_PAGE_SIZE_B
    107             MFB_TOP
    108             NVM_LEFT_PAGE
    109             NVM_RIGHT_PAGE
    110             NVM_DATA_SIZE_B
    111             NVM_FLASH_PAGE_COUNT
    112             NVM_MGMT_SIZE_B */
    113          #include "nvm.h"
    114          
    115          /* Define two variables that hold the actual NVM data storage.  LEFT and RIGHT
    116             are not required to be continuous memory blocks so they can be define
    117             separately.  The linker is responsible for placing these storage containers
    118             on flash page boundaries. */
    119          #if (defined (__ICCARM__) || defined (__GNUC__))

   \                                 In section NVM, align 4, root
    120          NO_STRIPPING(NO_INIT(VAR_AT_SEGMENT (const uint8_t nvmStorageLeft[NVM_DATA_SIZE_B], __NVM__))); 
   \                     nvmStorageLeft:
   \   00000000                      DS8 1024

   \                                 In section NVM, align 4, root
    121          NO_STRIPPING(NO_INIT(VAR_AT_SEGMENT (const uint8_t nvmStorageRight[NVM_DATA_SIZE_B], __NVM__)));
   \                     nvmStorageRight:
   \   00000000                      DS8 1024
    122          #elif defined __CC_ARM
    123          uint8_t nvmStorageLeft[NVM_DATA_SIZE_B] __attribute__((section("__NVM__"), zero_init)); 
    124          uint8_t nvmStorageRight[NVM_DATA_SIZE_B]__attribute__((section("__NVM__"), zero_init));
    125          #endif
    126          
    127          /**
    128            * @brief  determine the state
    129            * @param  None
    130            * @retval state
    131            */

   \                                 In section .text, align 2, keep-with-next
    132          static uint8_t determineState(void)
    133          {
   \                     determineState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    134            uint32_t *leftMgmtPtr = (uint32_t *) NVM_LEFT_PAGE;
    135            uint32_t leftMgmt = *leftMgmtPtr;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable9
    136            uint32_t *rightMgmtPtr = (uint32_t *)NVM_RIGHT_PAGE;
    137            uint32_t rightMgmt = *rightMgmtPtr;
    138            uint8_t state=0;
    139            
    140            if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFFFFFFFF)) {
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable9_1  ;; 0xffff0000
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable9_2
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x42A1             CMP      R1,R4
   \   00000016   0xF06F 0x03FF      MVN      R3,#+255
   \   0000001A   0xD113             BNE.N    ??determineState_0
   \   0000001C   0xF112 0x0F01      CMN      R2,#+1
   \   00000020   0xD00A             BEQ.N    ??determineState_1
   \   00000022   0xF46F 0x017F      MVN      R1,#+16711680
   \   00000026   0x428A             CMP      R2,R1
   \   00000028   0xD101             BNE.N    ??determineState_2
    141              /* State 1 and state 4 use identical mgmt words.  The function
    142                 determineState() is only called at the start of a NVM read
    143                 or write.  During a read, state 1 and 4 both read from the
    144                 LEFT so there is no reason to make a distinction.  During
    145                 a write, the system will see the current page as LEFT and
    146                 therefore be transitioning from LEFT to RIGHT so state 4 is
    147                 correct.  State 1 is only required to transition from 0 to 2. */
    148              state = 4;
    149            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFF00FFFF)) {
    150              state = 2;
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xBD10             POP      {R4,PC}
    151            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFF000000)) {
   \                     ??determineState_2: (+1)
   \   0000002E   0xF112 0x7F80      CMN      R2,#+16777216
   \   00000032   0xD103             BNE.N    ??determineState_3
    152              state = 3;
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0xBD10             POP      {R4,PC}
    153            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFFFFFFFF)) {
    154              state = 4;
   \                     ??determineState_1: (+1)
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xBD10             POP      {R4,PC}
    155            } else if((leftMgmt==0xFFFF0000) && (rightMgmt==0xFFFFFF00)) {
   \                     ??determineState_3: (+1)
   \   0000003C   0x429A             CMP      R2,R3
   \   0000003E   0xD11D             BNE.N    ??determineState_4
    156              state = 5;
   \   00000040   0x2005             MOVS     R0,#+5
   \   00000042   0xBD10             POP      {R4,PC}
    157            } else if((leftMgmt==0xFF000000) && (rightMgmt==0xFFFFFF00)) {
   \                     ??determineState_0: (+1)
   \   00000044   0xF111 0x7F80      CMN      R1,#+16777216
   \   00000048   0xD103             BNE.N    ??determineState_5
   \   0000004A   0x429A             CMP      R2,R3
   \   0000004C   0xD108             BNE.N    ??determineState_6
    158              state = 6;
   \   0000004E   0x2006             MOVS     R0,#+6
   \   00000050   0xBD10             POP      {R4,PC}
    159            } else if((leftMgmt==0xFF000000) && (rightMgmt==0xFFFF0000)) {
    160              state = 7;
    161            } else if((leftMgmt==0xFFFFFFFF) && (rightMgmt==0xFFFF0000)) {
   \                     ??determineState_5: (+1)
   \   00000052   0xF111 0x0F01      CMN      R1,#+1
   \   00000056   0xD107             BNE.N    ??determineState_7
   \   00000058   0x42A2             CMP      R2,R4
   \   0000005A   0xD10F             BNE.N    ??determineState_4
    162              state = 8;
   \   0000005C   0x2008             MOVS     R0,#+8
   \   0000005E   0xBD10             POP      {R4,PC}
    163            } else if((leftMgmt==0xFFFFFF00) && (rightMgmt==0xFFFF0000)) {
   \                     ??determineState_6: (+1)
   \   00000060   0x42A2             CMP      R2,R4
   \   00000062   0xD10B             BNE.N    ??determineState_4
   \   00000064   0x2007             MOVS     R0,#+7
   \   00000066   0xBD10             POP      {R4,PC}
   \                     ??determineState_7: (+1)
   \   00000068   0x4299             CMP      R1,R3
   \   0000006A   0xD107             BNE.N    ??determineState_4
   \   0000006C   0x42A2             CMP      R2,R4
   \   0000006E   0xD101             BNE.N    ??determineState_8
    164              state = 9;
   \   00000070   0x2009             MOVS     R0,#+9
   \   00000072   0xBD10             POP      {R4,PC}
    165            } else if((leftMgmt==0xFFFFFF00) && (rightMgmt==0xFF000000)) {
   \                     ??determineState_8: (+1)
   \   00000074   0xF112 0x7F80      CMN      R2,#+16777216
   \   00000078   0xBF08             IT       EQ 
   \   0000007A   0x200A             MOVEQ    R0,#+10
    166              state = 10;
    167            } else {
    168              /* State 0 is used to indicate erased or invalid. */
    169              state = 0;
    170            }
    171            
    172            return state;
   \                     ??determineState_4: (+1)
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
    173          }
    174          
    175          /**
    176            * @brief  Copy the NVM data from flash into the provided RAM location.
    177            *         It is illegal for the offset to be greater than NVM_DATA_SIZE_B.
    178            * @param  data    A (RAM) pointer to where the data should be copied.
    179            * @param  offset  The location from which the data should be copied.  Must be
    180            *                16bit aligned.
    181            * @param  length  The length of the data in bytes.  Must be 16bit aligned. 
    182            * @retval An StStatus value indicating the success of the function.
    183            *         - ST_SUCCESS if the read completed cleanly.
    184            *         - ST_ERR_FATAL if the NVM storage management indicated an invalid
    185            *         state.  The function will return entirely 0xFF in the data parameter.
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          uint8_t halCommonReadFromNvm(void *data, uint32_t offset, uint16_t length)
    188          {
   \                     halCommonReadFromNvm: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
    189            uint16_t i;
    190            uint16_t *flash;
    191            /* Remember: all flash writes are 16bits. */
    192            uint16_t *ram = (uint16_t*)data;
    193            
    194            /* The NVM data storage system cannot function if the LEFT and RIGHT
    195               storage are not aligned to physical flash pages. */
    196            assert((NVM_LEFT_PAGE%MFB_PAGE_SIZE_B)==0);
   \   00000006   0x....             LDR.N    R6,??DataTable9
   \   00000008   0x.... 0x....      ADR.W    R8,?_1
   \   0000000C   0x05B0             LSLS     R0,R6,#+22
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0x4617             MOV      R7,R2
   \   00000012   0xD005             BEQ.N    ??halCommonReadFromNvm_0
   \   00000014   0x22C4             MOVS     R2,#+196
   \   00000016   0x4641             MOV      R1,R8
   \   00000018   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000001C   0x.... 0x....      BL       __iar_EmptyStepPoint
    197            assert((NVM_RIGHT_PAGE%MFB_PAGE_SIZE_B)==0);
   \                     ??halCommonReadFromNvm_0: (+1)
   \   00000020   0x....             LDR.N    R4,??DataTable9_2
   \   00000022   0x05A0             LSLS     R0,R4,#+22
   \   00000024   0xD005             BEQ.N    ??halCommonReadFromNvm_1
   \   00000026   0x22C5             MOVS     R2,#+197
   \   00000028   0x4641             MOV      R1,R8
   \   0000002A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000002E   0x.... 0x....      BL       __iar_EmptyStepPoint
    198            /* The offset of the NVM data must be 16bit aligned. */
    199            assert((offset&0x1)==0);
   \                     ??halCommonReadFromNvm_1: (+1)
   \   00000032   0x07E8             LSLS     R0,R5,#+31
   \   00000034   0xD505             BPL.N    ??halCommonReadFromNvm_2
   \   00000036   0x22C7             MOVS     R2,#+199
   \   00000038   0x4641             MOV      R1,R8
   \   0000003A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000003E   0x.... 0x....      BL       __iar_EmptyStepPoint
    200            /* The length of the NVM data must be 16bit aligned. */
    201            assert((length&0x1)==0);
   \                     ??halCommonReadFromNvm_2: (+1)
   \   00000042   0x07F8             LSLS     R0,R7,#+31
   \   00000044   0xD507             BPL.N    ??halCommonReadFromNvm_3
   \   00000046   0x22C9             MOVS     R2,#+201
   \   00000048   0x4641             MOV      R1,R8
   \   0000004A   0x.... 0x....      ADR.W    R0,?_4
   \   0000004E   0x.... 0x....      BL       __aeabi_assert
   \   00000052   0x.... 0x....      BL       __iar_EmptyStepPoint
    202            
    203            assert(offset+length<NVM_DATA_SIZE_B);
   \                     ??halCommonReadFromNvm_3: (+1)
   \   00000056   0x1978             ADDS     R0,R7,R5
   \   00000058   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000005C   0xD307             BCC.N    ??halCommonReadFromNvm_4
   \   0000005E   0x22CB             MOVS     R2,#+203
   \   00000060   0x4641             MOV      R1,R8
   \   00000062   0x.... 0x....      ADR.W    R0,?_5
   \   00000066   0x.... 0x....      BL       __aeabi_assert
   \   0000006A   0x.... 0x....      BL       __iar_EmptyStepPoint
    204            
    205            /* Obtain the data from NVM storage. */
    206            switch(determineState()) {
   \                     ??halCommonReadFromNvm_4: (+1)
   \   0000006E   0x.... 0x....      BL       determineState
   \   00000072   0x1E40             SUBS     R0,R0,#+1
   \   00000074   0x2803             CMP      R0,#+3
   \   00000076   0xD905             BLS.N    ??halCommonReadFromNvm_5
   \   00000078   0x1F00             SUBS     R0,R0,#+4
   \   0000007A   0x2803             CMP      R0,#+3
   \   0000007C   0xD90E             BLS.N    ??halCommonReadFromNvm_6
   \   0000007E   0x1F00             SUBS     R0,R0,#+4
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xD817             BHI.N    ??halCommonReadFromNvm_7
    207              case 1:
    208              case 2:
    209              case 3:
    210              case 4:
    211              case 9:
    212              case 10:
    213                flash = (uint16_t *)(NVM_LEFT_PAGE+offset);
   \                     ??halCommonReadFromNvm_5: (+1)
   \   00000084   0x19A8             ADDS     R0,R5,R6
    214                for(i=0;i<(length/2);i++) {
   \   00000086   0x2100             MOVS     R1,#+0
   \                     ??halCommonReadFromNvm_8: (+1)
   \   00000088   0xEBB1 0x0F57      CMP      R1,R7, LSR #+1
   \   0000008C   0xBFBE             ITTT     LT 
   \   0000008E   0xF830 0x2011      LDRHLT   R2,[R0, R1, LSL #+1]
   \   00000092   0xF829 0x2011      STRHLT   R2,[R9, R1, LSL #+1]
   \   00000096   0x1C49             ADDLT    R1,R1,#+1
    215                  ram[i] = flash[i];
   \   00000098   0xDBF6             BLT.N    ??halCommonReadFromNvm_8
   \   0000009A   0xE017             B.N      ??halCommonReadFromNvm_9
    216                }
    217              break;
    218              case 5:
    219              case 6:
    220              case 7:
    221              case 8:
    222                flash = (uint16_t *)(NVM_RIGHT_PAGE+offset);
   \                     ??halCommonReadFromNvm_6: (+1)
   \   0000009C   0x1928             ADDS     R0,R5,R4
    223                for(i=0;i<(length/2);i++) {
   \   0000009E   0x2100             MOVS     R1,#+0
   \                     ??halCommonReadFromNvm_10: (+1)
   \   000000A0   0xEBB1 0x0F57      CMP      R1,R7, LSR #+1
   \   000000A4   0xBFBE             ITTT     LT 
   \   000000A6   0xF830 0x2011      LDRHLT   R2,[R0, R1, LSL #+1]
   \   000000AA   0xF829 0x2011      STRHLT   R2,[R9, R1, LSL #+1]
   \   000000AE   0x1C49             ADDLT    R1,R1,#+1
    224                  ram[i] = flash[i];
   \   000000B0   0xDBF6             BLT.N    ??halCommonReadFromNvm_10
   \   000000B2   0xE00B             B.N      ??halCommonReadFromNvm_9
    225                }
    226              break;
    227              case 0:
    228              default:
    229                /* Reading from NVM while the mgmt bytes are in an invalid state
    230                   should not return any bytes actually found in flash.  Instead,
    231                   return nothing but 0xFF.  This is legitimate because the next
    232                   call to the write function will also find invalid mgmt bytes
    233                   and trigger an erasure of NVM, after which the NVM really will
    234                   contain just 0xFF for data (plus the new data supplied during
    235                   the write call). */
    236                for(i=0;i<(length/2);i++) {
   \                     ??halCommonReadFromNvm_7: (+1)
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000BA   0xE002             B.N      ??halCommonReadFromNvm_11
    237                  ram[i] = 0xFFFF;
   \                     ??halCommonReadFromNvm_12: (+1)
   \   000000BC   0xF829 0x0011      STRH     R0,[R9, R1, LSL #+1]
    238                }
   \   000000C0   0x1C49             ADDS     R1,R1,#+1
   \                     ??halCommonReadFromNvm_11: (+1)
   \   000000C2   0xEBB1 0x0F57      CMP      R1,R7, LSR #+1
   \   000000C6   0xDBF9             BLT.N    ??halCommonReadFromNvm_12
    239                /* Inform the calling code. using ST_ERR_FATAL, that there were
    240                   invalid mgmt bytes and 0xFF was forcefully returned. */
    241              return ST_ERR_FATAL;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0xE000             B.N      ??halCommonReadFromNvm_13
    242            }
    243            
    244            return ST_SUCCESS;
   \                     ??halCommonReadFromNvm_9: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \                     ??halCommonReadFromNvm_13: (+1)
   \   000000CE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    245          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,?_3
   \   00000004   0x.... 0x....      B.W      __aeabi_assert

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,?_2
   \   00000004   0x.... 0x....      B.W      __aeabi_assert

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,?_0
   \   00000004   0x.... 0x....      B.W      __aeabi_assert
    246          
    247          /**
    248            * @brief  Return the address of the token in NVM
    249            * @param  offset  The location offset from which the address should be returned
    250            * @retval The address requested
    251            */

   \                                 In section .text, align 2, keep-with-next
    252          uint16_t *halCommonGetAddressFromNvm(uint32_t offset)
    253          {
   \                     halCommonGetAddressFromNvm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    254            uint16_t *flash;
    255            
    256            /* The NVM data storage system cannot function if the LEFT and RIGHT
    257               storage are not aligned to physical flash pages. */
    258            assert((NVM_LEFT_PAGE%MFB_PAGE_SIZE_B)==0);
   \   00000004   0x....             LDR.N    R6,??DataTable9
   \   00000006   0x.... 0x....      ADR.W    R5,?_1
   \   0000000A   0x05B0             LSLS     R0,R6,#+22
   \   0000000C   0xD006             BEQ.N    ??halCommonGetAddressFromNvm_0
   \   0000000E   0xF44F 0x7281      MOV      R2,#+258
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000018   0x.... 0x....      BL       __iar_EmptyStepPoint
    259            assert((NVM_RIGHT_PAGE%MFB_PAGE_SIZE_B)==0);
   \                     ??halCommonGetAddressFromNvm_0: (+1)
   \   0000001C   0x....             LDR.N    R7,??DataTable9_2
   \   0000001E   0x05B8             LSLS     R0,R7,#+22
   \   00000020   0xD006             BEQ.N    ??halCommonGetAddressFromNvm_1
   \   00000022   0xF240 0x1203      MOVW     R2,#+259
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000002C   0x.... 0x....      BL       __iar_EmptyStepPoint
    260            /* The offset of the NVM data must be 16bit aligned. */
    261            assert((offset&0x1)==0);
   \                     ??halCommonGetAddressFromNvm_1: (+1)
   \   00000030   0x07E0             LSLS     R0,R4,#+31
   \   00000032   0xD506             BPL.N    ??halCommonGetAddressFromNvm_2
   \   00000034   0xF240 0x1205      MOVW     R2,#+261
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000003E   0x.... 0x....      BL       __iar_EmptyStepPoint
    262            
    263            /* Obtain the data from NVM storage. */
    264            switch(determineState()) {
   \                     ??halCommonGetAddressFromNvm_2: (+1)
   \   00000042   0x19A5             ADDS     R5,R4,R6
   \   00000044   0x.... 0x....      BL       determineState
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   \   0000004A   0x2803             CMP      R0,#+3
   \   0000004C   0xD911             BLS.N    ??halCommonGetAddressFromNvm_3
   \   0000004E   0x1F00             SUBS     R0,R0,#+4
   \   00000050   0x2803             CMP      R0,#+3
   \   00000052   0xD903             BLS.N    ??halCommonGetAddressFromNvm_4
   \   00000054   0x1F00             SUBS     R0,R0,#+4
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xD90B             BLS.N    ??halCommonGetAddressFromNvm_3
   \   0000005A   0xE001             B.N      ??halCommonGetAddressFromNvm_5
    265              case 1:
    266              case 2:
    267              case 3:
    268              case 4:
    269              case 9:
    270              case 10:
    271                flash = (uint16_t *)(NVM_LEFT_PAGE+offset);
    272              break;
    273              case 5:
    274              case 6:
    275              case 7:
    276              case 8:
    277                flash = (uint16_t *)(NVM_RIGHT_PAGE+offset);
   \                     ??halCommonGetAddressFromNvm_4: (+1)
   \   0000005C   0x19E5             ADDS     R5,R4,R7
    278              break;
   \   0000005E   0xE008             B.N      ??halCommonGetAddressFromNvm_3
    279              case 0:
    280              default:
    281                /* Flash is in an invalid state 
    282                   Fix it with a dummy write and then return the flash page left */
    283                {
    284          	uint16_t dummy = 0xFFFF;
   \                     ??halCommonGetAddressFromNvm_5: (+1)
   \   00000060   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000064   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    285          	halCommonWriteToNvm(&dummy, 0, 2);
   \   00000068   0x2202             MOVS     R2,#+2
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       halCommonWriteToNvm
    286          	flash = (uint16_t *)(NVM_LEFT_PAGE+offset);
    287                }
    288            }
    289            
    290            return flash;
   \                     ??halCommonGetAddressFromNvm_3: (+1)
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    291          }
    292          
    293          /**
    294            * @brief  erase the page
    295            * @param  page
    296            * @retval ST success
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          static uint8_t erasePage(uint32_t page)
    299          {
   \                     erasePage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    300            StStatus status;
    301            uint32_t i, k;
    302            uint32_t address;
    303            uint8_t *flash;
    304            
    305            /* Erasing a LEFT or RIGHT page requires erasing all of the flash pages.
    306              Since the mgmt bytes are stored at the bottom of a page, the flash pages
    307              are erased from the top down ensuring that that mgmt words are the last
    308              data to be erased.  This way, if a reset occurs while erasing, the mgmt
    309              words are still valid the next time determineState() is called. */
    310            for(i=NVM_FLASH_PAGE_COUNT;i>0;i--) {
   \   00000004   0x2501             MOVS     R5,#+1
    311              address = (page+((i-1)*MFB_PAGE_SIZE_B));
   \                     ??erasePage_0: (+1)
   \   00000006   0x1E6D             SUBS     R5,R5,#+1
   \   00000008   0xEB04 0x2685      ADD      R6,R4,R5, LSL #+10
    312              flash = (uint8_t *)address;
   \   0000000C   0x4637             MOV      R7,R6
    313              /* Scan the page to determine if it is fully erased already.
    314                 If the flash is not erased, erase it.  The purpose of scanning
    315                 first is to save a little time if erasing is not required. */
    316              for(k=0;k<MFB_PAGE_SIZE_B;k++,flash++) {
   \   0000000E   0x2000             MOVS     R0,#+0
    317                if(*flash != 0xFF) {
   \                     ??erasePage_1: (+1)
   \   00000010   0x7839             LDRB     R1,[R7, #+0]
   \   00000012   0x29FF             CMP      R1,#+255
   \   00000014   0xD006             BEQ.N    ??erasePage_2
    318                  status = halInternalFlashErase(MFB_PAGE_ERASE, address);
   \   00000016   0x4631             MOV      R1,R6
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      BL       halInternalFlashErase
    319                  if(status != ST_SUCCESS) {
   \   0000001E   0xB948             CBNZ.N   R0,??erasePage_3
    320                    return status;
    321                  }
    322                  /* Don't bother looking at the rest of this flash page and just
    323                     move to the next. */
    324                  k=MFB_PAGE_SIZE_B;
   \   00000020   0xF44F 0x6080      MOV      R0,#+1024
    325                }
    326              }
   \                     ??erasePage_2: (+1)
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
   \   00000028   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000002C   0xD3F0             BCC.N    ??erasePage_1
    327            }
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD1E9             BNE.N    ??erasePage_0
    328            return ST_SUCCESS;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??erasePage_3: (+1)
   \   00000034   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    329          }
    330          
    331          
    332          /* This macro is responsible for erasing an NVM page (LEFT or RIGHT). */
    333          #define ERASE_PAGE(page)          \
    334            do {                            \
    335              status = erasePage(page);     \
    336              if(status != ST_SUCCESS) { \
    337                return status;              \
    338              }                             \
    339            } while(0)
    340          
    341          
    342          /* This macro is responsible for writing the new data into the destination
    343             page and copying existing data from the source page to the
    344             destination page. */
    345          #define WRITE_DATA(destPage, srcPage, offset, length)                     \
    346            do {                                                                    \
    347              /* Copy all data below the new data from the srcPage to the destPage */ \
    348              status = halInternalFlashWrite(destPage+NVM_MGMT_SIZE_B,              \
    349                                             (uint16_t *)(srcPage+NVM_MGMT_SIZE_B),   \
    350                                             (offset-NVM_MGMT_SIZE_B)/2);           \
    351              if(status != ST_SUCCESS) { return status; }                        \
    352              /* Write the new data */                                                \
    353              status = halInternalFlashWrite(destPage+offset,                       \
    354                                             ram,                                   \
    355                                             (length)/2);                           \
    356              if(status != ST_SUCCESS) { return status; }                        \
    357              /* Copy all data above the new data from the srcPage to the destPage */ \
    358              status = halInternalFlashWrite(destPage+offset+length,                \
    359                                             (uint16_t *)(srcPage+offset+length),     \
    360                                             (NVM_DATA_SIZE_B-                      \
    361                                              length-offset-                        \
    362                                              NVM_MGMT_SIZE_B)/2);                  \
    363              if(status != ST_SUCCESS) { return status; }                        \
    364            } while(0)
    365          
    366          /* This macro is responsible for writing 16bits of management data to
    367             the proper management address. */
    368          #define WRITE_MGMT_16BITS(address, data)                  \
    369            do{                                                     \
    370              uint16_t value = data;                                  \
    371              status = halInternalFlashWrite((address), &value, 1); \
    372              if(status != ST_SUCCESS) {                         \
    373                return status;                                      \
    374              }                                                     \
    375            } while(0)
    376          
    377          
    378          /**
    379            * @brief  Write the NVM data from the provided location RAM into flash.
    380            *         It is illegal for the offset to be greater than NVM_DATA_SIZE_B.
    381            * @param  data    A (RAM) pointer from where the data should be taken.
    382            * @param  offset  The location to which the data should be written.  Must be
    383            *                16bit aligned.
    384            * @param  length  The length of the data in bytes.  Must be 16bit aligned.
    385            * @retval An StStatus value indicating the success of the function.
    386            *         - ST_SUCCESS if the write completed cleanly.
    387            *         - Any other status value is an error code generated by the low level
    388            *         flash erase and write API.  Refer to hal_flash.h for details.
    389            */

   \                                 In section .text, align 2, keep-with-next
    390          uint8_t halCommonWriteToNvm(const void *data, uint32_t offset, uint16_t length)
    391          {
   \                     halCommonWriteToNvm: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
    392            StStatus status;
    393            uint8_t state, exitState;
    394            uint32_t srcPage;
    395            uint32_t destPage;
    396            /* Remember: NVM data storage works on 16bit quantities. */
    397            uint16_t *ram = (uint16_t*)data;
    398            
    399            /* The NVM data storage system cannot function if the LEFT and RIGHT
    400               storage are not aligned to physical flash pages. */
    401            assert((NVM_LEFT_PAGE%MFB_PAGE_SIZE_B)==0);
   \   00000004   0x....             LDR.N    R0,??DataTable9
   \   00000006   0x.... 0x....      ADR.W    R7,?_1
   \   0000000A   0x0580             LSLS     R0,R0,#+22
   \   0000000C   0xB086             SUB      SP,SP,#+24
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0x4616             MOV      R6,R2
   \   00000012   0xD006             BEQ.N    ??halCommonWriteToNvm_0
   \   00000014   0xF240 0x1291      MOVW     R2,#+401
   \   00000018   0x4639             MOV      R1,R7
   \   0000001A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000001E   0x.... 0x....      BL       __iar_EmptyStepPoint
    402            assert((NVM_RIGHT_PAGE%MFB_PAGE_SIZE_B)==0);
   \                     ??halCommonWriteToNvm_0: (+1)
   \   00000022   0x....             LDR.N    R4,??DataTable9_2
   \   00000024   0x05A0             LSLS     R0,R4,#+22
   \   00000026   0xD006             BEQ.N    ??halCommonWriteToNvm_1
   \   00000028   0xF44F 0x72C9      MOV      R2,#+402
   \   0000002C   0x4639             MOV      R1,R7
   \   0000002E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000032   0x.... 0x....      BL       __iar_EmptyStepPoint
    403            /* The offset of the NVM data must be 16bit aligned. */
    404            assert((offset&0x1)==0);
   \                     ??halCommonWriteToNvm_1: (+1)
   \   00000036   0x07E8             LSLS     R0,R5,#+31
   \   00000038   0xD506             BPL.N    ??halCommonWriteToNvm_2
   \   0000003A   0xF44F 0x72CA      MOV      R2,#+404
   \   0000003E   0x4639             MOV      R1,R7
   \   00000040   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000044   0x.... 0x....      BL       __iar_EmptyStepPoint
    405            /* The length of the NVM data must be 16bit aligned. */
    406            assert((length&0x1)==0);
   \                     ??halCommonWriteToNvm_2: (+1)
   \   00000048   0x07F0             LSLS     R0,R6,#+31
   \   0000004A   0xD508             BPL.N    ??halCommonWriteToNvm_3
   \   0000004C   0xF44F 0x72CB      MOV      R2,#+406
   \   00000050   0x4639             MOV      R1,R7
   \   00000052   0x.... 0x....      ADR.W    R0,?_4
   \   00000056   0x.... 0x....      BL       __aeabi_assert
   \   0000005A   0x.... 0x....      BL       __iar_EmptyStepPoint
    407            /* It is illegal to write to an offset outside of NVM storage. */
    408            assert(offset+length<NVM_DATA_SIZE_B);
   \                     ??halCommonWriteToNvm_3: (+1)
   \   0000005E   0x1970             ADDS     R0,R6,R5
   \   00000060   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000064   0xD308             BCC.N    ??halCommonWriteToNvm_4
   \   00000066   0xF44F 0x72CC      MOV      R2,#+408
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0x.... 0x....      ADR.W    R0,?_5
   \   00000070   0x.... 0x....      BL       __aeabi_assert
   \   00000074   0x.... 0x....      BL       __iar_EmptyStepPoint
    409            
    410            
    411            state = determineState();
    412            
    413            switch(state) {
   \                     ??halCommonWriteToNvm_4: (+1)
   \   00000078   0x.... 0x....      LDR.W    R9,??DataTable9
   \   0000007C   0xF5C6 0x6080      RSB      R0,R6,#+1024
   \   00000080   0x1B40             SUBS     R0,R0,R5
   \   00000082   0x1F00             SUBS     R0,R0,#+4
   \   00000084   0xEA4F 0x0850      LSR      R8,R0,#+1
   \   00000088   0x1CA0             ADDS     R0,R4,#+2
   \   0000008A   0x9004             STR      R0,[SP, #+16]
   \   0000008C   0x19AF             ADDS     R7,R5,R6
   \   0000008E   0x1F28             SUBS     R0,R5,#+4
   \   00000090   0x0840             LSRS     R0,R0,#+1
   \   00000092   0x9003             STR      R0,[SP, #+12]
   \   00000094   0xF44F 0x4A7F      MOV      R10,#+65280
   \   00000098   0x.... 0x....      BL       determineState
   \   0000009C   0x1E40             SUBS     R0,R0,#+1
   \   0000009E   0x2803             CMP      R0,#+3
   \   000000A0   0xD905             BLS.N    ??halCommonWriteToNvm_5
   \   000000A2   0x1F00             SUBS     R0,R0,#+4
   \   000000A4   0x2803             CMP      R0,#+3
   \   000000A6   0xD908             BLS.N    ??halCommonWriteToNvm_6
   \   000000A8   0x1F00             SUBS     R0,R0,#+4
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD827             BHI.N    ??halCommonWriteToNvm_7
    414              case 1:
    415              case 2:
    416              case 3:
    417              case 4:
    418              case 9:
    419              case 10:
    420                state = 3;
    421                srcPage = NVM_LEFT_PAGE;
   \                     ??halCommonWriteToNvm_5: (+1)
   \   000000AE   0xF8CD 0x9008      STR      R9,[SP, #+8]
    422                destPage = NVM_RIGHT_PAGE;
   \   000000B2   0x9401             STR      R4,[SP, #+4]
    423                exitState = 7;
   \   000000B4   0xF04F 0x0B07      MOV      R11,#+7
    424              break;
   \   000000B8   0xE051             B.N      ??halCommonWriteToNvm_8
    425              case 5:
    426              case 6:
    427              case 7:
    428              case 8:
    429                state = 7;
    430                srcPage = NVM_RIGHT_PAGE;
   \                     ??halCommonWriteToNvm_6: (+1)
   \   000000BA   0x9402             STR      R4,[SP, #+8]
    431                destPage = NVM_LEFT_PAGE;
   \   000000BC   0xF8CD 0x9004      STR      R9,[SP, #+4]
    432                exitState = 3;
   \   000000C0   0xF04F 0x0B03      MOV      R11,#+3
    433              break;
    434              case 0:
    435              default:
    436                /* Invalid state.  Default to writing to the LEFT page.  Defaulting to
    437                   using RIGHT as the source page is valid since the RIGHT page
    438                   will also be erased and therefore produce 0xFF for data values. */
    439                state = 0;
    440                srcPage = NVM_RIGHT_PAGE;
    441                destPage = NVM_LEFT_PAGE;
    442                exitState = 3;
    443              break;
    444            }
    445            
    446            /* Advance the state machine.  Starting on state 3 requires state 7 to
    447               exit and starting on state 7 requires state 3 to exit.  Starting on
    448               any other state requires either 3 or 7 to exit.
    449               NOTE:  Refer to nvm.h for a description of the states and how the
    450                      state transitions correspond to erasing, writing data, and
    451                      writing mgmt values. */
    452            while(TRUE) {
    453              switch(state) {
    454                case 0:
    455                  /* State 0 is the only state where the source page needs to be erased. */
    456                  ERASE_PAGE(srcPage);
    457                  ERASE_PAGE(destPage);
    458                  WRITE_DATA(destPage, srcPage, offset, length);
    459                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+0, 0x0000);
    460                  state=1;
    461                break;
    462                case 1:
    463                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+2, 0xFF00);
    464                  state=2;
    465                break;
    466                case 2:
    467                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+0, 0x0000);
    468                  state=3;
    469                break;
    470                case 3:
    471                  if(exitState==3) {
    472                    return ST_SUCCESS;
    473                  }
    474                  ERASE_PAGE(destPage);
    475                  state=4;
    476                break;
    477                case 4:
    478                  WRITE_DATA(destPage, srcPage, offset, length);
    479                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+0, 0xFF00);
    480                  state=5;
    481                break;
    482                case 5:
    483                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+2, 0xFF00);
    484                  state=6;
    485                break;
    486                case 6:
    487                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+0, 0x0000);
    488                  state=7;
    489                break;
    490                case 7:
    491                  if(exitState==7) {
    492                    return ST_SUCCESS;
    493                  }
    494                  ERASE_PAGE(destPage);
   \                     ??halCommonWriteToNvm_9: (+1)
   \   000000C4   0x9801             LDR      R0,[SP, #+4]
   \   000000C6   0x.... 0x....      BL       erasePage
   \   000000CA   0xB9A8             CBNZ.N   R0,??halCommonWriteToNvm_10
    495                  state=8;
    496                break;
    497                case 8:
    498                  WRITE_DATA(destPage, srcPage, offset, length);
   \   000000CC   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_14: (+1)
   \   000000D0   0xB990             CBNZ.N   R0,??halCommonWriteToNvm_10
   \   000000D2   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_18: (+1)
   \   000000D6   0xB978             CBNZ.N   R0,??halCommonWriteToNvm_10
   \   000000D8   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16: (+1)
   \   000000DC   0xB960             CBNZ.N   R0,??halCommonWriteToNvm_10
    499                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+0, 0xFF00);
   \   000000DE   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_21: (+1)
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       halInternalFlashWrite
   \   000000E8   0xB930             CBNZ.N   R0,??halCommonWriteToNvm_10
    500                  state=9;
    501                break;
    502                case 9:
    503                  WRITE_MGMT_16BITS(NVM_RIGHT_PAGE+2, 0xFF00);
   \   000000EA   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_20: (+1)
   \   000000EE   0xB918             CBNZ.N   R0,??halCommonWriteToNvm_10
    504                  state=10;
    505                break;
    506                case 10:
    507                  WRITE_MGMT_16BITS(NVM_LEFT_PAGE+0, 0x0000);
   \   000000F0   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_10: (+1)
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD02F             BEQ.N    ??halCommonWriteToNvm_11
   \                     ??halCommonWriteToNvm_10: (+1)
   \   000000F8   0xB007             ADD      SP,SP,#+28
   \   000000FA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??halCommonWriteToNvm_7: (+1)
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       erasePage
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD1F7             BNE.N    ??halCommonWriteToNvm_10
   \   00000108   0x4648             MOV      R0,R9
   \   0000010A   0x.... 0x....      BL       erasePage
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD1F2             BNE.N    ??halCommonWriteToNvm_10
   \   00000112   0x9A03             LDR      R2,[SP, #+12]
   \   00000114   0x1D21             ADDS     R1,R4,#+4
   \   00000116   0xF109 0x0004      ADD      R0,R9,#+4
   \   0000011A   0x.... 0x....      BL       halInternalFlashWrite
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD1EA             BNE.N    ??halCommonWriteToNvm_10
   \   00000122   0x9906             LDR      R1,[SP, #+24]
   \   00000124   0x0872             LSRS     R2,R6,#+1
   \   00000126   0xEB05 0x0009      ADD      R0,R5,R9
   \   0000012A   0x.... 0x....      BL       halInternalFlashWrite
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD1E2             BNE.N    ??halCommonWriteToNvm_10
   \   00000132   0x4642             MOV      R2,R8
   \   00000134   0x19E1             ADDS     R1,R4,R7
   \   00000136   0xEB09 0x0007      ADD      R0,R9,R7
   \   0000013A   0x.... 0x....      BL       halInternalFlashWrite
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD1DA             BNE.N    ??halCommonWriteToNvm_10
   \   00000142   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD1D6             BNE.N    ??halCommonWriteToNvm_10
   \   0000014A   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD1D2             BNE.N    ??halCommonWriteToNvm_10
   \   00000152   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000156   0xE7CF             B.N      ??halCommonWriteToNvm_10
   \                     ??halCommonWriteToNvm_11: (+1)
   \   00000158   0xF1BB 0x0F03      CMP      R11,#+3
   \   0000015C   0xD0CC             BEQ.N    ??halCommonWriteToNvm_10
   \                     ??halCommonWriteToNvm_8: (+1)
   \   0000015E   0x9801             LDR      R0,[SP, #+4]
   \   00000160   0x.... 0x....      BL       erasePage
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD1C7             BNE.N    ??halCommonWriteToNvm_10
   \   00000168   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000016C   0x2800             CMP      R0,#+0
   \   0000016E   0xD1C3             BNE.N    ??halCommonWriteToNvm_10
   \   00000170   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD1BF             BNE.N    ??halCommonWriteToNvm_10
   \   00000178   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD1BB             BNE.N    ??halCommonWriteToNvm_10
   \   00000180   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000184   0x4620             MOV      R0,R4
   \   00000186   0x.... 0x....      BL       halInternalFlashWrite
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD1B4             BNE.N    ??halCommonWriteToNvm_10
   \   0000018E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000192   0x....             LDR.N    R0,??DataTable9_3
   \   00000194   0x.... 0x....      BL       halInternalFlashWrite
   \   00000198   0x2800             CMP      R0,#+0
   \   0000019A   0xD1AD             BNE.N    ??halCommonWriteToNvm_10
   \   0000019C   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_11: (+1)
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD1A9             BNE.N    ??halCommonWriteToNvm_10
   \   000001A4   0xF1BB 0x0F07      CMP      R11,#+7
   \   000001A8   0xD18C             BNE.N    ??halCommonWriteToNvm_9
   \   000001AA   0xE7A5             B.N      ??halCommonWriteToNvm_10
    508                  state=3;
    509                break;
    510              }
    511            }
    512          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0xF8AD 0xA000      STRH     R10,[SP, #+0]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x9804             LDR      R0,[SP, #+16]
   \   00000002   0xF8AD 0xA000      STRH     R10,[SP, #+0]
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x9801             LDR      R0,[SP, #+4]
   \   00000002   0x9906             LDR      R1,[SP, #+24]
   \   00000004   0x0872             LSRS     R2,R6,#+1
   \   00000006   0x1828             ADDS     R0,R5,R0
   \   00000008   0x.... 0x....      B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x9802             LDR      R0,[SP, #+8]
   \   00000002   0x19C1             ADDS     R1,R0,R7
   \   00000004   0x9801             LDR      R0,[SP, #+4]
   \   00000006   0x4642             MOV      R2,R8
   \   00000008   0x19C0             ADDS     R0,R0,R7
   \   0000000A   0x.... 0x....      B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x9802             LDR      R0,[SP, #+8]
   \   00000002   0x9A03             LDR      R2,[SP, #+12]
   \   00000004   0x1D01             ADDS     R1,R0,#+4
   \   00000006   0x9801             LDR      R0,[SP, #+4]
   \   00000008   0x1D00             ADDS     R0,R0,#+4
   \   0000000A   0x.... 0x....      B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      B.W      halInternalFlashWrite

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x4648             MOV      R0,R9
   \   0000000A   0x.... 0x....      B.W      halInternalFlashWrite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     nvmStorageLeft

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     nvmStorageRight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     nvmStorageLeft+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x28 0x4E          DC8 "(NVM_LEFT_PAGE%MFB_PAGE_SIZE_B)==0"
   \              0x56 0x4D    
   \              0x5F 0x4C    
   \              0x45 0x46    
   \              0x54 0x5F    
   \              0x50 0x41    
   \              0x47 0x45    
   \              0x25 0x4D    
   \              0x46 0x42    
   \              0x5F 0x50    
   \              0x41 0x47    
   \              0x45 0x5F    
   \              0x53 0x49    
   \              0x5A 0x45    
   \              0x5F 0x42    
   \              0x29 0x3D    
   \              0x3D 0x30    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x4A          DC8 5CH, 4AH, 6FH, 6EH, 5CH, 44H, 6FH, 63H
   \              0x6F 0x6E    
   \              0x5C 0x44    
   \              0x6F 0x63    
   \   00000010   0x75 0x6D          DC8 75H, 6DH, 65H, 6EH, 74H, 73H, 5CH, 4DH
   \              0x65 0x6E    
   \              0x74 0x73    
   \              0x5C 0x4D    
   \   00000018   0x4F 0x5F          DC8 4FH, 5FH, 53H, 5FH, 61H, 6EH, 64H, 5FH
   \              0x53 0x5F    
   \              0x61 0x6E    
   \              0x64 0x5F    
   \   00000020   0x54 0x5C          DC8 54H, 5CH, 43H, 70H, 45H, 35H, 31H, 37H
   \              0x43 0x70    
   \              0x45 0x35    
   \              0x31 0x37    
   \   00000028   0x30 0x5F          DC8 30H, 5FH, 52H, 54H, 5FH, 53H, 79H, 73H
   \              0x52 0x54    
   \              0x5F 0x53    
   \              0x79 0x73    
   \   00000030   0x74 0x65          DC8 74H, 65H, 6DH, 73H, 5CH, 4CH, 61H, 62H
   \              0x6D 0x73    
   \              0x5C 0x4C    
   \              0x61 0x62    
   \   00000038   0x73 0x5C          DC8 73H, 5CH, 63H, 70H, 65H, 2DH, 35H, 31H
   \              0x63 0x70    
   \              0x65 0x2D    
   \              0x35 0x31    
   \   00000040   0x37 0x30          DC8 37H, 30H, 2DH, 6DH, 6FH, 74H, 65H, 2DH
   \              0x2D 0x6D    
   \              0x6F 0x74    
   \              0x65 0x2D    
   \   00000048   0x63 0x6F          DC8 63H, 6FH, 64H, 65H, 5CH, 55H, 74H, 69H
   \              0x64 0x65    
   \              0x5C 0x55    
   \              0x74 0x69    
   \   00000050   0x6C 0x69          DC8 6CH, 69H, 74H, 69H, 65H, 73H, 5CH, 53H
   \              0x74 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000058   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 57H, 31H, 30H, 38H
   \              0x33 0x32    
   \              0x57 0x31    
   \              0x30 0x38    
   \   00000060   0x78 0x78          DC8 78H, 78H, 5FH, 48H, 41H, 4CH, 5FH, 44H
   \              0x5F 0x48    
   \              0x41 0x4C    
   \              0x5F 0x44    
   \   00000068   0x72 0x69          DC8 72H, 69H, 76H, 65H, 72H, 5CH, 6DH, 69H
   \              0x76 0x65    
   \              0x72 0x5C    
   \              0x6D 0x69    
   \   00000070   0x63 0x72          DC8 63H, 72H, 6FH, 5CH, 63H, 6FH, 72H, 74H
   \              0x6F 0x5C    
   \              0x63 0x6F    
   \              0x72 0x74    
   \   00000078   0x65 0x78          DC8 65H, 78H, 6DH, 33H, 5CH, 6EH, 76H, 6DH
   \              0x6D 0x33    
   \              0x5C 0x6E    
   \              0x76 0x6D    
   \   00000080   0x2E 0x63          DC8 2EH, 63H, 0
   \              0x00         
   \   00000083   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x28 0x4E          DC8 "(NVM_RIGHT_PAGE%MFB_PAGE_SIZE_B)==0"
   \              0x56 0x4D    
   \              0x5F 0x52    
   \              0x49 0x47    
   \              0x48 0x54    
   \              0x5F 0x50    
   \              0x41 0x47    
   \              0x45 0x25    
   \              0x4D 0x46    
   \              0x42 0x5F    
   \              0x50 0x41    
   \              0x47 0x45    
   \              0x5F 0x53    
   \              0x49 0x5A    
   \              0x45 0x5F    
   \              0x42 0x29    
   \              0x3D 0x3D    
   \              0x30 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x28 0x6F          DC8 "(offset&0x1)==0"
   \              0x66 0x66    
   \              0x73 0x65    
   \              0x74 0x26    
   \              0x30 0x78    
   \              0x31 0x29    
   \              0x3D 0x3D    
   \              0x30 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x28 0x6C          DC8 "(length&0x1)==0"
   \              0x65 0x6E    
   \              0x67 0x74    
   \              0x68 0x26    
   \              0x30 0x78    
   \              0x31 0x29    
   \              0x3D 0x3D    
   \              0x30 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x6F 0x66          DC8 "offset+length<NVM_DATA_SIZE_B"
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x2B 0x6C    
   \              0x65 0x6E    
   \              0x67 0x74    
   \              0x68 0x3C    
   \              0x4E 0x56    
   \              0x4D 0x5F    
   \              0x44 0x41    
   \              0x54 0x41    
   \              0x5F 0x53    
   \              0x49 0x5A    
   \              0x45 0x5F    
   \              0x42 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0
    513          
    514          #endif /* NVM_RAM_EMULATION */
    515          
    516          /**
    517            * @}
    518            */
    519          
    520          /**
    521            * @}
    522            */ 
    523          
    524          /**
    525            * @}
    526            */
    527          
    528          
    529          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   determineState
      24   erasePage
        24   -> halInternalFlashErase
      24   halCommonGetAddressFromNvm
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> determineState
        24   -> halCommonWriteToNvm
      32   halCommonReadFromNvm
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
        32   -> determineState
      64   halCommonWriteToNvm
        64   -> __aeabi_assert
        64   -> __iar_EmptyStepPoint
        64   -> determineState
        64   -> erasePage
        64   -> halInternalFlashWrite


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       8  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      14  ?Subroutine3
      14  ?Subroutine4
      14  ?Subroutine5
      14  ?Subroutine6
      12  ?Subroutine7
      14  ?Subroutine8
      10  ?Subroutine9
      36  ?_0
     132  ?_1
      36  ?_2
      16  ?_3
      16  ?_4
      32  ?_5
     126  determineState
      54  erasePage
     118  halCommonGetAddressFromNvm
     210  halCommonReadFromNvm
     428  halCommonWriteToNvm
    1024  nvmStorageLeft
    1024  nvmStorageRight

 
 1 336 bytes in section .text
 2 048 bytes in section NVM
 
 1 336 bytes of CODE memory
 2 048 bytes of DATA memory

Errors: none
Warnings: none
