###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:28:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"routing.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\routing.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\routing.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Routing\routing.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          
     17          
     18          #include "defs/esnl_pub.h"
     19          
     20          #ifdef _ENABLE_ROUTING_
     21          
     22          #include "FEAT_STM32W/STM32W_Radio.h"
     23          
     24          #include "common.h"
     25          
     26          #include "routing.h"
     27          
     28          #include "routing_AODV.h"
     29          #include "routing_OEDSR.h"
     30          #include "routing_MMCR.h"
     31          
     32          #include "FEAT_Queuing/Queuing.h"
     33          #include "FEAT_Networking/Phy_layer.h"
     34          #include "FEAT_Networking/tsp_common_pub.h"
     35          
     36          #include "Application.h"
     37          #ifdef FEAT_ENABLE_CC
     38          	#include "congestionControl.h"
     39          #endif
     40          
     41          
     42          ///////////////////////////////////////////////

   \                                 In section .bss, align 1
     43          unsigned char XDATA AODV_control_bit;
   \                     AODV_control_bit:
   \   00000000                      DS8 1
     44          unsigned char XDATA OEDSR_control_bit;
   \                     OEDSR_control_bit:
   \   00000001                      DS8 1
     45          
     46          uint8_t AODV_route_control;
   \                     AODV_route_control:
   \   00000002                      DS8 1
     47          uint8_t AODVcounter_update;
     48          
     49          uint8_t data_forward_control_;
   \                     data_forward_control_:
   \   00000003                      DS8 1

   \                                 In section .bss, align 1
   \                     AODVcounter_update:
   \   00000000                      DS8 1
     50          
     51          unsigned char XDATA RREQ_counter;
     52          unsigned char XDATA RREP_counter;
     53          unsigned char XDATA ACK_AODV_counter;
     54          unsigned char XDATA DATA_AODV_counter;
   \                     DATA_AODV_counter:
   \   00000001                      DS8 1

   \                                 In section .bss, align 1
   \                     RREQ_counter:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     RREP_counter:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ACK_AODV_counter:
   \   00000000                      DS8 1
     55          ///////////////////////////////////////////////

   \                                 In section .data, align 1
     56          uint8_t can_start_on_beam = 1;  // node can start route discovery after the first (only) BEAM
   \                     can_start_on_beam:
   \   00000000   0x01               DC8 1
     57          
     58          ///////////////////////////////////////////////
     59          #ifndef _ARM_
     60          	#ifdef __KEIL__
     61          		sbit YLED = P2 ^ 4;
     62          	#else
     63          		#define YLED P2_4
     64          	#endif
     65          #endif // not _ARM_
     66          ///////////////////////////////////////////////
     67          
     68          

   \                                 In section .text, align 2, keep-with-next
     69          void recvStopData ( sint8_t XDATA *p )
     70          {
     71          	data_forward_control_ = 0;
   \                     recvStopData: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
     72          }
   \   00000006   0x4770             BX       LR               ;; return
     73          
     74          ///////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
     75          void routing_init()
     76          {
     77          	data_forward_control_ = 1;
   \                     routing_init: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
     78          	my_protocol_ = ROUTING_PROTOCOL_MMCR;//ROUTING_PROTOCOL_OEDSR;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x....             LDR.N    R1,??DataTable11_1
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
     79          	routing_set_routing_protocol();
   \   0000000C                      REQUIRE routing_set_routing_protocol
   \   0000000C                      ;; // Fall through to label routing_set_routing_protocol
     80          }
     81          
     82          ///////////////////////////////////////////////
     83          

   \                                 In section .text, align 2, keep-with-next
     84          void routing_set_routing_protocol() // my_protocol_ has correct value
     85          {
   \                     routing_set_routing_protocol: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     86          #ifdef FEAT_ENABLE_AODV
     87          	if ( ROUTING_PROTOCOL_AODV == my_protocol_ )
   \   00000002   0x....             LDR.N    R5,??DataTable11_1
   \   00000004   0x....             LDR.N    R4,??DataTable11
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD105             BNE.N    ??routing_set_routing_protocol_0
     88          	{
     89          		AODV_control_bit = 1;
   \   0000000C   0x7020             STRB     R0,[R4, #+0]
     90          		OEDSR_control_bit = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7060             STRB     R0,[R4, #+1]
     91          		routing_init_AODV();
   \   00000012   0x.... 0x....      BL       routing_init_AODV
   \   00000016   0xE005             B.N      ??routing_set_routing_protocol_1
     92          	}
     93          	else
     94          #endif
     95          #ifdef _ENABLE_OEDSR_
     96          	if ( ROUTING_PROTOCOL_OEDSR == my_protocol_ )
   \                     ??routing_set_routing_protocol_0: (+1)
   \   00000018   0xB920             CBNZ.N   R0,??routing_set_routing_protocol_1
     97          	{
     98          		AODV_control_bit = 0;
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
     99          		OEDSR_control_bit = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x7060             STRB     R0,[R4, #+1]
    100          		routing_init_OEDSR();
   \   00000020   0x.... 0x....      BL       routing_init_OEDSR
    101          	}
    102          #endif // _ENABLE_OEDSR_
    103          #ifdef FEAT_ENABLE_MMCR
    104          	if ( ROUTING_PROTOCOL_MMCR == my_protocol_ )
   \                     ??routing_set_routing_protocol_1: (+1)
   \   00000024   0x7828             LDRB     R0,[R5, #+0]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD108             BNE.N    ??routing_set_routing_protocol_2
    105          	{
    106          		AODV_control_bit = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7020             STRB     R0,[R4, #+0]
    107          		OEDSR_control_bit = 0;
   \   0000002E   0x7060             STRB     R0,[R4, #+1]
    108          		//MMCR_control_bit = 1;
    109          		routing_init_MPR_select();
                 		^
Warning[Pe223]: function "routing_init_MPR_select" declared implicitly
   \   00000030   0x.... 0x....      BL       routing_init_MPR_select
    110          		routing_init_MMCR();
   \   00000034   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000038   0x.... 0x....      B.W      routing_init_MMCR
    111          	}
    112          #endif // FEAT_ENABLE_MMCR
    113          }
   \                     ??routing_set_routing_protocol_2: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    114          
    115          //////////////////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    116          void routing_receive_packet ( sint8_t XDATA *p, sint8_t rssi )
    117          {
   \                     routing_receive_packet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    118          
    119          	pkt_t XDATA *pkt = ( pkt_t XDATA * ) p;
    120          
    121          	// ######################################################3
    122          	// ### Receive packet to myself or broadcast
    123          	// ######################################################3
    124          	if ((MY_ADDR == pkt->dst_id)||(0xFF == pkt->dst_id))
   \   00000004   0x....             LDR.N    R0,??DataTable11_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x79E1             LDRB     R1,[R4, #+7]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x29FF             CMPNE    R1,#+255
   \   00000012   0xD105             BNE.N    ??routing_receive_packet_0
    125          	{
    126          		if (TSP_HANDLED_PACKET == tsp_receive( (uint8_t*)p, rssi ))
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       tsp_receive
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD048             BEQ.N    ??routing_receive_packet_1
    127          		{
    128          			return;
    129          		}
    130          	}
    131          
    132          	// ######################################################3
    133          	// ### Start routing when received BEAM message
    134          	// ######################################################3
    135          	if ( FLAG_BEAM == pkt->flags )
   \                     ??routing_receive_packet_0: (+1)
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
   \   00000022   0x280A             CMP      R0,#+10
   \   00000024   0xBF04             ITT      EQ 
   \   00000026   0x4620             MOVEQ    R0,R4
   \   00000028   0x.... 0x....      BLEQ     app_recvBEAM
    136          	{
    137          		app_recvBEAM ( p );
    138          
    139          #ifdef CH_START_ROUTE
    140          
    141          	#ifdef _ENABLE_OEDSR_
    142          		/*
    143          		if (ROUTING_PROTOCOL_OEDSR == my_protocol_)
    144          		{
    145          			if (dist_approx_on_){ set_distance(rssi); }
    146          			else { set_distance(0); }
    147          		}*/
    148          	#endif // _ENABLE_OEDSR_
    149          #ifdef FEAT_ENABLE_AODV
    150          		// for AODV which has already the route -> skip
    151          		if (( ROUTING_PROTOCOL_AODV == my_protocol_)
    152          			&& ( -1 != AODV_find_direction ( BS_ADDR ) ) )
    153          		{ // DO NOTHING
    154          		}
    155          		else
    156          #endif // FEAT_ENABLE_AODV
    157          		{
    158          			//  FOR ANYTHING ELSE start route Discovery toward BS
    159          			if ( CLUSTERING_I_AM_CH == my_CH_ )
    160          				rtr_start_routing ( BS_ADDR );
    161          		}
    162          #endif // CH_START_ROUTE
    163          	} // if FLAG_BEAM
    164          
    165          	// ######################################################
    166          	// ### Receive packet if above minimal threshold
    167          	// ######################################################
    168          	// FILTERING of messages below certain RSSI threshold (!! values are absolute)
    169          	if ( rssi >= my_rssi_threshold_ )
   \   0000002C   0x....             LDR.N    R0,??DataTable11_3
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD23E             BCS.N    ??routing_receive_packet_1
    170          	{
    171          		return;
    172          	}
    173          	else
    174          	{
    175          		// ######################################################
    176          		// ### Handle routing packets and forwarding
    177          		// ######################################################
    178          		switch ( pkt->flags )
   \   00000034   0x....             LDR.N    R0,??DataTable11_1
   \   00000036   0x7862             LDRB     R2,[R4, #+1]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x....             LDR.N    R1,??DataTable11
   \   0000003C   0x3A0B             SUBS     R2,R2,#+11
   \   0000003E   0xD00C             BEQ.N    ??routing_receive_packet_2
   \   00000040   0x1E52             SUBS     R2,R2,#+1
   \   00000042   0xD010             BEQ.N    ??routing_receive_packet_3
   \   00000044   0x1E92             SUBS     R2,R2,#+2
   \   00000046   0xD017             BEQ.N    ??routing_receive_packet_4
   \   00000048   0x1E52             SUBS     R2,R2,#+1
   \   0000004A   0xD022             BEQ.N    ??routing_receive_packet_5
   \   0000004C   0x3A5B             SUBS     R2,R2,#+91
   \   0000004E   0x2A03             CMP      R2,#+3
   \   00000050   0xD918             BLS.N    ??routing_receive_packet_6
   \   00000052   0x3A08             SUBS     R2,R2,#+8
   \   00000054   0x2A03             CMP      R2,#+3
   \   00000056   0xD91C             BLS.N    ??routing_receive_packet_5
   \   00000058   0xE022             B.N      ??routing_receive_packet_7
    179          		{
    180          				///////////////////////////////////////////////
    181          #ifdef _ENABLE_OEDSR_
    182          			case FLAG_HELLO:
    183          				if ( ROUTING_PROTOCOL_OEDSR == my_protocol_ )
   \                     ??routing_receive_packet_2: (+1)
   \   0000005A   0xBB50             CBNZ.N   R0,??routing_receive_packet_1
    184          				{
    185          					recvHELLO ( ( hpkt_t XDATA * ) p );
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000062   0x.... 0x....      B.W      recvHELLO
    186          				}
    187          				break;
    188          #endif // _ENABLE_OEDSR_
    189          				///////////////////////////////////////////////
    190          #ifdef _ENABLE_OEDSR_
    191          			case FLAG_ACK:
    192          				if ( ROUTING_PROTOCOL_OEDSR == my_protocol_ )
   \                     ??routing_receive_packet_3: (+1)
   \   00000066   0xBB20             CBNZ.N   R0,??routing_receive_packet_1
    193          				{
    194          					// check if should accept ACK
    195          					if ( OEDSR_STATE_IDLE != oedsr_state_ )
   \   00000068   0x....             LDR.N    R0,??DataTable11_4
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0xB308             CBZ.N    R0,??routing_receive_packet_1
    196          					{
    197          						if ( 0xFF == recvACK ( p ) )
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000074   0x.... 0x....      B.W      recvACK
    198          						{	// if BS found as next hop
    199          //							RLED = 0;
    200          						}
    201          					}
    202          				}
    203          				break;
    204          #endif // _ENABLE_OEDSR_
    205          				///////////////////////////////////////////////
    206          //#ifdef _ENABLE_OEDSR_
    207          			case FLAG_SELECT:
    208          #ifdef _ENABLE_OEDSR_
    209          				if ( ROUTING_PROTOCOL_OEDSR == my_protocol_ )
   \                     ??routing_receive_packet_4: (+1)
   \   00000078   0xB9D8             CBNZ.N   R0,??routing_receive_packet_1
    210          				{
    211          					recvSelect ( p );
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000080   0x.... 0x....      B.W      recvSelect
    212          				}
    213          #endif // _ENABLE_OEDSR_
    214          #ifdef FEAT_ENABLE_MMCR
    215          				if ( ROUTING_PROTOCOL_MMCR == my_protocol_ )
    216          				{
    217          //					mmcr_recvSelect ( p );
    218          				}
    219          #endif // FEAT_ENABLE_MMCR
    220          				break;
    221          
    222          // THE BLOCK BELOW SHOULD NOT BE THERE!!!
    223          #ifdef FEAT_ENABLE_MMCR
    224          			case FLAG_HELLO_MMCR:
    225          			case FLAG_ACK_MMCR:
    226          			case FLAG_TC_MMCR:
    227          			case FLAG_CHSW_MMCR:
    228          				if ( ROUTING_PROTOCOL_MMCR == my_protocol_ )
   \                     ??routing_receive_packet_6: (+1)
   \   00000084   0x2802             CMP      R0,#+2
   \   00000086   0xD114             BNE.N    ??routing_receive_packet_1
    229          				{
    230          					mmcr_recv_routing_msg ( (pkt_t XDATA *)p );
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000008E   0x.... 0x....      B.W      mmcr_recv_routing_msg
    231          				}
    232          				break;
    233          #endif // FEAT_ENABLE_MMCR
    234          				///////////////////////////////////////////////
    235          				
    236          				///////////////////////////////////////////////
    237          				//Process Data Packet
    238          
    239          			case FLAG_DATA:
    240          			case FLAG_DATA_TEST:
    241          			case FLAG_DATA_ARB:
    242          			case FLAG_DATA_TEST_V2:
    243          			case FLAG_DATA_MODULAR:
    244          #ifdef FEAT_ENABLE_CC
    245          				cc_recv_pkts_ ++; // Count received packets
    246          #endif
    247          #ifdef _ENABLE_OEDSR_
    248          				if ( data_forward_control_ )
   \                     ??routing_receive_packet_5: (+1)
   \   00000092   0x78C8             LDRB     R0,[R1, #+3]
   \   00000094   0xB168             CBZ.N    R0,??routing_receive_packet_1
    249          				{
    250          //					YLED = ( ( ~YLED ) && recvDATA ( p, rssi ) );
    251          					recvDATA ( p, rssi ) ;
   \   00000096   0x4629             MOV      R1,R5
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000009E   0x....             B.N      recvDATA
    252          				}
    253          #endif // _ENABLE_OEDSR_
    254          				break;
    255          
    256          				///////////////////////////////////////////////
    257          #ifdef FEAT_ENABLE_AODV
    258          			default:
    259          				if ( 1 == AODV_control_bit )
   \                     ??routing_receive_packet_7: (+1)
   \   000000A0   0x7808             LDRB     R0,[R1, #+0]
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD105             BNE.N    ??routing_receive_packet_1
    260          				{
    261          					//if(AODV_route_control){
    262          					Routing_AODV ( p, rssi );
                 					               ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "int8_t *"
   \   000000A6   0x4629             MOV      R1,R5
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000AE   0x.... 0x....      B.W      Routing_AODV
    263          					//}
    264          				}
    265          				break;
    266          #endif
    267          
    268          		}
    269          	}
    270          }
   \                     ??routing_receive_packet_1: (+1)
   \   000000B2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    271          //////////////////////////////////////////////////////////////////////////////////////////////
    272          
    273          
    274          // ##############################################################

   \                                 In section .text, align 2, keep-with-next
    275          void routing_data_request ( sint8_t XDATA *p )
    276          {
    277          	data_forward_control_ = 1;
   \                     routing_data_request: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x70CA             STRB     R2,[R1, #+3]
    278          
    279          	switch ( my_protocol_ )
   \   00000006   0x....             LDR.N    R2,??DataTable11_1
   \   00000008   0x7812             LDRB     R2,[R2, #+0]
   \   0000000A   0xB11A             CBZ.N    R2,??routing_data_request_0
   \   0000000C   0x2A02             CMP      R2,#+2
   \   0000000E   0xD006             BEQ.N    ??routing_data_request_1
   \   00000010   0xD302             BCC.N    ??routing_data_request_2
   \   00000012   0x4770             BX       LR
    280          	{
    281          #ifdef _ENABLE_OEDSR_
    282          		case ROUTING_PROTOCOL_OEDSR:
    283          			// TODO: Handling of START DATA GENERATION and/or FORWARDING message:
    284          			//		  - start data generation
    285          			//		  - forward the message (multihop case)
    286          			recvAcceptData ( p );
                 			                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "int8_t *"
   \                     ??routing_data_request_0: (+1)
   \   00000014   0x.... 0x....      B.W      recvAcceptData
    287          			break;
    288          #endif // _ENABLE_OEDSR_
    289          #ifdef FEAT_ENABLE_AODV
    290          		case ROUTING_PROTOCOL_AODV:
    291          			AODV_route_control = 0;
   \                     ??routing_data_request_2: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x7088             STRB     R0,[R1, #+2]
    292          			break;
   \   0000001C   0x4770             BX       LR
    293          #endif
    294          
    295          #ifdef FEAT_ENABLE_MMCR
    296          		case ROUTING_PROTOCOL_MMCR:
    297          			// TODO: Handling of START DATA GENERATION and/or FORWARDING message:
    298          			//		  - start data generation
    299          			//		  - forward the message (multihop case)
    300          			mmcr_recvAcceptData ( p );
                 			^
Warning[Pe223]: function "mmcr_recvAcceptData" declared implicitly
   \                     ??routing_data_request_1: (+1)
   \   0000001E   0x.... 0x....      B.W      mmcr_recvAcceptData
    301          			break;
    302          #endif // FEAT_ENABLE_MMCR
    303          		default:
    304          			// ERROR
    305          			break;
    306          	}
    307          }
    308          
    309          // ##############################################################
    310          

   \                                 In section .text, align 2, keep-with-next
    311          int8_t  routing_send_DATA_base ( uint16_t base )
    312          {
   \                     routing_send_DATA_base: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    313          	int8_t temp = 0xEE;
    314          	if ( CLUSTERING_I_AM_CH != my_CH_ )
   \   00000004   0x....             LDR.N    R0,??DataTable11_5
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x28FD             CMP      R0,#+253
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xBF1C             ITT      NE 
    315          	{
    316          		return routing_to_CH_base ( base );
   \   0000000E   0xE8BD 0x4010      POPNE    {R4,LR}
   \   00000012   0x.... 0x....      BNE.W    routing_to_CH_base
    317          	}
    318          
    319          	update_pkt_send ( base );
   \   00000016   0x.... 0x....      BL       update_pkt_send
    320          
    321          	switch ( my_protocol_ )
   \   0000001A   0x....             LDR.N    R0,??DataTable11_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xB118             CBZ.N    R0,??routing_send_DATA_base_0
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD009             BEQ.N    ??routing_send_DATA_base_1
   \   00000024   0xD304             BCC.N    ??routing_send_DATA_base_2
   \   00000026   0xE00B             B.N      ??routing_send_DATA_base_3
    322          	{
    323          #ifdef _ENABLE_OEDSR_
    324          		case ROUTING_PROTOCOL_OEDSR:
    325          			temp = OEDSR_send_DATA_base ( base );
   \                     ??routing_send_DATA_base_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       OEDSR_send_DATA_base
    326          			break;
   \   0000002E   0xE008             B.N      ??routing_send_DATA_base_4
    327          #endif // _ENABLE_OEDSR_
    328          #ifdef FEAT_ENABLE_AODV
    329          		case ROUTING_PROTOCOL_AODV:
    330          			temp = AODV_send_DATA_base ( base );
   \                     ??routing_send_DATA_base_2: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       AODV_send_DATA_base
    331          			break;
   \   00000036   0xE004             B.N      ??routing_send_DATA_base_4
    332          #endif // FEAT_ENABLE_AODV
    333          #ifdef FEAT_ENABLE_MMCR
    334          		case ROUTING_PROTOCOL_MMCR:
    335          			temp = MMCR_send_DATA_base ( base );
   \                     ??routing_send_DATA_base_1: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       MMCR_send_DATA_base
    336          			break;
   \   0000003E   0xE000             B.N      ??routing_send_DATA_base_4
    337          #endif // FEAT_ENABLE_MMCR
    338          		default:
    339          			// ERROR
    340          		  	temp = 0;
   \                     ??routing_send_DATA_base_3: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
    341          			break;
    342          	}
    343          	return temp;
   \                     ??routing_send_DATA_base_4: (+1)
   \   00000042   0xB240             SXTB     R0,R0
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    344          	//return 0;
    345          }
    346          //////////////////////////////////////////////////////////////////////////////////////////////
    347          ///////////////////////////////////////////////
    348          /**
    349            * recvDATA - handles a received DATA packet
    350            * 1) check if final destination
    351            * 2) passes pakcet to sendDATA
    352            */

   \                                 In section .text, align 2, keep-with-next
    353          uint8_t recvDATA ( sint8_t XDATA *pkt, sint8_t rssi )
    354          {
   \                     recvDATA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    355          //	return sendDATA(pkt,rssi);
    356          //	return 1;
    357          
    358          	uint8_t packet_id;
    359          	uint8_t packet_len;
    360          
    361          	packet_id = que_get_empty_buffer_location();
   \   00000006   0x.... 0x....      BL       que_get_empty_buffer_location
   \   0000000A   0x4605             MOV      R5,R0
    362          	if ( 0xFF == packet_id )
   \   0000000C   0x2DFF             CMP      R5,#+255
   \   0000000E   0xD107             BNE.N    ??recvDATA_0
    363          	{
    364          		// Error with packet buffer allocation!!
    365          		// TODO: Handle the lack of space for new packet
    366          		app_drop_pkt ( 0xFFFF, MODULE_RTR, REASON_MEMORY_FULL, EVENT_DRECV );
   \   00000010   0x2303             MOVS     R3,#+3
   \   00000012   0x2205             MOVS     R2,#+5
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000001A   0x.... 0x....      BL       app_drop_pkt
    367          		return 0;
   \   0000001E   0xE03E             B.N      ??recvDATA_1
    368          	}
    369          	else
    370          	{
    371          		uint8_t i;
    372          		pkt_t *pkt_temp = ( pkt_t* ) pkt;
    373          		// Fill the TEST PACKET with hop information
    374          		if ( FLAG_DATA_TEST == pkt_temp->flags )
   \                     ??recvDATA_0: (+1)
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
   \   00000022   0x2872             CMP      R0,#+114
   \   00000024   0xD115             BNE.N    ??recvDATA_2
    375          		{
    376          			uint8_t XDATA *hop_list;
    377          
    378          #ifdef CH_START_ROUTE
    379          #ifndef SOURCE
    380          			pkt_temp->numhops = 0;
    381          #endif
    382          			//unsigned char sequ_num;
    383          			//unsigned char numhops;
    384          			//unsigned char hop_list;
    385          #endif
    386          			hop_list = (uint8_t XDATA *)& ( pkt_temp->hop_list );
    387          			if ( MAX_HOPLIST_INDEX > pkt_temp->numhops + 3 )
   \   00000026   0x7AA1             LDRB     R1,[R4, #+10]
   \   00000028   0x460A             MOV      R2,R1
   \   0000002A   0x1CD3             ADDS     R3,R2,#+3
   \   0000002C   0x2B50             CMP      R3,#+80
   \   0000002E   0xF104 0x000B      ADD      R0,R4,#+11
   \   00000032   0xDA19             BGE.N    ??recvDATA_3
    388          			{
    389          				hop_list[ ( pkt_temp->numhops ) ++] = MY_ADDR;
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0x72A1             STRB     R1,[R4, #+10]
   \   00000038   0x....             LDR.N    R1,??DataTable11_2
   \   0000003A   0x7809             LDRB     R1,[R1, #+0]
   \   0000003C   0x5411             STRB     R1,[R2, R0]
    390          				hop_list[ ( pkt_temp->numhops ) ++] = rssi;
   \   0000003E   0x7AA1             LDRB     R1,[R4, #+10]
   \   00000040   0x540E             STRB     R6,[R1, R0]
    391          				hop_list[ ( pkt_temp->numhops ) ++] = my_tx_power_;
   \   00000042   0x1C49             ADDS     R1,R1,#+1
   \   00000044   0x1C4A             ADDS     R2,R1,#+1
   \   00000046   0x72A2             STRB     R2,[R4, #+10]
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x....             LDR.N    R2,??DataTable11_6
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x540A             STRB     R2,[R1, R0]
   \   00000050   0xE00A             B.N      ??recvDATA_3
    392          			}
    393          		}
    394          
    395          		else if ( FLAG_DATA_TEST_V2 == pkt_temp->flags )
   \                     ??recvDATA_2: (+1)
   \   00000052   0x2875             CMP      R0,#+117
   \   00000054   0xD108             BNE.N    ??recvDATA_3
    396          		{
    397          			pkt_v2_t XDATA *pkt_v2 = ( pkt_v2_t XDATA * ) pkt;
    398          			pkt_mod_header_t XDATA *ph = ( pkt_mod_header_t XDATA * ) ( & ( pkt_v2->data_modules ) );
   \   00000056   0xF104 0x0009      ADD      R0,R4,#+9
   \   0000005A   0xE002             B.N      ??recvDATA_4
    399          			//ph->module_type = PKT_MODULE_TYPE_HOPLIST;
    400          			uint8_t mod_len;
    401          			while ( PKT_MODULE_TYPE_END != ph->module_type )
    402          			{
    403          				mod_len = ph->module_length;
    404          				switch ( ph->module_type )
    405          				{
    406          					case PKT_MODULE_TYPE_ADFS:
    407          #ifdef FEAT_ENABLE_SFQ
    408          						{
    409          							/*							pkt_mod_header_t *ph = (pkt_mod_header_t *)(&(msg[msg_i]));
    410          														pkt_mod_adfs_t *p_adfs = (pkt_mod_adfs_t*)(&msg[msg_i + PKT_MODULE_LEN_HEADER]);
    411          
    412          														ph->module_type = PKT_MODULE_TYPE_ADFS;
    413          														ph->module_length = PKT_MODULE_LEN_ADFS;
    414          
    415          														p_adfs->weight = my_source_weight_;
    416          														p_adfs ->ticker = rtc_get_rticks();
    417          
    418          														len = len + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_ADFS;
    419          														msg_i = msg_i + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_ADFS;
    420          							*/
    421          						}
    422          #endif // FEAT_ENABLE_SFQ
    423          						break;
    424          					case PKT_MODULE_TYPE_HOPLIST:
    425          						update_hoplist_module_recv ( & ( ph->content ), rssi );
    426          						break;
    427          					case PKT_MODULE_TYPE_DUMMY:
    428          						break;
    429          				}
    430          				ph = ( ( pkt_mod_header_t XDATA * ) ( ( ( char XDATA * ) ( ph ) ) + mod_len + PKT_MODULE_LEN_HEADER ) );
   \                     ??recvDATA_5: (+1)
   \   0000005C   0x7841             LDRB     R1,[R0, #+1]
   \   0000005E   0x1808             ADDS     R0,R1,R0
   \   00000060   0x1C80             ADDS     R0,R0,#+2
    431          			} //while
   \                     ??recvDATA_4: (+1)
   \   00000062   0x7801             LDRB     R1,[R0, #+0]
   \   00000064   0x2941             CMP      R1,#+65
   \   00000066   0xD1F9             BNE.N    ??recvDATA_5
    432          		}
    433          
    434          
    435          
    436          		// copy packet ...
    437          		packet_len = GET_PKT_LEN ( pkt );
   \                     ??recvDATA_3: (+1)
   \   00000068   0x79A0             LDRB     R0,[R4, #+6]
    438          //		strncpy(&(buffer0[QBUFF_BASE(packet_id)]), pkt, packet_len);
    439          		for ( i = 0 ; i < packet_len; i++ )
   \   0000006A   0x....             LDR.N    R2,??DataTable11_7
   \   0000006C   0x1DC0             ADDS     R0,R0,#+7
   \   0000006E   0xB2C0             UXTB     R0,R0
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0xE005             B.N      ??recvDATA_6
    440          			buffer0[ ( packet_id * SIZE_Q_BUFF ) +i] = pkt[i];
   \                     ??recvDATA_7: (+1)
   \   00000074   0x2664             MOVS     R6,#+100
   \   00000076   0x570B             LDRSB    R3,[R1, R4]
   \   00000078   0xFB06 0x1605      MLA      R6,R6,R5,R1
   \   0000007C   0x1C49             ADDS     R1,R1,#+1
   \   0000007E   0x54B3             STRB     R3,[R6, R2]
   \                     ??recvDATA_6: (+1)
   \   00000080   0x4281             CMP      R1,R0
   \   00000082   0xDBF7             BLT.N    ??recvDATA_7
    441          
    442          		// Enqueue packet
    443          		if ( 0 == que_enQpacket ( packet_id ) )
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0x.... 0x....      BL       que_enQpacket
   \   0000008A   0xB950             CBNZ.N   R0,??recvDATA_8
    444          		{
    445          			// Failed -> free the packet
    446          			app_drop_pkt ( packet_id, MODULE_RTR, REASON_QUEUE_FULL, EVENT_DRECV );
   \   0000008C   0x2303             MOVS     R3,#+3
   \   0000008E   0x2204             MOVS     R2,#+4
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x4628             MOV      R0,R5
   \   00000094   0x.... 0x....      BL       app_drop_pkt
    447          			que_make_empty_buffer ( packet_id );
   \   00000098   0x4628             MOV      R0,R5
   \   0000009A   0x.... 0x....      BL       que_make_empty_buffer
    448          			// Handle the lack of space in queue
    449          			return 0;
   \                     ??recvDATA_1: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBD70             POP      {R4-R6,PC}
    450          		}
    451          	}
    452          	return 1;
   \                     ??recvDATA_8: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xBD70             POP      {R4-R6,PC}       ;; return
    453          }
    454          ///////////////////////////////////////////////
    455          
    456          // ##############################################################
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void routing_send_counters()
    459          {
    460          	switch ( my_protocol_ )
   \                     routing_send_counters: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xBF08             IT       EQ 
    461          	{
    462          #ifdef _ENABLE_OEDSR_
    463          		case ROUTING_PROTOCOL_OEDSR:
    464          			//send_OEDSR_counters();
    465          			break;
    466          #endif // _ENABLE_OEDSR_
    467          #ifdef FEAT_ENABLE_AODV
    468          		case ROUTING_PROTOCOL_AODV:
    469          			send_aodv_counters();
   \   00000008   0x.... 0x....      BEQ.W    send_aodv_counters
    470          			break;
    471          #endif
    472          
    473          #ifdef FEAT_ENABLE_MMCR
    474          		case ROUTING_PROTOCOL_MMCR:
    475          //			send_MMCR_counters();
    476          			break;
    477          #endif // FEAT_ENABLE_MMCR
    478          
    479          
    480          		default:
    481          			// ERROR
    482          			break;
    483          	}
    484          }
   \   0000000C   0x4770             BX       LR               ;; return
    485          
    486          // ##############################################################
    487          
    488          
    489          ///////////////////////////////////////////////
    490          /**
    491            * sendDATA - handles a sending of DATA packet
    492            * 1) check if buffer ready then passes packet
    493            * 2) else temporarly stores
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          int8_t routing_to_CH_base ( uint16_t base )
    496          {
    497          	// SDCC:
    498          	pkt_t * XDATA pkt = ( pkt_t XDATA * ) ( & ( buffer0[ base] ) ); //&(QBUFF_ACCESS(base,0));
    499          
    500          //	if (enableDataTx_)
    501          	if ( 1 )
    502          	{
    503          		// find destination -- only when taken out of the main loop
    504          		pkt->mac_dst = SWAP16((uint16_t)my_CH_);
   \                     routing_to_CH_base: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11_7
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0x....             LDR.N    R1,??DataTable11_5
   \   00000006   0x8809             LDRH     R1,[R1, #+0]
   \   00000008   0x020A             LSLS     R2,R1,#+8
   \   0000000A   0xEA42 0x2111      ORR      R1,R2,R1, LSR #+8
   \   0000000E   0x8041             STRH     R1,[R0, #+2]
    505          		pkt->mac_src = SWAP16((uint16_t)MY_ADDR);
   \   00000010   0x....             LDR.N    R1,??DataTable11_2
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x0209             LSLS     R1,R1,#+8
   \   00000016   0x8081             STRH     R1,[R0, #+4]
    506          
    507          		// send the packet
    508          		if ( AODVcounter_update )
   \   00000018   0x....             LDR.N    R1,??DataTable11_8
   \   0000001A   0x780A             LDRB     R2,[R1, #+0]
   \   0000001C   0xB132             CBZ.N    R2,??routing_to_CH_base_0
    509          		{
    510          			DATA_AODV_counter++;
   \   0000001E   0x784A             LDRB     R2,[R1, #+1]
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \   00000022   0x704A             STRB     R2,[R1, #+1]
    511          #ifdef _ENABLE_OEDSR_
    512          			DAT_OEDSR_counter++;
   \   00000024   0x....             LDR.N    R1,??DataTable11_9
   \   00000026   0x780A             LDRB     R2,[R1, #+0]
   \   00000028   0x1C52             ADDS     R2,R2,#+1
   \   0000002A   0x700A             STRB     R2,[R1, #+0]
    513          #endif // _ENABLE_OEDSR_
    514          #ifdef FEAT_ENABLE_MMCR
    515          			///mmcr_DAT_MMCR_counter++;
    516          #endif // FEAT_ENABLE_MMCR
    517          		}
    518          		// ENERGY USAGE
    519          		{
    520          			uint32_t energy_delta = ( ( ( pkt_t* ) pkt )->length + 7 );
    521          			my_energy_ = my_energy_ - energy_delta ;
   \                     ??routing_to_CH_base_0: (+1)
   \   0000002C   0x....             LDR.N    R1,??DataTable11_10
   \   0000002E   0x7980             LDRB     R0,[R0, #+6]
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0x1DC0             ADDS     R0,R0,#+7
   \   00000034   0x1A10             SUBS     R0,R2,R0
   \   00000036   0x6008             STR      R0,[R1, #+0]
    522          		}
    523          	}
    524          	else
    525          	{
    526          		APPEND_LOG ( NODE_ID_STR, NODE_ID_STR_LEN );
    527          		APPEND_LOG ( "DROP DATA\r", 10 );
    528          		// drop the packet
    529          		return 0;
    530          	}
    531          	return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x4770             BX       LR               ;; return
    532          }
    533          ///////////////////////////////////////////////
    534          
    535          /**
    536            * update_hoplist_module_recv(hoplist, rssi) - updates hoplist
    537            *  when receiving a packet (node + rssi)
    538            */

   \                                 In section .text, align 2, keep-with-next
    539          void update_hoplist_module_recv ( uint8_t XDATA *hoplist, uint8_t rssi )
    540          {
    541          	pkt_mod_hoplist_t XDATA *p_hop = ( pkt_mod_hoplist_t XDATA * ) ( hoplist );
    542          
    543          	switch ( p_hop->hoplist_type )
    544          	{
    545          		case HOPLIST_TYPE_V1:
    546          #ifdef GENERATE_HOPLIST_VER_1
    547          			if ( HOPLIST_TYPE_V1 == )
    548          			{
    549          				unsigned char *hop_list;
    550          				unsigned char &seq = msg[msg_i+PKT_MODULE_LEN_HEADER];
    551          				unsigned char &type = msg[msg_i+PKT_MODULE_LEN_HEADER+1];
    552          				unsigned char &numhops = msg[msg_i+PKT_MODULE_LEN_HEADER+2];
    553          				hop_list = msg[msg_i+PKT_MODULE_LEN_HEADER+3];
    554          				seq = sequence_no_;
    555          				type =
    556          					if ( MAX_HOPLIST_INDEX > numhops + 3 )
    557          					{
    558          						hop_list[ numhops ++] = MY_ADDR;
    559          						hop_list[ numhops ++] = 20;
    560          						hop_list[ numhops ++] = my_tx_power_;
    561          					}
    562          					len = len + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_HOPLIST;
    563          				msg_i = msg_i + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_HOPLIST;
    564          			}
    565          			else // == HOPLIST_TYPE_CC
    566          #endif
    567          				break;
    568          		case HOPLIST_TYPE_CC:
    569          #ifdef FEAT_ENABLE_CC
    570          			{
    571          				unsigned char *hop_list;
    572          				hop_list = & ( p_hop->hop_list );
    573          				if ( MAX_HOPLIST_COUNT >= p_hop->numhops + HOPLIST_TYPE_CC_NODE_STRUCTURE_SIZE )
    574          				{
    575          					hop_list[ ( p_hop->numhops ) ] = MY_ADDR;
    576          					hop_list[ ( p_hop->numhops ) +1] = rssi;
    577          //					hop_list[ (p_hop->numhops) +2] = my_tx_power_;
    578          //					hop_list[ (p_hop->numhops) +3] = cc_throughput_;
    579          //					hop_list[ (p_hop->numhops) +4] = cc_throughput_;
    580          //					hop_list[ (p_hop->numhops) +5] = cc_inflow_limit_;
    581          //					hop_list[ (p_hop->numhops) +6] = cc_droprate_;
    582          //					hop_list[ (p_hop->numhops) +7] = que_buffer_empty_slots_end_;
    583          					p_hop->numhops += HOPLIST_TYPE_CC_NODE_STRUCTURE_SIZE;
    584          				}
    585          			}
    586          #endif
    587          			break;
    588          		default:
    589          			break;
    590          	}
    591          }
   \                     update_hoplist_module_recv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    592          
    593          
    594          
    595          /**
    596            * update_hoplist_module_send(hoplist) - updates hoplist
    597            *  when sending a packet (tx power + statistics)
    598            */

   \                                 In section .text, align 2, keep-with-next
    599          void update_hoplist_module_send ( uint8_t XDATA *hoplist )
    600          {
    601          	pkt_mod_hoplist_t XDATA *p_hop = ( pkt_mod_hoplist_t XDATA * ) ( hoplist );
    602          	switch ( p_hop->hoplist_type )
    603          	{
    604          		case HOPLIST_TYPE_V1:
    605          #ifdef GENERATE_HOPLIST_VER_1
    606          			if ( HOPLIST_TYPE_V1 == )
    607          			{
    608          				unsigned char XDATA *hop_list;
    609          				unsigned char &seq = msg[msg_i+PKT_MODULE_LEN_HEADER];
    610          				unsigned char &type = msg[msg_i+PKT_MODULE_LEN_HEADER+1];
    611          				unsigned char &numhops = msg[msg_i+PKT_MODULE_LEN_HEADER+2];
    612          				hop_list = msg[msg_i+PKT_MODULE_LEN_HEADER+3];
    613          				seq = sequence_no_;
    614          				type =
    615          					if ( MAX_HOPLIST_INDEX > numhops + 3 )
    616          					{
    617          						hop_list[ numhops ++] = MY_ADDR;
    618          						hop_list[ numhops ++] = 20;
    619          						hop_list[ numhops ++] = my_tx_power_;
    620          					}
    621          					len = len + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_HOPLIST;
    622          				msg_i = msg_i + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_HOPLIST;
    623          			}
    624          			else // == HOPLIST_TYPE_CC
    625          #endif
    626          				break;
    627          		case HOPLIST_TYPE_CC:
    628          #ifdef FEAT_ENABLE_CC
    629          			{
    630          				uint8_t XDATA *hop_list;
    631          				hop_list = & ( p_hop->hop_list );
    632          //				hop_list[ (p_hop->numhops) -8] = MY_ADDR;
    633          //				hop_list[ (p_hop->numhops) -7] = 20;
    634          				hop_list[ ( p_hop->numhops ) -6] = my_tx_power_;
    635          				hop_list[ ( p_hop->numhops ) -5] = cc_throughput_;
    636          				hop_list[ ( p_hop->numhops ) -4] = cc_predicted_throughput_;
    637          
    638          //				hop_list[ (p_hop->numhops) -3] = (int8_t)(10*cc_flow_alpha_);
    639          				hop_list[ ( p_hop->numhops ) -3] = cc_calculated_inflow_limit_;
    640          
    641          				hop_list[ ( p_hop->numhops ) -2] = cc_droprate_;
    642          
    643          				hop_list[ ( p_hop->numhops ) -1] = NUMQBUFFS - que_buffer_empty_slots_end_;
    644          //				hop_list[ (p_hop->numhops) -1] = que_buffer_empty_slots_end_;
    645          //				hop_list[ (p_hop->numhops) -1] = (uint8_t)(0x30+cc_flow_error_);
    646          
    647          				hop_list[ ( p_hop->numhops ) +1] = cc_upstream_nodes_status_[0];
    648          				hop_list[ ( p_hop->numhops ) +2] = cc_upstream_nodes_status_[1];
    649          			}
    650          #endif
    651          			break;
    652          		default:
    653          			break;
    654          	}
    655          }
   \                     update_hoplist_module_send: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    656          
    657          
    658          
    659          
    660          
    661          
    662          /**
    663            * update_pkt_send(base) - updates packet content when sending a packet
    664            *  (hoplist and othe modules)
    665            */

   \                                 In section .text, align 2, keep-with-next
    666          void update_pkt_send ( uint16_t base )
    667          {
    668          	pkt_v2_t XDATA *pkt = ( pkt_v2_t XDATA * ) ( & ( buffer0[base] ) ); //&(QBUFF_ACCESS(base,0));
    669          
    670          	if ( FLAG_DATA_TEST_V2 == pkt->flag )
   \                     update_pkt_send: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11_7
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0x7841             LDRB     R1,[R0, #+1]
   \   00000006   0x2975             CMP      R1,#+117
   \   00000008   0xD107             BNE.N    ??update_pkt_send_0
    671          	{
    672          		pkt_mod_header_t XDATA *ph = ( pkt_mod_header_t XDATA * ) ( & ( pkt->data_modules ) );
   \   0000000A   0x3009             ADDS     R0,R0,#+9
    673          		//ph->module_type = PKT_MODULE_TYPE_HOPLIST;
    674          		uint8_t mod_len = ph->module_length ;
   \   0000000C   0x7841             LDRB     R1,[R0, #+1]
   \   0000000E   0xE001             B.N      ??update_pkt_send_1
    675          		while ( PKT_MODULE_TYPE_END != ph->module_type )
    676          		{
    677          			switch ( ph->module_type )
    678          			{
    679          				case PKT_MODULE_TYPE_ADFS:
    680          #ifdef FEAT_ENABLE_SFQ
    681          					{
    682          						/*							pkt_mod_header_t *ph = (pkt_mod_header_t *)(&(msg[msg_i]));
    683          												pkt_mod_adfs_t *p_adfs = (pkt_mod_adfs_t*)(&msg[msg_i + PKT_MODULE_LEN_HEADER]);
    684          
    685          												ph->module_type = PKT_MODULE_TYPE_ADFS;
    686          												ph->module_length = PKT_MODULE_LEN_ADFS;
    687          
    688          												p_adfs->weight = my_source_weight_;
    689          												p_adfs ->ticker = rtc_get_rticks();
    690          
    691          												len = len + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_ADFS;
    692          												msg_i = msg_i + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_ADFS;
    693          						*/
    694          					}
    695          #endif // FEAT_ENABLE_SFQ
    696          					break;
    697          				case PKT_MODULE_TYPE_HOPLIST:
    698          					update_hoplist_module_send ( & ( ph->content ) );
    699          					break;
    700          				case PKT_MODULE_TYPE_DUMMY:
    701          					break;
    702          			}
    703          			ph = ( ( pkt_mod_header_t XDATA * ) ( ( ( char XDATA * ) ( ph ) ) + mod_len + PKT_MODULE_LEN_HEADER ) );
   \                     ??update_pkt_send_2: (+1)
   \   00000010   0x1808             ADDS     R0,R1,R0
   \   00000012   0x1C80             ADDS     R0,R0,#+2
    704          		} //while
   \                     ??update_pkt_send_1: (+1)
   \   00000014   0x7802             LDRB     R2,[R0, #+0]
   \   00000016   0x2A41             CMP      R2,#+65
   \   00000018   0xD1FA             BNE.N    ??update_pkt_send_2
    705          	}
    706          }
   \                     ??update_pkt_send_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    707          
    708          
    709          /**
    710            * rtr_dropped_link(??) - the link failed (after few retransmissions??) - update routing
    711            *    and optionally restart route discovery
    712            */

   \                                 In section .text, align 2, keep-with-next
    713          void rtr_dropped_link(uint16_t hop_id)
    714          {
    715          	switch ( my_protocol_ )
   \                     rtr_dropped_link: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11_1
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0xB119             CBZ.N    R1,??rtr_dropped_link_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD005             BEQ.N    ??rtr_dropped_link_1
   \   0000000A   0xD302             BCC.N    ??rtr_dropped_link_2
   \   0000000C   0x4770             BX       LR
    716          	{
    717          #ifdef _ENABLE_OEDSR_
    718          		case ROUTING_PROTOCOL_OEDSR:
    719          			oedsr_dropped_link();
   \                     ??rtr_dropped_link_0: (+1)
   \   0000000E   0x.... 0x....      B.W      oedsr_dropped_link
    720          			break;
    721          #endif // _ENABLE_OEDSR_
    722          #ifdef FEAT_ENABLE_AODV
    723          		case ROUTING_PROTOCOL_AODV:
    724          			aodv_dropped_link(hop_id);
   \                     ??rtr_dropped_link_2: (+1)
   \   00000012   0x.... 0x....      B.W      aodv_dropped_link
    725          			break;
    726          #endif
    727          #ifdef FEAT_ENABLE_MMCR
    728          		case ROUTING_PROTOCOL_MMCR:
    729          			mmcr_dropped_link(hop_id);
   \                     ??rtr_dropped_link_1: (+1)
   \   00000016   0x.... 0x....      B.W      mmcr_dropped_link
    730          			break;
    731          #endif
    732          		default:
    733          			// ERROR
    734          			break;
    735          	}
    736          }
    737          
    738          
    739          /**
    740            * rtr_add_neighbor(DST, NEXT_HOP, METRIC) - update routing for one-hop neighbor
    741            */

   \                                 In section .text, align 2, keep-with-next
    742          void rtr_add_neighbor(uint16_t dst_id, uint16_t next_hop, uint8_t metric)
    743          {
    744          #ifndef BS_NEIGHBOR
    745          	if (BS_ADDR == next_hop)
    746          	{
    747          		return; // skip if not a neigbor of BS
    748          	}
    749          #endif //
    750          	switch ( my_protocol_ )
   \                     rtr_add_neighbor: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0x781B             LDRB     R3,[R3, #+0]
   \   00000004   0xB11B             CBZ.N    R3,??rtr_add_neighbor_0
   \   00000006   0x2B02             CMP      R3,#+2
   \   00000008   0xD009             BEQ.N    ??rtr_add_neighbor_1
   \   0000000A   0xD302             BCC.N    ??rtr_add_neighbor_2
   \   0000000C   0x4770             BX       LR
    751          	{
    752          #ifdef _ENABLE_OEDSR_
    753          		case ROUTING_PROTOCOL_OEDSR:
    754          			oedsr_set_route(dst_id, next_hop, metric);
   \                     ??rtr_add_neighbor_0: (+1)
   \   0000000E   0x.... 0x....      B.W      oedsr_set_route
    755          			break;
    756          #endif // _ENABLE_OEDSR_
    757          #ifdef FEAT_ENABLE_AODV
    758          		case ROUTING_PROTOCOL_AODV:
    759          #warning AODV - Route update has incorrect index (age of the routing info)
                  ^
Warning[Pe1105]: #warning directive: AODV - Route update has incorrect index
          (age of the routing info)
    760          			route_table_update_AODV(dst_id, 0, next_hop, metric);
   \                     ??rtr_add_neighbor_2: (+1)
   \   00000012   0x4613             MOV      R3,R2
   \   00000014   0x460A             MOV      R2,R1
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x.... 0x....      B.W      route_table_update_AODV
    761          			break;
    762          #endif
    763          #ifdef FEAT_ENABLE_MMCR
    764          		case ROUTING_PROTOCOL_MMCR:
    765          			mmcr_set_route(dst_id, next_hop, metric);
   \                     ??rtr_add_neighbor_1: (+1)
   \   0000001E   0x.... 0x....      B.W      mmcr_set_route
    766          			break;
    767          #endif
    768          		default:
    769          			// ERROR
    770          			break;
    771          	}
    772          }
    773          
    774          /**
    775            * rtr_start_routing(DST_ID) - start a route discovery for "DST_ID"
    776            */

   \                                 In section .text, align 2, keep-with-next
    777          void rtr_start_routing(uint16_t dst_id)
    778          {
    779          	switch ( my_protocol_ )
   \                     rtr_start_routing: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11_1
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xBF08             IT       EQ 
    780          	{
    781          #ifdef _ENABLE_OEDSR_
    782          		case ROUTING_PROTOCOL_OEDSR:
    783          			oedsr_start_routing(dst_id);
   \   00000008   0x.... 0x....      BEQ.W    oedsr_start_routing
    784          			break;
    785          #endif // _ENABLE_OEDSR_
    786          #ifdef FEAT_ENABLE_AODV
    787          		case ROUTING_PROTOCOL_AODV:
    788          //			aodv_start_routing(dst_id);
    789          			break;
    790          #endif
    791          #ifdef FEAT_ENABLE_MMCR
    792          		case ROUTING_PROTOCOL_MMCR:
    793          //			mmcr_start_routing(dst_id);
    794          			break;
    795          #endif
    796          		default:
    797          			// ERROR
    798          			break;
    799          	}
    800          }
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     AODV_control_bit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     my_protocol_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     my_addr8_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     my_rssi_threshold_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     oedsr_state_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     my_CH_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     my_tx_power_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     buffer0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     AODVcounter_update

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     DAT_OEDSR_counter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     my_energy_
    801          
    802          #endif // _ENABLE_ROUTING_
    803          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   recvDATA
        16   -> app_drop_pkt
        16   -> que_enQpacket
        16   -> que_get_empty_buffer_location
        16   -> que_make_empty_buffer
       0   recvStopData
       0   routing_data_request
         0   -> mmcr_recvAcceptData
         0   -> recvAcceptData
       0   routing_init
         0   -> routing_set_routing_protocol
      16   routing_receive_packet
         0   -> Routing_AODV
         0   -> mmcr_recv_routing_msg
         0   -> recvACK
         0   -> recvDATA
         0   -> recvHELLO
         0   -> recvSelect
        16   -> tsp_receive
       8   routing_send_DATA_base
         8   -> AODV_send_DATA_base
         8   -> MMCR_send_DATA_base
         8   -> OEDSR_send_DATA_base
         8   -> routing_to_CH_base
         8   -> update_pkt_send
       0   routing_send_counters
         0   -> send_aodv_counters
      16   routing_set_routing_protocol
        16   -> routing_init_AODV
         0   -> routing_init_MMCR
        16   -> routing_init_MPR_select
        16   -> routing_init_OEDSR
       0   routing_to_CH_base
       0   rtr_add_neighbor
         0   -> mmcr_set_route
         0   -> oedsr_set_route
         0   -> route_table_update_AODV
       0   rtr_dropped_link
         0   -> aodv_dropped_link
         0   -> mmcr_dropped_link
         0   -> oedsr_dropped_link
       0   rtr_start_routing
         0   -> oedsr_start_routing
       0   update_hoplist_module_recv
       0   update_hoplist_module_send
       0   update_pkt_send


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       1  ACK_AODV_counter
       4  AODV_control_bit
          OEDSR_control_bit
          AODV_route_control
          data_forward_control_
       2  AODVcounter_update
          DATA_AODV_counter
       1  RREP_counter
       1  RREQ_counter
       1  can_start_on_beam
     166  recvDATA
       8  recvStopData
      34  routing_data_request
      12  routing_init
     180  routing_receive_packet
      70  routing_send_DATA_base
      14  routing_send_counters
      62  routing_set_routing_protocol
      60  routing_to_CH_base
      34  rtr_add_neighbor
      26  rtr_dropped_link
      14  rtr_start_routing
       2  update_hoplist_module_recv
       2  update_hoplist_module_send
      28  update_pkt_send

 
   9 bytes in section .bss
   1 byte  in section .data
 756 bytes in section .text
 
 756 bytes of CODE memory
  10 bytes of DATA memory

Errors: none
Warnings: 5
