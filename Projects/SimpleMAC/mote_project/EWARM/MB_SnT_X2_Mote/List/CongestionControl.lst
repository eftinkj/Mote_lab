###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:26:29
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\CongestionControl.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\CongestionControl.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"CongestionControl.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\CongestionControl.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\CongestionControl.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\CongestionControl.c
      1          /****************************************************************************
      2          **
      3          ** Copyright (C) 2006-2005 Maciej Zawodniok, James W. Fonda. All rights reserved.
      4          **
      5          ** This file is part of the documentation of the UMR Mote Toolkit.
      6          **
      7          ** This file may be used under the terms of the GNU General Public
      8          ** License version 2.0 as published by the Free Software Foundation
      9          ** and appearing in the file LICENSE.GPL included in the packaging of
     10          ** this file.
     11          **
     12          ** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
     13          ** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
     14          **
     15          ****************************************************************************/
     16          
     17          //Queuing Code for ADFS
     18          
     19          //#include "esnl_pub.h"
     20          #include "CongestionControl.h"
     21          #include "HW_LIB/RTC.h"
     22          #include "FEAT_Queuing/Queuing.h"
     23          #include "packet.h"
     24          #include "FEAT_Scheduler/sch_basic_pub.h"
     25          
     26          #ifdef FEAT_ENABLE_CC
     27          
     28          //**********************
     29          //Define Variables
     30          
     31          uint32_t xdata cc_processing_timeout_;
     32          uint32_t xdata cc_timeout_length_ = DEFAULT_CC_TIMEOUT;
     33          uint32_t xdata cc_period_length_ ;
     34          uint32_t xdata cc_last_period_tick_ ;
     35          
     36          uint16_t xdata cc_generated_pkts_;
     37          uint16_t xdata cc_sent_pkts_;
     38          uint16_t xdata cc_recv_pkts_;
     39          uint16_t xdata cc_drop_pkts_;
     40          
     41          uint16_t xdata cc_timeout_divider_;
     42          
     43          uint16_t xdata cc_throughput_;
     44          uint16_t xdata cc_predicted_throughput_;
     45          uint16_t xdata cc_previous_throughput_;
     46          uint16_t xdata cc_droprate_;
     47          
     48          float xdata cc_flow_alpha_;
     49          float xdata cc_flow_gamma_;
     50          float xdata cc_flow_error_;
     51          float xdata cc_kv_queue_gain_;
     52          
     53          uint8_t xdata cc_ideal_queue_;
     54          int16_t xdata cc_queue_error_;
     55          
     56          uint16_t xdata cc_recv_outflow_limit_;
     57          uint16_t xdata cc_calculated_inflow_limit_;
     58          uint16_t xdata cc_ownflow_limit_;
     59          uint16_t xdata cc_target_outflow_;
     60          uint16_t xdata cc_previous_target_outflow_ ;
     61          
     62          
     63          float xdata cc_bo_alpha_;
     64          float xdata cc_bo_sigma_;
     65          float xdata cc_bo_outflow_error_;
     66          float xdata cc_bo_kv_;
     67          
     68          uint16_t xdata cc_bo_value_;
     69          
     70          uint8_t xdata	cc_need_to_send_upstream_;
     71          
     72          uint8_t xdata	cc_upstream_nodes_count_; // number of nodes in the below tables
     73          uint16_t xdata	cc_upstream_nodes_[MAX_UPSTREAM_NODES]; // MAC address of upstraem nodes
     74          uint8_t xdata	cc_upstream_nodes_status_[MAX_UPSTREAM_NODES]; // status (need to send limit, sending limit, done sending)
     75          uint8_t xdata	cc_upstream_nodes_frame_id_[MAX_UPSTREAM_NODES];
     76          
     77          
     78          // ##############################################################################
     79          // ## Misc counters
     80          // ##############################################################################
     81          #ifdef ENABLE_CC_DEBUG_COUNTERS
     82          uint16_t xdata cc_count_data_lost_;
     83          uint16_t xdata cc_count_upstream_lost_=0;
     84          uint16_t xdata cc_count_scan_lost_;
     85          #endif
     86          
     87          
     88          /// == sizeof(pkt_v2_PCCup_t)
     89          #ifdef FEAT_ENABLE_CC
     90          	char XDATA temp_p[20];
     91          #endif
     92          //**********************
     93          /**
     94            *
     95            */
     96          void cc_init ( bit full_reset )
     97          {
     98          	if ( full_reset )
     99          	{
    100          		cc_timeout_length_ = DEFAULT_CC_TIMEOUT;
    101          	}
    102          	cc_processing_timeout_ = rtc_get_ticks() + cc_timeout_length_;
    103          	cc_generated_pkts_ = 0;
    104          	cc_period_length_ = 1;
    105          	cc_last_period_tick_ = rtc_get_ticks();
    106          
    107          	cc_sent_pkts_ = 0;
    108          	cc_recv_pkts_ = 0;
    109          	cc_drop_pkts_ = 0;
    110          
    111          	cc_timeout_divider_ = cc_timeout_length_ / DEFAULT_ONE_SECOND;
    112          	cc_throughput_ = 0;
    113          	cc_predicted_throughput_ = 0;
    114          	cc_previous_throughput_ = 0;
    115          	cc_droprate_ = 0;
    116          
    117          	cc_flow_alpha_ = 1.0;
    118          	cc_flow_gamma_ = 0.001;
    119          
    120          	cc_kv_queue_gain_ = 0.9;
    121          	cc_ideal_queue_ = CC_TARGET_QUEUE;
    122          
    123          	cc_recv_outflow_limit_ = CC_MAX_OUT_FLOW;
    124          	cc_calculated_inflow_limit_ = cc_ideal_queue_; // initially count in only the ideal queue level
    125          	cc_ownflow_limit_ = CC_MAX_OUT_FLOW;
    126          
    127          	cc_target_outflow_ = cc_calculated_inflow_limit_;
    128          	cc_previous_target_outflow_ = cc_calculated_inflow_limit_;
    129          
    130          	cc_bo_alpha_ = 1.0;
    131          	cc_bo_sigma_ = 0.01;
    132          	cc_bo_outflow_error_ = 0;
    133          	cc_bo_kv_ = 0.1;
    134          
    135          	cc_bo_value_ = PCC_DEFAULT_BO_VALUE;
    136          
    137          	cc_need_to_send_upstream_ = PCC_JNL_NUMBER_OF_UPSTREAM;
    138          	cc_upstream_nodes_count_ = PCC_JNL_NUMBER_OF_UPSTREAM; // number of nodes in the below tables
    139          #ifdef SOURCE
    140          	cc_upstream_nodes_count_--;
    141          #endif
    142          
    143          	{
    144          		uint8_t i;
    145          		for ( i = 0; i < MAX_UPSTREAM_NODES; i++ )
    146          		{
    147          			cc_upstream_nodes_[MAX_UPSTREAM_NODES] = 0x0F; // MAC address of upstraem nodes
    148          			cc_upstream_nodes_status_[MAX_UPSTREAM_NODES] = 0x0F; // status (need to send limit, sending limit, done sending)
    149          			cc_upstream_nodes_frame_id_[MAX_UPSTREAM_NODES] = 0x0F;
    150          		}
    151          	}
    152          
    153          #ifdef NODE_5_PCC_RELAY
    154          	cc_upstream_nodes_[0] = 0x01;
    155          	cc_upstream_nodes_[1] = 0x02;
    156          #endif
    157          #ifdef NODE_7_PCC_SOURCE
    158          	cc_upstream_nodes_[0] = 0x02;
    159          #endif
    160          
    161          	sch_add_loop((sch_loop_func_t)cc_loop);
    162          }
    163          
    164          
    165          /**
    166           *  cc_loop() - executes main loop block (BUT DOES NOT LOOP ITSELF!!!)
    167           */
    168          void cc_loop( void )
    169          {
    170          #ifdef FEAT_ENABLE_CC
    171          		// Check if need to do the periodic update of Congestion Control
    172          		if ( ( cc_processing_timeout_ < rtc_get_ticks() ) )
    173          		{
    174          			cc_end_of_period ();
    175          		}
    176          #endif
    177          #ifdef INCLUDE_PCC
    178          		if ( ( 1 == DATA_waiting_4_BO_ ) && ( phy_backoff_timeout_ < rtc_get_ticks() ) )
    179          		{
    180          			DATA_waiting_4_BO_ = 0;
    181          #ifdef _ENABLE_NETWORK_STACK_
    182          			phy_transmit_packet();
    183          #endif // _ENABLE_NETWORK_STACK_
    184          		}
    185          #endif
    186          
    187          #if (0)
    188          		//FEAT_ENABLE_CH_SWITCHING
    189          		if ( (CS_ENABLED == cs_enabled_) && (cs_switching_timeout_ < rtc_get_ticks() ) )
    190          		{
    191          			cs_switching_timeout();
    192          			cs_send_join ( 0xFE, 0x11 );
    193          
    194          		}
    195          #endif
    196          }
    197          
    198          
    199          /**
    200            *
    201            */
    202          void cc_change_protocol()
    203          {
    204          	if (PHY_BACKOFF_NO_PCC != my_backoff_)
    205          	{
    206          		cc_need_to_send_upstream_ = PCC_JNL_NUMBER_OF_UPSTREAM;
    207          		cc_upstream_nodes_count_ = PCC_JNL_NUMBER_OF_UPSTREAM; // number of nodes in the below tables
    208          #ifdef SOURCE
    209          		cc_upstream_nodes_count_--;
    210          #endif
    211          		cc_change_timeout ( DEFAULT_CC_TIMEOUT );
    212          		cc_bo_value_ = PCC_DEFAULT_BO_VALUE-1;
    213          	}
    214          	else
    215          	{
    216          		cc_need_to_send_upstream_ = 0;
    217          		cc_change_timeout ( DEFAULT_ONE_SECOND );
    218          		cc_bo_value_ = PCC_DEFAULT_BO_VALUE;
    219          	}
    220          }
    221          
    222          
    223          /**
    224            *
    225            */
    226          void cc_change_timeout ( uint32_t timeout )
    227          {
    228          	if ( CC_TIMEOUT_MIN > timeout )
    229          	{
    230          		cc_timeout_length_ = CC_TIMEOUT_MIN;
    231          	}
    232          	else if ( CC_TIMEOUT_MAX < timeout )
    233          	{
    234          		cc_timeout_length_ = CC_TIMEOUT_MAX;
    235          	}
    236          	else
    237          	{
    238          		cc_timeout_length_ = timeout;
    239          	}
    240          }
    241          
    242          
    243          /**
    244            *
    245            */
    246          void cc_end_of_period ()
    247          {
    248          	float throughput;
    249          	float alpha_delta ;
    250          	// Check if received duplicates of the period request
    251          	if ( rtc_get_ticks() - cc_last_period_tick_ < CC_MIN_PERIOD )
    252          	{
    253          		return;
    254          	}
    255          	cc_period_length_ = rtc_get_ticks() - cc_last_period_tick_;
    256          	cc_last_period_tick_ = rtc_get_ticks();
    257          //	throughput = cc_sent_pkts_ / cc_timeout_divider_;
    258          	throughput = (float)(cc_sent_pkts_ * DEFAULT_ONE_SECOND) / (float)cc_period_length_;
    259          
    260          	cc_flow_error_ = throughput - ( float ) cc_predicted_throughput_;
    261          	alpha_delta = cc_flow_gamma_ * throughput * cc_flow_error_;
    262          //	alpha_delta = cc_flow_gamma_ * cc_throughput_ * cc_flow_error_;
    263          
    264          	cc_flow_alpha_ += alpha_delta;
    265          	cc_flow_alpha_ = MAX ( cc_flow_alpha_, MIN_FLOW_ALPHA );
    266          	cc_flow_alpha_ = MIN ( cc_flow_alpha_, MAX_FLOW_ALPHA );
    267          
    268          	cc_predicted_throughput_ = ( uint16_t ) ( throughput * cc_flow_alpha_ );
    269          
    270          
    271          	cc_previous_throughput_ = cc_throughput_;
    272          	cc_throughput_ = ( uint16_t ) throughput;
    273          	cc_droprate_ = cc_drop_pkts_ * DEFAULT_ONE_SECOND / cc_period_length_;
    274          	cc_processing_timeout_ = rtc_get_ticks() + cc_timeout_length_;
    275          	cc_generated_pkts_ = 0;
    276          	cc_sent_pkts_ = 0;
    277          	cc_recv_pkts_ = 0;
    278          	cc_drop_pkts_ = 0;
    279          	// Delayed setting of the timeoutr divider to accomodate for
    280          	// change of timeout in the middle of timeout period
    281          	cc_timeout_divider_ = cc_timeout_length_ / DEFAULT_ONE_SECOND;
    282          
    283          /////// !!!!!! how to enable case when the PCC upstrema is comming a bit earlier then own PERIOD end
    284          //	cc_recv_outflow_limit_ = CC_MAX_OUT_FLOW; // reset limit -> if will receive the update then keep it
    285          
    286          	// Calculate and send the info only when the PCC backoff is used
    287          	if (PHY_BACKOFF_PCC == my_backoff_)
    288          	{
    289          		// Calculate the allowed incomming traffic
    290          		cc_calculate_allowed_inflow();
    291          
    292          		// Prepare the ConCon updates for all incomming/own flows
    293          		cc_apply_cc_to_own_flows();
    294          		cc_prepare_cc_messages_for_inflows();
    295          
    296          		cc_recalculate_BO_params();
    297          	}
    298          }
    299          
    300          
    301          // ##############################################################################
    302          // ##
    303          // ##############################################################################
    304          
    305          
    306          // ##############################################################################
    307          // ## Function Section
    308          // ##############################################################################
    309          
    310          //**********************
    311          
    312          /**
    313            * cc_calculate_allowed_inflow() - Calculate the allowed incomming traffic
    314            */
    315          void cc_calculate_allowed_inflow()
    316          {
    317          	int16_t temp_i;
    318          	// Implement buffer management from the paper
    319          	// queue utilization error = difference between actual and ideal queue level
    320          	cc_queue_error_ = ( int16_t ) ( NUMQBUFFS - que_buffer_empty_slots_end_ ) - ( int16_t ) cc_ideal_queue_;
    321          	temp_i = ( int16_t ) ( cc_kv_queue_gain_ * cc_queue_error_ );
    322          
    323          //	cc_target_outflow_ = MIN(cc_calculated_inflow_limit_, cc_recv_outflow_limit_);
    324          
    325          	cc_previous_target_outflow_ = cc_target_outflow_;
    326          #ifdef SOURCE
    327          	cc_target_outflow_ = cc_recv_outflow_limit_;
    328          #else
    329          	cc_target_outflow_ = cc_predicted_throughput_;
    330          #endif
    331          
    332          //	cc_target_outflow_ = MIN(cc_predicted_throughput_, cc_recv_outflow_limit_);
    333          	cc_target_outflow_ = MAX ( cc_target_outflow_ , 1 );
    334          
    335          	if ( 0 > temp_i )
    336          	{
    337          		cc_calculated_inflow_limit_ = cc_target_outflow_ - temp_i;
    338          	}
    339          	else if ( ( uint16_t ) temp_i > cc_target_outflow_ )
    340          	{
    341          		cc_calculated_inflow_limit_ = 0;
    342          	}
    343          	else
    344          	{
    345          		cc_calculated_inflow_limit_ = cc_target_outflow_ - ( uint16_t ) temp_i;
    346          	}
    347          }
    348          
    349          
    350          /**
    351            * cc_apply_cc_to_own_flows() - Restric own flows
    352            */
    353          void cc_apply_cc_to_own_flows()
    354          {
    355          #ifdef SOURCE
    356          	// Set limits on own flows
    357          	//  - either simply restric packet creation rate
    358          	//  - or modify datacollection method
    359          	// Use OWN SOURCE WEIGTH to calculate number of allowed packets
    360          	if (PHY_BACKOFF_NO_PCC != my_backoff_)
    361          	{
    362          		cc_ownflow_limit_ = cc_calculated_inflow_limit_ / PCC_JNL_NUMBER_OF_UPSTREAM;
    363          		// cc_ownflow_limit_ = cc_target_outflow_ / PCC_JNL_NUMBER_OF_UPSTREAM;
    364          	}
    365          #endif
    366          }
    367          
    368          
    369          /**
    370            * cc_prepare_cc_messages_for_inflows() - Prepare the ConCon updates for all incomming/own flows
    371            */
    372          void cc_prepare_cc_messages_for_inflows()
    373          {
    374          	// Check if there are upstream nodes (be aware of own source)
    375          #ifdef SOURCE
    376          	if ( 2 > cc_upstream_nodes_count_ )
    377          		return;
    378          #else
    379          	if ( 1 > cc_upstream_nodes_count_ )
    380          		return;
    381          #endif
    382          	{
    383          		pkt_v2_PCCup_t *pcc_pkt = ( pkt_v2_PCCup_t * ) temp_p;
    384          		uint8_t i;
    385          		// Fill the packet in
    386          		uint8_t len = sendPCCupstream ( temp_p );
    387          
    388          		// for each upastream node update DST fields
    389          //		for ( i = 0; i < cc_upstream_nodes_count_; i++ )
    390          		for ( i = 0; i < 1; i++ )
    391          		{
    392          			pcc_pkt->mac_dst = cc_upstream_nodes_[i]; // iterate through list to set correct value
    393          			pcc_pkt->dst_id = cc_upstream_nodes_[i]; //
    394          
    395          #ifdef PCC_DEBUG_UPSTREAM_MSG
    396          			cc_upstream_nodes_frame_id_[i] = api_send_packet16 ( temp_p, len, 0xffff );
    397          #else
    398          			cc_upstream_nodes_frame_id_[i] = api_send_packet16 ( temp_p, len, cc_upstream_nodes_[i] );
    399          #endif
    400          			cc_upstream_nodes_status_[i] = PCC_UPSTREAM_NODE_STATUS_SENDING;
    401          		}
    402          		cc_need_to_send_upstream_ = cc_upstream_nodes_count_; // Need to send messages -> check if received OK
    403          	}
    404          }
    405          
    406          
    407          
    408          /**
    409            * cc_recv_API_ack(frame_id, status) - handle reception of ACK when sending
    410            *		PCC upstream commands,
    411            *		returns 1 if found PCC message, or 0 if this belongs to another packet
    412            */
    413          uint8_t cc_recv_API_ack ( uint8_t frame_id, uint8_t status )
    414          {
    415          	uint8_t i;
    416          	// for each upastream node update DST fields
    417          	for ( i = 0; i < cc_upstream_nodes_count_; i++ )
    418          	{
    419          		if ( frame_id == cc_upstream_nodes_frame_id_[i] )
    420          		{
    421          			if ( TX_STATUS_OK == status )
    422          			{
    423          				// cc_upstream_nodes_frame_id_[i];
    424          				cc_upstream_nodes_status_[i] = PCC_UPSTREAM_NODE_STATUS_IDLE;
    425          				cc_need_to_send_upstream_--;
    426          			}
    427          			else
    428          			{
    429          				pkt_v2_PCCup_t *pcc_pkt = ( pkt_v2_PCCup_t * ) temp_p;
    430          				uint8_t len;
    431          #ifdef ENABLE_CC_DEBUG_COUNTERS
    432          				cc_count_upstream_lost_++;
    433          #endif
    434          				// If exceeded retransmission limit, then stop
    435          				if ( CC_MAX_UPSTREAM_RETRIES < cc_upstream_nodes_status_[i] )
    436          				{
    437          					cc_upstream_nodes_status_[i] = PCC_UPSTREAM_NODE_STATUS_IDLE;
    438          					cc_need_to_send_upstream_--;
    439          					return 1;
    440          				}
    441          				// Fill the packet in
    442          				len = sendPCCupstream ( temp_p );
    443          				pcc_pkt->mac_dst = cc_upstream_nodes_[i]; // iterate through list to set correct value
    444          				pcc_pkt->dst_id = cc_upstream_nodes_[i]; //
    445          #ifdef PCC_DEBUG_UPSTREAM_MSG
    446          				cc_upstream_nodes_frame_id_[i] = api_send_packet16 ( temp_p, len, 0xffff );
    447          #else
    448          				cc_upstream_nodes_frame_id_[i] = api_send_packet16 ( temp_p, len, cc_upstream_nodes_[i] );
    449          #endif
    450          				cc_upstream_nodes_status_[i] ++; // count retransmissions
    451          			}
    452          			return 1; // since found it is done
    453          		}
    454          	}
    455          	return 0; // not found frame_id -> maybe the ACK is for another messages
    456          }
    457          
    458          
    459          /**
    460            * sendPCCupstream - prepare PCC upstream message
    461            */
    462          unsigned int sendPCCupstream ( char*p )
    463          {
    464          	pkt_v2_PCCup_t *pcc_pkt = ( pkt_v2_PCCup_t * ) p;
    465          
    466          	pcc_pkt->start = START_BYTE;
    467          	pcc_pkt->flag = FLAG_PCC_V2;
    468          	pcc_pkt->mac_dst = 0xFFFF; // iterate through list to set correct value
    469          	pcc_pkt->mac_src = MY_ADDR;
    470          	pcc_pkt->length = SIZE_OF_PCC_UPSTREAM_PKT; // of the packet'd data
    471          	pcc_pkt->dst_id = 0xFF; //
    472          	pcc_pkt->src_id = MY_ADDR; // part of DATA field
    473          
    474          	pcc_pkt->module_type = PKT_MODULE_TYPE_PCC_UPSTREAM;
    475          	pcc_pkt->module_len = PKT_MODULE_LEN_PCC_UPSTREAM;
    476          	pcc_pkt->flow_limit = cc_calculated_inflow_limit_ / cc_upstream_nodes_count_;
    477          	pcc_pkt->misc = 0xAA;
    478          	pcc_pkt->next_module_type = PKT_MODULE_TYPE_END;
    479          
    480          	return SIZE_OF_PCC_UPSTREAM_PKT;
    481          }
    482          
    483          
    484          
    485          
    486          
    487          /**
    488            * cc_recv_PCC_upstream(pkt) - handle reception of PCC upstream message
    489            *		apply to the BO and
    490            */
    491          void cc_recv_PCC_upstream ( char *p )
    492          {
    493          	pkt_v2_PCCup_t *pcc_pkt = ( pkt_v2_PCCup_t * ) p;
    494          	cc_recv_outflow_limit_ = pcc_pkt->flow_limit;
    495          
    496          	cc_end_of_period();
    497          }
    498          
    499          
    500          
    501          
    502          int8_t cc_checkAllowedSourceFlow()
    503          {
    504          	if (PHY_BACKOFF_NO_PCC != my_backoff_)
    505          	{
    506          		// add one always to allow at least one packet ??? DO WE NEED THIS? ???
    507          		uint16_t allowed = 0;
    508          		if ( ( 0 == cc_ownflow_limit_ ) && ( 0 == cc_generated_pkts_ ) )
    509          			allowed = 1; // case when there is no flow allowed
    510          		else if ( cc_ownflow_limit_ > cc_generated_pkts_ )
    511          			allowed = cc_ownflow_limit_ - cc_generated_pkts_;
    512          		if ( allowed > 0xFE )
    513          			allowed = 0xFE;
    514          		return 	allowed;
    515          	}
    516          	return 1; // always allow for NO PCC case
    517          }
    518          
    519          // ##############################################################################
    520          // ##
    521          // ##############################################################################
    522          
    523          
    524          
    525          /**
    526            * cc_recalculate_BO_params() - recalculates backoff params (e.g. backoff window)
    527            */
    528          void cc_recalculate_BO_params()
    529          {
    530          // Update only when this is a source node - for relay do not change (fixed BO)
    531          #ifdef SOURCE
    532          	float alpha_delta;
    533          	float b, v;
    534          	cc_bo_outflow_error_ = cc_throughput_ - cc_previous_target_outflow_;
    535          	alpha_delta = cc_bo_sigma_ * cc_previous_throughput_ * cc_bo_outflow_error_;
    536          	cc_bo_alpha_ += alpha_delta;
    537          
    538          	cc_bo_alpha_ = MAX ( cc_bo_alpha_, PCC_MIN_BO_ALPHA );
    539          	cc_bo_alpha_ = MIN ( cc_bo_alpha_, PCC_MAX_BO_ALPHA );
    540          
    541          	b = cc_bo_value_ * cc_throughput_;
    542          	v = cc_target_outflow_ - cc_bo_alpha_ * cc_throughput_ + cc_bo_kv_ * cc_bo_outflow_error_;
    543          	cc_bo_value_ = b / v;
    544          
    545          	cc_bo_value_  = MAX ( cc_bo_value_ , PCC_MIN_BO_VALUE );
    546          	cc_bo_value_  = MIN ( cc_bo_value_ , PCC_MAX_BO_VALUE );
    547          #endif
    548          
    549          // cc_previous_throughput_
    550          // cc_bo_alpha_;
    551          // cc_bo_sigma_;
    552          // cc_bo_outflow_error_;
    553          // cc_bo_kv_;
    554          
    555          
    556          //	cc_bo_alpha_
    557          //	cc_flow_error_
    558          //	cc_target_outflow_
    559          }
    560          
    561          #endif
    562          
    563          
    564          


 

 


Errors: none
Warnings: none
