###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:29:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\src_8bit_adc.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\src_8bit_adc.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"src_8bit_adc.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\src_8bit_adc.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\src_8bit_adc.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\src_8bit_adc.c
      1          #include "defs/esnl_pub.h"
      2          
      3          #ifdef _ENABLE_SRC_8BIT_ADC_
      4          
      5          #include "src_8bit_adc_prv.h"
      6          #include "src_8bit_adc_pub.h"
      7          
      8          
      9          #include "FEAT_Scheduler/sch_basic_pub.h"
     10          #include "sys_func.h"
     11          //#include "common.h"
     12          
     13          
     14          /****************************************************************************
     15          **	Constants, definies and typedefs  (PUBLIC)
     16          ****************************************************************************/
     17          
     18          /****************************************************************************
     19          **	Variables definition (PRIVATE)
     20          ****************************************************************************/
     21          
     22          
     23          /****************************************************************************
     24          **	Variables definition (PUBLIC)
     25          ****************************************************************************/
     26          
     27          
     28          /****************************************************************************
     29          **	Functions implementation (PUBLIC)
     30          ****************************************************************************/
     31          
     32          
     33          

   \                                 In section .bss, align 4
     34          src_d_mem_t XDATA* src_d_mem_p;
     35          
     36          uint8_t	XDATA src_d_mem_raw[SRC_D_MEM_STRUCT_SIZE];
   \                     src_d_mem_raw:
   \   00000000                      DS8 16
     37          
     38          uint16_t adc_value;
   \                     adc_value:
   \   00000010                      DS8 2
   \   00000012                      DS8 2
   \                     src_d_mem_p:
   \   00000014                      DS8 4
     39          
     40          #define SRC_8BIT_ADC_DEBUG
     41          

   \                                 In section .text, align 2, keep-with-next
     42          void src_8bit_powerup ()
     43          {
     44          	//int i;
     45          	//init variables
     46          	// init hardware config (e.g. GPIOs? ADCs?)
     47          	//ADC0 input PB5
     48          //	GPIO_PBCFGH[7:4] = 0;
     49          //	GPIO_PBCFGH = GPIO_PBCFGH & 0x11111101;
     50          	//ADC1 input PB6
     51          //	GPIO_PBCFGH[11:8] = 00;
     52          //	GPIO_PBCFGH = GPIO_PBCFGH & 0xFFFFF0FF;
     53          	//ADC2 input PB7
     54          //	GPIO_PBCFGH[15:12] = 0;
     55          //	GPIO_PBCFGH = GPIO_PBCFGH & 0xFFFF0FFF;
     56          	//ADC3 input PC1
     57          //	GPIO_PCCFGH[7:4] = 0;
     58          	//ADC4 input PA4
     59          //	GPIO_PACFGH[3:0] = 0;
     60          	//ADC5 input PA5 -  PACFGH [7:4]
     61          //	((gpia_pacfgh_t)GPIO_PACFGH).PA5 = 0;
     62          	//GPIO_PACFGH = GPIO_PACFGH & 0xFFFFFF0F;	// PA5/ADC5
     63          	//GPIO_PACFGH = GPIO_PACFGH & 0xFFFFFFF0; // PA4/ADC4
     64          	
     65          }
   \                     src_8bit_powerup: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     66          
     67          /**
     68           * ssn_init () - sets up Signal Processing Module
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          void src_8bit_adc_init ( void )
     71          {
   \                     src_8bit_adc_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     72          	src_d_mem_p = (src_d_mem_t XDATA*)src_d_mem_raw;
   \   00000002   0x....             LDR.N    R0,??DataTable5
   \   00000004   0x6140             STR      R0,[R0, #+20]
     73          	src_d_mem_p -> enabled_ = 0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     74          	src_d_mem_p -> timeout_ = 0;
   \   0000000A   0x6041             STR      R1,[R0, #+4]
     75          	src_d_mem_p -> rate_ = SRC_8BIT_DEFAULT_RATE;
   \   0000000C   0x2114             MOVS     R1,#+20
   \   0000000E   0x8101             STRH     R1,[R0, #+8]
     76          	src_d_mem_p -> seq_ = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8141             STRH     R1,[R0, #+10]
     77          	src_d_mem_p -> context_ = 0xFF;
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x7301             STRB     R1,[R0, #+12]
     78          //	src_d_mem_p -> receiver = (recv_func_t *)NULL;
     79          
     80          	sch_add_loop( (sch_loop_func_t) src_8bit_adc_loop);
   \   00000018   0x.... 0x....      ADR.W    R0,src_8bit_adc_loop
   \   0000001C   0x.... 0x....      BL       sch_add_loop
     81          
     82          #ifdef SRC_8BIT_ADC_DEBUG
     83          	src_8bit_adc_enable();
   \   00000020   0x.... 0x....      BL       src_8bit_adc_enable
     84          #endif // SRC_8BIT_ADC_DEBUG
     85          	halAdcCalibrate(ADC_USER_APP);
   \   00000024   0xE8BD 0x4002      POP      {R1,LR}
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      B.W      halAdcCalibrate
     86          }
     87          
     88          
     89          
     90          
     91          /**
     92           * src_enable() - enable the dummy source
     93           */

   \                                 In section .text, align 2, keep-with-next
     94          void src_8bit_adc_enable()
     95          {
   \                     src_8bit_adc_enable: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     96          	src_d_mem_p -> timeout_ = rtc_get_ticks() + 1000 / src_d_mem_p -> rate_;
   \   00000002   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000006   0x....             LDR.N    R1,??DataTable5
   \   00000008   0x6949             LDR      R1,[R1, #+20]
   \   0000000A   0x.... 0x....      BL       ?Subroutine0
     97          	src_d_mem_p -> enabled_ = SRC_D_ENABLED;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7008             STRB     R0,[R1, #+0]
     98          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x890B             LDRH     R3,[R1, #+8]
   \   00000002   0xF44F 0x727A      MOV      R2,#+1000
   \   00000006   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   0000000A   0x1810             ADDS     R0,R2,R0
   \   0000000C   0x6048             STR      R0,[R1, #+4]
   \   0000000E   0x4770             BX       LR
     99          
    100          
    101          
    102          /**
    103           * src_disable() - disable the dummy source
    104           */

   \                                 In section .text, align 2, keep-with-next
    105          void src_8bit_adc_disable()
    106          {
    107          //	src_d_mem_p -> timeout_ = rtc_get_ticks() + 1000 / src_d_mem_p -> rate_;
    108          	src_d_mem_p -> enabled_ = SRC_D_DISABLED;
   \                     src_8bit_adc_disable: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5
   \   00000002   0x6949             LDR      R1,[R1, #+20]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    109          }
   \   00000008   0x4770             BX       LR               ;; return
    110          
    111          
    112          	
    113          	
    114          #include "ssn_basic_pub.h"
    115          
    116          
    117          /**
    118           * ssn_loop() - executes main loop block (BUT DOES NOT LOOP ITSELF!!!)
    119           */

   \                                 In section .text, align 4, keep-with-next
    120          void src_8bit_adc_loop( void )
    121          {
   \                     src_8bit_adc_loop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    122          	uint16_t temp = 0;
    123          	volatile StStatus result = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    124          	if ( SRC_D_ENABLED == src_d_mem_p -> enabled_)
   \   0000000A   0x....             LDR.N    R4,??DataTable5
   \   0000000C   0x6960             LDR      R0,[R4, #+20]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD12E             BNE.N    ??src_8bit_adc_loop_0
    125          	{
    126          		if (rtc_get_ticks() > src_d_mem_p -> timeout_)
   \   00000014   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000018   0x6961             LDR      R1,[R4, #+20]
   \   0000001A   0x6849             LDR      R1,[R1, #+4]
   \   0000001C   0x4281             CMP      R1,R0
   \   0000001E   0xD228             BCS.N    ??src_8bit_adc_loop_0
    127          		{
    128          			//(src_d_mem_p -> receiver)(src_d_mem_p->context_, src_d_mem_p->seq_++);
    129          			result = 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF88D 0x0000      STRB     R0,[SP, #+0]
    130          			if ( ST_ADC_CONVERSION_DONE == halRequestAdcData(ADC_USER_APP, &adc_value))
   \   00000026   0xF104 0x0110      ADD      R1,R4,#+16
   \   0000002A   0x.... 0x....      BL       halRequestAdcData
   \   0000002E   0x2880             CMP      R0,#+128
   \   00000030   0xBF08             IT       EQ 
   \   00000032   0x8A21             LDRHEQ   R1,[R4, #+16]
    131          			{
    132          				//stat != ST_ADC_CONVERSION_DONE
    133          				temp = (adc_value<0)?0:adc_value;
                 				                 ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
   \   00000034   0xD003             BEQ.N    ??src_8bit_adc_loop_1
    134          			}
    135          			else
    136          			{
    137          				temp = src_d_mem_p->seq_++;
   \   00000036   0x6960             LDR      R0,[R4, #+20]
   \   00000038   0x8941             LDRH     R1,[R0, #+10]
   \   0000003A   0x1C4A             ADDS     R2,R1,#+1
   \   0000003C   0x8142             STRH     R2,[R0, #+10]
    138          			}
    139          			ssn_recv_sample(src_d_mem_p->context_, temp);
   \                     ??src_8bit_adc_loop_1: (+1)
   \   0000003E   0x6960             LDR      R0,[R4, #+20]
   \   00000040   0x7B00             LDRB     R0,[R0, #+12]
   \   00000042   0x.... 0x....      BL       ssn_recv_sample
    140          			src_d_mem_p -> timeout_ = rtc_get_ticks() + 1000 / src_d_mem_p -> rate_;
   \   00000046   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000004A   0x6961             LDR      R1,[R4, #+20]
   \   0000004C   0x.... 0x....      BL       ?Subroutine0
    141          
    142          			result = halStartAdcConversion(ADC_USER_APP, ADC_REF_INT,
    143          										   ADC_SOURCE_ADC4_VREF2, ADC_CONVERSION_TIME_US_1024);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000050   0x2305             MOVS     R3,#+5
   \   00000052   0x2249             MOVS     R2,#+73
   \   00000054   0x212A             MOVS     R1,#+42
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x.... 0x....      BL       halStartAdcConversion
   \   0000005C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    144          			if (ST_ERR_FATAL != result)
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD004             BEQ.N    ??src_8bit_adc_loop_0
    145          			{
    146          				sys_error(3);
   \   00000068   0xE8BD 0x4016      POP      {R1,R2,R4,LR}
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0x.... 0x....      B.W      sys_error
    147          			}
    148          		}
    149          	}
    150          }
   \                     ??src_8bit_adc_loop_0: (+1)
   \   00000072   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    151          	
    152          
    153          /**
    154           * src_set_rate(uint16_t rate) - set a sample rate in Hz (up to 1kHz)
    155           */

   \                                 In section .text, align 2, keep-with-next
    156          void src_8bit_adc_set_rate(uint16_t rate)
    157          {
    158          	src_d_mem_p->rate_ = rate;
   \                     src_8bit_adc_set_rate: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5
   \   00000002   0x6949             LDR      R1,[R1, #+20]
   \   00000004   0x8108             STRH     R0,[R1, #+8]
    159          }
   \   00000006   0x4770             BX       LR               ;; return
    160          
    161          
    162          /**
    163           * src_attach ( uint8_t context, void code* receiver) - connects to a receiver module
    164           */

   \                                 In section .text, align 2, keep-with-next
    165          void src_8bit_adc_attach ( uint8_t context)// void code* receiver)
    166          {
    167          	src_d_mem_p->context_ = context;
   \                     src_8bit_adc_attach: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5
   \   00000002   0x6949             LDR      R1,[R1, #+20]
   \   00000004   0x7308             STRB     R0,[R1, #+12]
    168          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     src_d_mem_raw
    169          
    170          
    171          /****************************************************************************
    172          **	Functions implementation (PRIVATE)
    173          ****************************************************************************/
    174          
    175          
    176          
    177          // ############################################################################
    178          // ############################################################################
    179          // Spacers
    180          // ############################################################################
    181          // ############################################################################
    182          
    183          
    184          
    185          #endif // _ENABLE_SIG_BASIC_
    186          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   src_8bit_adc_attach
       0   src_8bit_adc_disable
       8   src_8bit_adc_enable
         8   -> halCommonGetInt32uMillisecondTick
       8   src_8bit_adc_init
         0   -> halAdcCalibrate
         8   -> sch_add_loop
         8   -> src_8bit_adc_enable
      16   src_8bit_adc_loop
        16   -> halCommonGetInt32uMillisecondTick
        16   -> halRequestAdcData
        16   -> halStartAdcConversion
        16   -> ssn_recv_sample
         0   -> sys_error
       0   src_8bit_adc_set_rate
       0   src_8bit_powerup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
      16  ?Subroutine0
       8  src_8bit_adc_attach
      10  src_8bit_adc_disable
      20  src_8bit_adc_enable
      46  src_8bit_adc_init
     116  src_8bit_adc_loop
       8  src_8bit_adc_set_rate
       2  src_8bit_powerup
      24  src_d_mem_raw
          adc_value
          src_d_mem_p

 
  24 bytes in section .bss
 230 bytes in section .text
 
 230 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: 1
