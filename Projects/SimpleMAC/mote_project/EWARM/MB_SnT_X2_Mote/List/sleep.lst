###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:29:14
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\sleep.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\sleep.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"sleep.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\sleep.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\sleep.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\sleep.c
      1          /**
      2            ******************************************************************************
      3            * @file    sleep.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012
      7            * @brief   Main program body
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include PLATFORM_HEADER
     30          #include "micro-common.h"
     31          
     32          /** @addtogroup HAL
     33            * @{
     34            */
     35          
     36          /** @defgroup SLEEP
     37            * @brief sleep modules
     38            * @{
     39            */
     40          
     41          /* Private define ------------------------------------------------------------*/
     42          /* We don't have a real register to hold this composite information.
     43            Pretend we do so halGetWakeInfo can operate like halGetResetInfo.
     44            This "register" is only ever set by halInternalSleep.
     45             [31] = WakeInfoValid
     46             [30] = SleepSkipped
     47             [29] = CSYSPWRUPREQ
     48             [28] = CDBGPWRUPREQ
     49             [27] = PWR->WAKECR2
     50             [26] = TIMER_WAKE_WRAP
     51             [25] = TIMER_WAKE_COMPB
     52             [24] = TIMER_WAKE_COMPA
     53             [23:0] = corresponding GPIO activity */
     54          #define WAKEINFOVALID_INTERNAL_WAKE_EVENT_BIT 31
     55          #define SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT  30
     56          #define CSYSPWRUPREQ_INTERNAL_WAKE_EVENT_BIT  29
     57          #define CDBGPWRUPREQ_INTERNAL_WAKE_EVENT_BIT  28
     58          #define WAKECORE_INTERNAL_WAKE_EVENT_BIT      27
     59          #define WRAP_INTERNAL_WAKE_EVENT_BIT          26
     60          #define CMPB_INTERNAL_WAKE_EVENT_BIT          25
     61          #define CMPA_INTERNAL_WAKE_EVENT_BIT          24
     62          /* This define shifts events from the PWR->WAKESR register into the proper
     63             place in the halInternalWakeEvent variable */
     64          #define INTERNAL_WAKE_EVENT_BIT_SHIFT         20
     65          /* Private typedef -----------------------------------------------------------*/
     66          /* Private macros ------------------------------------------------------------*/
     67          /* Private variables ---------------------------------------------------------*/
     68          

   \                                 In section .bss, align 4
     69          static uint32_t halInternalWakeEvent=0;
     70          
     71          /* forceSleepTmrCnt is a flag indicating that the system timer module
     72             should force a fake value for SLEEPTMR_CNT whenever the timer is
     73             accessed.  For FogBugz 11909/11920 workaround.*/
     74          boolean forceSleepTmrCnt = FALSE;
   \                     forceSleepTmrCnt:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
     75          /* wakeupSleepTmrCnt is a capturing of the SLEEPTMR_CNT immediately upon
     76             waking up from deep sleep.  This value is used to know when the counter
     77             has ticked forward.  For FogBugz 11909/11920 workaround.*/
     78          uint32_t wakeupSleepTmrCnt = 0;
   \                     wakeupSleepTmrCnt:
   \   00000008                      DS8 4
     79          /* Private function prototypes -----------------------------------------------*/
     80          /* Private functions ---------------------------------------------------------*/
     81          
     82          /** @defgroup  micro_common_Private_Functions
     83            * @{
     84            */
     85          
     86          /**
     87            * @brief Gets the internal wake event info
     88            * @param None
     89            * @retval internal wake event info
     90            */

   \                                 In section .text, align 2, keep-with-next
     91          uint32_t halGetWakeInfo(void)
     92          {
     93            return halInternalWakeEvent;
   \                     halGetWakeInfo: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4770             BX       LR               ;; return
     94          }
     95          
     96          /**
     97            * @brief  hal internal sleep mode.
     98            * @param PWR_SleepMode selects the sleep mode 
     99            * @retval None
    100            */

   \                                 In section .text, align 2, keep-with-next
    101          void halInternalSleep(SleepModes sleepMode)
    102          {
   \                     halInternalSleep: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
    103            /* Timer restoring always takes place during the wakeup sequence.  We save
    104               the state here in case SLEEPMODE_NOTIMER is invoked, which would disable
    105               the clocks.*/
    106            uint32_t CLK_SLEEPCRSAVED = CLK->SLEEPCR;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable4_2  ;; 0x40000004
    107            
    108            /* This code assumes all wake source registers are properly configured.
    109               As such, it should be called from halSleepWithOptions() or from
    110               halSleepForQsWithOptions() which configues the wake sources.*/
    111            
    112            /* The parameter gpioWakeSel is a bitfield composite of the GPIO wake
    113               sources derived from the 3 ports, indicating which of the 24 GPIO
    114               are configured as a wake source.*/
    115            uint32_t gpioWakeSel  = (PWR->WAKEPAR<<0);
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable4_3  ;; 0x4000bc08
   \   0000000C   0xB09A             SUB      SP,SP,#+104
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x9018             STR      R0,[SP, #+96]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
    116                   gpioWakeSel |= (PWR->WAKEPBR<<8);
   \   00000014   0x6869             LDR      R1,[R5, #+4]
    117                   gpioWakeSel |= (PWR->WAKEPCR<<16);
   \   00000016   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000001A   0x68A9             LDR      R1,[R5, #+8]
   \   0000001C   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000020   0x9000             STR      R0,[SP, #+0]
    118            
    119            /* PB2 is also PWR_WAKECR1_SC1.  Set this wake source if PB2's GPIO wake is set.*/
    120            if(PWR->WAKEPBR & PWR_WAKEPxR_Px2) {
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x0740             LSLS     R0,R0,#+29
   \   00000026   0xD503             BPL.N    ??halInternalSleep_0
    121              PWR->WAKECR1 |= PWR_WAKECR1_SC1;
   \   00000028   0x69E0             LDR      R0,[R4, #+28]
   \   0000002A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000002E   0x61E0             STR      R0,[R4, #+28]
    122            }
    123            
    124            /* PA2 is also PWR_WAKECR1_SC2.  Set this wake source if PA2's GPIO wake is set.*/
    125            if(PWR->WAKEPAR & PWR_WAKEPxR_Px2) {
   \                     ??halInternalSleep_0: (+1)
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x0740             LSLS     R0,R0,#+29
   \   00000034   0xD503             BPL.N    ??halInternalSleep_1
    126              PWR->WAKECR1 |= PWR_WAKECR1_SC2;
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000003C   0x61E0             STR      R0,[R4, #+28]
    127            }
    128            
    129            /* The PWR_WAKECR1_IRQD source can come from any pin based on IRQD's sel register.*/
    130            if(gpioWakeSel & BIT(EXTI->CR[1])) {
   \                     ??halInternalSleep_1: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x6929             LDR      R1,[R5, #+16]
   \   00000042   0xFA20 0xF201      LSR      R2,R0,R1
   \   00000046   0x07D0             LSLS     R0,R2,#+31
   \   00000048   0xD503             BPL.N    ??halInternalSleep_2
    131              PWR->WAKECR1 |= PWR_WAKECR1_IRQD;
   \   0000004A   0x69E0             LDR      R0,[R4, #+28]
   \   0000004C   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000050   0x61E0             STR      R0,[R4, #+28]
    132            }
    133            
    134            halInternalWakeEvent = 0; /* clear old wake events */
   \                     ??halInternalSleep_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R6,??DataTable4_1
    135            
    136            switch(sleepMode)
   \   00000058   0x.... 0x....      LDR.W    R10,??DataTable4_4  ;; 0x4000a014
   \   0000005C   0x6070             STR      R0,[R6, #+4]
   \   0000005E   0xF89D 0x0068      LDRB     R0,[SP, #+104]
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xF000 0x824A      BEQ.W    ??halInternalSleep_3
   \   00000068   0xF0C0 0x825A      BCC.W    ??halInternalSleep_4
   \   0000006C   0x2803             CMP      R0,#+3
   \   0000006E   0xD01E             BEQ.N    ??halInternalSleep_5
   \   00000070   0xD305             BCC.N    ??halInternalSleep_6
   \   00000072   0x2804             CMP      R0,#+4
   \   00000074   0xF040 0x8254      BNE.W    ??halInternalSleep_4
    137            {
    138              case SLEEPMODE_NOTIMER:
    139                /* The sleep timer clock sources (both RC and XTAL) are turned off.
    140                   Wakeup is possible from only GPIO.  System time is lost.
    141                   NOTE: Timer restoring always takes place during the wakeup sequence.*/
    142                CLK->SLEEPCR = 0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x6060             STR      R0,[R4, #+4]
    143                goto deepSleepCore;
   \   0000007C   0xE017             B.N      ??halInternalSleep_5
    144              
    145              case SLEEPMODE_WAKETIMER:
    146                /* The sleep timer clock sources remain running.  The RC is always
    147                   running and the 32kHz XTAL depends on the board header.  Wakeup
    148                   is possible from both GPIO and the sleep timer.  System time
    149                   is maintained.  The sleep timer is assumed to be configured
    150                   properly for wake events.
    151                   NOTE: This mode assumes the caller has configured the *entire*
    152                        sleep timer properly.*/
    153                
    154                if(SLPTMR->IER&SLPTMR_IER_WRAP) {
   \                     ??halInternalSleep_6: (+1)
   \   0000007E   0xF8DA 0x0040      LDR      R0,[R10, #+64]
   \   00000082   0x07C0             LSLS     R0,R0,#+31
   \   00000084   0xD503             BPL.N    ??halInternalSleep_7
    155                  PWR->WAKECR1 |= PWR_WAKECR1_WRAP;
   \   00000086   0x69E0             LDR      R0,[R4, #+28]
   \   00000088   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000008C   0x61E0             STR      R0,[R4, #+28]
    156                }
    157                if(SLPTMR->IER&SLPTMR_IER_CMPB) {
   \                     ??halInternalSleep_7: (+1)
   \   0000008E   0xF8DA 0x0040      LDR      R0,[R10, #+64]
   \   00000092   0x0740             LSLS     R0,R0,#+29
   \   00000094   0xD503             BPL.N    ??halInternalSleep_8
    158                  PWR->WAKECR1 |= PWR_WAKECR1_COMPB;
   \   00000096   0x69E0             LDR      R0,[R4, #+28]
   \   00000098   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000009C   0x61E0             STR      R0,[R4, #+28]
    159                }
    160                if(SLPTMR->IER&SLPTMR_IER_CMPA) {
   \                     ??halInternalSleep_8: (+1)
   \   0000009E   0xF8DA 0x0040      LDR      R0,[R10, #+64]
   \   000000A2   0x0780             LSLS     R0,R0,#+30
   \   000000A4   0xD503             BPL.N    ??halInternalSleep_5
    161                  PWR->WAKECR1 |= PWR_WAKECR1_COMPA;
   \   000000A6   0x69E0             LDR      R0,[R4, #+28]
   \   000000A8   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000AC   0x61E0             STR      R0,[R4, #+28]
   \                     ??halInternalSleep_5: (+1)
   \   000000AE   0x2060             MOVS     R0,#+96
   \   000000B0   0xF380 0x8811      MSR      BASEPRI,R0
    162                }
    163                /* fall into SLEEPMODE_MAINTAINTIMER's sleep code: */
    164              case SLEEPMODE_MAINTAINTIMER:
    165                /* The sleep timer clock sources remain running.  The RC is always
    166                   running and the 32kHz XTAL depends on the board header.  Wakeup
    167                   is possible from only GPIO.  System time is maintained.
    168                   NOTE: System time is maintained without any sleep timer interrupts
    169                        because the hardware sleep timer counter is large enough
    170                        to hold the entire count value and not need a RAM counter.*/
    171          
    172            /*============================================================================
    173                                    ##### Core deep sleep code #####
    174            ============================================================================*/    
    175          deepSleepCore:
    176                /* Interrupts *must* be/stay disabled for DEEP SLEEP operation
    177                   INTERRUPTS_OFF will use BASEPRI to disable all interrupts except
    178                   fault handlers and PendSV. */
    179                INTERRUPTS_OFF();
    180                /* This is the point of no return.  From here on out, only the interrupt
    181                   sources available in PWR->WAKECR1 will be captured and propagated across
    182                   deep sleep.
    183                  stick all our saved info onto stack since it's only temporary */
    184                {
    185                  boolean restoreWatchdog = WDG_GetStatus();
   \   000000B4   0x.... 0x....      BL       WDG_GetStatus
   \   000000B8   0xF88D 0x005C      STRB     R0,[SP, #+92]
    186                  boolean skipSleep = FALSE;
   \   000000BC   0xF04F 0x0B00      MOV      R11,#+0
    187                  
    188                  /* Only three register blocks keep power across deep sleep:
    189                      CM_HV, GPIO, SLOW_TIMERS  */
    190          
    191                  /* All other register blocks lose their state across deep sleep:
    192                      MAC, SECURITY, SERIAL, TMR1, TMR2, EVENT, CM_LV, RAM_CTRL,
    193                      AUX_ADC, FLASH_CONTROL, ITM, DWT, FPB, NVIC, TPIU */
    194          
    195                  /* The sleep code will only save and restore registers where it is
    196                     meaningful and necessary to do so.  In most cases, there must still
    197                     be a powerup function to restore proper state.*/
    198          
    199                  /* NOTE: halPowerUp() and halPowerDown() will always be called before
    200                     and after this function.  halPowerDown and halPowerUp should leave
    201                     the modules in a safe state and then restart the modules.
    202                     (For example, shutting down and restarting Timer1) */
    203          
    204                  /* ----BASEBAND
    205                            reinitialized by stStackPowerUp() */
    206                  /*----MAC
    207                            reinitialized by stStackPowerUp() */
    208                  /*----SECURITY
    209                            reinitialized by stStackPowerUp() */
    210                  /*----SERIAL
    211                            reinitialized by halPowerUp() or similar */
    212                  /*----TMR1
    213                            reinitialized by halPowerUp() or similar */
    214                  /*----TMR2
    215                            reinitialized by halPowerUp() or similar */
    216                  /*----EVENT
    217                    SRC or FLAG interrupts are not saved or restored
    218                    MISS interrupts are not saved or restored
    219                    MAC_RX_INT_MASK - reinitialized by stStackPowerUp()
    220                    MAC_TX_INT_MASK - reinitialized by stStackPowerUp()
    221                    MAC_TIMER_INT_MASK - reinitialized by stStackPowerUp()
    222                    BB_INT_MASK - reinitialized by stStackPowerUp()
    223                    SEC_INT_MASK - reinitialized by stStackPowerUp() */
    224                  uint32_t SLPTMR_IERSAVED = SLPTMR->IER;
   \   000000C0   0xF8DA 0x0040      LDR      R0,[R10, #+64]
   \   000000C4   0x.... 0x....      LDR.W    R8,??DataTable4_5  ;; 0x4000a814
   \   000000C8   0x.... 0x....      LDR.W    R9,??DataTable4_6  ;; 0x40004004
   \   000000CC   0x.... 0x....      LDR.W    R7,??DataTable4_7  ;; 0x40005000
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable4_8  ;; 0xe000ed04
   \   000000D4   0x.... 0x....      LDR.W    R2,??DataTable4_9  ;; 0x4000b408
   \   000000D8   0x9016             STR      R0,[SP, #+88]
    225                  uint32_t MGMT_IT_IERSAVED = MGMT_IT->IER;
   \   000000DA   0xF8DA 0x0044      LDR      R0,[R10, #+68]
   \   000000DE   0x9015             STR      R0,[SP, #+84]
    226                  /* TIM1_IT->IER - reinitialized by halPowerUp() or similar
    227                     TIM2_IT->IER - reinitialized by halPowerUp() or similar
    228                     SC1_IT->IER - reinitialized by halPowerUp() or similar
    229                     SC2_IT->IER - reinitialized by halPowerUp() or similar
    230                     ADC->IER - reinitialized by halPowerUp() or similar */
    231                  uint32_t EXTI_TSRSAVED_0 = EXTI->TSR[0];
   \   000000E0   0xF8D8 0x004C      LDR      R0,[R8, #+76]
   \   000000E4   0x9014             STR      R0,[SP, #+80]
    232                  uint32_t EXTI_TSRSAVED_1 = EXTI->TSR[1];
   \   000000E6   0xF8D8 0x0050      LDR      R0,[R8, #+80]
   \   000000EA   0x9013             STR      R0,[SP, #+76]
    233                  uint32_t EXTI_TSRSAVED_2 = EXTI->TSR[2];
   \   000000EC   0xF8D8 0x0054      LDR      R0,[R8, #+84]
   \   000000F0   0x9012             STR      R0,[SP, #+72]
    234                  uint32_t EXTI_TSRSAVED_3 = EXTI->TSR[3];
   \   000000F2   0xF8D8 0x0058      LDR      R0,[R8, #+88]
   \   000000F6   0x9011             STR      R0,[SP, #+68]
    235                  /* SC1_IT->ICR - reinitialized by halPowerUp() or similar
    236                     SC2_IT->ICR - reinitialized by halPowerUp() or similar */
    237                  /* ----CM_LV */
    238                  uint32_t CLK_HSECR1SAVED = CLK->HSECR1;
   \   000000F8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000FC   0x9010             STR      R0,[SP, #+64]
    239                  uint32_t CLK_HSICRSAVED = CLK->HSICR;
   \   000000FE   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000102   0x900F             STR      R0,[SP, #+60]
    240                  uint32_t CLK_DITHERCRSAVED = CLK->DITHERCR;
   \   00000104   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \   00000108   0x900E             STR      R0,[SP, #+56]
    241                  /* CLK->HSECR2 - reinitialized by halPowerUp() or similar
    242                     CLK->CPUCR  - reinitialized by halPowerUp() or similar
    243                     TMR1_CLK_SEL - reinitialized by halPowerUp() or similar
    244                     TMR2_CLK_SEL - reinitialized by halPowerUp() or similar */
    245                  uint32_t GPIO_PCTRACECRSAVED = GPIO_DBG->PCTRACECR;
   \   0000010A   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   0000010E   0x900D             STR      R0,[SP, #+52]
    246                  /*----RAM_CTRL */
    247                  uint32_t MEM_RAMPROTR1SAVED = MEM->RAMPROTR1;
   \   00000110   0x6838             LDR      R0,[R7, #+0]
   \   00000112   0x900C             STR      R0,[SP, #+48]
    248                  uint32_t MEM_RAMPROTR2SAVED = MEM->RAMPROTR2;
   \   00000114   0x6878             LDR      R0,[R7, #+4]
   \   00000116   0x900B             STR      R0,[SP, #+44]
    249                  uint32_t MEM_RAMPROTR3SAVED = MEM->RAMPROTR3;
   \   00000118   0x68B8             LDR      R0,[R7, #+8]
   \   0000011A   0x900A             STR      R0,[SP, #+40]
    250                  uint32_t MEM_RAMPROTR4SAVED = MEM->RAMPROTR4;
   \   0000011C   0x68F8             LDR      R0,[R7, #+12]
   \   0000011E   0x9009             STR      R0,[SP, #+36]
    251                  uint32_t MEM_RAMPROTR5SAVED = MEM->RAMPROTR5;
   \   00000120   0x6938             LDR      R0,[R7, #+16]
   \   00000122   0x9008             STR      R0,[SP, #+32]
    252                  uint32_t MEM_RAMPROTR6SAVED = MEM->RAMPROTR6;
   \   00000124   0x6978             LDR      R0,[R7, #+20]
   \   00000126   0x9007             STR      R0,[SP, #+28]
    253                  uint32_t MEM_RAMPROTR7SAVED = MEM->RAMPROTR7;
   \   00000128   0x69B8             LDR      R0,[R7, #+24]
   \   0000012A   0x9006             STR      R0,[SP, #+24]
    254                  uint32_t MEM_RAMPROTR8SAVED = MEM->RAMPROTR8;
   \   0000012C   0x69F8             LDR      R0,[R7, #+28]
   \   0000012E   0x9005             STR      R0,[SP, #+20]
    255                  uint32_t MEM_RAMCRSAVED = MEM->RAMCR;
   \   00000130   0x6AB8             LDR      R0,[R7, #+40]
   \   00000132   0x9004             STR      R0,[SP, #+16]
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable4_10  ;; 0xe000e100
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x6849             LDR      R1,[R1, #+4]
   \   0000013C   0x9103             STR      R1,[SP, #+12]
    256                  /*----AUX_ADC
    257                            reinitialized by halPowerUp() or similar */
    258                  /*----CAL_ADC
    259                            reinitialized by stStackPowerUp() */
    260                  /*----FLASH_CONTROL
    261                            configured on the fly by the flash library */
    262                  /*----ITM
    263                            reinitialized by halPowerUp() or similar */
    264                  /*----DWT
    265                            not used by software on chip */
    266                  /*----FPB
    267                            not used by software on chip */
    268                  /*----NVIC
    269                      SysTick->CTRL- fixed, restored by cstartup when exiting deep sleep
    270                     SysTick->LOAD - fixed, restored by cstartup when exiting deep sleep */
    271                  uint32_t NVIC_ISERSAVED = NVIC->ISER[0]; //mask against wake sources
    272                  /* NVIC->ISPR[0] - used below when overlapping interrupts and wake sources
    273                     NVIC_IPR_3to0 - fixed, restored by cstartup when exiting deep sleep
    274                     NVIC_IPR_7to4 - fixed, restored by cstartup when exiting deep sleep
    275                     NVIC_IPR_11to8 - fixed, restored by cstartup when exiting deep sleep
    276                     NVIC_IPR_15to12 - fixed, restored by cstartup when exiting deep sleep
    277                     NVIC_IPR_19to16 - fixed, restored by cstartup when exiting deep sleep */
    278                  uint32_t SCB_VTORSAVED = SCB->VTOR;
    279                  /* SCB->CCR - fixed, restored by cstartup when exiting deep sleep
    280                     SCB->SHP[0] - fixed, restored by cstartup when exiting deep sleep
    281                     SCB->SHP[1] - fixed, restored by cstartup when exiting deep sleep
    282                     SCB->SHP[2] - fixed, restored by cstartup when exiting deep sleep
    283                     SCB->SHCSR - fixed, restored by cstartup when exiting deep sleep */
    284                  /*----TPIU
    285                            reinitialized by halPowerUp() or similar*/
    286          
    287                  /* stmDebugPowerDown() should have shutdown the DWT/ITM/TPIU already.*/
    288                  
    289                  /* freeze input to the GPIO from LV (alternate output functions freeze)*/
    290                  PWR->DSLEEPCR1 = PWR_DSLEEPCR1_LVFREEZE;
   \   0000013E   0x2102             MOVS     R1,#+2
   \   00000140   0x6021             STR      R1,[R4, #+0]
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable4_11  ;; 0x4000b008
   \   00000146   0x6809             LDR      R1,[R1, #+0]
   \   00000148   0x6812             LDR      R2,[R2, #+0]
   \   0000014A   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000014E   0x.... 0x....      LDR.W    R2,??DataTable4_12  ;; 0x4000b808
   \   00000152   0x6812             LDR      R2,[R2, #+0]
   \   00000154   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000158   0x9102             STR      R1,[SP, #+8]
   \   0000015A   0xF04F 0x31FF      MOV      R1,#-1
   \   0000015E   0x6261             STR      R1,[R4, #+36]
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable4_13  ;; 0xe000e200
   \   00000164   0x680A             LDR      R2,[R1, #+0]
   \   00000166   0x6871             LDR      R1,[R6, #+4]
   \   00000168   0x04D2             LSLS     R2,R2,#+19
   \   0000016A   0xD509             BPL.N    ??halInternalSleep_9
   \   0000016C   0x686A             LDR      R2,[R5, #+4]
   \   0000016E   0x07D2             LSLS     R2,R2,#+31
   \   00000170   0xD506             BPL.N    ??halInternalSleep_9
   \   00000172   0x69E2             LDR      R2,[R4, #+28]
   \   00000174   0x07D2             LSLS     R2,R2,#+31
   \   00000176   0xBF44             ITT      MI 
   \   00000178   0xF04F 0x0B01      MOVMI    R11,#+1
   \   0000017C   0xF441 0x7180      ORRMI    R1,R1,#0x100
    291                  /* record GPIO state for wake monitoring purposes
    292                     By having a snapshot of GPIO state, we can figure out after waking
    293                     up exactly which GPIO could have woken us up.
    294                     Reading the three IN registers is done separately to avoid warnings
    295                     about undefined order of __IO access. */
    296                  uint32_t GPIO_IN_SAVED =   GPIOA->IDR;
    297                         GPIO_IN_SAVED |= (GPIOB->IDR<<8);
    298                         GPIO_IN_SAVED |= (GPIOC->IDR<<16);
    299                  /* reset the power up events by writing 1 to all bits. */
    300                  PWR->WAKESR = 0xFFFFFFFF;
    301          
    302                  /* By clearing the events, the wake up event capturing is activated.
    303                    At this point we can safely check our interrupt flags since event
    304                    capturing is now overlapped.  Up to now, interrupts indicate
    305                    activity, after this point, powerup events indicate activity.
    306                    If any of the interrupt flags are set, that means we saw a wake event
    307                    sometime while entering sleep, so we need to skip over sleeping */
    308          
    309                  /*--possible interrupt sources for waking:
    310                      IRQA, IRQB, IRQC, IRQD
    311                      SleepTMR CMPA, CMPB, Wrap
    312                      PWR->WAKECR2 (DebugIsr)*/
    313          
    314                  /* check for IRQA interrupt and if IRQA (PB0) is wake source */
    315                  if((NVIC->ISPR[0]&NVIC_IxxR_IRQA) && (PWR->WAKEPBR&PWR_WAKEPxR_Px0) && (PWR->WAKECR1&PWR_WAKECR1_MONEN))
    316                  {
    317                    skipSleep = TRUE;
    318                    /* log IRQA as a wake event */
    319                    halInternalWakeEvent |= BIT(PORTB_PIN(0));
    320                  }
    321                  /* check for IRQB interrupt and if IRQB (PB6) is wake source */
    322                  if((NVIC->ISPR[0]&NVIC_IxxR_IRQB) && (PWR->WAKEPBR&PWR_WAKEPxR_Px6) && (PWR->WAKECR1&PWR_WAKECR1_MONEN))
   \                     ??halInternalSleep_9: (+1)
   \   00000180   0x.... 0x....      LDR.W    R2,??DataTable4_13  ;; 0xe000e200
   \   00000184   0x6812             LDR      R2,[R2, #+0]
   \   00000186   0x0492             LSLS     R2,R2,#+18
   \   00000188   0xD509             BPL.N    ??halInternalSleep_10
   \   0000018A   0x686A             LDR      R2,[R5, #+4]
   \   0000018C   0x0652             LSLS     R2,R2,#+25
   \   0000018E   0xD506             BPL.N    ??halInternalSleep_10
   \   00000190   0x69E2             LDR      R2,[R4, #+28]
   \   00000192   0x07D2             LSLS     R2,R2,#+31
   \   00000194   0xBF44             ITT      MI 
   \   00000196   0xF04F 0x0B01      MOVMI    R11,#+1
   \   0000019A   0xF441 0x4180      ORRMI    R1,R1,#0x4000
    323                  {
    324                    skipSleep = TRUE;
    325                    /* log IRQB as a wake event */
    326                    halInternalWakeEvent |= BIT(PORTB_PIN(6));
    327                  }
    328                  /* check for IRQC interrupt and if IRQC (EXTI->CR[0]) is wake source */
    329                  if((NVIC->ISPR[0]&NVIC_IxxR_IRQC) && (gpioWakeSel&BIT(EXTI->CR[0])) && (PWR->WAKECR1&PWR_WAKECR1_MONEN))
   \                     ??halInternalSleep_10: (+1)
   \   0000019E   0x.... 0x....      LDR.W    R3,??DataTable4_13  ;; 0xe000e200
   \   000001A2   0x681B             LDR      R3,[R3, #+0]
   \   000001A4   0x2201             MOVS     R2,#+1
   \   000001A6   0x045B             LSLS     R3,R3,#+17
   \   000001A8   0xD50E             BPL.N    ??halInternalSleep_11
   \   000001AA   0x9B00             LDR      R3,[SP, #+0]
   \   000001AC   0xF8D5 0xC00C      LDR      R12,[R5, #+12]
   \   000001B0   0xFA23 0xF30C      LSR      R3,R3,R12
   \   000001B4   0x07DB             LSLS     R3,R3,#+31
   \   000001B6   0xD507             BPL.N    ??halInternalSleep_11
   \   000001B8   0x69E3             LDR      R3,[R4, #+28]
   \   000001BA   0x07DB             LSLS     R3,R3,#+31
   \   000001BC   0xD504             BPL.N    ??halInternalSleep_11
    330                  {
    331                    skipSleep = TRUE;
    332                    /* log IRQC as a wake event */
    333                    halInternalWakeEvent |= BIT(EXTI->CR[0]);
   \   000001BE   0x68EB             LDR      R3,[R5, #+12]
   \   000001C0   0xFA02 0xF303      LSL      R3,R2,R3
   \   000001C4   0x4693             MOV      R11,R2
   \   000001C6   0x4319             ORRS     R1,R3,R1
    334                  }
    335                  /* check for IRQD interrupt and if IRQD (EXTI->CR[1]) is wake source */
    336                  if((NVIC->ISPR[0]&NVIC_IxxR_IRQD) && (gpioWakeSel&BIT(EXTI->CR[1])) && ((PWR->WAKECR1&PWR_WAKECR1_MONEN) || (PWR->WAKECR1&PWR_WAKECR1_IRQD)))
   \                     ??halInternalSleep_11: (+1)
   \   000001C8   0x.... 0x....      LDR.W    R3,??DataTable4_13  ;; 0xe000e200
   \   000001CC   0x681B             LDR      R3,[R3, #+0]
   \   000001CE   0x041B             LSLS     R3,R3,#+16
   \   000001D0   0xD510             BPL.N    ??halInternalSleep_12
   \   000001D2   0x9B00             LDR      R3,[SP, #+0]
   \   000001D4   0xF8D5 0xC010      LDR      R12,[R5, #+16]
   \   000001D8   0xFA23 0xF30C      LSR      R3,R3,R12
   \   000001DC   0x07DB             LSLS     R3,R3,#+31
   \   000001DE   0xD509             BPL.N    ??halInternalSleep_12
   \   000001E0   0x69E3             LDR      R3,[R4, #+28]
   \   000001E2   0x07DB             LSLS     R3,R3,#+31
   \   000001E4   0xD402             BMI.N    ??halInternalSleep_13
   \   000001E6   0x69E3             LDR      R3,[R4, #+28]
   \   000001E8   0x071B             LSLS     R3,R3,#+28
   \   000001EA   0xD503             BPL.N    ??halInternalSleep_12
    337                  {
    338                    skipSleep = TRUE;
    339                    /* log IRQD as a wake event */
    340                    halInternalWakeEvent |= BIT(EXTI->CR[1]);
   \                     ??halInternalSleep_13: (+1)
   \   000001EC   0x692B             LDR      R3,[R5, #+16]
   \   000001EE   0x4693             MOV      R11,R2
   \   000001F0   0x409A             LSLS     R2,R2,R3
   \   000001F2   0x4311             ORRS     R1,R2,R1
    341                  }
    342                  /* check for SleepTMR CMPA interrupt and if SleepTMR CMPA is wake source */
    343                  if((NVIC_IxxR_SLEEPTMR&SLPTMR_IER_CMPA) && (PWR->WAKECR1&PWR_WAKECR1_COMPA))
    344                  {
    345                    skipSleep = TRUE;
    346                    /* log SleepTMR CMPA as a wake event */
    347                    halInternalWakeEvent |= BIT32(CMPA_INTERNAL_WAKE_EVENT_BIT);
    348                  }
    349                  /*check for SleepTMR CMPB interrupt and if SleepTMR CMPB is wake source */
    350                  if((NVIC_IxxR_SLEEPTMR&SLPTMR_IER_CMPB) && (PWR->WAKECR1&PWR_WAKECR1_COMPB))
    351                  {
    352                    skipSleep = TRUE;
    353                    /* log SleepTMR CMPB as a wake event */
    354                    halInternalWakeEvent |= BIT32(CMPB_INTERNAL_WAKE_EVENT_BIT);
    355                  }
    356                  /* check for SleepTMR WRAP interrupt and if SleepTMR WRAP is wake source */
    357                  if((NVIC_IxxR_SLEEPTMR&SLPTMR_IER_WRAP) && (PWR->WAKECR1&PWR_WAKECR1_WRAP))
    358                  {
    359                    skipSleep = TRUE;
    360                    /* log SleepTMR WRAP as a wake event */
    361                    halInternalWakeEvent |= BIT32(WRAP_INTERNAL_WAKE_EVENT_BIT);
    362                  }
    363                  /* check for Debug interrupt and if PWR->WAKECR2 is wake source */
    364                  if((NVIC->ISPR[0]&NVIC_IxxR_DEBUG) && (PWR->WAKECR1&PWR_WAKECR1_CORE))
   \                     ??halInternalSleep_12: (+1)
   \   000001F4   0x.... 0x....      LDR.W    R2,??DataTable4_13  ;; 0xe000e200
   \   000001F8   0x6812             LDR      R2,[R2, #+0]
   \   000001FA   0x03D2             LSLS     R2,R2,#+15
   \   000001FC   0xD506             BPL.N    ??halInternalSleep_14
   \   000001FE   0x69E2             LDR      R2,[R4, #+28]
   \   00000200   0x0612             LSLS     R2,R2,#+24
   \   00000202   0xBF44             ITT      MI 
   \   00000204   0xF04F 0x0B01      MOVMI    R11,#+1
   \   00000208   0xF041 0x6100      ORRMI    R1,R1,#0x8000000
    365                  {
    366                    skipSleep = TRUE;
    367                    /* log PWR->WAKECR2 as a wake event */
    368                    halInternalWakeEvent |= BIT32(WAKECORE_INTERNAL_WAKE_EVENT_BIT);
   \                     ??halInternalSleep_14: (+1)
   \   0000020C   0x6071             STR      R1,[R6, #+4]
    369                  }
    370                  
    371                  /* only propagate across deep sleep the interrupts that are both
    372                  enabled and possible wake sources */
    373                  {
    374                    uint32_t wakeSourceInterruptMask = 0;
   \   0000020E   0x2100             MOVS     R1,#+0
   \   00000210   0x686A             LDR      R2,[R5, #+4]
   \   00000212   0x07D2             LSLS     R2,R2,#+31
    375                    
    376                    if(PWR->WAKEPBR & PWR_WAKEPxR_Px0)
    377                    {
    378                      wakeSourceInterruptMask |= NVIC_IxxR_IRQA;
    379                    }
    380                    if(PWR->WAKEPBR & PWR_WAKEPxR_Px6)
   \   00000214   0x686A             LDR      R2,[R5, #+4]
   \   00000216   0xBF48             IT       MI 
   \   00000218   0xF44F 0x5180      MOVMI    R1,#+4096
   \   0000021C   0x0652             LSLS     R2,R2,#+25
    381                    {
    382                      wakeSourceInterruptMask |= NVIC_IxxR_IRQB;
    383                    }
    384                    if(gpioWakeSel&BIT(EXTI->CR[0]))
   \   0000021E   0x9A00             LDR      R2,[SP, #+0]
   \   00000220   0x68EB             LDR      R3,[R5, #+12]
   \   00000222   0xBF48             IT       MI 
   \   00000224   0xF441 0x5100      ORRMI    R1,R1,#0x2000
   \   00000228   0x40DA             LSRS     R2,R2,R3
   \   0000022A   0x07D2             LSLS     R2,R2,#+31
    385                    {
    386                      wakeSourceInterruptMask |= NVIC_IxxR_IRQC;
    387                    }
    388                    if(gpioWakeSel&BIT(EXTI->CR[1]))
   \   0000022C   0x9A00             LDR      R2,[SP, #+0]
   \   0000022E   0x692B             LDR      R3,[R5, #+16]
   \   00000230   0xBF48             IT       MI 
   \   00000232   0xF441 0x4180      ORRMI    R1,R1,#0x4000
   \   00000236   0x40DA             LSRS     R2,R2,R3
   \   00000238   0x07D2             LSLS     R2,R2,#+31
    389                    {
    390                      wakeSourceInterruptMask |= NVIC_IxxR_IRQD;
    391                    }
    392                    if((PWR->WAKECR1&PWR_WAKECR1_COMPA) || (PWR->WAKECR1&PWR_WAKECR1_COMPB) ||
    393                       (PWR->WAKECR1&PWR_WAKECR1_WRAP))
   \   0000023A   0x69E2             LDR      R2,[R4, #+28]
   \   0000023C   0xBF48             IT       MI 
   \   0000023E   0xF441 0x4100      ORRMI    R1,R1,#0x8000
   \   00000242   0x06D2             LSLS     R2,R2,#+27
   \   00000244   0xD405             BMI.N    ??halInternalSleep_15
   \   00000246   0x69E2             LDR      R2,[R4, #+28]
   \   00000248   0x0692             LSLS     R2,R2,#+26
   \   0000024A   0xD402             BMI.N    ??halInternalSleep_15
   \   0000024C   0x69E2             LDR      R2,[R4, #+28]
   \   0000024E   0x0652             LSLS     R2,R2,#+25
   \   00000250   0xD501             BPL.N    ??halInternalSleep_16
    394                    {
    395                      wakeSourceInterruptMask |= NVIC_IxxR_SLEEPTMR;
   \                     ??halInternalSleep_15: (+1)
   \   00000252   0xF041 0x0110      ORR      R1,R1,#0x10
    396                    }
    397                    if(PWR->WAKECR1&PWR_WAKECR1_CORE) 
   \                     ??halInternalSleep_16: (+1)
   \   00000256   0x69E2             LDR      R2,[R4, #+28]
   \   00000258   0x0612             LSLS     R2,R2,#+24
   \   0000025A   0xBF48             IT       MI 
   \   0000025C   0xF441 0x3180      ORRMI    R1,R1,#0x10000
    398                    {
    399                      wakeSourceInterruptMask |= NVIC_IxxR_DEBUG;
    400                    }
    401                    
    402                    NVIC_ISERSAVED &= wakeSourceInterruptMask;
   \   00000260   0x4008             ANDS     R0,R1,R0
   \   00000262   0x9001             STR      R0,[SP, #+4]
    403                  }
    404          
    405                  /* disable watchdog while sleeping (since we can't reset it asleep) */
    406                  WDG_Cmd(DISABLE);
   \   00000264   0x2000             MOVS     R0,#+0
   \   00000266   0x.... 0x....      BL       WDG_Cmd
    407                  
    408                /*  The chip is not allowed to enter a deep sleep mode (which could
    409                    cause a core reset cycle) while CSYSPWRUPREQ is set.  CSYSPWRUPREQ
    410                    indicates that the debugger is trying to access sections of the
    411                    chip that would get reset during deep sleep.  Therefore, a reset
    412                    cycle could very easily cause the debugger to error and we don't
    413                    want that.  While the power management state machine will stall
    414                    if CSYSPWRUPREQ is set (to avoid the situation just described),
    415                    in this stalled state the chip will not be responsive to wake
    416                    events.  To be sensitive to wake events, we must handle them in
    417                    software instead.  To accomplish this, we request that the
    418                    CSYSPWRUPACK be inhibited (which will indicate the debugger is not
    419                    connected).  But, we cannot induce deep sleep until CSYSPWRUPREQ/ACK
    420                    go low and these are under the debuggers control, so we must stall
    421                    and wait here.  If there is a wake event during this time, break
    422                    out and wake like normal.  If the ACK eventually clears,
    423                    we can proceed into deep sleep.  The PWR->CSYSPWRUPACKCR
    424                    functionality will hold off the debugger (by holding off the ACK)
    425                    until we are safely past and out of deep sleep.  The power management
    426                    state machine then becomes responsible for clearing
    427                    PWR->CSYSPWRUPACKCR and responding to a CSYSPWRUPREQ with a
    428                    CSYSPWRUPACK at the right/safe time.*/
    429                  PWR->CSYSPWRUPACKCR = PWR_CSYSPWRUPACKCR_INHIBIT;
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0x63E0             STR      R0,[R4, #+60]
    430                  {
    431                    /* Use a local copy of PWR->WAKECR1 to avoid warnings from the compiler
    432                       about order of __IO accesses */
    433                    uint32_t wakeSel = PWR->WAKECR1;
   \   0000026E   0x69E0             LDR      R0,[R4, #+28]
    434                    /* stall until a wake event or CSYSPWRUPREQ/ACK clears */
    435                    while( (PWR->CSYSPWRUPACKSR) && (!(PWR->WAKESR&wakeSel)) ) {}
   \                     ??halInternalSleep_17: (+1)
   \   00000270   0x6BA1             LDR      R1,[R4, #+56]
   \   00000272   0xB111             CBZ.N    R1,??halInternalSleep_18
   \   00000274   0x6A61             LDR      R1,[R4, #+36]
   \   00000276   0x4201             TST      R1,R0
   \   00000278   0xD0FA             BEQ.N    ??halInternalSleep_17
   \                     ??halInternalSleep_18: (+1)
   \   0000027A   0x6A61             LDR      R1,[R4, #+36]
   \   0000027C   0x4201             TST      R1,R0
   \   0000027E   0xF000 0x80F2      BEQ.W    ??halInternalSleep_19
    436                    /* if there was a wake event, allow CSYSPWRUPACK and skip sleep */
    437                    if(PWR->WAKESR&wakeSel)
    438                    {
    439                      PWR->CSYSPWRUPACKCR = 0x00;
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0x63E0             STR      R0,[R4, #+60]
    440                      skipSleep = TRUE;
   \   00000286   0xF04F 0x0B01      MOV      R11,#+1
    441                    }
    442                  }
    443          
    444                  if(!skipSleep)
    445                  {
    446                    /* FogBugz 7283 states that we must switch to the OSCHF when entering
    447                       deep sleep since using the 24MHz XTAL could result in RAM
    448                       corruption.  This switch must occur at least 2*24MHz cycles before
    449                       sleeping.*/
    450                    /* FogBugz 8858 states that we cannot go into deep-sleep when the
    451                       chip is clocked with the 24MHz XTAL with a duty cycle as low as
    452                       70/30 since this causes power_down generation timing to fail.*/
    453                    CLK->HSECR2 &= ~CLK_HSECR2_SW1;
    454                    /* If DS12 needs to be forced regardless of state, clear
    455                       PWR->DSLEEPCR2 here.  This is hugely dangerous and
    456                       should only be done in very controlled chip tests.*/
    457                    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;      /* enable deep sleep */
    458                    extern __IO boolean halPendSvSaveContext;
    459                    halPendSvSaveContext = 1;          /* 1 means save context */
    460                    /* The INTERRUPTS_OFF used at the beginning of this function set
    461                       BASEPRI such that the only interrupts that will fire are faults
    462                       and PendSV.  Trigger PendSV now to induce a context save.*/
    463                    SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;    /* pend the context save and Dsleep */
    464                    /* Since the interrupt will not fire immediately it is possible to
    465                       execute a few lines of code.  To stay halted in this spot until the
    466                       WFI instruction, spin on the context flag (which will get cleared
    467                       during the startup sequence when restoring context).*/
    468                    while(halPendSvSaveContext) {}
    469                    /* I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
    470                       Save the value of the SLEEPTMR_CNT register immediately after
    471                       waking up from a real sleep.  For FogBugz 11909/11920 workaround.*/
    472                    wakeupSleepTmrCnt = SLPTMR->CNTH<<16;
    473                    wakeupSleepTmrCnt |= SLPTMR->CNTL;
    474                  } 
    475                  else 
    476                  {
    477                    /* Record the fact that we skipped sleep */
    478                    halInternalWakeEvent |= BIT32(SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT);
   \                     ??halInternalSleep_20: (+1)
   \   0000028A   0x6870             LDR      R0,[R6, #+4]
   \   0000028C   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   00000290   0x6070             STR      R0,[R6, #+4]
    479                    /* If this was a true deep sleep, we would have executed cstartup and
    480                       PRIMASK would be set right now.  If we skipped sleep, PRIMASK is not
    481                       set so we explicitely set it to guarantee the powerup sequence
    482                       works cleanly and consistently with respect to interrupt
    483                       dispatching and enabling.*/
    484                    __disable_irq();
   \   00000292   0xB672             CPSID    I
    485                  }
    486                  
    487                  /* Clear the interrupt flags for all wake sources. This
    488                     is necessary because if we don't execute an actual deep sleep cycle
    489                     the interrupt flags will never be cleared.  By clearing the flags,
    490                     we always mimick a real deep sleep as closely as possible and
    491                     guard against any accidental interrupt triggering coming out
    492                     of deep sleep.  (The interrupt dispatch code coming out of sleep
    493                     is responsible for translating wake events into interrupt events,
    494                     and if we don't clear interrupt flags here it's possible for an
    495                     interrupt to trigger even if it wasn't the true wake event.)*/
    496                  SLPTMR->ISR = (SLPTMR_IER_CMPA | SLPTMR_IER_CMPB | SLPTMR_IER_WRAP);
   \                     ??halInternalSleep_21: (+1)
   \   00000294   0x2007             MOVS     R0,#+7
   \   00000296   0xF8CA 0x0000      STR      R0,[R10, #+0]
    497                  EXTI->PR = (EXTI_PR_IRQAP | EXTI_PR_IRQBP | EXTI_PR_IRQCP | EXTI_PR_IRQDP);
   \   0000029A   0x200F             MOVS     R0,#+15
   \   0000029C   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   000002A0   0x....             LDR.N    R1,??DataTable4_10  ;; 0xe000e100
    498                  
    499                  /* immediately restore the registers we saved before sleeping
    500                     so IRQ and SleepTMR capture can be reenabled as quickly as possible
    501                     this is safe because our global interrupts are still disabled
    502                     other registers will be restored later */
    503          
    504                  CLK->SLEEPCR = CLK_SLEEPCRSAVED;
   \   000002A2   0x9818             LDR      R0,[SP, #+96]
   \   000002A4   0x6060             STR      R0,[R4, #+4]
    505                  SLPTMR->IER = SLPTMR_IERSAVED;
   \   000002A6   0x9816             LDR      R0,[SP, #+88]
   \   000002A8   0xF8CA 0x0040      STR      R0,[R10, #+64]
    506                  MGMT_IT->IER = MGMT_IT_IERSAVED;
   \   000002AC   0x9815             LDR      R0,[SP, #+84]
   \   000002AE   0xF8CA 0x0044      STR      R0,[R10, #+68]
    507                  EXTI->TSR[0] = EXTI_TSRSAVED_0;
   \   000002B2   0x9814             LDR      R0,[SP, #+80]
   \   000002B4   0xF8C8 0x004C      STR      R0,[R8, #+76]
    508                  EXTI->TSR[1] = EXTI_TSRSAVED_1;
   \   000002B8   0x9813             LDR      R0,[SP, #+76]
   \   000002BA   0xF8C8 0x0050      STR      R0,[R8, #+80]
    509                  EXTI->TSR[2] = EXTI_TSRSAVED_2;
   \   000002BE   0x9812             LDR      R0,[SP, #+72]
   \   000002C0   0xF8C8 0x0054      STR      R0,[R8, #+84]
    510                  EXTI->TSR[3] = EXTI_TSRSAVED_3;
   \   000002C4   0x9811             LDR      R0,[SP, #+68]
   \   000002C6   0xF8C8 0x0058      STR      R0,[R8, #+88]
    511                  CLK->HSECR1 = CLK_HSECR1SAVED;
   \   000002CA   0x9810             LDR      R0,[SP, #+64]
   \   000002CC   0xF8C9 0x0000      STR      R0,[R9, #+0]
    512                  CLK->HSICR = CLK_HSICRSAVED;
   \   000002D0   0x980F             LDR      R0,[SP, #+60]
   \   000002D2   0xF8C9 0x0004      STR      R0,[R9, #+4]
    513                  CLK->DITHERCR = CLK_DITHERCRSAVED;
   \   000002D6   0x980E             LDR      R0,[SP, #+56]
   \   000002D8   0xF8C9 0x0014      STR      R0,[R9, #+20]
    514                  GPIO_DBG->PCTRACECR = GPIO_PCTRACECRSAVED;
   \   000002DC   0x980D             LDR      R0,[SP, #+52]
   \   000002DE   0xF8C9 0x0024      STR      R0,[R9, #+36]
    515                  MEM->RAMPROTR1 = MEM_RAMPROTR1SAVED;
   \   000002E2   0x980C             LDR      R0,[SP, #+48]
   \   000002E4   0x6038             STR      R0,[R7, #+0]
    516                  MEM->RAMPROTR2 = MEM_RAMPROTR2SAVED;
   \   000002E6   0x980B             LDR      R0,[SP, #+44]
   \   000002E8   0x6078             STR      R0,[R7, #+4]
    517                  MEM->RAMPROTR3 = MEM_RAMPROTR3SAVED;
   \   000002EA   0x980A             LDR      R0,[SP, #+40]
   \   000002EC   0x60B8             STR      R0,[R7, #+8]
    518                  MEM->RAMPROTR4 = MEM_RAMPROTR4SAVED;
   \   000002EE   0x9809             LDR      R0,[SP, #+36]
   \   000002F0   0x60F8             STR      R0,[R7, #+12]
    519                  MEM->RAMPROTR5 = MEM_RAMPROTR5SAVED;
   \   000002F2   0x9808             LDR      R0,[SP, #+32]
   \   000002F4   0x6138             STR      R0,[R7, #+16]
    520                  MEM->RAMPROTR6 = MEM_RAMPROTR6SAVED;
   \   000002F6   0x9807             LDR      R0,[SP, #+28]
   \   000002F8   0x6178             STR      R0,[R7, #+20]
    521                  MEM->RAMPROTR7 = MEM_RAMPROTR7SAVED;
   \   000002FA   0x9806             LDR      R0,[SP, #+24]
   \   000002FC   0x61B8             STR      R0,[R7, #+24]
    522                  MEM->RAMPROTR8 = MEM_RAMPROTR8SAVED;
   \   000002FE   0x9805             LDR      R0,[SP, #+20]
   \   00000300   0x61F8             STR      R0,[R7, #+28]
    523                  MEM->RAMCR = MEM_RAMCRSAVED;
   \   00000302   0x9804             LDR      R0,[SP, #+16]
   \   00000304   0x62B8             STR      R0,[R7, #+40]
    524                  NVIC->ISER[0] = NVIC_ISERSAVED;
   \   00000306   0x9801             LDR      R0,[SP, #+4]
   \   00000308   0x6008             STR      R0,[R1, #+0]
    525                  SCB->VTOR = SCB_VTORSAVED;
   \   0000030A   0x....             LDR.N    R1,??DataTable4_8  ;; 0xe000ed04
   \   0000030C   0x9803             LDR      R0,[SP, #+12]
   \   0000030E   0x6048             STR      R0,[R1, #+4]
    526                  
    527                  /* PWR->WAKECR2/NVIC_IxxR_DEBUG and INT_IRQx is cleared by NVIC->ICPR[0] below */
    528                  NVIC->ICPR[0] = 0xFFFFFFFF;
   \   00000310   0xF04F 0x30FF      MOV      R0,#-1
   \   00000314   0x....             LDR.N    R1,??DataTable4_14  ;; 0xe000e280
   \   00000316   0x6008             STR      R0,[R1, #+0]
   \   00000318   0x....             LDR.N    R1,??DataTable4_12  ;; 0x4000b808
    529                  
    530                  /* Now that we're awake, normal interrupts are operational again
    531                     Take a snapshot of the new GPIO state and the EVENT register to
    532                     record our wake event*/
    533                  uint32_t GPIO_IN_NEW =   GPIOA->IDR;
   \   0000031A   0x....             LDR.N    R0,??DataTable4_11  ;; 0x4000b008
   \   0000031C   0x6802             LDR      R2,[R0, #+0]
    534                         GPIO_IN_NEW |= (GPIOB->IDR<<8);
   \   0000031E   0x....             LDR.N    R0,??DataTable4_9  ;; 0x4000b408
   \   00000320   0x6800             LDR      R0,[R0, #+0]
    535                         GPIO_IN_NEW |= (GPIOC->IDR<<16);
   \   00000322   0x6809             LDR      R1,[R1, #+0]
    536                  /* Only operate on power up events that are also wake events.  Power
    537                     up events will always trigger like an interrupt flag, so we have
    538                     to check them against events that are enabled for waking. (This is
    539                     a two step process because we're accessing two __IO values.)*/
    540                  uint32_t powerUpEvents = PWR->WAKESR;
   \   00000324   0x6A63             LDR      R3,[R4, #+36]
    541                         powerUpEvents &= PWR->WAKECR1;
   \   00000326   0x69E7             LDR      R7,[R4, #+28]
    542                  halInternalWakeEvent |= ((GPIO_IN_SAVED^GPIO_IN_NEW)&gpioWakeSel);
    543                  /* PWR_WAKESR_SC1 is PB2 which is bit 10 */
    544                  halInternalWakeEvent |= (!!(powerUpEvents&PWR_WAKESR_SC1))<<((1*8)+2);
    545                  /* PWR_WAKESR_SC2 is PA2 which is bit 2 */
    546                  halInternalWakeEvent |= (!!(powerUpEvents&PWR_WAKESR_SC2))<<((0*8)+2);
    547                  /* PWR_WAKESR_IRQD is chosen by EXTI->CR[1] */
    548                  halInternalWakeEvent |= (!!(powerUpEvents&PWR_WAKESR_IRQD))<<(EXTI->CR[1]);
   \   00000328   0xF8D5 0xC010      LDR      R12,[R5, #+16]
    549                  halInternalWakeEvent |= ((powerUpEvents & 
    550                                            (PWR_WAKESR_CSYSPWRRUPREQ  |
    551                                             PWR_WAKESR_CPWRRUPREQ  |
    552                                             PWR_WAKESR_CORE      |
    553                                             PWR_WAKESR_WRAP  |
    554                                             PWR_WAKESR_COMPB |
    555                                             PWR_WAKESR_COMPA ))
    556                                                    <<INTERNAL_WAKE_EVENT_BIT_SHIFT);
   \   0000032C   0xF8DD 0xE008      LDR      LR,[SP, #+8]
   \   00000330   0xEA42 0x2000      ORR      R0,R2,R0, LSL #+8
   \   00000334   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000338   0x9900             LDR      R1,[SP, #+0]
   \   0000033A   0xEA80 0x000E      EOR      R0,R0,LR
   \   0000033E   0x403B             ANDS     R3,R7,R3
   \   00000340   0x4008             ANDS     R0,R1,R0
   \   00000342   0x0859             LSRS     R1,R3,#+1
   \   00000344   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000348   0xEA40 0x2081      ORR      R0,R0,R1, LSL #+10
   \   0000034C   0x0899             LSRS     R1,R3,#+2
   \   0000034E   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000352   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   00000356   0x08D9             LSRS     R1,R3,#+3
   \   00000358   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000035C   0xFA01 0xF10C      LSL      R1,R1,R12
   \   00000360   0x4308             ORRS     R0,R1,R0
   \   00000362   0x6877             LDR      R7,[R6, #+4]
   \   00000364   0xF403 0x717C      AND      R1,R3,#0x3F0
   \   00000368   0xEA40 0x5001      ORR      R0,R0,R1, LSL #+20
   \   0000036C   0x4338             ORRS     R0,R0,R7
   \   0000036E   0x6070             STR      R0,[R6, #+4]
    557                  /* at this point wake events are fully captured and interrupts have
    558                     taken over handling all new events */
    559                  /* Bring limited interrupts back online.  INTERRUPTS_OFF will use
    560                     BASEPRI to disable all interrupts except fault handlers and PendSV.
    561                     PRIMASK is still set though (global interrupt disable) so we need
    562                     to clear that next.*/
    563                  INTERRUPTS_OFF();
   \   00000370   0x2060             MOVS     R0,#+96
   \   00000372   0xF380 0x8811      MSR      BASEPRI,R0
    564                  
    565                  /* Now that BASEPRI has taken control of interrupt enable/disable,
    566                     we can clear PRIMASK to reenable global interrupt operation.*/
    567                  __enable_irq();
   \   00000376   0xB662             CPSIE    I
    568                  
    569                  /* wake events are saved and interrupts are back on track,
    570                     disable gpio freeze */
    571                  PWR->DSLEEPCR1 = 0x00;
   \   00000378   0x2000             MOVS     R0,#+0
   \   0000037A   0x6020             STR      R0,[R4, #+0]
    572                  
    573                  /* restart watchdog if it was running when we entered sleep
    574                     do this before dispatching interrupts while we still have tight
    575                     control of code execution*/
    576                  if(restoreWatchdog) 
   \   0000037C   0xF89D 0x005C      LDRB     R0,[SP, #+92]
   \   00000380   0xB110             CBZ.N    R0,??halInternalSleep_22
    577                  {
    578                    WDG_Cmd(ENABLE);
   \   00000382   0x2001             MOVS     R0,#+1
   \   00000384   0x.... 0x....      BL       WDG_Cmd
    579                  }
    580                  
    581                  /* Pend any interrupts associated with deep sleep wake sources.  The
    582                     restoration of NVIC->ISER[0] above and the changing of BASEPRI below
    583                     is responsible for proper dispatching of interrupts at the end of
    584                     halSleepWithOptions.*/
    585          
    586                  /* The PWR->WAKECR2 wake source triggers a Debug Interrupt. If NVIC_IxxR_DEBUG
    587                     interrupt is enabled and PWR->WAKECR2 is a wake event, then pend the
    588                     Debug interrupt (using the wake_core bit).*/
    589                  if((NVIC->ISER[0]&NVIC_IxxR_DEBUG) &&
    590                      (halInternalWakeEvent&BIT(WAKECORE_INTERNAL_WAKE_EVENT_BIT)))
   \                     ??halInternalSleep_22: (+1)
   \   00000388   0x6870             LDR      R0,[R6, #+4]
   \   0000038A   0x....             LDR.N    R1,??DataTable4_10  ;; 0xe000e100
   \   0000038C   0x6809             LDR      R1,[R1, #+0]
   \   0000038E   0x03C9             LSLS     R1,R1,#+15
   \   00000390   0xD503             BPL.N    ??halInternalSleep_23
   \   00000392   0x0101             LSLS     R1,R0,#+4
   \   00000394   0xBF44             ITT      MI 
   \   00000396   0x2120             MOVMI    R1,#+32
   \   00000398   0x6221             STRMI    R1,[R4, #+32]
    591                  {
    592                    PWR->WAKECR2 = PWR_WAKECR2_COREWAKE;
    593                  }
    594          
    595                  /* The SleepTMR CMPA is linked to a real ISR.  If the SleepTMR CMPA
    596                     interrupt is enabled and CMPA is a wake event, then pend the CMPA
    597                     interrupt (force the second level interrupt).*/
    598                  if((SLPTMR->IER&SLPTMR_IER_CMPA) &&
    599                      (halInternalWakeEvent&BIT(CMPA_INTERNAL_WAKE_EVENT_BIT)))
   \                     ??halInternalSleep_23: (+1)
   \   0000039A   0xF8DA 0x1040      LDR      R1,[R10, #+64]
   \   0000039E   0x0789             LSLS     R1,R1,#+30
   \   000003A0   0xD504             BPL.N    ??halInternalSleep_24
   \   000003A2   0x01C1             LSLS     R1,R0,#+7
   \   000003A4   0xBF44             ITT      MI 
   \   000003A6   0x2102             MOVMI    R1,#+2
   \   000003A8   0xF8CA 0x100C      STRMI    R1,[R10, #+12]
    600                  {
    601                    SLPTMR->IFR = SLPTMR_IER_CMPA;
    602                  }
    603          
    604                  /* The SleepTMR CMPB is linked to a real ISR.  If the SleepTMR CMPB
    605                     interrupt is enabled and CMPB is a wake event, then pend the CMPB
    606                     interrupt (force the second level interrupt).*/
    607                  if((SLPTMR->IER&SLPTMR_IER_CMPB) &&
    608                      (halInternalWakeEvent&BIT(CMPB_INTERNAL_WAKE_EVENT_BIT)))
   \                     ??halInternalSleep_24: (+1)
   \   000003AC   0xF8DA 0x1040      LDR      R1,[R10, #+64]
   \   000003B0   0x0749             LSLS     R1,R1,#+29
   \   000003B2   0xD504             BPL.N    ??halInternalSleep_25
   \   000003B4   0x0181             LSLS     R1,R0,#+6
   \   000003B6   0xBF44             ITT      MI 
   \   000003B8   0x2104             MOVMI    R1,#+4
   \   000003BA   0xF8CA 0x100C      STRMI    R1,[R10, #+12]
    609                  {
    610                    SLPTMR->IFR = SLPTMR_IER_CMPB;
    611                  }
    612          
    613                  /* The SleepTMR WRAP is linked to a real ISR.  If the SleepTMR WRAP
    614                     interrupt is enabled and WRAP is a wake event, then pend the WRAP
    615                     interrupt (force the second level interrupt).*/
    616                  if((SLPTMR->IER&SLPTMR_IER_WRAP) &&
    617                      (halInternalWakeEvent&BIT(WRAP_INTERNAL_WAKE_EVENT_BIT)))
   \                     ??halInternalSleep_25: (+1)
   \   000003BE   0xF8DA 0x1040      LDR      R1,[R10, #+64]
   \   000003C2   0x07C9             LSLS     R1,R1,#+31
   \   000003C4   0xD504             BPL.N    ??halInternalSleep_26
   \   000003C6   0x0141             LSLS     R1,R0,#+5
   \   000003C8   0xBF44             ITT      MI 
   \   000003CA   0x2101             MOVMI    R1,#+1
   \   000003CC   0xF8CA 0x100C      STRMI    R1,[R10, #+12]
    618                  {
    619                    SLPTMR->IFR = SLPTMR_IER_WRAP;
    620                  }
    621          
    622                  /* The four IRQs are linked to a real ISR.  If any of the four IRQs
    623                     triggered, then pend their ISR */
    624                  /* If the IRQA interrupt mode is enabled and IRQA (PB0) is wake
    625                     event, then pend the interrupt. */
    626                  if(((EXTI->TSR[0]&EXTI_TSR_INTMOD)!=0) && (halInternalWakeEvent&BIT(PORTB_PIN(0))))
   \                     ??halInternalSleep_26: (+1)
   \   000003D0   0xF8D8 0x104C      LDR      R1,[R8, #+76]
   \   000003D4   0xF011 0x0FE0      TST      R1,#0xE0
   \   000003D8   0xD005             BEQ.N    ??halInternalSleep_27
   \   000003DA   0x05C1             LSLS     R1,R0,#+23
   \   000003DC   0xD503             BPL.N    ??halInternalSleep_27
    627                  {
    628                    NVIC->ISPR[0] = NVIC_IxxR_IRQA;
   \   000003DE   0x....             LDR.N    R2,??DataTable4_13  ;; 0xe000e200
   \   000003E0   0xF44F 0x5180      MOV      R1,#+4096
   \   000003E4   0x6011             STR      R1,[R2, #+0]
    629                  }
    630                  /* If the IRQB interrupt mode is enabled and IRQB (PB6) is wake
    631                     event, then pend the interrupt. */
    632                  if(((EXTI->TSR[1]&EXTI_TSR_INTMOD)!=0) && (halInternalWakeEvent&BIT(PORTB_PIN(6))))
   \                     ??halInternalSleep_27: (+1)
   \   000003E6   0xF8D8 0x1050      LDR      R1,[R8, #+80]
   \   000003EA   0xF011 0x0FE0      TST      R1,#0xE0
   \   000003EE   0xD005             BEQ.N    ??halInternalSleep_28
   \   000003F0   0x0441             LSLS     R1,R0,#+17
   \   000003F2   0xD503             BPL.N    ??halInternalSleep_28
    633                  {
    634                    NVIC->ISPR[0] = NVIC_IxxR_IRQB;
   \   000003F4   0x....             LDR.N    R2,??DataTable4_13  ;; 0xe000e200
   \   000003F6   0xF44F 0x5100      MOV      R1,#+8192
   \   000003FA   0x6011             STR      R1,[R2, #+0]
    635                  }
    636                  /* If the IRQC interrupt mode is enabled and IRQC (EXTI->CR[0]) is wake
    637                     event, then pend the interrupt. */
    638                  if(((EXTI->TSR[2]&EXTI_TSR_INTMOD)!=0) && (halInternalWakeEvent&BIT(EXTI->CR[0])))
   \                     ??halInternalSleep_28: (+1)
   \   000003FC   0xF8D8 0x1054      LDR      R1,[R8, #+84]
   \   00000400   0xF011 0x0FE0      TST      R1,#0xE0
   \   00000404   0xD008             BEQ.N    ??halInternalSleep_29
   \   00000406   0x68E9             LDR      R1,[R5, #+12]
   \   00000408   0xFA20 0xF201      LSR      R2,R0,R1
   \   0000040C   0x07D1             LSLS     R1,R2,#+31
   \   0000040E   0xD503             BPL.N    ??halInternalSleep_29
    639                  {
    640                    NVIC->ISPR[0] = NVIC_IxxR_IRQC;
   \   00000410   0x....             LDR.N    R2,??DataTable4_13  ;; 0xe000e200
   \   00000412   0xF44F 0x4180      MOV      R1,#+16384
   \   00000416   0x6011             STR      R1,[R2, #+0]
    641                  }
    642                  /* If the IRQD interrupt mode is enabled and IRQD (EXTI->CR[1]) is wake
    643                     event, then pend the interrupt. */
    644                  if(((EXTI->TSR[3]&EXTI_TSR_INTMOD)!=0) && (halInternalWakeEvent&BIT(EXTI->CR[1])))
   \                     ??halInternalSleep_29: (+1)
   \   00000418   0xF8D8 0x1058      LDR      R1,[R8, #+88]
   \   0000041C   0xF011 0x0FE0      TST      R1,#0xE0
   \   00000420   0xD008             BEQ.N    ??halInternalSleep_30
   \   00000422   0x6929             LDR      R1,[R5, #+16]
   \   00000424   0xFA20 0xF201      LSR      R2,R0,R1
   \   00000428   0x07D1             LSLS     R1,R2,#+31
   \   0000042A   0xD503             BPL.N    ??halInternalSleep_30
    645                  {
    646                    NVIC->ISPR[0] = NVIC_IxxR_IRQD;
   \   0000042C   0x....             LDR.N    R2,??DataTable4_13  ;; 0xe000e200
   \   0000042E   0xF44F 0x4100      MOV      R1,#+32768
   \   00000432   0x6011             STR      R1,[R2, #+0]
    647                  }
    648          
    649                  /* Due to FogBugz 11909/11920, SLEEPTMR_CNT may not have updated yet so
    650                     we must ensure that the CNT register updates before returning.  It's
    651                     only necessary to wait for the CNT to update when we've gone to
    652                     sleep, the SLEEPTMR is enabled, and the sleep mode used a timer.
    653                     This code could delay for up to 1ms, but will return as soon as it
    654                     can.  In the situation where the chip slept for a known amount of
    655                     time, this code will not delay and instead the system timer will
    656                     report a fake, but accurate time.*/
    657                  if((!skipSleep) && (SLPTMR->CR&SLPTMR_CR_EN) &&
    658                     (CLK->SLEEPCR&CLK_SLEEPCR_LSI10KEN) && (sleepMode!=SLEEPMODE_NOTIMER))
   \                     ??halInternalSleep_30: (+1)
   \   00000434   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000438   0xD159             BNE.N    ??halInternalSleep_31
   \   0000043A   0x....             LDR.N    R1,??DataTable4_15  ;; 0x4000600c
   \   0000043C   0x6809             LDR      R1,[R1, #+0]
   \   0000043E   0x0509             LSLS     R1,R1,#+20
   \   00000440   0xD555             BPL.N    ??halInternalSleep_31
   \   00000442   0x6861             LDR      R1,[R4, #+4]
   \   00000444   0x0789             LSLS     R1,R1,#+30
   \   00000446   0xD552             BPL.N    ??halInternalSleep_31
   \   00000448   0xF89D 0x1068      LDRB     R1,[SP, #+104]
   \   0000044C   0x2904             CMP      R1,#+4
   \   0000044E   0xD04E             BEQ.N    ??halInternalSleep_31
    659                  {
    660                    uint32_t currSleepTmrCnt;
    661                    
    662                   #ifdef BUG11909_WORKAROUND_C
    663                    /* THIS WORKAROUND IS NOT PROVEN 100% RELIABLE.  THIS SHOULD NOT BE
    664                       USED UNTIL IT IS PROVEN PERFECTLY RELIABLE.
    665                       This workaround attempts to force the SLEEPTMR_CNT to tick sooner
    666                       than normal.  It does so by toggling between the clock sources
    667                       to get the CNT to increment.  There is a chance the SLEEPTMR_CNT
    668                       could become random doing this! */
    669                    {
    670                      currSleepTmrCnt = SLPTMR->CNTH<<16;
    671                      currSleepTmrCnt |= SLPTMR->CNTL;
    672                      if(currSleepTmrCnt == wakeupSleepTmrCnt) {
    673                        uint32_t GPIOC_ODRSAVED = GPIOC->ODR;
    674                        uint32_t GPIOC_CRHSAVED = GPIOC->CRH;
    675                        uint32_t SLPTMR_CRSAVED = SLPTMR->CR;
    676                        /* It is not necessary to do anything with CLK->SLEEPCR.*/
    677                        GPIOC->BSR = GPIO_BSR_BS7;
    678                        SET_REG_FIELD(GPIOC->CRH, GPIO_BSR_BS7, GPIO_Mode_OUT_PP, 12);
    679                        do {
    680                          /* Toggling between RC/XTAL will produce a clock edge
    681                             into the timer and cause CNT to increment.*/
    682                          SLPTMR->CR ^= SLPTMR_CR_CLKSEL;
    683                          currSleepTmrCnt = SLPTMR->CNTH<<16;
    684                          currSleepTmrCnt |= SLPTMR->CNTL;
    685                        } while(currSleepTmrCnt == wakeupSleepTmrCnt);
    686                        GPIOC->ODR = GPIOC_ODRSAVED;
    687                        GPIOC->CRH = GPIOC_CRHSAVED;
    688                        SLPTMR->CR = SLPTMR_CRSAVED;
    689                        forceSleepTmrCnt = FALSE;
    690                      }
    691                    }
    692                    #endif /* BUG11909_WORKAROUND_C */
    693                    
    694                    /* Knowing that halSleepTimerIsr is about to be taken (when
    695                       interrupts get enabled) tells us that the chip woke up due
    696                       to the timer and therefore sleepTmrArtificalCnt is valid
    697                       and needs to be forced.  This allows us to bypass delaying
    698                       for SLEEPTMR_CNT to tick forward.  For FogBugz 11909/11920
    699                       workaround.*/
    700                    if((NVIC->ISER[0]&NVIC_IxxR_SLEEPTMR) && (NVIC->ISPR[0]&NVIC_IxxR_SLEEPTMR)) {
   \   00000450   0x....             LDR.N    R1,??DataTable4_10  ;; 0xe000e100
   \   00000452   0x6809             LDR      R1,[R1, #+0]
   \   00000454   0x06C9             LSLS     R1,R1,#+27
   \   00000456   0xD52B             BPL.N    ??halInternalSleep_32
   \   00000458   0x....             LDR.N    R1,??DataTable4_13  ;; 0xe000e200
   \   0000045A   0x6809             LDR      R1,[R1, #+0]
   \   0000045C   0x06C9             LSLS     R1,R1,#+27
   \   0000045E   0xD527             BPL.N    ??halInternalSleep_32
    701                      /* sleepTmrArtificalCnt was set before sleeping
    702                         by halSleepForQuarterSeconds */
    703                      forceSleepTmrCnt = TRUE;
   \   00000460   0x2101             MOVS     R1,#+1
   \   00000462   0x7031             STRB     R1,[R6, #+0]
   \   00000464   0xE043             B.N      ??halInternalSleep_31
    704                    } else {
   \                     ??halInternalSleep_19: (+1)
   \   00000466   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000046A   0xF47F 0xAF0E      BNE.W    ??halInternalSleep_20
   \   0000046E   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   00000472   0x....             LDR.N    R1,??DataTable4_8  ;; 0xe000ed04
   \   00000474   0x....             LDR.N    R2,??DataTable4_8  ;; 0xe000ed04
   \   00000476   0x0840             LSRS     R0,R0,#+1
   \   00000478   0x0040             LSLS     R0,R0,#+1
   \   0000047A   0xF8C9 0x0018      STR      R0,[R9, #+24]
   \   0000047E   0x....             LDR.N    R0,??DataTable4_8  ;; 0xe000ed04
   \   00000480   0x68C0             LDR      R0,[R0, #+12]
   \   00000482   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000486   0x60C8             STR      R0,[R1, #+12]
   \   00000488   0x2101             MOVS     R1,#+1
   \   0000048A   0x....             LDR.N    R0,??DataTable4_16
   \   0000048C   0x7001             STRB     R1,[R0, #+0]
   \   0000048E   0x....             LDR.N    R1,??DataTable4_8  ;; 0xe000ed04
   \   00000490   0x6809             LDR      R1,[R1, #+0]
   \   00000492   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000496   0x6011             STR      R1,[R2, #+0]
   \                     ??halInternalSleep_33: (+1)
   \   00000498   0x7801             LDRB     R1,[R0, #+0]
   \   0000049A   0x2900             CMP      R1,#+0
   \   0000049C   0xD1FC             BNE.N    ??halInternalSleep_33
   \   0000049E   0x....             LDR.N    R0,??DataTable4_15  ;; 0x4000600c
   \   000004A0   0x....             LDR.N    R1,??DataTable4_15  ;; 0x4000600c
   \   000004A2   0x6840             LDR      R0,[R0, #+4]
   \   000004A4   0x0400             LSLS     R0,R0,#+16
   \   000004A6   0x60B0             STR      R0,[R6, #+8]
   \   000004A8   0x6889             LDR      R1,[R1, #+8]
   \   000004AA   0x4308             ORRS     R0,R1,R0
   \   000004AC   0x60B0             STR      R0,[R6, #+8]
   \   000004AE   0xE6F1             B.N      ??halInternalSleep_21
    705                      uint16_t us = 1000;
    706                      uint32_t beginTime;
    707                      forceSleepTmrCnt = FALSE;
   \                     ??halInternalSleep_32: (+1)
   \   000004B0   0x2200             MOVS     R2,#+0
   \   000004B2   0x7032             STRB     R2,[R6, #+0]
   \   000004B4   0xF44F 0x717A      MOV      R1,#+1000
    708                      /* It is possible to be in a situation where the SLEEPTMR is no
    709                         longer ticking (32k XTAL issues).  To guard against getting
    710                         stuck in this loop, use the MAC Timer to timeout after 1ms (since
    711                         that is the maximum time this loop would normally delay for).*/
    712                      MACTMR->CR |= MACTMR_CR_EN;
   \   000004B8   0x....             LDR.N    R2,??DataTable4_17  ;; 0x40002038
   \   000004BA   0x6D53             LDR      R3,[R2, #+84]
   \   000004BC   0xF043 0x0301      ORR      R3,R3,#0x1
   \   000004C0   0x6553             STR      R3,[R2, #+84]
    713                      if((CLK->HSECR2&CLK_HSECR2_SW1)!=CLK_HSECR2_SW1) {
   \   000004C2   0xF8D9 0x3018      LDR      R3,[R9, #+24]
   \   000004C6   0x07DB             LSLS     R3,R3,#+31
    714                        us >>= 1;
    715                      }
    716                      beginTime = MACTMR->CNTR;
   \   000004C8   0x6813             LDR      R3,[R2, #+0]
   \   000004CA   0xBF58             IT       PL 
   \   000004CC   0xF44F 0x71FA      MOVPL    R1,#+500
    717                      do{
    718                        currSleepTmrCnt = SLPTMR->CNTH<<16;
   \                     ??halInternalSleep_34: (+1)
   \   000004D0   0x....             LDR.N    R4,??DataTable4_15  ;; 0x4000600c
    719                        currSleepTmrCnt |= SLPTMR->CNTL;
   \   000004D2   0x....             LDR.N    R5,??DataTable4_15  ;; 0x4000600c
   \   000004D4   0x6864             LDR      R4,[R4, #+4]
   \   000004D6   0x68AD             LDR      R5,[R5, #+8]
    720                      }while((currSleepTmrCnt == wakeupSleepTmrCnt) &&
    721                             (((MACTMR->CNTR - beginTime)&MACTMR_CNTR_CNT) < us));
   \   000004D8   0xEA45 0x4404      ORR      R4,R5,R4, LSL #+16
   \   000004DC   0x68B5             LDR      R5,[R6, #+8]
   \   000004DE   0x42AC             CMP      R4,R5
   \   000004E0   0xD105             BNE.N    ??halInternalSleep_31
   \   000004E2   0x6814             LDR      R4,[R2, #+0]
   \   000004E4   0x1AE4             SUBS     R4,R4,R3
   \   000004E6   0x0324             LSLS     R4,R4,#+12
   \   000004E8   0x0B24             LSRS     R4,R4,#+12
   \   000004EA   0x428C             CMP      R4,R1
   \   000004EC   0xD3F0             BCC.N    ??halInternalSleep_34
    722                    }
    723                  }
    724                }
    725          
    726                /* Mark the wake events valid just before exiting */
    727                halInternalWakeEvent |= BIT32(WAKEINFOVALID_INTERNAL_WAKE_EVENT_BIT);
   \                     ??halInternalSleep_31: (+1)
   \   000004EE   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   000004F2   0x6070             STR      R0,[R6, #+4]
    728                
    729                /* We are now reconfigured, appropriate ISRs are pended, and ready to go,
    730                   so enable interrupts! */
    731                INTERRUPTS_ON();
   \   000004F4   0x2000             MOVS     R0,#+0
   \   000004F6   0xF380 0x8811      MSR      BASEPRI,R0
    732                
    733                break; /* and deep sleeping is done! */
   \   000004FA   0xE01A             B.N      ??halInternalSleep_35
    734              
    735              case SLEEPMODE_IDLE:
    736                /* Only the CPU is idled.  The rest of the chip continues runing
    737                   normally.  The chip will wake from any interrupt.*/
    738                {
    739                  boolean restoreWatchdog = WDG_GetStatus();
   \                     ??halInternalSleep_3: (+1)
   \   000004FC   0x.... 0x....      BL       WDG_GetStatus
   \   00000500   0x4604             MOV      R4,R0
    740                  /* disable watchdog while sleeping (since we can't reset it asleep)*/
    741                  WDG_Cmd(DISABLE);
   \   00000502   0x2000             MOVS     R0,#+0
   \   00000504   0x.... 0x....      BL       WDG_Cmd
    742                  /* Normal ATOMIC/INTERRUPTS_OFF/INTERRUPTS_ON uses the BASEPRI mask
    743                     to juggle priority levels so that the fault handlers can always
    744                     be serviced.  But, the WFI instruction is only capable of
    745                     working with the PRIMASK bit.  Therefore, we have to switch from
    746                     using BASEPRI to PRIMASK to keep interrupts disabled so that the
    747                     WFI can return on an interrupt
    748                     Globally disable interrupts with PRIMASK */
    749                  __disable_irq();
   \   00000508   0xB672             CPSID    I
    750                  /* Bring the BASEPRI up to 0 to allow interrupts (but still disabled
    751                     with PRIMASK)*/
    752                  INTERRUPTS_ON();
   \   0000050A   0x2000             MOVS     R0,#+0
   \   0000050C   0xF380 0x8811      MSR      BASEPRI,R0
    753                  /* an internal function call is made here instead of injecting the
    754                  "WFI" assembly instruction because injecting assembly code will
    755                  cause the compiler's optimizer to reduce efficiency.*/
    756          #ifdef FLASH_ACCESS_FLASH_LP
    757                  BYPASS_MPU(
    758                             uint32_t FLASH_ACCESS_SAVED = FLASH_ACCESS;
    759                             FLASH->ACR&= ~FLASH_ACCESS_FLASH_LP;
    760                             halInternalIdleSleep();
    761                             FLASH->ACR= FLASH_ACCESS_SAVED;
    762                             )
    763          #else
    764                  halInternalIdleSleep();
   \   00000510   0x.... 0x....      BL       halInternalIdleSleep
    765          #endif /* FLASH_ACCESS_FLASH_LP */
    766                  /* restart watchdog if it was running when we entered sleep */
    767                  if(restoreWatchdog)
   \   00000514   0xB114             CBZ.N    R4,??halInternalSleep_36
    768                    WDG_Cmd(ENABLE);
   \   00000516   0x2001             MOVS     R0,#+1
   \   00000518   0x.... 0x....      BL       WDG_Cmd
    769                  /* The WFI instruction does not actually clear the PRIMASK bit, it
    770                     only allows the PRIMASK bit to be bypassed.  Therefore, we must
    771                     manually clear PRIMASK to reenable all interrupts.*/
    772                  __enable_irq();
   \                     ??halInternalSleep_36: (+1)
   \   0000051C   0xB662             CPSIE    I
    773                }
    774                break;
   \   0000051E   0xE008             B.N      ??halInternalSleep_35
    775                
    776              default:
    777                /* Oops! Invalid sleepMode parameter.*/
    778                assert(0);
   \                     ??halInternalSleep_4: (+1)
   \   00000520   0xF240 0x320A      MOVW     R2,#+778
   \   00000524   0x.... 0x....      ADR.W    R1,?_1
   \   00000528   0x....             ADR.N    R0,??DataTable4  ;; "0"
   \   0000052A   0x.... 0x....      BL       __aeabi_assert
   \   0000052E   0x.... 0x....      BL       __iar_EmptyStepPoint
    779            }
    780          }
   \                     ??halInternalSleep_35: (+1)
   \   00000532   0xB01B             ADD      SP,SP,#+108
   \   00000534   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    781          
    782          /**
    783            * @brief Configures the sleep mode option.
    784            * @param PWR_SleepMode selects the sleep mode 
    785            *        This parameter can be any of the @ref PWR_SleepModes_TypeDef enumeration.
    786            * @param gpioWakeBitMask selects the gpio wake bit mask 
    787            * @retval None
    788            */

   \                                 In section .text, align 2, keep-with-next
    789          void halSleepWithOptions(SleepModes sleepMode, uint32_t gpioWakeBitMask)
    790          {
    791            /* configure all GPIO wake sources */
    792            PWR->WAKEPAR = (gpioWakeBitMask>>0)&0xFF;
   \                     halSleepWithOptions: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable4_3  ;; 0x4000bc08
   \   00000002   0xB2CB             UXTB     R3,R1
   \   00000004   0x6013             STR      R3,[R2, #+0]
    793            PWR->WAKEPBR = (gpioWakeBitMask>>8)&0xFF;
   \   00000006   0xF3C1 0x2307      UBFX     R3,R1,#+8,#+8
   \   0000000A   0x6053             STR      R3,[R2, #+4]
    794            PWR->WAKEPCR = (gpioWakeBitMask>>16)&0xFF;
   \   0000000C   0xF3C1 0x4107      UBFX     R1,R1,#+16,#+8
   \   00000010   0x6091             STR      R1,[R2, #+8]
    795            
    796            /* use the defines found in the board file to choose our wakeup source(s)*/
    797            PWR->WAKECR1 = 0;  /* start with no wake sources */
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable4_18  ;; 0x40000020
   \   00000016   0x600B             STR      R3,[R1, #+0]
    798            
    799            /* if any of the GPIO wakeup monitor bits are set, enable the top level
    800               GPIO wakeup monitor */
    801            if((PWR->WAKEPAR)||(PWR->WAKEPBR)||(PWR->WAKEPCR))
   \   00000018   0x6813             LDR      R3,[R2, #+0]
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0x6853             LDREQ    R3,[R2, #+4]
   \   00000020   0x2B00             CMPEQ    R3,#+0
   \   00000022   0xD101             BNE.N    ??halSleepWithOptions_0
   \   00000024   0x6892             LDR      R2,[R2, #+8]
   \   00000026   0xB11A             CBZ.N    R2,??halSleepWithOptions_1
    802            {
    803              PWR->WAKECR1 |= PWR_WAKECR1_MONEN;
   \                     ??halSleepWithOptions_0: (+1)
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000002E   0x600A             STR      R2,[R1, #+0]
    804            }
    805            /* NOTE: The use of PWR_WAKECR1_CPWRRUPREQ should not be necessary since asserting
    806               CDBGPWRUPREQ will bring the chip to DS0 where the debug components are
    807               maintained but it's not necessary to completely wake to the running state.*/
    808            
    809            /* always wakeup when the debugger attempts to access the chip */
    810            PWR->WAKECR1 |= PWR_WAKECR1_CSYSPWRRUPREQ;
   \                     ??halSleepWithOptions_1: (+1)
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000036   0x600A             STR      R2,[R1, #+0]
    811          
    812            /* always wakeup when the debug channel attempts to access the chip */
    813            PWR->WAKECR1 |= PWR_WAKECR1_CORE;
   \   00000038   0x680A             LDR      R2,[R1, #+0]
   \   0000003A   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000003E   0x600A             STR      R2,[R1, #+0]
    814            /* the timer wakeup sources are enabled below in POWERSAVE, if needed */
    815            
    816            /* wake sources are configured so do the actual sleeping */
    817            halInternalSleep(sleepMode);
   \   00000040   0x....             B.N      halInternalSleep
    818          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x30 0x00          DC8      "0",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     forceSleepTmrCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40000004         DC32     0x40000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x4000BC08         DC32     0x4000bc08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x4000A014         DC32     0x4000a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x4000A814         DC32     0x4000a814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40004004         DC32     0x40004004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x4000B408         DC32     0x4000b408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x4000B008         DC32     0x4000b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x4000B808         DC32     0x4000b808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x4000600C         DC32     0x4000600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0x........         DC32     halPendSvSaveContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0x40002038         DC32     0x40002038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_18:
   \   00000000   0x40000020         DC32     0x40000020

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_0:
   \   00000000   0x30 0x00          DC8 "0"

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x4A          DC8 5CH, 4AH, 6FH, 6EH, 5CH, 44H, 6FH, 63H
   \              0x6F 0x6E    
   \              0x5C 0x44    
   \              0x6F 0x63    
   \   00000010   0x75 0x6D          DC8 75H, 6DH, 65H, 6EH, 74H, 73H, 5CH, 4DH
   \              0x65 0x6E    
   \              0x74 0x73    
   \              0x5C 0x4D    
   \   00000018   0x4F 0x5F          DC8 4FH, 5FH, 53H, 5FH, 61H, 6EH, 64H, 5FH
   \              0x53 0x5F    
   \              0x61 0x6E    
   \              0x64 0x5F    
   \   00000020   0x54 0x5C          DC8 54H, 5CH, 43H, 70H, 45H, 35H, 31H, 37H
   \              0x43 0x70    
   \              0x45 0x35    
   \              0x31 0x37    
   \   00000028   0x30 0x5F          DC8 30H, 5FH, 52H, 54H, 5FH, 53H, 79H, 73H
   \              0x52 0x54    
   \              0x5F 0x53    
   \              0x79 0x73    
   \   00000030   0x74 0x65          DC8 74H, 65H, 6DH, 73H, 5CH, 4CH, 61H, 62H
   \              0x6D 0x73    
   \              0x5C 0x4C    
   \              0x61 0x62    
   \   00000038   0x73 0x5C          DC8 73H, 5CH, 63H, 70H, 65H, 2DH, 35H, 31H
   \              0x63 0x70    
   \              0x65 0x2D    
   \              0x35 0x31    
   \   00000040   0x37 0x30          DC8 37H, 30H, 2DH, 6DH, 6FH, 74H, 65H, 2DH
   \              0x2D 0x6D    
   \              0x6F 0x74    
   \              0x65 0x2D    
   \   00000048   0x63 0x6F          DC8 63H, 6FH, 64H, 65H, 5CH, 55H, 74H, 69H
   \              0x64 0x65    
   \              0x5C 0x55    
   \              0x74 0x69    
   \   00000050   0x6C 0x69          DC8 6CH, 69H, 74H, 69H, 65H, 73H, 5CH, 53H
   \              0x74 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000058   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 57H, 31H, 30H, 38H
   \              0x33 0x32    
   \              0x57 0x31    
   \              0x30 0x38    
   \   00000060   0x78 0x78          DC8 78H, 78H, 5FH, 48H, 41H, 4CH, 5FH, 44H
   \              0x5F 0x48    
   \              0x41 0x4C    
   \              0x5F 0x44    
   \   00000068   0x72 0x69          DC8 72H, 69H, 76H, 65H, 72H, 5CH, 6DH, 69H
   \              0x76 0x65    
   \              0x72 0x5C    
   \              0x6D 0x69    
   \   00000070   0x63 0x72          DC8 63H, 72H, 6FH, 5CH, 63H, 6FH, 72H, 74H
   \              0x6F 0x5C    
   \              0x63 0x6F    
   \              0x72 0x74    
   \   00000078   0x65 0x78          DC8 65H, 78H, 6DH, 33H, 5CH, 73H, 6CH, 65H
   \              0x6D 0x33    
   \              0x5C 0x73    
   \              0x6C 0x65    
   \   00000080   0x65 0x70          DC8 65H, 70H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   00000085   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    819          
    820          /**
    821            * @}
    822            */
    823          
    824          /**
    825            * @}
    826            */ 
    827          
    828          /**
    829            * @}
    830            */
    831          
    832          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halGetWakeInfo
     144   halInternalSleep
       144   -> WDG_Cmd
       144   -> WDG_GetStatus
       144   -> __aeabi_assert
       144   -> __iar_EmptyStepPoint
       144   -> halInternalIdleSleep
       0   halSleepWithOptions
         0   -> halInternalSleep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  ?_0
     136  ?_1
      12  forceSleepTmrCnt
          halInternalWakeEvent
          wakeupSleepTmrCnt
       8  halGetWakeInfo
    1336  halInternalSleep
      66  halSleepWithOptions

 
    12 bytes in section .bss
     2 bytes in section .rodata
 1 622 bytes in section .text
 
 1 622 bytes of CODE  memory
     2 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
