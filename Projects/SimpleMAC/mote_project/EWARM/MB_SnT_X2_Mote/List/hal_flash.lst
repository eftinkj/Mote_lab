###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:26:44
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_flash.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_flash.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"hal_flash.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\hal_flash.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\hal_flash.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    hal-flash.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012 
      7            * @brief   Implements the generic hal flash manipulation routines.
      8            *
      9            *  @verbatim
     10            *
     11            *
     12              ===========================================================================
     13               ## Definition and description of public hal flash manipulation routines.##
     14              ===========================================================================
     15                [..]
     16                (#)  During an erase or a write the flash is not available,
     17                 which means code will not be executable from flash. These routines still
     18                 execute from flash, though, since the bus architecture can support doing so.
     19                 (+) This also means all interrupts will be disabled.
     20                 (+) Hardware documentation indicates 40us for a write and 21ms for an erase.
     21                 (+) See hal_flash.h for source code.
     22                        
     23              @endverbatim
     24            ******************************************************************************
     25            ******************************************************************************
     26            * @attention
     27            *
     28            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     29            *
     30            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     31            * You may not use this file except in compliance with the License.
     32            * You may obtain a copy of the License at:
     33            *
     34            *        http://www.st.com/software_license_agreement_liberty_v2
     35            *
     36            * Unless required by applicable law or agreed to in writing, software 
     37            * distributed under the License is distributed on an "AS IS" BASIS, 
     38            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     39            * See the License for the specific language governing permissions and
     40            * limitations under the License.
     41            *
     42            ******************************************************************************
     43            */
     44          
     45          /* Includes ------------------------------------------------------------------*/
     46          
     47          #include PLATFORM_HEADER
     48          #include "error.h"
     49          #include "fib-bootloader.h"
     50          #include "mpu.h"
     51          #include "memmap.h"
     52          #include "hal_flash.h"
     53          
     54          /** @addtogroup HAL
     55            * @{
     56            */
     57          
     58          /** @defgroup hal_flash
     59            * @brief hal_flash modules
     60            * @{
     61            */
     62          
     63          /* Private typedef -----------------------------------------------------------*/
     64          /* A translation table used to convert FibStatus codes to corresponding
     65             StStatus values */

   \                                 In section .text, align 4, keep-with-next
     66          static const StStatus fibToStStatus[] = {
   \                     fibToStStatus:
   \   00000000   0x00 0x02          DC8 0, 2, 2, 2, 75, 75, 70, 71
   \              0x02 0x02    
   \              0x4B 0x4B    
   \              0x46 0x47    
     67            ST_SUCCESS,                    /* FIB_SUCCESS             0 */
     68            ST_BAD_ARGUMENT,               /* FIB_ERR_UNALIGNED       1 */
     69            ST_BAD_ARGUMENT,               /* FIB_ERR_INVALID_ADDRESS 2 */
     70            ST_BAD_ARGUMENT,               /* FIB_ERR_INVALID_TYPE    3 */
     71            ST_ERR_FLASH_PROG_FAIL,        /* FIB_ERR_WRITE_PROTECTED 4 */
     72            ST_ERR_FLASH_PROG_FAIL,        /* FIB_ERR_WRITE_FAILED    5 */
     73            ST_ERR_FLASH_WRITE_INHIBITED,  /* FIB_ERR_ERASE_REQUIRED  6 */
     74            ST_ERR_FLASH_VERIFY_FAILED     /* FIB_ERR_VERIFY_FAILED   7 */
     75          };
     76          /* Private defines -----------------------------------------------------------*/
     77          /* Private macros ------------------------------------------------------------*/
     78          /* External variables --------------------------------------------------------*/

   \                                 In section .bss, align 1
     79          boolean flashEraseIsActive = FALSE;
   \                     flashEraseIsActive:
   \   00000000                      DS8 1
     80          
     81          /* Private function prototypes -----------------------------------------------*/
     82          /* Private functions ---------------------------------------------------------*/
     83          
     84          /** @defgroup  hal_flash_Private_Functions
     85            * @{
     86            */
     87          
     88          /**
     89            * @brief The purpose of flashEraseIsActive and halFlashEraseIsActive() is so that
     90            * interrupts can query the flash library to find out of Flash Erase is
     91            * active when their ISR gets invoked.  This is useful because Flash Erase
     92            * causes the chip to go ATOMIC for 21ms and this delay will disrupt interrupt
     93            * latency. By having a sinple API that an ISR can query for this state,
     94            * the ISR can appriopriately adjust for a 21ms latency time.
     95            */

   \                                 In section .text, align 2, keep-with-next
     96          boolean halFlashEraseIsActive(void)
     97          {
     98            return flashEraseIsActive;
   \                     halFlashEraseIsActive: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          static boolean verifyFib(void)
    102          {
    103            /* Ensure that a programmed FIB of a proper version is present */
    104            return ( (halFixedAddressTable.baseTable.type == FIXED_ADDRESS_TABLE_TYPE) &&
    105                     ( ( (halFixedAddressTable.baseTable.version & FAT_MAJOR_VERSION_MASK) 
    106                         == 0x0000 ) &&
    107                       (halFixedAddressTable.baseTable.version >= 0x0002) 
    108                     )
    109                   );
   \                     verifyFib: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_1
   \   00000002   0x8A01             LDRH     R1,[R0, #+16]
   \   00000004   0xF640 0x72A7      MOVW     R2,#+4007
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xBF02             ITTT     EQ 
   \   0000000C   0x8A40             LDRHEQ   R0,[R0, #+18]
   \   0000000E   0xF44F 0x417F      MOVEQ    R1,#+65280
   \   00000012   0x4208             TSTEQ    R0,R1
   \   00000014   0xD103             BNE.N    ??verifyFib_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xDB01             BLT.N    ??verifyFib_0
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR
   \                     ??verifyFib_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
    110          }
    111          
    112          /* The parameter 'eraseType' chooses which erasure will be performed while
    113             the 'address' parameter chooses the page to be erased during MFB page erase. */

   \                                 In section .text, align 2, keep-with-next
    114          StStatus halInternalFlashErase(uint8_t eraseType, uint32_t address)
    115          {
   \                     halInternalFlashErase: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
    116            FibStatus status;
    117            
    118            ATOMIC(
    119              BYPASS_MPU(
    120                flashEraseIsActive = TRUE;
    121           
    122                  assert(verifyFib());
    123                  status = halFixedAddressTable.fibFlashErase(
    124                                                     (((uint32_t)eraseType) | DO_ERASE), 
    125                                                     address);
    126              )
    127            )
   \   00000008   0xF3EF 0x8611      MRS      R6,BASEPRI
   \   0000000C   0x2060             MOVS     R0,#+96
   \   0000000E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000012   0x....             LDR.N    R7,??DataTable6
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7038             STRB     R0,[R7, #+0]
   \   00000018   0x.... 0x....      BL       verifyFib
   \   0000001C   0xB920             CBNZ.N   R0,??halInternalFlashErase_0
   \   0000001E   0x227F             MOVS     R2,#+127
   \   00000020   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000024   0x.... 0x....      BL       __iar_EmptyStepPoint
   \                     ??halInternalFlashErase_0: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable6_1
   \   0000002A   0x6A85             LDR      R5,[R0, #+40]
   \   0000002C   0x4641             MOV      R1,R8
   \   0000002E   0xF444 0x7080      ORR      R0,R4,#0x100
   \   00000032   0x47A8             BLX      R5
   \   00000034   0xB2F6             UXTB     R6,R6
   \   00000036   0xF386 0x8811      MSR      BASEPRI,R6
    128            /* If there are any interrupts pending that could have been delayed for 21ms,
    129               they will be serviced here since we exit the ATOMIC block.  These ISRs
    130               can query the flash library and find out that erasing is active.  After
    131               this point, we're no longer ATOMIC/disrupting latency so our erase
    132               active flag should be cleared. */
    133            flashEraseIsActive = FALSE;
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x7039             STRB     R1,[R7, #+0]
    134            
    135            if(status!=FIB_SUCCESS) {
   \   0000003E   0x.... 0x....      ADR.W    R6,fibToStStatus
   \   00000042   0xB918             CBNZ.N   R0,??halInternalFlashErase_1
    136              return fibToStStatus[status];
    137            }
    138              status = halFixedAddressTable.fibFlashErase(
    139                                                  (((uint32_t)eraseType) | DO_VERIFY), 
    140                                                  address);
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0xF444 0x7000      ORR      R0,R4,#0x200
   \   0000004A   0x47A8             BLX      R5
    141            return fibToStStatus[status];
   \                     ??halInternalFlashErase_1: (+1)
   \   0000004C   0x5D80             LDRB     R0,[R0, R6]
   \   0000004E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    142          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,?_1
   \   00000004   0x.... 0x....      ADR.W    R0,?_0
   \   00000008   0x.... 0x....      B.W      __aeabi_assert
    143          
    144          
    145            /*The parameter 'address' defines the starting address of where the
    146              programming will occur - this parameter MUST be half-word aligned since all
    147              programming operations are HW.  The parameter 'data' is a pointer to a buffer
    148              containin the 16bit half-words to be written.  Length is the number of 16bit
    149              half-words contained in 'data' to be written to flash.
    150              NOTE: This function can NOT write the option bytes and will throw an error
    151              if that is attempted.*/

   \                                 In section .text, align 2, keep-with-next
    152          StStatus halInternalFlashWrite(uint32_t address, uint16_t * data, uint32_t length)
    153          {
   \                     halInternalFlashWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
    154            FibStatus status;
    155              
    156            length = length * 2;  /* fib routines specify length in bytes */
   \   00000008   0x0056             LSLS     R6,R2,#+1
    157            
    158            ATOMIC(
    159              BYPASS_MPU( 
    160                  /* Ensure that a programmed FIB of a proper version is present */
    161                  assert(verifyFib());
    162                  status = halFixedAddressTable.fibFlashWrite(address, 
    163                                                              (uint8_t *)data, 
    164                                                              length,
    165                                                              0);
    166              )
    167            )
   \   0000000A   0xF3EF 0x8711      MRS      R7,BASEPRI
   \   0000000E   0x2060             MOVS     R0,#+96
   \   00000010   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000014   0x.... 0x....      BL       verifyFib
   \   00000018   0xB920             CBNZ.N   R0,??halInternalFlashWrite_0
   \   0000001A   0x22A7             MOVS     R2,#+167
   \   0000001C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000020   0x.... 0x....      BL       __iar_EmptyStepPoint
   \                     ??halInternalFlashWrite_0: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable6_1
   \   00000026   0x6A45             LDR      R5,[R0, #+36]
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x4632             MOV      R2,R6
   \   0000002C   0x4641             MOV      R1,R8
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x47A8             BLX      R5
   \   00000032   0xB2FF             UXTB     R7,R7
   \   00000034   0xF387 0x8811      MSR      BASEPRI,R7
    168            
    169            if(status!=FIB_SUCCESS) {
   \   00000038   0x.... 0x....      ADR.W    R7,fibToStStatus
   \   0000003C   0xB920             CBNZ.N   R0,??halInternalFlashWrite_1
    170              return fibToStStatus[status];
    171            }
    172              status = halFixedAddressTable.fibFlashWrite(address,
    173                                                          (uint8_t *)data,
    174                                                          0,
    175                                                          length);
   \   0000003E   0x4633             MOV      R3,R6
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x47A8             BLX      R5
    176            
    177            return fibToStStatus[status];
   \                     ??halInternalFlashWrite_1: (+1)
   \   00000048   0x5DC0             LDRB     R0,[R0, R7]
   \   0000004A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    178          }
    179          
    180          
    181          /* The parameter 'byte' is the option byte number to be programmed.  This
    182             parameter can have a value of 0 through 7.  'data' is the 8bit value to be
    183             programmed into the option byte since the hardware will calculate the
    184             compliment and program the full 16bit option byte. */

   \                                 In section .text, align 2, keep-with-next
    185          StStatus halInternalCibOptionByteWrite(uint8_t byte, uint8_t data)
    186          {
   \                     halInternalCibOptionByteWrite: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    187            uint16_t dataAndInverse = HIGH_LOW_TO_INT(~data, data);
   \   00000002   0x43CA             MVNS     R2,R1
   \   00000004   0xEB01 0x2102      ADD      R1,R1,R2, LSL #+8
    188            /* There are only 8 option bytes, don't try to program more than that. */
    189            if (byte > 7) {
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \   0000000E   0xDB01             BLT.N    ??halInternalCibOptionByteWrite_0
    190              return ST_ERR_FLASH_PROG_FAIL;
   \   00000010   0x204B             MOVS     R0,#+75
   \   00000012   0xBD02             POP      {R1,PC}
    191            }
    192            return halInternalFlashWrite(CIB_OB_BOTTOM + (byte << 1), &dataAndInverse, 1);
   \                     ??halInternalCibOptionByteWrite_0: (+1)
   \   00000014   0x0040             LSLS     R0,R0,#+1
   \   00000016   0xF100 0x6000      ADD      R0,R0,#+134217728
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0xF500 0x2081      ADD      R0,R0,#+264192
   \   00000022   0x.... 0x....      BL       halInternalFlashWrite
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    193          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     flashEraseIsActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     halFixedAddressTable

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x76 0x65          DC8 "verifyFib()"
   \              0x72 0x69    
   \              0x66 0x79    
   \              0x46 0x69    
   \              0x62 0x28    
   \              0x29 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x4A          DC8 5CH, 4AH, 6FH, 6EH, 5CH, 44H, 6FH, 63H
   \              0x6F 0x6E    
   \              0x5C 0x44    
   \              0x6F 0x63    
   \   00000010   0x75 0x6D          DC8 75H, 6DH, 65H, 6EH, 74H, 73H, 5CH, 4DH
   \              0x65 0x6E    
   \              0x74 0x73    
   \              0x5C 0x4D    
   \   00000018   0x4F 0x5F          DC8 4FH, 5FH, 53H, 5FH, 61H, 6EH, 64H, 5FH
   \              0x53 0x5F    
   \              0x61 0x6E    
   \              0x64 0x5F    
   \   00000020   0x54 0x5C          DC8 54H, 5CH, 43H, 70H, 45H, 35H, 31H, 37H
   \              0x43 0x70    
   \              0x45 0x35    
   \              0x31 0x37    
   \   00000028   0x30 0x5F          DC8 30H, 5FH, 52H, 54H, 5FH, 53H, 79H, 73H
   \              0x52 0x54    
   \              0x5F 0x53    
   \              0x79 0x73    
   \   00000030   0x74 0x65          DC8 74H, 65H, 6DH, 73H, 5CH, 4CH, 61H, 62H
   \              0x6D 0x73    
   \              0x5C 0x4C    
   \              0x61 0x62    
   \   00000038   0x73 0x5C          DC8 73H, 5CH, 63H, 70H, 65H, 2DH, 35H, 31H
   \              0x63 0x70    
   \              0x65 0x2D    
   \              0x35 0x31    
   \   00000040   0x37 0x30          DC8 37H, 30H, 2DH, 6DH, 6FH, 74H, 65H, 2DH
   \              0x2D 0x6D    
   \              0x6F 0x74    
   \              0x65 0x2D    
   \   00000048   0x63 0x6F          DC8 63H, 6FH, 64H, 65H, 5CH, 55H, 74H, 69H
   \              0x64 0x65    
   \              0x5C 0x55    
   \              0x74 0x69    
   \   00000050   0x6C 0x69          DC8 6CH, 69H, 74H, 69H, 65H, 73H, 5CH, 53H
   \              0x74 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000058   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 57H, 31H, 30H, 38H
   \              0x33 0x32    
   \              0x57 0x31    
   \              0x30 0x38    
   \   00000060   0x78 0x78          DC8 78H, 78H, 5FH, 48H, 41H, 4CH, 5FH, 44H
   \              0x5F 0x48    
   \              0x41 0x4C    
   \              0x5F 0x44    
   \   00000068   0x72 0x69          DC8 72H, 69H, 76H, 65H, 72H, 5CH, 6DH, 69H
   \              0x76 0x65    
   \              0x72 0x5C    
   \              0x6D 0x69    
   \   00000070   0x63 0x72          DC8 63H, 72H, 6FH, 5CH, 63H, 6FH, 72H, 74H
   \              0x6F 0x5C    
   \              0x63 0x6F    
   \              0x72 0x74    
   \   00000078   0x65 0x78          DC8 65H, 78H, 6DH, 33H, 5CH, 68H, 61H, 6CH
   \              0x6D 0x33    
   \              0x5C 0x68    
   \              0x61 0x6C    
   \   00000080   0x5F 0x66          DC8 5FH, 66H, 6CH, 61H, 73H, 68H, 2EH, 63H
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x2E 0x63    
   \   00000088   0x00               DC8 0
   \   00000089   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    194          
    195          /**
    196            * @}
    197            */
    198          
    199          /**
    200            * @}
    201            */ 
    202          
    203          /**
    204            * @}
    205            */
    206          
    207          
    208          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halFlashEraseIsActive
       8   halInternalCibOptionByteWrite
         8   -> halInternalFlashWrite
      24   halInternalFlashErase
        24   -- Indirect call
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> verifyFib
      24   halInternalFlashWrite
        24   -- Indirect call
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> verifyFib
       0   verifyFib


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
      12  ?Subroutine0
      12  ?_0
     140  ?_1
       8  fibToStStatus
       1  flashEraseIsActive
       6  halFlashEraseIsActive
      40  halInternalCibOptionByteWrite
      82  halInternalFlashErase
      78  halInternalFlashWrite
      34  verifyFib

 
   1 byte  in section .bss
 420 bytes in section .text
 
 420 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
