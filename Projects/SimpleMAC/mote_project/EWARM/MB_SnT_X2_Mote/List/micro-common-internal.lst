###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:27:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\micro-common-internal.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\micro-common-internal.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"micro-common-internal.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\micro-common-internal.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\micro-common-internal.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\micro-common-internal.c
      1          /**
      2            ******************************************************************************
      3            * @file    micro-common-internal.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012 
      7            * @brief   STM32W108 internal, micro specific HAL functions.
      8            * @Note    This file is provided for completeness and it should not be modified
      9            *          by customers as it comtains code very tightly linked to undocumented
     10            *          device features
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     15            *
     16            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     17            * You may not use this file except in compliance with the License.
     18            * You may obtain a copy of the License at:
     19            *
     20            *        http://www.st.com/software_license_agreement_liberty_v2
     21            *
     22            * Unless required by applicable law or agreed to in writing, software 
     23            * distributed under the License is distributed on an "AS IS" BASIS, 
     24            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     25            * See the License for the specific language governing permissions and
     26            * limitations under the License.
     27            *
     28            ******************************************************************************
     29            */
     30          
     31          /* Includes ------------------------------------------------------------------*/
     32          
     33          #include PLATFORM_HEADER
     34          #include "error.h"
     35          #include "micro-common.h"
     36          #include "mfg-token.h"
     37          #include "hal_adc.h"
     38          
     39          /** @addtogroup HAL
     40            * @{
     41            */
     42          
     43          /** @defgroup micro-common-internal
     44            * @brief micro-common-internal modules
     45            * @{
     46            */
     47          
     48          /* Private define ------------------------------------------------------------*/
     49          /* Private typedef -----------------------------------------------------------*/
     50          /* Private macros ------------------------------------------------------------*/
     51          /* Private variables ---------------------------------------------------------*/
     52             /* Specify whether the regulator trimming is set for normal mode or radio boost mode */

   \                                 In section .bss, align 1
     53          __IO uint8_t regTrimBoostMode = FALSE;
   \                     regTrimBoostMode:
   \   00000000                      DS8 1
     54          
     55          /* Private function prototypes -----------------------------------------------*/
     56          /* Private functions ---------------------------------------------------------*/
     57          
     58          /** @defgroup  micro_Private_Functions
     59            * @{
     60            */
     61          
     62          /**
     63            * @brief  Calibrates the GPIO pads.
     64            * @param  None
     65            * @retval None
     66            */

   \                                 In section .text, align 2, keep-with-next
     67          void halCommonCalibratePads(void)
     68          {
   \                     halCommonCalibratePads: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     69            /* We don't need extreme accuracy for this measurement, so we can use
     70             * the fastest ADC sample rate */
     71            if(halMeasureVdd(ADC_SAMPLE_CLOCKS_32) < 2700) {
   \   00000002   0x....             LDR.N    R4,??DataTable3  ;; 0x4000bc00
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       halMeasureVdd
   \   0000000A   0xF640 0x218C      MOVW     R1,#+2700
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0xBFB4             ITE      LT 
   \   00000014   0xF040 0x0008      ORRLT    R0,R0,#0x8
   \   00000018   0xF020 0x0008      BICGE    R0,R0,#0x8
     72              GPIO_DBG->DBGCR |= GPIO_DBGCR_PADDRIVE;
     73            } else {
     74              GPIO_DBG->DBGCR &= ~GPIO_DBGCR_PADDRIVE;
   \   0000001C   0x6020             STR      R0,[R4, #+0]
     75            }
     76          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
     77          
     78          /**
     79            * @brief  Sets the trim values for the 1.8V and 1.2V regulators based upon 
     80            *         manufacturing configuration
     81            * @param  Boolean value of the boostmode
     82            * @retval None
     83            */

   \                                 In section .text, align 2, keep-with-next
     84          void halInternalSetRegTrim(boolean boostMode)
     85          {
   \                     halInternalSetRegTrim: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     86            tokTypeMfgRegTrim regTrim;
     87            uint8_t trim1V2;
     88            uint8_t trim1V8;
     89            
     90            halCommonGetMfgToken(&regTrim, TOKEN_MFG_REG_TRIM);
   \   00000004   0x....             LDR.N    R0,??DataTable3_1
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x.... 0x....      BL       ?Subroutine0
     91            /* The compiler can optimize this function a bit more and keep the 
     92             * values in processor registers if we use separate local vars instead
     93             * of just accessing via the structure fields */
     94            trim1V8 = regTrim.regTrim1V8;
     95            trim1V2 = regTrim.regTrim1V2;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000000E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000012   0xF89D 0x0001      LDRB     R0,[SP, #+1]
     96            
     97            /* If tokens are erased, default to reasonable values, otherwise use the
     98             * token values. */
     99            if((trim1V2 == 0xFF) && (trim1V8 == 0xFF))
    100            {
    101              trim1V8 = 4;
    102              trim1V2 = 0;
    103            }
    104            
    105            /* When the radio is in boost mode, we have to increase the 1.8V trim. */
    106            if(boostMode)
   \   00000016   0x....             LDR.N    R2,??DataTable3_2
   \   00000018   0x29FF             CMP      R1,#+255
   \   0000001A   0xBF02             ITTT     EQ 
   \   0000001C   0x28FF             CMPEQ    R0,#+255
   \   0000001E   0x2004             MOVEQ    R0,#+4
   \   00000020   0x2100             MOVEQ    R1,#+0
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xBF1A             ITTE     NE 
   \   00000026   0x1C80             ADDNE    R0,R0,#+2
   \   00000028   0x2301             MOVNE    R3,#+1
   \   0000002A   0x2300             MOVEQ    R3,#+0
    107            {
    108              trim1V8 += 2;
    109              regTrimBoostMode = TRUE;
    110            }
    111            else
    112            {
    113              regTrimBoostMode = FALSE;
   \   0000002C   0x7013             STRB     R3,[R2, #+0]
    114            }
    115            
    116            /* Clamp at 7 to ensure we don't exceed max values, accidentally set
    117               other bits, or wrap values. */
    118            if(trim1V8 > 7)
   \   0000002E   0xB2C0             UXTB     R0,R0
    119            {
    120              trim1V8 = 7;
    121            }
    122            if(trim1V2 > 7)
    123            {
    124              trim1V2 = 7;
    125            }
    126            
    127            /* only set the trim fields so that any test bits are not overwritten
    128               (they are used by some test scripts to force an external voltage in) */
    129            SET_REG_FIELD(PWR->VREGCR, PWR_VREGCR_1V8TRIM, trim1V8, 7);
   \   00000030   0x....             LDR.N    R2,??DataTable3_3  ;; 0x40000018
   \   00000032   0x6813             LDR      R3,[R2, #+0]
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xBFA8             IT       GE 
   \   00000038   0x2007             MOVGE    R0,#+7
   \   0000003A   0xF423 0x7360      BIC      R3,R3,#0x380
   \   0000003E   0xEA43 0x10C0      ORR      R0,R3,R0, LSL #+7
   \   00000042   0x6010             STR      R0,[R2, #+0]
   \   00000044   0x2908             CMP      R1,#+8
    130            SET_REG_FIELD(PWR->VREGCR, PWR_VREGCR_1V2TRIM, trim1V2, 0);   
   \   00000046   0x6810             LDR      R0,[R2, #+0]
   \   00000048   0xBFA8             IT       GE 
   \   0000004A   0x2107             MOVGE    R1,#+7
   \   0000004C   0x08C0             LSRS     R0,R0,#+3
   \   0000004E   0xEA41 0x00C0      ORR      R0,R1,R0, LSL #+3
   \   00000052   0x6010             STR      R0,[R2, #+0]
    131          }
   \   00000054   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2302             MOVS     R3,#+2
   \   00000002   0x227F             MOVS     R2,#+127
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      B.W      halInternalGetMfgTokenData
    132          
    133          /**
    134            * @brief  Determine VREG_OUT in the current mode (normal or boost).
    135            * @param  None
    136            * @retval VREG_OUT in millivolts, depending on normal or boost mode
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          uint16_t halInternalGetVreg(void)
    139          {
   \                     halInternalGetVreg: (+1)
   \   00000000   0xB500             PUSH     {LR}
    140            tokTypeMfgRegVoltage1V8 vregOutTok;
    141          
    142            /* Convert the value into mV. VREG_OUT is ideally 1.8V, but it won't be
    143               exactly 1.8V.  The actual value is stored in the manufacturing token
    144               TOKEN_MFG_1V8_REG_VOLTAGE. The token stores the value in 10^-4, but we
    145               need 10^-3 so divide by 10. If this token is not set (0xFFFF), then
    146               assume 1800mV. */
    147            halCommonGetMfgToken(&vregOutTok, TOKEN_MFG_1V8_REG_VOLTAGE);
   \   00000002   0x....             LDR.N    R0,??DataTable3_4
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
   \   00000006   0xB083             SUB      SP,SP,#+12
   \   00000008   0x.... 0x....      BL       ?Subroutine0
    148            if(vregOutTok == 0xFFFF)
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000010   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xBF0E             ITEE     EQ 
   \   00000018   0xF44F 0x60E1      MOVEQ    R0,#+1800
   \   0000001C   0x210A             MOVNE    R1,#+10
   \   0000001E   0xFB90 0xF0F1      SDIVNE   R0,R0,R1
    149            {
    150              vregOutTok = 1800;
    151            } else
    152            {
    153              vregOutTok /= 10;
   \   00000022   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    154            }
    155            /* Adjust vregOutTok if in boost mode, which raises Vreg by 2 clicks.
    156               Multiply it by the ratio (47 - regTrimNormal) / (47 - regTrimBoost)
    157               where regTrimNormal and regTrimBoost are the regulator trim values for
    158               the two modes (from regTrim1V8 token).  The 47 - trim comes from the
    159               ratio of resistors used in the bandgap circuit.  The correction is
    160               typically +5% (regTrimNormal is usually 3 or 4 and boost is 2 higher). */
    161            if (regTrimBoostMode)
   \   00000026   0x....             LDR.N    R0,??DataTable3_2
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB308             CBZ.N    R0,??halInternalGetVreg_0
    162             {
    163              tokTypeMfgRegTrim regTrim;
    164              uint8_t regTrimNormal, regTrimBoost;
    165          
    166              halCommonGetMfgToken(&regTrim, TOKEN_MFG_REG_TRIM);
   \   0000002C   0x....             LDR.N    R0,??DataTable3_1
   \   0000002E   0x8801             LDRH     R1,[R0, #+0]
   \   00000030   0x2302             MOVS     R3,#+2
   \   00000032   0x227F             MOVS     R2,#+127
   \   00000034   0xA801             ADD      R0,SP,#+4
   \   00000036   0x.... 0x....      BL       halInternalGetMfgTokenData
    167              regTrimNormal = regTrim.regTrim1V8;
   \   0000003A   0xF89D 0x0005      LDRB     R0,[SP, #+5]
    168              if (regTrimNormal == 0xFF)
    169              { /* If token erased, assume reasonable defaults */
    170                regTrimNormal = 4; /* 4 from halInternalSetRegTrim() and Stromboli-S-015_*.doc */
    171              }
    172              regTrimBoost = regTrimNormal + 2;
    173              if (regTrimBoost > 7)
    174              {
    175                regTrimBoost = 7; /* Peg it at max of 7 */
    176              }
    177              /* Increase vregOutTok by the above-indicated ratio for boost compensation */
    178              vregOutTok = (((((uint32_t) vregOutTok) * (47 - regTrimNormal))
    179                                                      + (47 - regTrimBoost )/2) /* rounding */
    180                                                      / (47 - regTrimBoost));
   \   0000003E   0xF8BD 0x3000      LDRH     R3,[SP, #+0]
   \   00000042   0x28FF             CMP      R0,#+255
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0x2004             MOVEQ    R0,#+4
   \   00000048   0x1C81             ADDS     R1,R0,#+2
   \   0000004A   0xB2C9             UXTB     R1,R1
   \   0000004C   0x2908             CMP      R1,#+8
   \   0000004E   0xBFA8             IT       GE 
   \   00000050   0x2107             MOVGE    R1,#+7
   \   00000052   0xF1C1 0x022F      RSB      R2,R1,#+47
   \   00000056   0xEB02 0x72D2      ADD      R2,R2,R2, LSR #+31
   \   0000005A   0xF1C0 0x002F      RSB      R0,R0,#+47
   \   0000005E   0x1052             ASRS     R2,R2,#+1
   \   00000060   0xFB00 0x2003      MLA      R0,R0,R3,R2
   \   00000064   0xF1C1 0x012F      RSB      R1,R1,#+47
   \   00000068   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    181            }
    182            return ((uint16_t) vregOutTok);
   \                     ??halInternalGetVreg_0: (+1)
   \   00000070   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000074   0xBD0E             POP      {R1-R3,PC}       ;; return
    183          }
    184          
    185          /**
    186            * @brief  Blocks the current thread of execution for the specified amount 
    187            *         of time, in microseconds.
    188            * @param  The value of the delay on us
    189            * @retval None
    190            */

   \                                 In section .text, align 2, keep-with-next
    191          void halCommonDelayMicroseconds(uint16_t us)
    192          {
    193            /* halCommonDelayMicroseconds
    194                     -enables MAC Timer and leaves it enabled.
    195                     -does not touch MAC Timer Compare registers.
    196                     -max delay is 65535 usec.
    197                     NOTE: This function primarily designed for when the chip is running off of
    198                           the XTAL, which is the most common situation.  When running from
    199                           OSCHF, though, the clock speed is cut in half, so the input parameter
    200                           is divided by two.  With respect to accuracy, we're now limited by
    201                           the accuracy of OSCHF (much lower than XTAL). */
    202            uint32_t beginTime = MACTMR->CNTR;
   \                     halCommonDelayMicroseconds: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable3_5  ;; 0x40002038
    203            
    204            /* If we're not using the XTAL, the MAC Timer is running off OSCHF,
    205               that means the clock is half speed, 6MHz.  We need to halve our delay
    206               time. */
    207            if((CLK->HSECR2 & CLK_HSECR2_SW1) != CLK_HSECR2_SW1)
   \   00000002   0x....             LDR.N    R3,??DataTable3_6  ;; 0x4000401c
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x07DB             LSLS     R3,R3,#+31
   \   0000000A   0xBF58             IT       PL 
   \   0000000C   0x0840             LSRPL    R0,R0,#+1
    208            {
    209              us >>= 1;
    210            }
    211              
    212            /* we have about 2us of overhead in the calculations */
    213            if(us<=2)
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xDB09             BLT.N    ??halCommonDelayMicroseconds_0
    214            {
    215              return;
    216            }
    217            
    218            /* MAC Timer is enabled in stmRadioInit, which may not have been called yet.
    219              This algorithm needs the MAC Timer so we enable it here. */
    220            MACTMR->CR |= MACTMR_CR_EN;
   \   00000012   0x6D4B             LDR      R3,[R1, #+84]
   \   00000014   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000018   0x654B             STR      R3,[R1, #+84]
    221          
    222             /* since our max delay (65535<<1) is less than half the size of the 
    223              20 bit mac timer, we can easily just handle the potential for
    224              mac timer wrapping by subtracting the time delta and masking out
    225              the extra bits */
    226            while(((MACTMR->CNTR - beginTime)&MACTMR_CNTR_CNT) < us )
   \                     ??halCommonDelayMicroseconds_1: (+1)
   \   0000001A   0x680B             LDR      R3,[R1, #+0]
   \   0000001C   0x1A9B             SUBS     R3,R3,R2
   \   0000001E   0x031B             LSLS     R3,R3,#+12
   \   00000020   0x0B1B             LSRS     R3,R3,#+12
   \   00000022   0x4283             CMP      R3,R0
   \   00000024   0xD3F9             BCC.N    ??halCommonDelayMicroseconds_1
    227            {
    228              ; /* spin */
    229            }
    230          }
   \                     ??halCommonDelayMicroseconds_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    231          
    232          /**
    233            * @brief  Blocks the current thread of execution for the specified amount
    234            *         of time, in milliseconds
    235            * Burning cycles for milliseconds is generally a bad idea, but it is
    236            * necessary in some situations.  If you have to burn more than 65ms of time,
    237            * the halCommonDelayMicroseconds function becomes cumbersome, so this
    238            * function gives you millisecond granularity.
    239            * @param  The value of the delay in ms
    240            * @retval None
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          void halCommonDelayMilliseconds(uint16_t ms)
    243          {
   \                     halCommonDelayMilliseconds: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    244            if(ms == 0)
   \   00000004   0xD104             BNE.N    ??halCommonDelayMilliseconds_0
    245            {
    246              return;
   \   00000006   0xBD10             POP      {R4,PC}
    247            }
    248            
    249            while(ms-- > 0) 
    250            {
    251              halCommonDelayMicroseconds(1000);
   \                     ??halCommonDelayMilliseconds_1: (+1)
   \   00000008   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000C   0x.... 0x....      BL       halCommonDelayMicroseconds
    252            }
   \                     ??halCommonDelayMilliseconds_0: (+1)
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x1E44             SUBS     R4,R0,#+1
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F6             BNE.N    ??halCommonDelayMilliseconds_1
    253          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4000BC00         DC32     0x4000bc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     TOKEN_MFG_REG_TRIM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     regTrimBoostMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40000018         DC32     0x40000018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     TOKEN_MFG_1V8_REG_VOLTAGE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40002038         DC32     0x40002038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x4000401C         DC32     0x4000401c
    254          
    255          /**
    256            * @}
    257            */
    258          
    259          /**
    260            * @}
    261            */ 
    262          
    263          /**
    264            * @}
    265            */
    266          
    267          
    268          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   halCommonCalibratePads
         8   -> halMeasureVdd
       0   halCommonDelayMicroseconds
       8   halCommonDelayMilliseconds
         8   -> halCommonDelayMicroseconds
      16   halInternalGetVreg
        16   -> halInternalGetMfgTokenData
      16   halInternalSetRegTrim
        16   -> halInternalGetMfgTokenData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
      10  ?Subroutine0
      32  halCommonCalibratePads
      40  halCommonDelayMicroseconds
      28  halCommonDelayMilliseconds
     118  halInternalGetVreg
      86  halInternalSetRegTrim
       1  regTrimBoostMode

 
   1 byte  in section .bss
 342 bytes in section .text
 
 342 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
