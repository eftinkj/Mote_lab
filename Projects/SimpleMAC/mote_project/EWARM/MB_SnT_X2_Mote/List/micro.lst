###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:27:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\micro.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\micro.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"micro.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\micro.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\micro.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\micro.c
      1          /**
      2            ******************************************************************************
      3            * @file    micro.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.1
      6            * @date    30-November-2012 
      7            * @brief   STM32W108 micro specific minimal HAL functions
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include PLATFORM_HEADER
     30          #include "board.h"
     31          #include "error.h"
     32          #include "micro-common.h"
     33          #include "board.h"
     34          #include "system-timer.h"
     35          #include "hal_adc.h"
     36          #include "memmap.h"
     37          #include "iap_bootloader.h"
     38          
     39          #include <stdlib.h>
     40          #include <string.h>
     41          
     42          /** @addtogroup HAL
     43            * @{
     44            */
     45          
     46          /** @defgroup micro
     47            * @brief micro modules
     48            * @{
     49            */
     50          
     51          /* Private define ------------------------------------------------------------*/
     52          /* Private typedef -----------------------------------------------------------*/
     53          #pragma pack(1)
     54          typedef struct appSwitchStruct {
     55            uint32_t signature;
     56            uint8_t mode;
     57            uint8_t channel;
     58            union {
     59              uint16_t panID;
     60              uint16_t offset;
     61            } param;
     62          } appSwitchStructType;
     63          #pragma pack()
     64          
     65          /* Private macros ------------------------------------------------------------*/
     66          /* Private variables ---------------------------------------------------------*/

   \                                 In section .data, align 4
   \   00000000   0x20000000         DC32 20000000H
     67          static appSwitchStructType *appSwitch = (appSwitchStructType *) RAM_BOTTOM;

   \                                 In section .data, align 2
     68          static uint16_t seed0 = 0xbeef;
   \                     seed0:
   \   00000000   0xBEEF             DC16 48879
   \   00000002   0xFACE             DC16 64206
     69          static uint16_t seed1 = 0xface;
     70          
     71          /* Private function prototypes -----------------------------------------------*/
     72          /* Private functions ---------------------------------------------------------*/
     73          
     74          /** @defgroup  micro_Private_Functions
     75            * @{
     76            */
     77          
     78          /**
     79            * @brief  Initializes microcontroller-specific peripherals. 
     80            * @param  None
     81            * @retval None
     82            */

   \                                 In section .text, align 2, keep-with-next
     83          void halInit(void)
     84          {
   \                     halInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     85            halCommonStartXtal();
   \   00000002   0x.... 0x....      BL       halCommonTryToSwitchToXtal
     86            /* Disable the REG_EN external regulator enable signal.  Out of reset this
     87               signal overrides PA7.  By disabling it early, PA7 is reclaimed as a GPIO.
     88               If an external regulator is required, the following line of code should
     89               be deleted. */
     90            GPIO_DBG->DBGCR &= ~GPIO_DBGCR_EXTREGEN;
   \   00000006   0x....             LDR.N    R0,??DataTable5  ;; 0x4000bc00
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000000E   0x6001             STR      R1,[R0, #+0]
     91            halInternalSetRegTrim(FALSE);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       halInternalSetRegTrim
     92            halInternalInitAdc();
   \   00000016   0x.... 0x....      BL       halInternalInitAdc
     93            halCommonCalibratePads();
   \   0000001A   0x.... 0x....      BL       halCommonCalibratePads
     94            halBoardPowerUp();
   \   0000001E   0x.... 0x....      BL       halBoardPowerUp
     95            halCommonSwitchToXtal();
   \   00000022   0x.... 0x....      BL       halCommonSwitchToXtal
     96            halInternalCalibrateFastRc();
   \   00000026   0x.... 0x....      BL       halInternalCalibrateFastRc
     97            
     98            #ifndef DISABLE_WATCHDOG
     99              WDG_Cmd(ENABLE);
    100            #endif
    101          
    102            halInternalStartSystemTimer();
   \   0000002A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000002E   0x.... 0x....      B.W      halInternalStartSystemTimer
    103          }
    104          
    105          /**
    106            * @brief  Restarts the microcontroller and therefore everything else. 
    107              of the planets status  
    108            * @param  None
    109            * @retval None
    110            */

   \                                 In section .text, align 2, keep-with-next
    111          void halReboot(void)
    112          {
    113            INTERRUPTS_OFF();
   \                     halReboot: (+1)
   \   00000000   0x2060             MOVS     R0,#+96
   \   00000002   0xF380 0x8811      MSR      BASEPRI,R0
    114          
    115            /* FCLK must be 6MHz to allow the SYSRESETREQ signal to cleanly
    116               propagate and reset the chip.  Switch SYSCLK first since we need
    117               the cycles used by switching FCLK to guarantee the SYSCLK is
    118               stable and ready for SYSRESETREQ. */
    119            CLK->HSECR2 = 0x00; /* Guarantee SYSCLK is sourced from OSCHF */
   \   00000006   0x....             LDR.N    R0,??DataTable5_1  ;; 0x4000401c
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    120            CLK->CPUCR = 0x00;   /* Guarantee FCLK is sourced from PCLK */
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    121            
    122            SCB->AIRCR = (0x05FA0000 | SCB_AIRCR_SYSRESETREQ_Msk); /* trigger the reset */
   \   0000000E   0x....             LDR.N    R0,??DataTable5_2  ;; 0x5fa0004
   \   00000010   0x....             LDR.N    R1,??DataTable5_3  ;; 0xe000ed0c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    123            /* NOTE: SYSRESETREQ is not the same as nRESET. t will not do the debug
    124               pieces: DWT, ITM, FPB, vector catch, etc */
    125          }
   \   00000014   0x4770             BX       LR               ;; return
    126          
    127          /**
    128            * @brief  Powers down microcontroller peripherals and board peripherals.  
    129            * @param  None
    130            * @retval None
    131            */

   \                                 In section .text, align 2, keep-with-next
    132          void halPowerDown(void)
    133          {
    134            halBoardPowerDown();
   \                     halPowerDown: (+1)
   \   00000000   0x.... 0x....      B.W      halBoardPowerDown
    135          }
    136          
    137          /**
    138            * @brief  Powers up microcontroller peripherals and board peripherals.  
    139            * @param  None
    140            * @retval None
    141            */

   \                                 In section .text, align 2, keep-with-next
    142          void halPowerUp(void)
    143          {
   \                     halPowerUp: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    144            halInternalPowerUpKickXtal();
   \   00000002   0x.... 0x....      BL       halInternalPowerUpKickXtal
    145            halInternalInitAdc();
   \   00000006   0x.... 0x....      BL       halInternalInitAdc
    146            halCommonCalibratePads();  
   \   0000000A   0x.... 0x....      BL       halCommonCalibratePads
    147            halBoardPowerUp();
   \   0000000E   0x.... 0x....      BL       halBoardPowerUp
    148            halInternalBlockUntilXtal();
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x.... 0x....      B.W      halInternalBlockUntilXtal
    149          }
    150          
    151          /**
    152            * @brief  Seeds the pseudorandom number generator.
    153            * @param  seed 
    154            * @retval None
    155            */

   \                                 In section .text, align 2, keep-with-next
    156          void halCommonSeedRandom(uint32_t seed)
    157          {
    158            seed0 = (uint16_t) seed;
    159            if (seed0 == 0)
   \                     halCommonSeedRandom: (+1)
   \   00000000   0xB281             UXTH     R1,R0
   \   00000002   0xB909             CBNZ.N   R1,??halCommonSeedRandom_0
    160              seed0 = 0xbeef;
   \   00000004   0xF64B 0x61EF      MOVW     R1,#+48879
   \                     ??halCommonSeedRandom_0: (+1)
   \   00000008   0x....             LDR.N    R2,??DataTable5_4
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    161            seed1 = (uint16_t) (seed >> 16);
   \   0000000C   0x0C00             LSRS     R0,R0,#+16
    162            if (seed1 == 0)
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0xF64F 0x20CE      MOVWEQ   R0,#+64206
    163              seed1 = 0xface;
   \   00000014   0x8050             STRH     R0,[R2, #+2]
    164          }
   \   00000016   0x4770             BX       LR               ;; return
    165          
    166          /**
    167            * @brief  shift the current value and copy to the new val
    168            * @param  value
    169            * @param  taps
    170            * @retval the shifted value
    171            */

   \                                 In section .text, align 2, keep-with-next
    172          static uint16_t shift(uint16_t *val, uint16_t taps)
    173          {
    174            uint16_t newVal = *val;
   \                     shift: (+1)
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
    175          
    176            if (newVal & 0x8000)
   \   00000002   0x0413             LSLS     R3,R2,#+16
   \   00000004   0xBF48             IT       MI 
   \   00000006   0x404A             EORMI    R2,R1,R2
    177              newVal ^= taps;
    178            *val = newVal << 1;
   \   00000008   0x0051             LSLS     R1,R2,#+1
   \   0000000A   0x8001             STRH     R1,[R0, #+0]
    179            return newVal;
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x4770             BX       LR               ;; return
    180          }
    181          
    182          /**
    183            * @brief  pseudorandom number generator.   
    184            * @param  None
    185            * @retval random number generated
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          uint16_t halCommonGetRandom(void)
    188          {
   \                     halCommonGetRandom: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    189            return (shift(&seed0, 0x0062) ^ shift(&seed1, 0x100B));
   \   00000002   0x....             LDR.N    R4,??DataTable5_4
   \   00000004   0x2162             MOVS     R1,#+98
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       shift
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0xF241 0x010B      MOVW     R1,#+4107
   \   00000012   0x1CA0             ADDS     R0,R4,#+2
   \   00000014   0x.... 0x....      BL       shift
   \   00000018   0x4068             EORS     R0,R0,R5
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    190          }
    191          
    192          /**
    193            * @brief  Refer to the C stdlib memcpy().  
    194            * @param  dest
    195            * @param  source
    196            * @param  number of bytes
    197            * @retval None
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          void halCommonMemCopy(void *dest, const void *source, uint16_t bytes)
    200          {
    201            memcpy(dest, source, bytes);
   \                     halCommonMemCopy: (+1)
   \   00000000   0x.... 0x....      B.W      __aeabi_memcpy
    202          }
    203          
    204          /**
    205            * @brief  Refer to the C stdlib memcmp(). 
    206            * @param  source0
    207            * @param  source1
    208            * @param  number of bytes
    209            * @retval the result of the comparaison
    210            */

   \                                 In section .text, align 2, keep-with-next
    211          int8_t halCommonMemCompare(const void *source0, const void *source1, uint16_t bytes)
    212          {
   \                     halCommonMemCompare: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    213            return memcmp(source0, source1, bytes);
   \   00000002   0x.... 0x....      BL       memcmp
   \   00000006   0xB240             SXTB     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    214          }
    215          
    216          /**
    217            * @brief  Refer to the C stdlib memset().  
    218            * @param  dest
    219            * @param  the value
    220            * @param  number of bytes
    221            * @retval None
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          void halCommonMemSet(void *dest, uint8_t val, uint16_t bytes)
    224          {
   \                     halCommonMemSet: (+1)
   \   00000000   0x4613             MOV      R3,R2
    225            memset(dest, val, bytes);
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4619             MOV      R1,R3
   \   00000006   0x.... 0x....      B.W      __aeabi_memset
    226          }
    227          
    228          /**
    229            * @brief  Manage the Isr of the chip
    230            * @param  None
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void halManagementIsr(void)
    234          {
    235            if (MGMT_IT->ISR & MGMT_ISR_HSECOMPLLIF) {
   \                     halManagementIsr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4000a018
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xD508             BPL.N    ??halManagementIsr_0
    236              /* The xtal has crossed the LO threshold indicating we're ready
    237               * to switch to it. */
    238              wakeupXtalState = WAKEUP_XTAL_STATE_READY_SWITCH;
   \   00000008   0x....             LDR.N    R2,??DataTable5_6
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x7011             STRB     R1,[R2, #+0]
    239          
    240              /* We're done with this interrupt. */
    241              MGMT_IT->IER &= ~MGMT_ISR_HSECOMPLLIF;
   \   0000000E   0x6C01             LDR      R1,[R0, #+64]
   \   00000010   0x0849             LSRS     R1,R1,#+1
   \   00000012   0x0049             LSLS     R1,R1,#+1
   \   00000014   0x6401             STR      R1,[R0, #+64]
    242              MGMT_IT->ISR = MGMT_ISR_HSECOMPLLIF;
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    243            }
    244          }
   \                     ??halManagementIsr_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    245          
    246          /**
    247            * @brief  Start the bootloader mode
    248            * @param  the mode
    249            * @param  the channel
    250            * @param  panID
    251            * @retval the status
    252            */

   \                                 In section .text, align 2, keep-with-next
    253          StStatus halBootloaderStart(uint8_t mode, uint8_t channel, uint16_t panID)
    254          {
   \                     halBootloaderStart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    255            if (mode<= BOOTLOADER_MODE_OTA) 
   \   00000002   0x2802             CMP      R0,#+2
   \   00000004   0xDA25             BGE.N    ??halBootloaderStart_0
    256            {
    257          #ifdef CORTEXM3_STM32W108xB
    258              if (mode ==  BOOTLOADER_MODE_UART) 
   \   00000006   0xF04F 0x5300      MOV      R3,#+536870912
   \   0000000A   0x....             LDR.N    R4,??DataTable5_7  ;; 0xb001204d
   \   0000000C   0xB990             CBNZ.N   R0,??halBootloaderStart_1
    259              {
    260                uint8_t cut = *(__IO uint8_t *) 0x08040798;
   \   0000000E   0x....             LDR.N    R1,??DataTable5_8  ;; 0x8040798
    261                if (!((halFixedAddressTable.baseTable.type == FIXED_ADDRESS_TABLE_TYPE) &&
    262                      (((halFixedAddressTable.baseTable.version & FAT_MAJOR_VERSION_MASK) 
    263                        == 0x0000 ) &&
    264                       (halFixedAddressTable.baseTable.version == 0x0003) /* checking presence of valid version */ 
    265                         ) && (cut >= 2) && (cut <= 3)))     
   \   00000010   0x....             LDR.N    R2,??DataTable5_9
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x8A15             LDRH     R5,[R2, #+16]
   \   00000016   0xF640 0x76A7      MOVW     R6,#+4007
   \   0000001A   0x42B5             CMP      R5,R6
   \   0000001C   0xBF01             ITTTT    EQ 
   \   0000001E   0x8A52             LDRHEQ   R2,[R2, #+18]
   \   00000020   0xF44F 0x457F      MOVEQ    R5,#+65280
   \   00000024   0x422A             TSTEQ    R2,R5
   \   00000026   0x2A03             CMPEQ    R2,#+3
   \   00000028   0xD102             BNE.N    ??halBootloaderStart_2
   \   0000002A   0x1E89             SUBS     R1,R1,#+2
   \   0000002C   0x2902             CMP      R1,#+2
   \   0000002E   0xD30C             BCC.N    ??halBootloaderStart_3
    266          	/* Cut not supported */
    267          	return ST_ERR_FATAL;
    268              } 
    269              else 
    270              {
    271                /* Check that OTA bootloader is at the base of the flash */
    272                if (*((uint32_t *) (MFB_BOTTOM + 28)) == IAP_BOOTLOADER_APP_SWITCH_SIGNATURE)
    273                {
    274                  appSwitch->channel = ((channel >= 11) && (channel <= 26)) ? channel :IAP_BOOTLOADER_DEFAULT_CHANNEL;
    275                  appSwitch->param.panID = panID;
    276                }
    277                else 
    278                {
    279                  return ST_ERR_FATAL;
   \                     ??halBootloaderStart_2: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xBD70             POP      {R4-R6,PC}
    280                }
   \                     ??halBootloaderStart_1: (+1)
   \   00000034   0x....             LDR.N    R5,??DataTable5_10  ;; 0x800001c
   \   00000036   0x682D             LDR      R5,[R5, #+0]
   \   00000038   0x42A5             CMP      R5,R4
   \   0000003A   0xD1F9             BNE.N    ??halBootloaderStart_2
   \   0000003C   0xF1A1 0x050B      SUB      R5,R1,#+11
   \   00000040   0x2D10             CMP      R5,#+16
   \   00000042   0xBF28             IT       CS 
   \   00000044   0x210F             MOVCS    R1,#+15
   \   00000046   0x7159             STRB     R1,[R3, #+5]
   \   00000048   0x80DA             STRH     R2,[R3, #+6]
    281              }
    282          #endif
    283          #if defined (CORTEXM3_STM32W108CC)
    284              if (mode ==  BOOTLOADER_MODE_OTA)
    285              {
    286                appSwitch->channel = ((channel >= 11) && (channel <= 26)) ? channel :IAP_BOOTLOADER_DEFAULT_CHANNEL;
    287                appSwitch->param.panID = panID;
    288              }
    289          #endif
    290              appSwitch->signature = IAP_BOOTLOADER_APP_SWITCH_SIGNATURE;
   \                     ??halBootloaderStart_3: (+1)
   \   0000004A   0x601C             STR      R4,[R3, #+0]
    291              appSwitch->mode = mode;
   \   0000004C   0x7118             STRB     R0,[R3, #+4]
    292              halReboot();
   \   0000004E   0x.... 0x....      BL       halReboot
    293            }
    294            
    295            return ST_BAD_ARGUMENT;
   \                     ??halBootloaderStart_0: (+1)
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    296          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x4000BC00         DC32     0x4000bc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x4000401C         DC32     0x4000401c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     seed0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4000A018         DC32     0x4000a018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     wakeupXtalState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0xB001204D         DC32     0xb001204d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x08040798         DC32     0x8040798

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     halFixedAddressTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x0800001C         DC32     0x800001c
    297          
    298          /**
    299            * @}
    300            */
    301          
    302          /**
    303            * @}
    304            */ 
    305          
    306          /**
    307            * @}
    308            */
    309          
    310          
    311          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   halBootloaderStart
        16   -> halReboot
      16   halCommonGetRandom
        16   -> shift
       8   halCommonMemCompare
         8   -> memcmp
       0   halCommonMemCopy
         0   -> __aeabi_memcpy
       0   halCommonMemSet
         0   -> __aeabi_memset
       0   halCommonSeedRandom
       8   halInit
         8   -> halBoardPowerUp
         8   -> halCommonCalibratePads
         8   -> halCommonSwitchToXtal
         8   -> halCommonTryToSwitchToXtal
         8   -> halInternalCalibrateFastRc
         8   -> halInternalInitAdc
         8   -> halInternalSetRegTrim
         0   -> halInternalStartSystemTimer
       0   halManagementIsr
       0   halPowerDown
         0   -> halBoardPowerDown
       8   halPowerUp
         8   -> halBoardPowerUp
         8   -> halCommonCalibratePads
         0   -> halInternalBlockUntilXtal
         8   -> halInternalInitAdc
         8   -> halInternalPowerUpKickXtal
       0   halReboot
       0   shift


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  appSwitch
      86  halBootloaderStart
      28  halCommonGetRandom
      10  halCommonMemCompare
       4  halCommonMemCopy
      10  halCommonMemSet
      24  halCommonSeedRandom
      50  halInit
      28  halManagementIsr
       4  halPowerDown
      26  halPowerUp
      22  halReboot
       4  seed0
          seed1
      16  shift

 
   8 bytes in section .data
 352 bytes in section .text
 
 352 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
