###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:29:28
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\ssn_8bit.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\ssn_8bit.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"ssn_8bit.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\ssn_8bit.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\ssn_8bit.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_SigProc\ssn_8bit.c
      1          #include "defs/esnl_pub.h"
      2          
      3          #ifdef _ENABLE_SSN_8BIT_
      4          
      5          #include "ssn_8bit_prv.h"
      6          #include "ssn_8bit_pub.h"
      7          
      8          #include "FEAT_Queuing/Queuing.h"
      9          //#include "sys_func.h"
     10          
     11          //#include "packet.h"
     12          //#include "common.h"
     13          
     14          
     15          #include "FEAT_Networking/tsp_common_pub.h"
     16          #include "FEAT_Scheduler/sch_basic_pub.h"
     17          //#include "HW_LIB/new_adc_0_pub.h"
     18          
     19          #include "sys_func.h"
     20          #include "common.h"
     21          
     22          #ifdef _ENABLE_SRC_DUMMY_
     23          	#define _BRIDGE_EXP_
     24          #endif // _ENABLE_SRC_DUMMY_
     25          
     26          // generate 255 packets in a row
     27          //#define SSN_TEST
     28          //#undef SSN_TEST
     29          
     30          /****************************************************************************
     31          **	Constants, definies and typedefs  (PUBLIC)
     32          ****************************************************************************/
     33          
     34          /****************************************************************************
     35          **	Variables definition (PRIVATE)
     36          ****************************************************************************/
     37          
     38          
     39          /****************************************************************************
     40          **	Variables definition (PUBLIC)
     41          ****************************************************************************/
     42          
     43          
     44          /****************************************************************************
     45          **	Functions implementation (PUBLIC)
     46          ****************************************************************************/
     47          
     48          
     49          

   \                                 In section .bss, align 4
     50          ssn_mem_t XDATA* ssn_mem_p;
   \                     ssn_mem_p:
   \   00000000                      DS8 4
     51          

   \                                 In section .bss, align 4
     52          uint8_t	XDATA ssn_mem_raw[SSN_MEM_STRUCT_SIZE];
   \                     ssn_mem_raw:
   \   00000000                      DS8 32
     53          SSN_BUFF_ITEM_T	XDATA ssn_buffer_raw[SSN_BUFF_SIZE];
   \                     ssn_buffer_raw:
   \   00000020                      DS8 256
     54          
     55          
     56          /**
     57           * ssn_init () - sets up Signal Processing Module
     58           */

   \                                 In section .text, align 2, keep-with-next
     59          void ssn_init ( void )
     60          {
   \                     ssn_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     61          //	float XDATA * temp_coeff;
     62          	int i;
     63          	for( i=0; i < SSN_BUFF_SIZE; i++) { ssn_buffer_raw[i]=i; }
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable7
   \                     ??ssn_init_0: (+1)
   \   00000006   0xEB00 0x0241      ADD      R2,R0,R1, LSL #+1
   \   0000000A   0x8411             STRH     R1,[R2, #+32]
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0x2980             CMP      R1,#+128
   \   00000010   0xDBF9             BLT.N    ??ssn_init_0
     64          
     65          	ssn_mem_p = (ssn_mem_t XDATA* )ssn_mem_raw;
   \   00000012   0x....             LDR.N    R4,??DataTable7_1
   \   00000014   0x6020             STR      R0,[R4, #+0]
     66          
     67          	ssn_mem_p-> head_ = 0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6001             STR      R1,[R0, #+0]
     68          	ssn_mem_p-> tail_ = 0;
     69          	ssn_mem_p-> buff = ssn_buffer_raw;
   \   0000001A   0xF100 0x0120      ADD      R1,R0,#+32
   \   0000001E   0xF8C0 0x1006      STR      R1,[R0, #+6]
     70          	ssn_mem_p-> rate_ = 400; // rate in Hz
   \   00000022   0xF44F 0x71C8      MOV      R1,#+400
   \   00000026   0x8141             STRH     R1,[R0, #+10]
     71          	// TODO: setup NEW ADC to use this rate
     72          
     73          	ssn_mem_p-> next_pkt_ = SSN_8BIT_SPP;
   \   00000028   0x2114             MOVS     R1,#+20
   \   0000002A   0x8081             STRH     R1,[R0, #+4]
     74          	ssn_mem_p-> start_time_ = 0; // start index for the Packet
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF8C0 0x100E      STR      R1,[R0, #+14]
     75          	ssn_mem_p-> start_index_ = 0; // start index for the Packet
   \   00000032   0x8181             STRH     R1,[R0, #+12]
     76          	ssn_mem_p-> burst_enabled_ = 0; // send a burst of a given size
   \   00000034   0x8241             STRH     R1,[R0, #+18]
     77          
     78          	ssn_mem_p-> pause_ = 0; // send a burst of a given size
   \   00000036   0x7501             STRB     R1,[R0, #+20]
     79          	ssn_mem_p-> pause_timeout_ = 0; // send a burst of a given size
   \   00000038   0xF8C0 0x1015      STR      R1,[R0, #+21]
     80          	
     81          	ssn_mem_p->burst_timeout_ = 0;
   \   0000003C   0xF8C0 0x1019      STR      R1,[R0, #+25]
     82          
     83          	#ifdef SSN_TEST
     84          		ssn_mem_p-> burst_enabled_ = 10000;//255; // send a burst of a given size	
   \   00000040   0xF242 0x7110      MOVW     R1,#+10000
   \   00000044   0x8241             STRH     R1,[R0, #+18]
     85          	#endif // SSN_TEST
     86          	sch_add_loop( (sch_loop_func_t) ssn_loop);
   \   00000046   0x.... 0x....      ADR.W    R0,ssn_loop
   \   0000004A   0x.... 0x....      BL       sch_add_loop
     87          
     88          	ssn_mem_p-> seq_no_ = 0;
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x7748             STRB     R0,[R1, #+29]
     89          	
     90          #ifdef _BRIDGE_EXP_
     91          	// (adc_channel, context, receiver)
     92          	//adc0_attach(0, 0x22, NULL);
     93          	//adc_resumeADC();
     94          #endif // _BRIDGE_EXP_
     95          }
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
     96          
     97          
     98          /**
     99           * uint16_t ssn_start_burst(uint16_t len) - starts the burst transmission of LEN packets (e.g.)
    100           * RETURNS the number of scheduled packets or 0 is failed/already transmitting
    101           */

   \                                 In section .text, align 2, keep-with-next
    102          uint16_t ssn_start_burst(uint16_t len)
    103          {
    104          	if (0 == ssn_mem_p -> burst_enabled_)
   \                     ssn_start_burst: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_1
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x8A53             LDRH     R3,[R2, #+18]
   \   00000006   0xB94B             CBNZ.N   R3,??ssn_start_burst_0
    105          	{	// Reset buffer (if this is what we want????)
    106          		ssn_mem_p-> seq_no_ = 0;
   \   00000008   0x7753             STRB     R3,[R2, #+29]
    107          		ssn_mem_p-> head_ = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x800A             STRH     R2,[R1, #+0]
    108          		ssn_mem_p-> tail_ = 0;
   \   00000010   0x804A             STRH     R2,[R1, #+2]
    109          		ssn_mem_p->next_pkt_ =  ssn_mem_p->head_ + SSN_8BIT_SPP;
   \   00000012   0x880A             LDRH     R2,[R1, #+0]
   \   00000014   0x3214             ADDS     R2,R2,#+20
   \   00000016   0x808A             STRH     R2,[R1, #+4]
    110          		return ssn_mem_p-> burst_enabled_ = len; // send a burst of a given size	
   \   00000018   0x8248             STRH     R0,[R1, #+18]
   \   0000001A   0x4770             BX       LR
    111          	}
    112          	else
    113          	{
    114          		return 0;
   \                     ??ssn_start_burst_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    115          	}
    116          }	
    117          	
    118          /**
    119           * uint16_t ssn_stop_burst() - stops the burst transmission
    120           * RETURNS 1 when successful (always??
    121           */

   \                                 In section .text, align 2, keep-with-next
    122          uint16_t ssn_stop_burst()
    123          {
    124          	if (0 != ssn_mem_p -> burst_enabled_)
   \                     ssn_stop_burst: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_1
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x8A41             LDRH     R1,[R0, #+18]
   \   00000006   0xB131             CBZ.N    R1,??ssn_stop_burst_0
    125          	{	// Disable and reset buffer (??)
    126          		ssn_mem_p -> burst_enabled_ = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8241             STRH     R1,[R0, #+18]
    127          		ssn_mem_p-> head_ = 0;
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
    128          		ssn_mem_p-> tail_ = 0;
   \   0000000E   0x8041             STRH     R1,[R0, #+2]
    129          		ssn_mem_p->next_pkt_ =  ssn_mem_p->head_ + SSN_8BIT_SPP; // not needed ??
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0x3114             ADDS     R1,R1,#+20
   \   00000014   0x8081             STRH     R1,[R0, #+4]
    130          		return 1;
    131          	}
    132          	else
    133          	{
    134          		return 1; // already disabled
   \                     ??ssn_stop_burst_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x4770             BX       LR               ;; return
    135          	}
    136          }	
    137          	
    138          	
    139          	/**
    140          	 * ssn_test() - tests Signal Processing operation (e.g.)
    141          	 */
    142          	uint8_t ssn_test();
    143          	
    144          	
    145          /**
    146           * ssn_loop() - executes main loop block (BUT DOES NOT LOOP ITSELF!!!)
    147           */

   \                                 In section .text, align 4, keep-with-next
    148          void ssn_loop( void )
    149          {
   \                     ssn_loop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    150          	//	ssn_mem_p->sample_interval_ = (ssn_mem_p->last_tick_ - ssn_mem_p->tail_tick_);
    151          	if ( 1 == ssn_mem_p->pause_)
   \   00000002   0x....             LDR.N    R4,??DataTable7_1
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x7D01             LDRB     R1,[R0, #+20]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD109             BNE.N    ??ssn_loop_0
    152          	{
    153          		if ( ssn_mem_p->pause_timeout_ < rtc_get_ticks())
   \   0000000C   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0xF8D1 0x2015      LDR      R2,[R1, #+21]
   \   00000016   0x4282             CMP      R2,R0
   \   00000018   0xD22D             BCS.N    ??ssn_loop_1
    154          		{
    155          			ssn_mem_p->pause_ = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7508             STRB     R0,[R1, #+20]
   \   0000001E   0xBD10             POP      {R4,PC}
    156          		}
    157          	}
    158          	else if ( 0 < ssn_mem_p->burst_enabled_)
   \                     ??ssn_loop_0: (+1)
   \   00000020   0x8A41             LDRH     R1,[R0, #+18]
   \   00000022   0xB341             CBZ.N    R1,??ssn_loop_1
    159          	{
    160          		if ( ( 0 < (ssn_mem_p->head_ - ssn_mem_p->next_pkt_) )
    161          			&& ( 0xFF00 > (ssn_mem_p->head_ - ssn_mem_p->next_pkt_) ) )
   \   00000024   0x8801             LDRH     R1,[R0, #+0]
   \   00000026   0x8880             LDRH     R0,[R0, #+4]
   \   00000028   0x1A08             SUBS     R0,R1,R0
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD220             BCS.N    ??ssn_loop_1
    162          		{
    163          			if (0 == ssn_send_pkt(SSN_8BIT_SPP))
   \   00000034   0x2014             MOVS     R0,#+20
   \   00000036   0x.... 0x....      BL       ssn_send_pkt
   \   0000003A   0xB948             CBNZ.N   R0,??ssn_loop_2
    164          			{
    165          				ssn_mem_p->pause_ = 1;
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x7508             STRB     R0,[R1, #+20]
    166          				ssn_mem_p->pause_timeout_ = rtc_get_ticks() + SSN_PAUSE_DELAY;
   \   00000042   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x6821             LDR      R1,[R4, #+0]
   \   0000004A   0xF8C1 0x0015      STR      R0,[R1, #+21]
   \   0000004E   0xBD10             POP      {R4,PC}
    167          			}
    168          			else
    169          			{
    170          				ssn_mem_p->burst_enabled_--;
   \                     ??ssn_loop_2: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x8A41             LDRH     R1,[R0, #+18]
   \   00000054   0x1E49             SUBS     R1,R1,#+1
   \   00000056   0x8241             STRH     R1,[R0, #+18]
    171          				ssn_mem_p->next_pkt_ += SSN_8BIT_SPP;
    172          				ssn_mem_p->start_index_ = ssn_mem_p->next_pkt_ - SSN_8BIT_SPP ;
    173          				//ssn_mem_p->start_time_ = rtc_get_ticks() - (SSN_SPP*1000/ssn_mem_p->rate_);
    174          				ssn_mem_p->start_time_ = ssn_mem_p->start_time_ + (1000UL*SSN_8BIT_SPP/(uint32_t)ssn_mem_p->rate_);
   \   00000058   0xF644 0x6220      MOVW     R2,#+20000
   \   0000005C   0x8881             LDRH     R1,[R0, #+4]
   \   0000005E   0x3114             ADDS     R1,R1,#+20
   \   00000060   0x8081             STRH     R1,[R0, #+4]
   \   00000062   0x3914             SUBS     R1,R1,#+20
   \   00000064   0x8181             STRH     R1,[R0, #+12]
   \   00000066   0x8943             LDRH     R3,[R0, #+10]
   \   00000068   0xF8D0 0x100E      LDR      R1,[R0, #+14]
   \   0000006C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000070   0x1851             ADDS     R1,R2,R1
   \   00000072   0xF8C0 0x100E      STR      R1,[R0, #+14]
    175          			}
    176          		}
    177          	}
    178          	else
    179          	{
    180          		/* // do nothing if disabled
    181          		if ( ssn_mem_p->burst_timeout_ > rtc_get_ticks())
    182          		{
    183          			ssn_mem_p->burst_enabled_ = 10;
    184          		}
    185          		*/
    186          //		adc_suspendADC();
    187          	}
    188          	// If packet is filled then sent out
    189          }
   \                     ??ssn_loop_1: (+1)
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    190          	
    191          	
    192          	/**
    193          	 * ssn_recv_sample(uint8_t context, uint16_t value) - receives a sample
    194          	 */

   \                                 In section .text, align 2, keep-with-next
    195          void ssn_recv_sample(uint8_t context, uint16_t value)
    196          {
    197          	(ssn_mem_p->buff)[ssn_mem_p->head_ & SSN_BUFF_MASK] = value;
   \                     ssn_recv_sample: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_1
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF8D0 0x2006      LDR      R2,[R0, #+6]
   \   00000008   0x7803             LDRB     R3,[R0, #+0]
   \   0000000A   0xF003 0x037F      AND      R3,R3,#0x7F
   \   0000000E   0xF822 0x1013      STRH     R1,[R2, R3, LSL #+1]
    198          	ssn_mem_p->head_++;
   \   00000012   0x8801             LDRH     R1,[R0, #+0]
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    199          	if (0 == ((ssn_mem_p->head_ - ssn_mem_p->tail_) & SSN_BUFF_MASK))
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x8842             LDRH     R2,[R0, #+2]
   \   0000001C   0x1A89             SUBS     R1,R1,R2
   \   0000001E   0xF011 0x0F7F      TST      R1,#0x7F
   \   00000022   0xBF04             ITT      EQ 
   \   00000024   0x1C51             ADDEQ    R1,R2,#+1
   \   00000026   0x8041             STRHEQ   R1,[R0, #+2]
    200          	{
    201          		// eat your own tail
    202          		ssn_mem_p->tail_++;
    203          	}
    204          }
   \   00000028   0x4770             BX       LR               ;; return
    205          
    206          
    207          /**
    208           * ssn_execute_command(packet) - executes a command received in "packet"
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          void ssn_execute_command ( uint8_t *packet)
    211          {	
   \                     ssn_execute_command: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    212          	ssn_command_mod_v1_t *cmd = (ssn_command_mod_v1_t*)packet;
    213          	switch (cmd->command)
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD01A             BEQ.N    ??ssn_execute_command_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD118             BNE.N    ??ssn_execute_command_0
    214          	{
    215          		case SSN_CMD_SET:
    216          			// set interval and other params
    217          			return;
    218          			//break;
    219          		case SSN_CMD_REQ:
    220          //			ssn_mem_p->start_time_ = cmd->ticks;
    221          //			ssn_mem_p->start_index_ = ssn_mem_p->head_ - ssn_time_offset(cmd->ticks);
    222          			//adc_set_rate_divider((uint8_t)((uint16_t)20000 / cmd->rate));
    223          			ssn_mem_p->rate_ = cmd->rate;
   \   0000000E   0x....             LDR.N    R5,??DataTable7_1
   \   00000010   0xF8B4 0x0007      LDRH     R0,[R4, #+7]
   \   00000014   0x6829             LDR      R1,[R5, #+0]
   \   00000016   0x8148             STRH     R0,[R1, #+10]
    224          			ssn_mem_p->start_time_ = rtc_get_ticks();
   \   00000018   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000001C   0x6829             LDR      R1,[R5, #+0]
   \   0000001E   0xF8C1 0x000E      STR      R0,[R1, #+14]
    225          			ssn_mem_p->start_index_ = ssn_mem_p->head_;
   \   00000022   0x8808             LDRH     R0,[R1, #+0]
   \   00000024   0x8188             STRH     R0,[R1, #+12]
    226          			ssn_mem_p->burst_timeout_ = rtc_get_ticks() + 1000UL * cmd->mod_data;
   \   00000026   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000002A   0x6829             LDR      R1,[R5, #+0]
   \   0000002C   0x7AE2             LDRB     R2,[R4, #+11]
   \   0000002E   0xF44F 0x737A      MOV      R3,#+1000
   \   00000032   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   00000036   0xF8C1 0x0019      STR      R0,[R1, #+25]
    227          			ssn_mem_p->next_pkt_ =  ssn_mem_p->start_index_ + SSN_8BIT_SPP;
   \   0000003A   0x8988             LDRH     R0,[R1, #+12]
   \   0000003C   0x3014             ADDS     R0,R0,#+20
   \   0000003E   0x8088             STRH     R0,[R1, #+4]
    228          //			ssn_send_pkt(cmd->mod_data); // sample count to send
    229          			break;
    230          	}
    231          }
   \                     ??ssn_execute_command_0: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    232          
    233          
    234          /****************************************************************************
    235          **	Functions implementation (PRIVATE)
    236          ****************************************************************************/
    237          
    238          
    239          /**
    240           * ssn_time_offset(start_ticks) -
    241           *	
    242           */

   \                                 In section .text, align 2, keep-with-next
    243          uint16_t ssn_time_offset(uint32_t start_ticks)
    244          {
   \                     ssn_time_offset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    245          	uint16_t off;
    246          	uint32_t d = rtc_get_ticks() - start_ticks;
   \   00000004   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
    247          	d = d * ssn_mem_p->rate_ / 1000;
    248          	off = (uint16_t)d;
    249          	return off;
   \   00000008   0x....             LDR.N    R1,??DataTable7_1
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x8949             LDRH     R1,[R1, #+10]
   \   0000000E   0x1B00             SUBS     R0,R0,R4
   \   00000010   0x4348             MULS     R0,R1,R0
   \   00000012   0xF44F 0x717A      MOV      R1,#+1000
   \   00000016   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000001A   0xB280             UXTH     R0,R0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    250          }
    251          
    252          /**
    253           * ssn_send_pkt(sample_count)
    254           *	
    255           */

   \                                 In section .text, align 2, keep-with-next
    256          uint8_t ssn_send_pkt(uint8_t sample_count)
    257          {
   \                     ssn_send_pkt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    258          	// 1) Reserve a packet in a queue buffer (NOT QUEUED YET) and check if successful
    259          	uint8_t pkt_id = NO_PACKET_INDEX;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    260          #ifdef SSN_WITH_RAW_FORMAT
    261          	uint8_t mod_len = sample_count + MOD_RAW_DATA_OVERHEAD;
   \   0000000A   0x1CE5             ADDS     R5,R4,#+3
    262          #else // SSN_WITH_RAW_FORMAT
    263          	uint8_t mod_len = SSN_SENSOR_DATA_V1_SIZE + sample_count;//sizeof(SSN_BUFF_ITEM_T);
    264          #endif // else SSN_WITH_RAW_FORMAT
    265          	if (0 == tsp_reserve_packet( mod_len, &pkt_id, BS_ADDR))
   \   0000000C   0x22FE             MOVS     R2,#+254
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0xB2E8             UXTB     R0,R5
   \   00000012   0x.... 0x....      BL       tsp_reserve_packet
   \   00000016   0xB920             CBNZ.N   R0,??ssn_send_pkt_0
    266          	{
    267          		// Error
    268          		sys_error(SYS_ERROR_MEM_FULL);
   \   00000018   0x2018             MOVS     R0,#+24
   \   0000001A   0x.... 0x....      BL       sys_error
    269          		return 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
    270          	}
    271          	{
    272          		IAR_PACKED uint8_t XDATA*pkt_samples = NULL;
    273          		uint16_t i, temp;
    274          		// 2) Get a pointer to the reserved MODULE inside the packet (set as DUMMY)
    275          		uint8_t XDATA*mod = (uint8_t XDATA*)tsp_get_dummy(pkt_id);
   \                     ??ssn_send_pkt_0: (+1)
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0x.... 0x....      BL       tsp_get_dummy
    276          		// 3) Fill the headers of the APP-specific module and the END module (REQUIRED!!)
    277          		//    .... (Possibly defered, but not for too long)
    278          		ssn_command_mod_v1_t XDATA*ph = ( ssn_command_mod_v1_t XDATA* )mod ;
    279          #ifdef SSN_WITH_RAW_FORMAT
    280          		pkt_mod_raw_data_t *raw = (pkt_mod_raw_data_t *)(&(ph->command));
    281          		ph->module_type = PKT_MODULE_TYPE_RAW_CHANNEL;
   \   0000002A   0x2260             MOVS     R2,#+96
   \   0000002C   0x7002             STRB     R2,[R0, #+0]
   \   0000002E   0x1C81             ADDS     R1,R0,#+2
    282          		ph->module_length = mod_len;
   \   00000030   0x7045             STRB     R5,[R0, #+1]
    283          		// 4) Fill the content of the APP-specific module
    284          		//    .... (Possibly defered, but not for too long)
    285          		raw -> seq_num = ssn_mem_p-> seq_no_++;
   \   00000032   0x....             LDR.N    R0,??DataTable7_1
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x7F53             LDRB     R3,[R2, #+29]
   \   00000038   0x1C5D             ADDS     R5,R3,#+1
   \   0000003A   0x7755             STRB     R5,[R2, #+29]
   \   0000003C   0x700B             STRB     R3,[R1, #+0]
    286          		raw -> channel = MY_ADC_CHANNEL;
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x704A             STRB     R2,[R1, #+1]
    287          		raw -> numsamples = sample_count;
   \   00000042   0x708C             STRB     R4,[R1, #+2]
    288          		pkt_samples = (uint8_t XDATA*)(&(raw->samples_list));
   \   00000044   0x1CC9             ADDS     R1,R1,#+3
    289          #else
    290          		ph ->module_type = PKT_MODULE_TYPE_SSN_V1;
    291          		ph ->module_length = mod_len;
    292          		// 4) Fill the content of the APP-specific module
    293          		//    .... (Possibly defered, but not for too long)
    294          		ph ->command = SSN_DATA_V1;
    295          		ph -> ticks = ENDIAN32(ssn_mem_p->start_time_);
    296          		ph -> rate = ENDIAN16(ssn_mem_p->rate_);
    297          		ph -> channel = MY_ADC_CHANNEL;
    298          		ph -> seq_num = ssn_mem_p->seq_no_++;
    299          		pkt_samples = (uint8_t XDATA*)(&(ph->mod_data));
    300          #endif // not SSN_WITH_RAW_FORMAT
    301          		for( i = 0; i < sample_count; i++)
   \   00000046   0xE00D             B.N      ??ssn_send_pkt_1
    302          		{
    303          			temp = (ssn_mem_p->buff)[(i+ssn_mem_p->start_index_)&SSN_BUFF_MASK];
    304          			pkt_samples[i] = (uint8_t)(temp/100); // Divide by 100 to get value in 0.01V units (10mV)
   \                     ??ssn_send_pkt_2: (+1)
   \   00000048   0x6803             LDR      R3,[R0, #+0]
   \   0000004A   0xF8D3 0x5006      LDR      R5,[R3, #+6]
   \   0000004E   0x899B             LDRH     R3,[R3, #+12]
   \   00000050   0x189B             ADDS     R3,R3,R2
   \   00000052   0xF003 0x037F      AND      R3,R3,#0x7F
   \   00000056   0xF835 0x3013      LDRH     R3,[R5, R3, LSL #+1]
   \   0000005A   0x2564             MOVS     R5,#+100
   \   0000005C   0xFB93 0xF3F5      SDIV     R3,R3,R5
   \   00000060   0x5453             STRB     R3,[R2, R1]
    305          			//(ssn_mem_p->buff)[(i+ssn_mem_p->start_index_)&SSN_BUFF_MASK];
    306          		}		
   \   00000062   0x1C52             ADDS     R2,R2,#+1
   \                     ??ssn_send_pkt_1: (+1)
   \   00000064   0x42A2             CMP      R2,R4
   \   00000066   0xDBEF             BLT.N    ??ssn_send_pkt_2
    307          	}
    308          	// 5) Send the Packet out via TRANSPORT layer (by default put into the queue)
    309          	return tsp_send_from_modules(pkt_id);
   \   00000068   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006C   0x.... 0x....      BL       tsp_send_from_modules
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    310          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     ssn_mem_raw

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     ssn_mem_p
    311          
    312          /**
    313          * sig_filter_new_data(input) -
    314          *	
    315          */
    316          //void sig_filter_reset(sig_filter_mem_t XDATA *filter);
    317          
    318          /**
    319          * sig_filter_new_config(module) -
    320          *	
    321          */
    322          //void sig_filter_new_config(sig_filter_mem_t XDATA *filter, uint8_t * module)
    323          
    324          
    325          /**
    326          * sig_filter_new_data(input) -
    327          *	
    328          */
    329          /*
    330          float sig_filter_new_data( sig_filter_mem_t XDATA *filter, float input )
    331          {
    332          	float new_y = B[1] * input;
    333          	X[idx%] = input;
    334              for(i=2; i<3; i++)
    335          	{
    336          		new_y = new_y + X(idx-i+1)* B(i) - Y(idx-i+1)*A(i);
    337          	}
    338          	Y[idx] = new_y;
    339          }
    340          */
    341          
    342          // ############################################################################
    343          // ############################################################################
    344          // Spacers
    345          // ############################################################################
    346          // ############################################################################
    347          
    348          
    349          
    350          #endif // _ENABLE_SSN_BASIC_
    351          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ssn_execute_command
        16   -> halCommonGetInt32uMillisecondTick
       8   ssn_init
         8   -> sch_add_loop
       8   ssn_loop
         8   -> halCommonGetInt32uMillisecondTick
         8   -> ssn_send_pkt
       0   ssn_recv_sample
      16   ssn_send_pkt
        16   -> sys_error
        16   -> tsp_get_dummy
        16   -> tsp_reserve_packet
        16   -> tsp_send_from_modules
       0   ssn_start_burst
       0   ssn_stop_burst
       8   ssn_time_offset
         8   -> halCommonGetInt32uMillisecondTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
      66  ssn_execute_command
      86  ssn_init
     120  ssn_loop
       4  ssn_mem_p
     288  ssn_mem_raw
          ssn_buffer_raw
      42  ssn_recv_sample
     114  ssn_send_pkt
      32  ssn_start_burst
      26  ssn_stop_burst
      30  ssn_time_offset

 
 292 bytes in section .bss
 524 bytes in section .text
 
 524 bytes of CODE memory
 292 bytes of DATA memory

Errors: none
Warnings: none
