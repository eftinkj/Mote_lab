###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:30:21
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_sc.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_sc.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"stm32w108xx_sc.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\stm32w108xx_sc.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\stm32w108xx_sc.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Libraries\STM32W108xx_StdPeriph_Driver\src\stm32w108xx_sc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32w108xx_sc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    30-November-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial Controller (SC):
      9            *           + Universal Asynchronous Receiver/Transmitter communication
     10            *           + Serial Peripheral Interface communication
     11            *           + Inter-Integrated Circuit communication
     12            *           + DMA transfers management in UART and SPI modes
     13            *
     14            *  @verbatim
     15            *
     16           ===============================================================================
     17                                 ##### How to use this driver #####
     18           ===============================================================================
     19            (#) Peripherals GPIO Configuration: 
     20                 (++) Select the desired pin GPIO_InitStruct->GPIO_Pin according to the
     21                      defined Initialization and Configuration Tables for each serial control
     22                      modes (UART, SPI master, SPI Salve and I2C).
     23                 (++) Refer to the Initialization and Configuration Tables to configure 
     24                      the GPIO_InitStruct->GPIO_Mode
     25                 (++) Call GPIO_Init() function.
     26             (#) For the I2C mode Program the clock rate using the I2C_Init() function.
     27             (#) For the SPI mode Program the Polarity, Phase, First Data, Clcok rate
     28                 and the Peripheral Mode rate using the SPI_Init() function.
     29             (#) For the UART mode Program the Baud Rate, Word Length , Stop Bit, Parity and Hardware 
     30                 flow control using the UART_Init() function.
     31             (#) Enable the PPP using the PPP_Cmd() function. 
     32             (#) For UART Mode set pull-up resistors on Tx and Rx pins using GPIO_SetBits() function.
     33             (#) Enable the NVIC and the corresponding interrupt using the function. 
     34                 PPP_ITConfig() if you need to use interrupt mode. 
     35             (#) When using the DMA mode 
     36                 (++) Configure the DMA using SC_DMA_Init() function.
     37                 (++) Active the needed channel Request using SC_DMA_ChannelLoadEnable() function.
     38          
     39             [..]
     40             (@) PPP can be UART, SPI or I2C.
     41             (@) The DMA is not support for I2C mode.
     42          
     43              @endverbatim
     44            *
     45            ******************************************************************************
     46            * @attention
     47            *
     48            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     49            *
     50            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     51            * You may not use this file except in compliance with the License.
     52            * You may obtain a copy of the License at:
     53            *
     54            *        http://www.st.com/software_license_agreement_liberty_v2
     55            *
     56            * Unless required by applicable law or agreed to in writing, software 
     57            * distributed under the License is distributed on an "AS IS" BASIS, 
     58            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     59            * See the License for the specific language governing permissions and
     60            * limitations under the License.
     61            *
     62            ******************************************************************************
     63            */
     64          
     65          
     66          /* Includes ------------------------------------------------------------------*/
     67          #include "stm32w108xx_sc.h"
     68          
     69          /** @addtogroup STM32W108xx_StdPeriph_Driver
     70            * @{
     71            */
     72          
     73          /** @defgroup SERIAL_CONTROLLER
     74            * @brief SC driver modules
     75            * @{
     76            */
     77          
     78          /* Private typedef -----------------------------------------------------------*/
     79          /* Private define ------------------------------------------------------------*/
     80          /* I2C ADD0 mask */
     81          #define OAR1_ADD0_Set           ((uint8_t)0x01)
     82          #define OAR1_ADD0_Reset         ((uint8_t)0xFE)
     83          #define SPICR_CLEAR_MASK        ((uint32_t)0xFFFFFFE8)
     84          
     85          /* Private macro -------------------------------------------------------------*/
     86          #define    ABS(x)         ((x) > 0) ? (x) : (-(x))
     87          /* Private variables ---------------------------------------------------------*/
     88          /* Private function prototypes -----------------------------------------------*/
     89          /* Private functions ---------------------------------------------------------*/
     90          
     91          /** @defgroup SC_Private_Functions
     92            * @{
     93            */
     94          
     95          /** @defgroup SC_Group1 Universal Asynchronous Receiver/Transmitter communication
     96           *  @brief   universal asynchronous receiver transmitter functions 
     97           *
     98          @verbatim   
     99           ===============================================================================
    100                     ##### Universal Asynchronous Receiver-Transmitter functions #####
    101           ===============================================================================
    102              [..] This section provides a set of functions allowing to handles the Universal
    103                   Asynchronous Receiver Transmitter communication.
    104              
    105              (@) Only SC1 include an universal asynchronous receiver transmitter (UART) controller.
    106          
    107          *** Initialization and Configuration ***
    108           =======================================
    109              [..] The GPIO pins that can be assigned to UART interface are listed in the following table:
    110             +------------------------------------------------------+     
    111             |Parameter | Direction | GPIO configuration |  SC1 pin | 
    112             |----------|-----------|--------------------|----------|             
    113             |   TXD    |    Out    |  Alternate Output  |   PB1    |
    114             |          |           |    (push-pull)     |          |
    115             |----------|-----------|-------------------------------|  
    116             |   RXD    |    In     |        Input       |   PB2    |
    117             |----------|-----------|--------------------|----------|             
    118             |   nCTS   |    In     |        Input       |   PB3    |
    119             |----------|-----------|-------------------------------|  
    120             |   nRTS   |    Out    |  Alternate Output  |   PB4    |
    121             |          |           |    (push-pull)     |          |
    122             +------------------------------------------------------+
    123          
    124              [..] For the asynchronous mode these parameters can be configured: 
    125                   (+) Baud Rate.
    126                   (+) Word Length.
    127                   (+) Stop Bit.
    128                   (+) Parity: If the parity is enabled, then the MSB bit of the data written
    129                        in the data register is transmitted but is changed by the parity bit.
    130                        Depending on the frame length defined by the M bit (7-bits or 8-bits),
    131                        the possible UART frame formats are as listed in the following table:
    132          
    133             +-------------------------------------------------------------+     
    134             |   M bit |  PCE bit  |            UART frame                 |
    135             |---------------------|---------------------------------------|             
    136             |    0    |    0      |    | SB | 7 bit data | STB |          |
    137             |---------|-----------|---------------------------------------|  
    138             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    139             |---------|-----------|---------------------------------------|  
    140             |    1    |    0      |    | SB | 8 bit data | STB |          |
    141             |---------|-----------|---------------------------------------|  
    142             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    143             +-------------------------------------------------------------+            
    144          
    145                   (+) Hardware flow control.
    146              [..] The UART_Init() function follows the UART asynchronous configuration 
    147                   procedure (details for the procedure is available in datasheet.
    148          
    149          *** Data transfers ***
    150           =====================
    151              [..] In reception, data are received and then stored into an internal Rx buffer while 
    152                   In transmission, data are first stored into an internal Tx buffer before being 
    153                   transmitted.
    154          
    155              [..] The read access of the SCx_DR register can be done using 
    156                   UART_ReceiveData() function and returns the Rx buffered value. Whereas a write 
    157                   access to the SCx_DR can be done using UART_SendData() function and stores 
    158                   the written data into Tx buffer.
    159          
    160           *** Interrupts and flags management ***
    161           =======================================
    162              [..] This subsection provides also a set of functions allowing to configure the 
    163                   UART Interrupts sources, Requests and check or clear the flags or pending bits status. 
    164                   The user should identify which mode will be used in his application to 
    165                   manage the communication: Polling mode, Interrupt mode or DMA mode(refer SC_Group4).
    166          
    167              [..] In Polling Mode, the UART communication can be managed by these flags:
    168                   (#) UART_FLAG_TXE: to indicate the status of the transmit buffer register.
    169                   (#) UART_FLAG_RXNE: to indicate the status of the receive buffer register.
    170                   (#) UART_FLAG_IDLE: to indicate the status of the Idle Line.
    171                   (#) UART_FLAG_CTS: to indicate the status of the nCTS line.
    172                   (#) UART_FLAG_FE: to indicate if a frame error occur.
    173                   (#) UART_FLAG_PE: to indicate if a parity error occur.
    174                   (#) UART_FLAG_OVR: to indicate if an Overrun error occur.
    175              [..] In this mode it is advised to use the following functions:
    176                   (+) FlagStatus UART_GetFlagStatus(SC_UART_TypeDef* SCx_UART, uint32_t UART_FLAG).
    177              [..] In this mode all the UART flags are cleared by hardware.
    178          
    179              [..] In Interrupt Mode, the UART communication can be managed by 7 interrupt 
    180                   sources and 7 pending bits:
    181                   (+) Pending Bits:
    182                       (##) UART_IT_PE: to indicate the status of Parity Error interrupt.  
    183                       (##) UART_IT_FE: to indicate the status of Framing Error interrupt.
    184                       (##) UART_IT_UND: to indicate the status of UnderRun Error interrupt.
    185                       (##) UART_IT_OVR: to indicate the status of OverRun Error interrupt.
    186                       (##) UART_IT_IDLE: to indicate the status of IDLE line detected interrupt.
    187                       (##) UART_IT_TXE: to indicate the status of the Transmit data register empty interrupt.
    188                       (##) UART_IT_RXNE: to indicate the status of the Data Register not empty interrupt.
    189          
    190                   (+) Interrupt Source:
    191                       (##) UART_IT_PE: specifies the interrupt source forParity Error pending interrupt.  
    192                       (##) UART_IT_FE: specifies the interrupt source for Framing Error pending interrupt.
    193                       (##) UART_IT_UND: specifies the interrupt source for UnderRun Error pending interrupt.
    194                       (##) UART_IT_OVR: specifies the interrupt source for OverRun Error pending interrupt.
    195                       (##) UART_IT_IDLE: specifies the interrupt source for IDLE line detected pending interrupt.
    196                       (##) UART_IT_TXE: specifies the interrupt source for the Transmit data register empty pending interrupt.
    197                       (##) UART_IT_RXNE: specifies the interrupt source for the Data Register not empty pending interrupt.
    198                       -@@- These parameters are coded in order to use them as interrupt source 
    199                            or as pending bits.
    200              [..] In this Mode it is advised to use the following functions:
    201                   (+) void UART_ITConfig(SC_IT_TypeDef* SCx_IT, uint32_t UART_IT, FunctionalState NewState).
    202                   (+) ITStatus UART_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t UART_IT).
    203                   (+) void UART_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t UART_IT).
    204          
    205          @endverbatim
    206            * @{
    207            */
    208          
    209          /**
    210            * @brief  Deinitializes the SCx_UART peripheral registers to their default reset values.
    211            * @param  SCx_UART: where x can be 1 to select the Serial controller peripheral.
    212            * @retval None
    213            */

   \                                 In section .text, align 2, keep-with-next
    214          void UART_DeInit(SC_UART_TypeDef* SCx_UART)
    215          {
    216            /* Check the parameters */
    217            assert_param(IS_UART_PERIPH(SCx_UART));
    218            
    219            SCx_UART->CR = 0;
   \                     UART_DeInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6181             STR      R1,[R0, #+24]
    220            SCx_UART->UARTCR = 0;
   \   00000004   0x6201             STR      R1,[R0, #+32]
    221            SCx_UART->UARTBRR1 = 0;
   \   00000006   0x62C1             STR      R1,[R0, #+44]
    222            SCx_UART->UARTBRR2 = 0;
   \   00000008   0x6301             STR      R1,[R0, #+48]
    223          }
   \   0000000A   0x4770             BX       LR               ;; return
    224          
    225          /**
    226            * @brief  Initializes the SC1_UART peripheral according to the specified
    227            *   parameters in the UART_InitStruct .
    228            * @param  SCx_UART: where x can be 1 to select the Serial controller peripheral.
    229            * @param  UART_InitStruct: pointer to a UART_InitTypeDef structure
    230            *   that contains the configuration information for the specified SC1_UART peripheral.
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void UART_Init(SC_UART_TypeDef* SCx_UART, UART_InitTypeDef* UART_InitStruct)
    234          {
   \                     UART_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    235            int32_t temp1, temp2 = 0;
    236            uint32_t clockfrequency = 0;
    237            uint32_t N = 0;
    238          
    239            /* Check the parameters */
    240            assert_param(IS_UART_PERIPH(SCx_UART));
    241            assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));
    242            assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLength));   
    243            assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
    244            assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
    245            assert_param(IS_UART_HARDWARE_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
    246            
    247            /* Disable the selected UART by clearing the MODE bits in the CR register */
    248            SCx_UART->CR &= (uint16_t)~((uint16_t)SC_CR_MODE);
   \   00000006   0x69A0             LDR      R0,[R4, #+24]
   \   00000008   0xF64F 0x71FC      MOVW     R1,#+65532
   \   0000000C   0x4008             ANDS     R0,R1,R0
   \   0000000E   0x61A0             STR      R0,[R4, #+24]
    249            
    250            /*---------------------------- UARTCR Configuration ------------------------*/
    251            /* Configure the USART Word Length, Parity and mode ------------------------*/
    252            /* Set STOP bit according to USART_StopBits value */
    253            /* Set the M bits according to UART_WordLength value */
    254            /* Set PCE and PS bits according to USART_Parity value */
    255            /* Set HFCE and AHFCE bits according to UART_HardwareFlowControl value */
    256            SCx_UART->UARTCR = (uint32_t)(UART_InitStruct->UART_WordLength | UART_InitStruct->UART_Parity |
    257                                          UART_InitStruct->UART_StopBits | UART_InitStruct->UART_HardwareFlowControl);
   \   00000010   0x68E9             LDR      R1,[R5, #+12]
   \   00000012   0x6868             LDR      R0,[R5, #+4]
   \   00000014   0x4308             ORRS     R0,R1,R0
   \   00000016   0x68A9             LDR      R1,[R5, #+8]
   \   00000018   0x4308             ORRS     R0,R1,R0
   \   0000001A   0x6929             LDR      R1,[R5, #+16]
   \   0000001C   0x4308             ORRS     R0,R1,R0
   \   0000001E   0x6220             STR      R0,[R4, #+32]
    258            /*---------------------------- UART BRR Configuration ----------------------*/
    259            /* Configure the UART Baud Rate --------------------------------------------*/
    260            clockfrequency = CLK_GetClocksFreq();
   \   00000020   0x.... 0x....      BL       CLK_GetClocksFreq
    261            N = (uint16_t)(clockfrequency/(2*(UART_InitStruct->UART_BaudRate)));
   \   00000024   0x6829             LDR      R1,[R5, #+0]
    262            
    263            /* Write to UART BRR1 */
    264            SCx_UART->UARTBRR1 &= (uint32_t)~SC_UARTBRR1_N;
   \   00000026   0x6AE2             LDR      R2,[R4, #+44]
   \   00000028   0x0C12             LSRS     R2,R2,#+16
   \   0000002A   0x0412             LSLS     R2,R2,#+16
   \   0000002C   0x62E2             STR      R2,[R4, #+44]
   \   0000002E   0x0049             LSLS     R1,R1,#+1
   \   00000030   0xFBB0 0xF1F1      UDIV     R1,R0,R1
    265            SCx_UART->UARTBRR1 |= (uint32_t)N;
   \   00000034   0x6AE2             LDR      R2,[R4, #+44]
   \   00000036   0xB289             UXTH     R1,R1
   \   00000038   0x430A             ORRS     R2,R1,R2
   \   0000003A   0x62E2             STR      R2,[R4, #+44]
    266          
    267            temp1 = (int32_t)(clockfrequency/(2*N));
   \   0000003C   0x0049             LSLS     R1,R1,#+1
   \   0000003E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
    268            temp2 = (int32_t)(clockfrequency/(2*N +1));
    269          
    270            temp1 = ABS((int32_t)((int32_t)temp1 - (int32_t)UART_InitStruct->UART_BaudRate));
   \   00000042   0x682B             LDR      R3,[R5, #+0]
   \   00000044   0x1C49             ADDS     R1,R1,#+1
   \   00000046   0x1AD2             SUBS     R2,R2,R3
   \   00000048   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004C   0xBF48             IT       MI 
   \   0000004E   0x4252             RSBMI    R2,R2,#+0
    271            temp2 = ABS((int32_t)((int32_t)temp2 - (int32_t)UART_InitStruct->UART_BaudRate));
   \   00000050   0x1AC0             SUBS     R0,R0,R3
   \   00000052   0xBF48             IT       MI 
   \   00000054   0x4240             RSBMI    R0,R0,#+0
    272            
    273            /* Check the baud rate error and write to UART BRR2 */
    274            if(temp1 > temp2)
   \   00000056   0x4290             CMP      R0,R2
   \   00000058   0x6B20             LDR      R0,[R4, #+48]
   \   0000005A   0xBFB2             ITEE     LT 
   \   0000005C   0xF040 0x0001      ORRLT    R0,R0,#0x1
   \   00000060   0x0840             LSRGE    R0,R0,#+1
   \   00000062   0x0040             LSLGE    R0,R0,#+1
    275            {
    276              SCx_UART->UARTBRR2 |= (uint32_t)SC_UARTBRR1_F;
    277            }
    278            else
    279            {
    280              SCx_UART->UARTBRR2 &=(uint32_t)~SC_UARTBRR1_F;
   \   00000064   0x6320             STR      R0,[R4, #+48]
    281            }
    282          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    283          
    284          /**
    285            * @brief  Fills each UART_InitStruct member with its default value.
    286            * @param  UART_InitStruct: pointer to a UART_InitTypeDef structure
    287            *   which will be initialized.
    288            * @retval None
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          void UART_StructInit(UART_InitTypeDef* UART_InitStruct)
    291          {
    292            /* UART_InitStruct members default value */
    293            UART_InitStruct->UART_BaudRate = 115200;
   \                     UART_StructInit: (+1)
   \   00000000   0xF44F 0x31E1      MOV      R1,#+115200
   \   00000004   0x6001             STR      R1,[R0, #+0]
    294            UART_InitStruct->UART_WordLength = UART_WordLength_8b;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x6041             STR      R1,[R0, #+4]
    295            UART_InitStruct->UART_StopBits = UART_StopBits_1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    296            UART_InitStruct->UART_Parity = UART_Parity_No;
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    297            UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_Disable;  
   \   00000010   0x6101             STR      R1,[R0, #+16]
    298          }
   \   00000012   0x4770             BX       LR               ;; return
    299          
    300          /**
    301            * @brief  Enables or disables the RTS assertion for the specified SC1_UART peripheral.
    302            * @param  SCx_UART: where x can be 1 to select the Serial controller peripheral.
    303            * @param  NewState: new state of the SC1_UART peripheral.
    304            *         This parameter can be: ENABLE or DISABLE.
    305            * @retval None
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          void UART_RTSAssertionCmd(SC_UART_TypeDef* SCx_UART, FunctionalState NewState)
    308          {
    309            /* Check the parameters */
    310            assert_param(IS_UART_PERIPH(SCx_UART));
    311            assert_param(IS_FUNCTIONAL_STATE(NewState));
    312            
    313            if (NewState != DISABLE)
   \                     UART_RTSAssertionCmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6A01             LDR      R1,[R0, #+32]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0xF64F 0x72FE      MOVWEQ   R2,#+65534
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    314            {
    315              /* The RTS signal is asserted by setting the nRTS bit in the UARTCR register */
    316              SCx_UART->UARTCR |= SC_UARTCR_nRTS;
    317            }
    318            else
    319            {
    320              /* The RTS signal is deasserted by clearing the nRTS bit in the UARTCR register */
    321              SCx_UART->UARTCR &= (uint16_t)~((uint16_t)SC_UARTCR_nRTS);
   \   00000010   0x6201             STR      R1,[R0, #+32]
    322            }
    323          }
   \   00000012   0x4770             BX       LR               ;; return
    324          
    325          /**
    326            * @brief  Enables or disables the specified SC1_UART peripheral.
    327            * @param  SCx_UART: where x can be 1 to select the Serial controller peripheral.
    328            * @param  NewState: new state of the SC1_UART peripheral.
    329            *         This parameter can be: ENABLE or DISABLE.
    330            * @retval None
    331            */

   \                                 In section .text, align 2, keep-with-next
    332          void UART_Cmd(SC_UART_TypeDef* SCx_UART, FunctionalState NewState)
    333          {
    334            /* Check the parameters */
    335            assert_param(IS_UART_PERIPH(SCx_UART));
    336            assert_param(IS_FUNCTIONAL_STATE(NewState));
    337            
    338            if (NewState != DISABLE)
   \                     UART_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6981             LDR      R1,[R0, #+24]
   \   00000004   0xF64F 0x72FC      MOVW     R2,#+65532
   \   00000008   0xD005             BEQ.N    ??UART_Cmd_0
    339            {
    340              /* Enable the selected UART by setting the MODE bit 0 in the CR register */
    341              SCx_UART->CR &= (uint16_t)~((uint16_t)SC_CR_MODE);
   \   0000000A   0x4011             ANDS     R1,R2,R1
   \   0000000C   0x6181             STR      R1,[R0, #+24]
    342              SCx_UART->CR |= SC_CR_MODE_0;
   \   0000000E   0x6981             LDR      R1,[R0, #+24]
   \   00000010   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000014   0xE000             B.N      ??UART_Cmd_1
    343            }
    344            else
    345            {
    346              /* Disable the selected UART by clearing the MODE bits in the CR register */
    347              SCx_UART->CR &= (uint16_t)~((uint16_t)SC_CR_MODE);
   \                     ??UART_Cmd_0: (+1)
   \   00000016   0x4011             ANDS     R1,R2,R1
   \                     ??UART_Cmd_1: (+1)
   \   00000018   0x6181             STR      R1,[R0, #+24]
    348            }
    349          }
   \   0000001A   0x4770             BX       LR               ;; return
    350          
    351          /**
    352            * @brief  Enables or disables the specified SCx_UART interrupts.
    353            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
    354            * @param  UART_IT: specifies the SCx_UART interrupt source to be enabled or disabled. 
    355            *   This parameter can be one of the following values:
    356            *     @arg UART_IT_PE: Parity error interrupt mask
    357            *     @arg UART_IT_FE: Frame error interrupt mask
    358            *     @arg UART_IT_UND: Underrun interrupt mask (to be checked)
    359            *     @arg UART_IT_OVR: Overrun interrupt mask
    360            *     @arg UART_IT_IDLE: Idle line detected interrupt mask
    361            *     @arg UART_IT_TXE: Transmit data register empty interrupt mask
    362            *     @arg UART_IT_RXNE: Data Register not empty interrupt mask
    363            * @param  NewState: new state of the specified SCx_UART interrupt source.
    364            *   This parameter can be: ENABLE or DISABLE.
    365            * @retval None
    366            */

   \                                 In section .text, align 2, keep-with-next
    367          void UART_ITConfig(SC_IT_TypeDef* SCx_IT, uint32_t UART_IT, FunctionalState NewState)
    368          {
    369            /* Check the parameters */
    370            assert_param(IS_UART_IT_PERIPH(SCx_IT));
    371            assert_param(IS_UART_IT(UART_IT));
    372            assert_param(IS_FUNCTIONAL_STATE(NewState));
    373            
    374            if (NewState != DISABLE)
   \                     UART_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6C02             LDR      R2,[R0, #+64]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
    375            {
    376              /* Enable the selected UART interrupt */
    377              SCx_IT->IER |= UART_IT;
    378            }
    379            else
    380            {
    381              /* Disable the selected UART interrupt */
    382              SCx_IT->IER &= (uint16_t)~((uint16_t)UART_IT);
   \   0000000E   0x6401             STR      R1,[R0, #+64]
    383            }
    384          }
   \   00000010   0x4770             BX       LR               ;; return
    385          
    386          /**
    387            * @brief  Trigger event configuration to handle the specified SCx_UART interrupt.
    388            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
    389            * @param  UART_IT: specifies the SCx_UART interrupt to be configured. 
    390            *   This parameter can be one of the following values:
    391            *     @arg UART_IT_IDLE: Idle line detected interrupt
    392            *     @arg UART_IT_TXE: Transmit data register empty interrupt
    393            *     @arg UART_IT_RXNE: Data Register not empty interrupt
    394            * @param  TriggerEvent: Trigger event configuration of the specified SCx_UART interrupt.
    395            *   This parameter can be one of the following values:
    396            *     @arg SC_TriggerEvent_Edge: The specified SCx_UART interrupt will be generated on edge
    397            *     @arg SC_TriggerEvent_Level: The specified SCx_UART interrupt will be generated on level
    398            * @retval None
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          void UART_TriggerEventConfig(SC_IT_TypeDef* SCx_IT, uint32_t UART_IT, uint32_t TriggerEvent)
    401          {
    402            /* Check the parameters */
    403            assert_param(IS_UART_IT_PERIPH(SCx_IT));
    404            assert_param(IS_UART_TRIGGEREVENT_IT(UART_IT));
    405            assert_param(IS_SC_TRIGGEREVENT(TriggerEvent));
    406            
    407            if (TriggerEvent != SC_TriggerEvent_Edge)
   \                     UART_TriggerEventConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6CC2             LDR      R2,[R0, #+76]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
    408            {
    409              /* The UART_IT interrupt will be handled on level */
    410              SCx_IT->ICR |= UART_IT;
    411            }
    412            else
    413            {
    414              /* The UART_IT interrupt will be handled on edge */
    415              SCx_IT->ICR &= (uint16_t)~((uint16_t)UART_IT);
   \   0000000E   0x64C1             STR      R1,[R0, #+76]
    416            }
    417          }
   \   00000010   0x4770             BX       LR               ;; return
    418          
    419          /**
    420            * @brief  Transmits a Data through the SC1_UART peripheral.
    421            * @param  SCx_UART: where x can be 1 to select the Serial controller peripheral.
    422            * @param  Data: Data to be transmitted.
    423            * @retval None
    424            */

   \                                 In section .text, align 2, keep-with-next
    425          void UART_SendData(SC_UART_TypeDef* SCx_UART, uint8_t Data)
    426          {
    427            uint32_t scxbase = 0x00;
    428          
    429            /* Check the parameters */
    430            assert_param(IS_UART_PERIPH(SCx_UART));
    431          
    432            scxbase = (uint32_t)SCx_UART; 
    433            
    434            *(__IO uint32_t *) scxbase = Data;
   \                     UART_SendData: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    435          }
   \   00000002   0x4770             BX       LR               ;; return
    436          
    437          /**
    438            * @brief  Returns the most recent received data by the SC1_UART peripheral. 
    439            * @param  SCx_UART: where x can be 1 to select the Serial controller peripheral.
    440            * @retval The value of the received data.
    441            */

   \                                 In section .text, align 2, keep-with-next
    442          uint8_t UART_ReceiveData(SC_UART_TypeDef* SCx_UART)
    443          {
    444            uint32_t scxbase = 0x00;
    445            
    446            /* Check the parameters */
    447            assert_param(IS_UART_PERIPH(SCx_UART));
    448            
    449            scxbase = (uint32_t)SCx_UART; 
    450            
    451            return *(__IO uint32_t *) scxbase;
   \                     UART_ReceiveData: (+1)
   \   00000000   0x....             B.N      ?Subroutine1
    452          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    453          
    454          /**
    455            * @brief  Checks whether the specified SC1_UART flag is set or not.
    456            * @param  SCx_UART: where x can be 1 to select the Serial controller peripheral.
    457            * @param  UART_FLAG: specifies the SCx_UART flag to check.
    458            *   This parameter can be one of the following values:
    459            *     @arg UART_FLAG_CTS: Clear to send flag.
    460            *     @arg UART_FLAG_RXNE: Receive data register not empty flag.
    461            *     @arg UART_FLAG_TXE: Transmit data register empty flag.
    462            *     @arg UART_FLAG_ORE: OverRun Error flag.
    463            *     @arg UART_FLAG_FE: Framing Error flag.
    464            *     @arg UART_FLAG_PE: Parity Error flag.
    465            *     @arg UART_FLAG_IDLE: Idle Line detection flag.
    466            * @retval The new state of UART_FLAG (SET or RESET).
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          FlagStatus UART_GetFlagStatus(SC_UART_TypeDef* SCx_UART, uint32_t UART_FLAG)
    469          {
    470            FlagStatus bitstatus = RESET;
    471            
    472            /* Check the parameters */
    473            assert_param(IS_UART_PERIPH(SCx_UART));
    474            assert_param(IS_UART_GET_FLAG(UART_FLAG));
    475            
    476            if ((SCx_UART->UARTSR & UART_FLAG) != (uint32_t)RESET)
   \                     UART_GetFlagStatus: (+1)
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
    477            {
    478              bitstatus = SET;
    479            }
    480            else
    481            {
    482              bitstatus = RESET;
    483            }
    484            return bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    485          }
    486          
    487          /**
    488            * @brief  Checks whether the specified SC1_UART pending interrupt is set or not.
    489            * @param  SCx_IT: where x can be 1 to select the Serial controller peripheral.
    490            * @param  UART_IT: specifies the pending interrupt to check.
    491            *   This parameter can be one of the following values:
    492            *     @arg UART_IT_PE: Parity error interrupt pending
    493            *     @arg UART_IT_FE: Frame error interrupt pending
    494            *     @arg UART_IT_UND: Underrun interrupt pending (to be checked)
    495            *     @arg UART_IT_OVR: Overrun interrupt pending
    496            *     @arg UART_IT_IDLE: Idle line detected interrupt pending
    497            *     @arg UART_IT_TXE: Transmit data register empty interrupt pending
    498            *     @arg UART_IT_RXNE: Data Register not empty interrupt pending
    499            * @retval The new state of UART_IT (SET or RESET).
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          ITStatus UART_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t UART_IT)
    502          {
    503            ITStatus bitstatus = RESET;
    504            uint32_t enablestatus = 0;
    505            /* Check the parameters */
    506            assert_param(IS_UART_IT_PERIPH(SCx_IT));
    507            assert_param(IS_UART_IT(UART_IT));
    508          
    509            enablestatus = (uint32_t)(SCx_IT->IER & UART_IT);
   \                     UART_GetITStatus: (+1)
   \   00000000   0x6C03             LDR      R3,[R0, #+64]
    510            if (((SCx_IT->ISR & UART_IT) != (uint32_t)RESET) && enablestatus)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x400B             ANDS     R3,R1,R3
   \   00000008   0x4208             TST      R0,R1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x2B00             CMPNE    R3,#+0
   \   0000000E   0x2201             MOVNE    R2,#+1
    511            {
    512              bitstatus = SET;
    513            }
    514            else
    515            {
    516              bitstatus = RESET;
    517            }
    518            return bitstatus;
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR               ;; return
    519          }
    520          
    521          /**
    522            * @brief  Clears the SC1_UART interrupt pending bits.
    523            * @param  SCx_IT: where x can be 1 to select the Serial controller peripheral.
    524            * @param  UART_IT: specifies the pending interrupt to check.
    525            *   This parameter can be one of the following values:
    526            *     @arg UART_IT_PE: Parity error interrupt pending
    527            *     @arg UART_IT_FE: Frame error interrupt pending
    528            *     @arg UART_IT_UND: Underrun interrupt pending (to be checked)
    529            *     @arg UART_IT_OVR: Overrun interrupt pending
    530            *     @arg UART_IT_IDLE: Idle line detected interrupt pending
    531            *     @arg UART_IT_TXE: Transmit data register empty interrupt pending
    532            *     @arg UART_IT_RXNE: Data Register not empty interrupt pending
    533            * @retval None
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          void UART_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t UART_IT)
    536          {
    537            /* Check the parameters */
    538            assert_param(IS_UART_IT_PERIPH(SCx_IT));
    539            assert_param(IS_UART_IT(UART_IT));
    540            
    541            SCx_IT->ISR = UART_IT;
   \                     UART_ClearITPendingBit: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    542          }
   \   00000002   0x4770             BX       LR               ;; return
    543          
    544          /**
    545            * @}
    546            */
    547          
    548          /** @defgroup SC_Group2 Serial peripheral interface communication
    549           *  @brief   serial peripheral interface functions 
    550           *
    551          @verbatim   
    552           ===============================================================================
    553                     ##### Serial Peripheral Interface functions #####
    554           ===============================================================================
    555              [..] This section provides a set of functions allowing to handles the serial peripheral
    556                   interface communication.
    557          
    558              (@) The SC1 and SC2 include an Serial Peripheral Interface (SPI) master/slave controller.
    559          
    560          *** Initialization and Configuration ***
    561           =======================================
    562              [..] The GPIO pins that can be assigned to SPI interface are listed in the following tables:
    563               (##) SPI Master Mode:
    564             +-----------------------------------------------------------------+     
    565             |Parameter | Direction | GPIO configuration |  SC1 pin | SC2 pin  | 
    566             |----------|-----------|--------------------|----------|----------|             
    567             |   MOSI   |    Out    |  Alternate Output  |   PB1    |   PA0    |
    568             |          |           |    (push-pull)     |          |          |
    569             |----------|-----------|-------------------------------|----------|  
    570             |   MISO   |    In     |        Input       |   PB2    |   PA1    |
    571             |----------|-----------|--------------------|----------|----------|             
    572             |   SCLK   |    Out    | Alternate Output   |   PB3    |    PA2   |
    573             |          |           |      (push-pull)   |          |          |
    574             |          |           |  Special SCLK mode |          |          |
    575             +-----------------------------------------------------------------+
    576              (##) SPI Slave Mode:
    577             +-----------------------------------------------------------------+     
    578             |Parameter | Direction | GPIO configuration |  SC1 pin | SC2 pin  | 
    579             |----------|-----------|--------------------|----------|----------|             
    580             |   MOSI   |    In     |       Input        |   PB2    |   PA0    |
    581             |----------|-----------|-------------------------------|----------|  
    582             |   MISO   |    Out    |  Alternate Output  |   PB1    |   PA1    |
    583             |          |           |      (push-pull)   |          |          |
    584             |----------|-----------|--------------------|----------|----------|             
    585             |   SCLK   |    In     |       Input        |   PB3    |   PA2    |
    586             |----------|-----------|--------------------|----------|----------|             
    587             |   nSSEL  |    In     |       Input        |   PB4    |   PA3    |
    588             +-----------------------------------------------------------------+
    589              [..]  For the Serial Peripheral Interface mode these parameters can be configured: 
    590                    (+) Mode.
    591                    (+) Data Size.
    592                    (+) Polarity.
    593                    (+) Phase.
    594                    (+) Baud Rate
    595                    (+) First Bit Transmission
    596              [..] The SPI_Init() function follows the SPI configuration procedures for Master mode
    597                   and Slave mode (details for these procedures are available in datasheet).
    598          
    599          *** Data transfers ***
    600           =====================
    601          
    602              [..] In reception, data are received and then stored into an internal Rx buffer while 
    603                   In transmission, data are first stored into an internal Tx buffer before being 
    604                   transmitted.
    605          
    606              [..] The read access of the SCx_DR register can be done using SPI_ReceiveData() 
    607                   function and returns the Rx buffered value. Whereas a write access to the SCx_DR 
    608                   can be done using SPI_SendData() function and stores the written data into 
    609                   Tx buffer. 
    610          
    611           *** Interrupts and flags management ***
    612           =======================================
    613              [..] This subsection provides also a set of functions allowing to configure the 
    614                   SPI Interrupts sources, Requests and check or clear the flags or pending bits status. 
    615                   The user should identify which mode will be used in his application to 
    616                   manage the communication: Polling mode, Interrupt mode or DMA mode(refer SC_Group4).
    617          
    618              [..] In Polling Mode, the SPI communication can be managed by these flags:
    619                   (#) SPI_FLAG_TXE: to indicate the status of the transmit buffer register.
    620                   (#) SPI_FLAG_RXNE: to indicate the status of the receive buffer register.
    621                   (#) SPI_FLAG_IDLE: to indicate the status of the Idle Line.
    622                   (#) SPI_FLAG_OVR: to indicate if an Overrun error occur.
    623              [..] In this Mode it is advised to use the following functions:
    624                   (+) FlagStatus SPI_GetFlagStatus(SC_SPI_TypeDef* SCx_SPI, uint32_t SPI_FLAG).
    625              [..] In this mode all the SPI flags are cleared by hardware.
    626          
    627              [..] In Interrupt Mode, the SPI communication can be managed by 5 interrupt 
    628                   sources and 5 pending bits:
    629                   (+) Pending Bits:
    630                       (##) SPI_IT_UND: to indicate the status of UnderRun Error interrupt.
    631                       (##) SPI_IT_OVR: to indicate the status of OverRun Error interrupt.
    632                       (##) SPI_IT_IDLE: to indicate the status of IDLE line detected interrupt.
    633                       (##) SPI_IT_TXE: to indicate the status of the Transmit data register empty interrupt.
    634                       (##) SPI_IT_RXNE: to indicate the status of the Data Register not empty interrupt.
    635          
    636                   (+) Interrupt Source:
    637                       (##) SPI_IT_UND: specifies the interrupt source for UnderRun Error pending interrupt.
    638                       (##) SPI_IT_OVR: specifies the interrupt source for OverRun Error pending interrupt.
    639                       (##) SPI_IT_IDLE: specifies the interrupt source for IDLE line detected pending interrupt.
    640                       (##) SPI_IT_TXE: specifies the interrupt source for the Transmit data register empty pending interrupt.
    641                       (##) SPI_IT_RXNE: specifies the interrupt source for the Data Register not empty pending interrupt.
    642                       -@@- These parameters are coded in order to use them as interrupt 
    643                           source or as pending bits.
    644              [..] In this mode it is advised to use the following functions:
    645                   (+) void SPI_ITConfig(SC_IT_TypeDef* SCx_IT, uint32_t SPI_IT, FunctionalState NewState).
    646                   (+) ITStatus SPI_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t SPI_IT).
    647                   (+) void SPI_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t SPI_IT).
    648          
    649          @endverbatim
    650            * @{
    651            */
    652          
    653          /**
    654            * @brief  Deinitializes the SCx_SPI peripheral registers to their default reset values.
    655            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    656            * @retval None
    657            */

   \                                 In section .text, align 2, keep-with-next
    658          void SPI_DeInit(SC_SPI_TypeDef* SCx_SPI)
    659          {
    660            /* Check the parameters */
    661            assert_param(IS_SPI_PERIPH(SCx_SPI));
    662            
    663            SCx_SPI->CR = 0;
   \                     SPI_DeInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6181             STR      R1,[R0, #+24]
    664            SCx_SPI->SPICR = 0;
   \   00000004   0x61C1             STR      R1,[R0, #+28]
    665            SCx_SPI->CRR1 = 0;
   \   00000006   0x....             B.N      ?Subroutine2
    666            SCx_SPI->CRR2 = 0;
    667          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6241             STR      R1,[R0, #+36]
   \   00000002   0x6281             STR      R1,[R0, #+40]
   \   00000004   0x4770             BX       LR               ;; return
    668          
    669          /**
    670            * @brief  Initializes the SCx_SPI peripheral according to the specified 
    671            *         parameters in the SPI_InitStruct.
    672            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    673            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    674            *         contains the configuration information for the specified SPI peripheral.
    675            * @retval None
    676            */

   \                                 In section .text, align 2, keep-with-next
    677          void SPI_Init(SC_SPI_TypeDef* SCx_SPI, SPI_InitTypeDef* SPI_InitStruct)
    678          {
   \                     SPI_Init: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0x460C             MOV      R4,R1
    679            uint32_t tmpreg = 0;
    680            uint8_t expvalue = 0, linvalue = 0, tmpexp = 0, tmplin = 0, idx = 0;
    681            uint32_t tempclockrate = 0, clockrate = 0, power = 0;
    682            
    683            /* Check the SPI parameters */
    684            assert_param(IS_SPI_PERIPH(SCx_SPI));
    685            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    686            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    687            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    688            assert_param(IS_SPI_CLOCK_RATE(SPI_InitStruct->SPI_ClockRate));
    689            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    690            
    691            /* Get the SCx SPICR register value */
    692            tmpreg = SCx_SPI->SPICR;
    693            
    694            /* Clear Mode, LSBFirst, CPOL and CPHA bits */
    695            tmpreg &= SPICR_CLEAR_MASK;
    696            /*---------------------------- SCx_SPICR Configuration ---------------------*/
    697            /* Set MSTR bits according to SPI_Mode values */
    698            /* Set LSBFirst bit according to SPI_FirstBit value */
    699            /* Set CPOL bit according to SPI_CPOL value */
    700            /* Set CPHA bit according to SPI_CPHA value */
    701            tmpreg |= (uint32_t)((uint32_t)SPI_InitStruct->SPI_Mode | (uint32_t)SPI_InitStruct->SPI_CPOL |
    702                                 (uint32_t)SPI_InitStruct->SPI_CPHA | (uint32_t)SPI_InitStruct->SPI_FirstBit);
    703            /* Write to SCx SPICR register */
    704            SCx_SPI->SPICR = tmpreg;
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
   \   00000008   0x8821             LDRH     R1,[R4, #+0]
   \   0000000A   0xF020 0x0017      BIC      R0,R0,#0x17
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x8861             LDRH     R1,[R4, #+2]
   \   00000012   0x4308             ORRS     R0,R1,R0
   \   00000014   0x88A1             LDRH     R1,[R4, #+4]
   \   00000016   0x4308             ORRS     R0,R1,R0
   \   00000018   0x89A1             LDRH     R1,[R4, #+12]
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
   \   0000001E   0x2500             MOVS     R5,#+0
   \   00000020   0x46A8             MOV      R8,R5
   \   00000022   0x46A9             MOV      R9,R5
   \   00000024   0x61C8             STR      R0,[R1, #+28]
    705            
    706            /*---------------------------- SCx_CRRx Configuration ----------------------*/
    707            for(linvalue = 0x00; linvalue < 16; linvalue++)
   \   00000026   0x2600             MOVS     R6,#+0
    708            {
    709              for(expvalue = 0x00; expvalue < 16; expvalue++)
   \                     ??SPI_Init_0: (+1)
   \   00000028   0x2700             MOVS     R7,#+0
    710              {
    711                power = 0x01;
   \                     ??SPI_Init_1: (+1)
   \   0000002A   0x.... 0x....      BL       ?Subroutine4
    712                for (idx=1; idx <= expvalue; idx++)
    713                {
    714                  power*=2;
    715                }
    716                tempclockrate = power * (uint32_t)(linvalue + 1);
    717                
    718                if (tempclockrate == ((uint32_t)((uint32_t)CLK_GetClocksFreq()/(uint32_t)(2*(SPI_InitStruct->SPI_ClockRate)))))
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000002E   0x68A1             LDR      R1,[R4, #+8]
   \   00000030   0x0049             LSLS     R1,R1,#+1
   \   00000032   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000036   0x4582             CMP      R10,R0
   \   00000038   0xD104             BNE.N    ??SPI_Init_2
    719                {
    720                  SCx_SPI->CRR1 = (uint32_t)linvalue;
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x6246             STR      R6,[R0, #+36]
    721                  SCx_SPI->CRR2 = (uint32_t)expvalue;
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x6287             STR      R7,[R0, #+40]
   \   00000042   0xE023             B.N      ??CrossCallReturnLabel_14
    722                }
    723                else
    724                {
    725                  /* Check the clock rate error and write to CRRx */
    726                  if((ABS((int32_t)tempclockrate - (int32_t)(CLK_GetClocksFreq()/(2*(SPI_InitStruct->SPI_ClockRate))))) < (ABS((int32_t)clockrate - (int32_t)(CLK_GetClocksFreq()/(2*(SPI_InitStruct->SPI_ClockRate))))))
   \                     ??SPI_Init_2: (+1)
   \   00000044   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000048   0x68A1             LDR      R1,[R4, #+8]
   \   0000004A   0x.... 0x....      BL       ?Subroutine5
    727                  {
    728                    clockrate = tempclockrate;
    729                    tmplin = linvalue;
    730                    tmpexp = expvalue;
    731                  }
    732                }
    733              }
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000004E   0xDB05             BLT.N    ??SPI_Init_3
   \   00000050   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000054   0x68A1             LDR      R1,[R4, #+8]
   \   00000056   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000005A   0xE004             B.N      ??CrossCallReturnLabel_8
   \                     ??SPI_Init_3: (+1)
   \   0000005C   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000060   0x68A1             LDR      R1,[R4, #+8]
   \   00000062   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000066   0x.... 0x....      BL       CLK_GetClocksFreq
   \   0000006A   0x68A1             LDR      R1,[R4, #+8]
   \   0000006C   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000070   0xDB05             BLT.N    ??SPI_Init_4
   \   00000072   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000076   0x68A1             LDR      R1,[R4, #+8]
   \   00000078   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000007C   0xE004             B.N      ??CrossCallReturnLabel_12
   \                     ??SPI_Init_4: (+1)
   \   0000007E   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000082   0x68A1             LDR      R1,[R4, #+8]
   \   00000084   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000088   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000008C   0x1C7F             ADDS     R7,R7,#+1
   \   0000008E   0x2F10             CMP      R7,#+16
   \   00000090   0xDBCB             BLT.N    ??SPI_Init_1
    734            }
   \   00000092   0x1C76             ADDS     R6,R6,#+1
   \   00000094   0x2E10             CMP      R6,#+16
   \   00000096   0xDBC7             BLT.N    ??SPI_Init_0
    735            
    736            SCx_SPI->CRR1 = (uint32_t)tmplin;
   \   00000098   0x....             B.N      ?Subroutine3
    737            SCx_SPI->CRR2 = (uint32_t)tmpexp;
    738          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x9800             LDR      R0,[SP, #+0]
   \   00000002   0xFA5F 0xF188      UXTB     R1,R8
   \   00000006   0x6241             STR      R1,[R0, #+36]
   \   00000008   0xB2ED             UXTB     R5,R5
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0x6285             STR      R5,[R0, #+40]
   \   0000000E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x4583             CMP      R11,R0
   \   00000002   0xDA02             BGE.N    ??Subroutine11_0
   \   00000004   0x46D1             MOV      R9,R10
   \   00000006   0x46B0             MOV      R8,R6
   \   00000008   0x463D             MOV      R5,R7
   \                     ??Subroutine11_0: (+1)
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x0049             LSLS     R1,R1,#+1
   \   00000002   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000006   0xEBA0 0x0009      SUB      R0,R0,R9
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x0049             LSLS     R1,R1,#+1
   \   00000002   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000006   0xEBA9 0x0000      SUB      R0,R9,R0
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x0049             LSLS     R1,R1,#+1
   \   00000002   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000006   0xEBA0 0x0B0A      SUB      R11,R0,R10
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x0049             LSLS     R1,R1,#+1
   \   00000002   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000006   0xEBAA 0x0B00      SUB      R11,R10,R0
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x0049             LSLS     R1,R1,#+1
   \   00000002   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000006   0xEBA9 0x0000      SUB      R0,R9,R0
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x0049             LSLS     R1,R1,#+1
   \   00000002   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000006   0xEBAA 0x0000      SUB      R0,R10,R0
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xE001             B.N      ??Subroutine4_0
   \                     ??Subroutine4_1: (+1)
   \   00000006   0x0040             LSLS     R0,R0,#+1
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \                     ??Subroutine4_0: (+1)
   \   0000000A   0xB2C9             UXTB     R1,R1
   \   0000000C   0x428F             CMP      R7,R1
   \   0000000E   0xDAFA             BGE.N    ??Subroutine4_1
   \   00000010   0x1C71             ADDS     R1,R6,#+1
   \   00000012   0xFB01 0xFA00      MUL      R10,R1,R0
   \   00000016   0x.... 0x....      B.W      CLK_GetClocksFreq
    739          
    740          /**
    741            * @brief  Fills each SPI_InitStruct member with its default value.
    742            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    743            * @retval None
    744            */

   \                                 In section .text, align 2, keep-with-next
    745          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    746          {
    747            /*--------------- Reset SPI init structure parameters values ---------------*/
    748            /* Initialize the SPI_Mode member */
    749            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \                     SPI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    750            /* Initialize the SPI_CPOL member */
    751            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    752            /* Initialize the SPI_CPHA member */
    753            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    754            /* Initialize the SPI_ClockRate member */
    755            SPI_InitStruct->SPI_ClockRate = 3000000;
   \   00000008   0x....             LDR.N    R1,??DataTable1  ;; 0x2dc6c0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    756            /* Initialize the SPI_FirstBit member */
    757            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    758          }
   \   00000010   0x4770             BX       LR               ;; return
    759          
    760          /**
    761            * @brief  Configures the Receiver driven mode for the selected SCx_SPI (Master mode only).
    762            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    763            * @param  SPI_ReceiverMode: specifies the Receiver driven mode to be configured.
    764            *   This parameter can be one of the following values:
    765            *     @arg SPI_ReceiverMode_TxDataReady: Initiate transactions when transmit data is available
    766            *     @arg SPI_ReceiverMode_RxFIFOFree: Initiate transactions when receive buffer has space
    767            * @retval None
    768            */

   \                                 In section .text, align 2, keep-with-next
    769          void SPI_ReceiverModeConfig(SC_SPI_TypeDef* SCx_SPI, uint32_t SPI_ReceiverMode)
    770          {
    771            /* Check the parameters */
    772            assert_param(IS_SPI_PERIPH(SCx_SPI));
    773            assert_param(IS_SPI_RECEIVER_DRIVEN_MODE(SPI_ReceiverMode));
    774            
    775            /* Clear RXMODE bit */
    776            SCx_SPI->SPICR &= (uint16_t)~((uint16_t)SC_SPICR_RXMODE);
   \                     SPI_ReceiverModeConfig: (+1)
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0xF64F 0x73DF      MOVW     R3,#+65503
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x61C2             STR      R2,[R0, #+28]
    777            
    778            /* Set new RXMODE bit value */
    779            SCx_SPI->SPICR |= SPI_ReceiverMode;
   \   0000000A   0x69C2             LDR      R2,[R0, #+28]
   \   0000000C   0x4311             ORRS     R1,R1,R2
   \   0000000E   0x61C1             STR      R1,[R0, #+28]
    780          }
   \   00000010   0x4770             BX       LR               ;; return
    781          
    782          /**
    783            * @brief  Enables or disables the last byte repeat transmission feature  
    784            *         for the specified SCx_SPI peripheral (Slave mode only).
    785            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    786            * @param  NewState: new state of the SCx_SPI peripheral.
    787            *         This parameter can be: ENABLE or DISABLE.
    788            * @retval None
    789            */

   \                                 In section .text, align 2, keep-with-next
    790          void SPI_LastByteRepeatCmd(SC_SPI_TypeDef* SCx_SPI, FunctionalState NewState)
    791          {
    792            /* Check the parameters */
    793            assert_param(IS_SPI_PERIPH(SCx_SPI));
    794            assert_param(IS_FUNCTIONAL_STATE(NewState));
    795            
    796            if (NewState != DISABLE)
   \                     SPI_LastByteRepeatCmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x69C1             LDR      R1,[R0, #+28]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0108      ORRNE    R1,R1,#0x8
   \   0000000A   0xF64F 0x72F7      MOVWEQ   R2,#+65527
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    797            {
    798              /* Enable the last byte repeat feature for the selected SPI by setting 
    799                 the RPTEN bit 0 in the SPICR register */
    800              SCx_SPI->SPICR |= SC_SPICR_RPTEN;
    801            }
    802            else
    803            {
    804              /* Disable the last byte repeat feature for the selected SPI by clearing
    805                 the RPTEN bit in the SPICR register */
    806              SCx_SPI->SPICR &= (uint16_t)~((uint16_t)SC_SPICR_RPTEN);
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    807            }
    808          }
   \   00000012   0x4770             BX       LR               ;; return
    809          
    810          /**
    811            * @brief  Enables or disables the specified SCx_SPI peripheral.
    812            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    813            * @param  NewState: new state of the SCx_SPI peripheral.
    814            *         This parameter can be: ENABLE or DISABLE.
    815            * @retval None
    816            */

   \                                 In section .text, align 2, keep-with-next
    817          void SPI_Cmd(SC_SPI_TypeDef* SCx_SPI, FunctionalState NewState)
    818          {
    819            /* Check the parameters */
    820            assert_param(IS_SPI_PERIPH(SCx_SPI));
    821            assert_param(IS_FUNCTIONAL_STATE(NewState));
    822            
    823            if (NewState != DISABLE)
   \                     SPI_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6981             LDR      R1,[R0, #+24]
   \   00000004   0xF64F 0x72FC      MOVW     R2,#+65532
   \   00000008   0xD005             BEQ.N    ??SPI_Cmd_0
    824            {
    825              /* Enable the selected SPI by setting the MODE bit 0 in the CR register */
    826              SCx_SPI->CR &= (uint16_t)~((uint16_t)SC_CR_MODE);
   \   0000000A   0x4011             ANDS     R1,R2,R1
   \   0000000C   0x6181             STR      R1,[R0, #+24]
    827              SCx_SPI->CR |= SC_CR_MODE_1;
   \   0000000E   0x6981             LDR      R1,[R0, #+24]
   \   00000010   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000014   0xE000             B.N      ??SPI_Cmd_1
    828            }
    829            else
    830            {
    831              /* Disable the selected SPI by clearing the MODE bits in the CR register */
    832              SCx_SPI->CR &= (uint16_t)~((uint16_t)SC_CR_MODE);
   \                     ??SPI_Cmd_0: (+1)
   \   00000016   0x4011             ANDS     R1,R2,R1
   \                     ??SPI_Cmd_1: (+1)
   \   00000018   0x6181             STR      R1,[R0, #+24]
    833            }
    834          }
   \   0000001A   0x4770             BX       LR               ;; return
    835          
    836          /**
    837            * @brief  Enables or disables the specified SCx_SPI interrupts.
    838            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
    839            * @param  SPI_IT: specifies the SCx_SPI interrupt source to be enabled or disabled. 
    840            *   This parameter can be one of the following values:
    841            *     @arg SPI_IT_UND: Underrun interrupt mask
    842            *     @arg SPI_IT_OVR: Overrun interrupt mask
    843            *     @arg SPI_IT_IDLE: Idle line detected interrupt mask
    844            *     @arg SPI_IT_TXE: Transmit data register empty interrupt mask
    845            *     @arg SPI_IT_RXNE: Data Register not empty interrupt mask
    846            * @param  NewState: new state of the specified SCx_SPI interrupt source.
    847            *   This parameter can be: ENABLE or DISABLE.
    848            * @retval None
    849            */

   \                                 In section .text, align 2, keep-with-next
    850          void SPI_ITConfig(SC_IT_TypeDef* SCx_IT, uint32_t SPI_IT, FunctionalState NewState)
    851          {
    852            /* Check the parameters */
    853            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
    854            assert_param(IS_SPI_IT(SPI_IT));
    855            assert_param(IS_FUNCTIONAL_STATE(NewState));
    856            
    857            if (NewState != DISABLE)
   \                     SPI_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6C02             LDR      R2,[R0, #+64]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
    858            {
    859              /* Enable the selected SPI interrupt */
    860              SCx_IT->IER |= SPI_IT;
    861            }
    862            else
    863            {
    864              /* Disable the selected SPI interrupt */
    865              SCx_IT->IER &= (uint16_t)~((uint16_t)SPI_IT);
   \   0000000E   0x6401             STR      R1,[R0, #+64]
    866            }
    867          }
   \   00000010   0x4770             BX       LR               ;; return
    868          
    869          /**
    870            * @brief  Trigger event configuration to handle the specified SCx_SPI interrupt.
    871            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
    872            * @param  SPI_IT: specifies the SCx_SPI interrupt to be configured. 
    873            *   This parameter can be one of the following values:
    874            *     @arg SPI_IT_IDLE: Idle line detected interrupt
    875            *     @arg SPI_IT_TXE: Transmit data register empty interrupt
    876            *     @arg SPI_IT_RXNE: Data Register not empty interrupt
    877            * @param  TriggerEvent: Trigger event configuration of the specified SCx_SPI interrupt.
    878            *   This parameter can be one of the following values:
    879            *     @arg SC_TriggerEvent_Edge: The specified SCx_SPI interrupt will be generated on edge
    880            *     @arg SC_TriggerEvent_Level: The specified SCx_SPI interrupt will be generated on level
    881            * @retval None
    882            */

   \                                 In section .text, align 2, keep-with-next
    883          void SPI_TriggerEventConfig(SC_IT_TypeDef* SCx_IT, uint32_t SPI_IT, uint32_t TriggerEvent)
    884          {
    885            /* Check the parameters */
    886            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
    887            assert_param(IS_SPI_TRIGGEREVENT_IT(SPI_IT));
    888            assert_param(IS_SC_TRIGGEREVENT(TriggerEvent));
    889            
    890            if (TriggerEvent != SC_TriggerEvent_Edge)
   \                     SPI_TriggerEventConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6CC2             LDR      R2,[R0, #+76]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
    891            {
    892              /* The SPI_IT interrupt will be handled on level */
    893              SCx_IT->ICR |= SPI_IT;
    894            }
    895            else
    896            {
    897              /* The SPI_IT interrupt will be handled on edge */
    898              SCx_IT->ICR &= (uint16_t)~((uint16_t)SPI_IT);
   \   0000000E   0x64C1             STR      R1,[R0, #+76]
    899            }
    900          }
   \   00000010   0x4770             BX       LR               ;; return
    901          
    902          /**
    903            * @brief  Transmits a Data through the SCx_SPI peripheral.
    904            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    905            * @param  Data: Data to be transmitted.
    906            * @retval None
    907            */

   \                                 In section .text, align 2, keep-with-next
    908          void SPI_SendData(SC_SPI_TypeDef* SCx_SPI, uint8_t Data)
    909          {
    910            uint32_t scxbase = 0x00;
    911          
    912            /* Check the parameters */
    913            assert_param(IS_SPI_PERIPH(SCx_SPI));
    914          
    915            scxbase = (uint32_t)SCx_SPI; 
    916            
    917            *(__IO uint32_t *) scxbase = Data;
   \                     SPI_SendData: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    918          }
   \   00000002   0x4770             BX       LR               ;; return
    919          
    920          /**
    921            * @brief  Returns the most recent received data by the SCx_SPI peripheral. 
    922            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    923            * @retval The value of the received data.
    924            */

   \                                 In section .text, align 2, keep-with-next
    925          uint8_t SPI_ReceiveData(SC_SPI_TypeDef* SCx_SPI)
   \                     SPI_ReceiveData: (+1)
   \   00000000   0xBF00             Nop      
    926          {
    927            uint32_t scxbase = 0x00;
    928            
    929            /* Check the parameters */
    930            assert_param(IS_SPI_PERIPH(SCx_SPI));
    931            
    932            scxbase = (uint32_t)SCx_SPI; 
    933          
    934            return *(__IO uint32_t *) scxbase;
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1
    935          }
    936          
    937          /**
    938            * @brief  Checks whether the specified SCx_SPI flag is set or not.
    939            * @param  SCx_SPI: where x can be 1 or 2 to select the Serial controller peripheral.
    940            * @param  SPI_FLAG: specifies the SCx_SPI flag to check.
    941            *   This parameter can be one of the following values:
    942            *     @arg SPI_FLAG_OVR:  OverRun Error flag.
    943            *     @arg SPI_FLAG_TXE:  Transmit data register empty flag.
    944            *     @arg SPI_FLAG_RXNE:  Receive data register not empty flag.
    945            *     @arg SPI_FLAG_IDLE:  IDLE line flag.
    946            * @retval The new state of SPI_FLAG (SET or RESET).
    947            */

   \                                 In section .text, align 2, keep-with-next
    948          FlagStatus SPI_GetFlagStatus(SC_SPI_TypeDef* SCx_SPI, uint32_t SPI_FLAG)
    949          {
    950            FlagStatus bitstatus = RESET;
    951            
    952            /* Check the parameters */
    953            assert_param(IS_SPI_PERIPH(SCx_SPI));
    954            assert_param(IS_SPI_GET_FLAG(SPI_FLAG));
    955            
    956            if ((SCx_SPI->SPISR & SPI_FLAG) != (uint32_t)RESET)
   \                     SPI_GetFlagStatus: (+1)
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
    957            {
    958              bitstatus = SET;
    959            }
    960            else
    961            {
    962              bitstatus = RESET;
    963            }
    964            return bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    965          }
    966          
    967          /**
    968            * @brief  Checks whether the specified SCx_SPI pending interrupt is set or not.
    969            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
    970            * @param  SPI_IT: specifies the SCx_SPI pending interrupt to check.
    971            *   This parameter can be one of the following values:
    972            *     @arg SPI_IT_UND: Underrun interrupt pending
    973            *     @arg SPI_IT_OVR: Overrun interrupt pending
    974            *     @arg SPI_IT_IDLE: Idle line detected interrupt pending
    975            *     @arg SPI_IT_TXE: Transmit data register empty interrupt pending
    976            *     @arg SPI_IT_RXNE: Data Register not empty interrupt pending
    977            * @retval The new state of SPI_IT (SET or RESET).
    978            */

   \                                 In section .text, align 2, keep-with-next
    979          ITStatus SPI_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t SPI_IT)
    980          {
    981            ITStatus bitstatus = RESET;
    982            uint32_t enablestatus = 0;
    983            
    984            /* Check the parameters */
    985            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
    986            assert_param(IS_SPI_IT(SPI_IT));
    987            
    988            enablestatus = (uint32_t)(SCx_IT->IER & SPI_IT);
   \                     SPI_GetITStatus: (+1)
   \   00000000   0x6C03             LDR      R3,[R0, #+64]
    989            if (((SCx_IT->ISR & SPI_IT) != (uint32_t)RESET) && enablestatus)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x400B             ANDS     R3,R1,R3
   \   00000008   0x4208             TST      R0,R1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x2B00             CMPNE    R3,#+0
   \   0000000E   0x2201             MOVNE    R2,#+1
    990            {
    991              bitstatus = SET;
    992            }
    993            else
    994            {
    995              bitstatus = RESET;
    996            }
    997            return bitstatus;
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR               ;; return
    998          }
    999          
   1000          /**
   1001            * @brief  Clears the SCx_SPI interrupt pending bits.
   1002            * @param  SCx_IT: where x can be 1 to select the Serial controller peripheral.
   1003            * @param  SPI_IT: specifies the SCx_SPI pending interrupt to check.
   1004            *   This parameter can be one of the following values:
   1005            *     @arg SPI_IT_UND: Underrun interrupt pending
   1006            *     @arg SPI_IT_OVR: Overrun interrupt pending
   1007            *     @arg SPI_IT_IDLE: Idle line detected interrupt pending
   1008            *     @arg SPI_IT_TXE: Transmit data register empty interrupt pending
   1009            *     @arg SPI_IT_RXNE: Data Register not empty interrupt pending
   1010            * @retval None
   1011            */

   \                                 In section .text, align 2, keep-with-next
   1012          void SPI_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t SPI_IT)
   1013          {
   1014            /* Check the parameters */
   1015            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
   1016            assert_param(IS_SPI_IT(SPI_IT));
   1017            
   1018            SCx_IT->ISR = SPI_IT;
   \                     SPI_ClearITPendingBit: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   1019          }
   \   00000002   0x4770             BX       LR               ;; return
   1020          
   1021          /**
   1022            * @}
   1023            */
   1024          
   1025          /** @defgroup SC_Group3 Inter-Integrated Circuit communication
   1026           *  @brief   inter-integrated circuit functions 
   1027           *
   1028          @verbatim   
   1029           ===============================================================================
   1030                     ##### Inter-Integrated Circuit functions #####
   1031           ===============================================================================
   1032              [..] This section provides a set of functions allowing to handles the Inter-Integrated 
   1033                   Circuit communication.
   1034          
   1035              (@) The SC1 and SC2 include an Inter-integrated circuit interface (I2C) master controller.
   1036          
   1037          *** Initialization and Configuration ***
   1038           =======================================
   1039          
   1040              [..] The GPIO pins that can be assigned to I2C interface are listed in the following table:
   1041             +------------------------------------------------------------------+     
   1042             |Parameter | Direction | GPIO configuration |  SC1 pin |  SC2 pin  |
   1043             |----------|-----------|--------------------|----------|-----------|             
   1044             |    SDA   |  In/Out   |  Alternate Output  |   PB1    |   PA1     |
   1045             |          |           |    (open drain)    |          |           |
   1046             |----------|-----------|-------------------------------------------|  
   1047             |    SCL   |  In/Out   |  Alternate Output  |   PB2    |   PA2     |
   1048             |          |           |    (open drain)    |          |           |
   1049             +------------------------------------------------------------------+    
   1050          
   1051              [..] For the Inter-Integrated Circuit mode only the Baud Rate parameter can be configured: 
   1052              
   1053              [..] The I2C_Init() function follows the I2C configuration procedure (this procedure 
   1054                   is available in datasheet).
   1055          
   1056              [..] The generate START and STOP can be done respectively using I2C_GenerateSTART() and 
   1057                   I2C_GenerateSTOP() functions.
   1058          
   1059              [..] The command for the ACK generation can be done I2C_AcknowledgeConfig() function.
   1060          
   1061          *** Data transfers ***
   1062           =====================
   1063              [..] To initiate a transmit segment, write the data to the SCx_DR data register,
   1064                   then set the BTE bit in the SCx_I2CCR1 register, and finally wait until 
   1065                   the BTE bit is clear and the BTF bit in the SCx_I2CSR register, these steps
   1066                   can be done using I2C_SendData() function. Alternatively to initiate the reception
   1067                   set the BRE bit in the SCx_I2CCR1 register and keep waiting until the BRE bit 
   1068                   is clear and the BTF bit in the SCx_I2CSR register is set then read the 
   1069                   Rx buffered value, these steps can be done using I2C_ReceiveData() function.
   1070          
   1071              [..] The Master transmit address byte to select the slave device in transmitter 
   1072                   or in receiver mode can be done using the I2C_Send7bitAddress() function
   1073          
   1074           *** Interrupts and flags management ***
   1075           =======================================
   1076              [..] This subsection provides also a set of functions allowing to configure the 
   1077                   I2C Interrupts sources, Requests and check or clear the flags or pending bits status. 
   1078                   The user should identify which mode will be used in his application to 
   1079                   manage the communication: Polling mode, Interrupt mode.
   1080          
   1081              [..] In Polling Mode, the I2C communication can be managed by 4 flags:
   1082                  (#) I2C_FLAG_NACK: to indicate the status of the not acknowledge flag.
   1083                  (#) I2C_FLAG_BTF: to indicate the status of the byte transfer finished flag.
   1084                  (#) I2C_FLAG_BRF: to indicate the status of the byte receive finished flag.
   1085                  (#) I2C_FLAG_CMDFIN: to indicate the status of the command finished flag.
   1086                
   1087              [..] In this Mode it is advised to use the following functions:
   1088                  (+) FlagStatus I2C_GetFlagStatus(SC_I2C_TypeDef* SCx_I2C, uint32_t I2C_FLAG).
   1089              [..] In this mode all the I2C flags are cleared by hardware.
   1090          
   1091            *** Interrupt Mode ***
   1092            ======================
   1093              [..] In Interrupt Mode, the I2C communication can be managed by 4 interrupt sources
   1094                   and 4 pending bits:
   1095          
   1096              [..] Interrupt Source:
   1097                  (#) I2C_IT_NACK: specifies the interrupt source for the not acknowledge interrupt.
   1098                  (#) I2C_IT_CMDFIN: specifies the interrupt source for the command finished interrupt.
   1099                  (#) I2C_IT_BTF: specifies the interrupt source for the byte transfer finished interrupt.
   1100                  (#) I2C_IT_BRF: specifies the interrupt source for the byte receive finished interrupt.
   1101                  
   1102              [..] Pending Bits:
   1103                  (#) I2C_IT_NACK: to indicate the status of not acknowledge pending interrupt.
   1104                  (#) I2C_IT_CMDFIN: to indicate the status of command finished pending interrupt.
   1105                  (#) I2C_IT_BTF: to indicate the status of byte transfer finished pending interrupt.
   1106                  (#) I2C_IT_BRF: to indicate the status of byte receive finished pending interrupt.
   1107                  
   1108              [..] In this Mode it is advised to use the following functions:
   1109                  (+) void I2C_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t I2C_IT).
   1110                  (+) ITStatus I2C_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t I2C_IT).
   1111          
   1112          @endverbatim
   1113            * @{
   1114            */
   1115          
   1116          /**
   1117            * @brief  Deinitializes the SCx_I2C peripheral registers to their default reset values.
   1118            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1119            * @retval None
   1120            */

   \                                 In section .text, align 2, keep-with-next
   1121          void I2C_DeInit(SC_I2C_TypeDef* SCx_I2C)
   1122          {
   1123            /* Check the parameters */
   1124            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1125            
   1126            SCx_I2C->CR = 0;
   \                     I2C_DeInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6181             STR      R1,[R0, #+24]
   1127            SCx_I2C->I2CCR1 = 0;
   \   00000004   0x6101             STR      R1,[R0, #+16]
   1128            SCx_I2C->I2CCR2 = 0;
   \   00000006   0x6141             STR      R1,[R0, #+20]
   1129            SCx_I2C->CRR1 = 0;
   \   00000008                      REQUIRE ?Subroutine2
   \   00000008                      ;; // Fall through to label ?Subroutine2
   1130            SCx_I2C->CRR2 = 0;
   1131          }
   1132          
   1133          /**
   1134            * @brief  Initializes the SCx_I2C peripheral according to the specified
   1135            *         parameters in the I2C_InitStruct.
   1136            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1137            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
   1138            *         contains the configuration information for the specified SCx_I2C peripheral.
   1139            * @retval None
   1140            */

   \                                 In section .text, align 2, keep-with-next
   1141          void I2C_Init(SC_I2C_TypeDef* SCx_I2C, I2C_InitTypeDef* I2C_InitStruct)
   1142          {
   \                     I2C_Init: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   1143            uint8_t expvalue = 0, lin = 0, tmpexp = 0, tmplin = 0, idx = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x46A8             MOV      R8,R5
   1144            uint32_t tempclockrate = 0, clockrate = 0, power = 0;
   \   0000000A   0x46A9             MOV      R9,R5
   1145            
   1146            /* Check the parameters */
   1147            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1148            assert_param(IS_I2C_CLOCK_RATE(I2C_InitStruct->I2C_ClockRate));
   1149            
   1150            /*---------------------------- SCx_CRRx Configuration ----------------------*/
   1151            /*---------------------------- SCx_CRRx Configuration ----------------------*/
   1152            for(lin = 0x00; lin < 16; lin++)
   \   0000000C   0x2600             MOVS     R6,#+0
   1153            {
   1154              for(expvalue = 0x00; expvalue < 16; expvalue++)
   \                     ??I2C_Init_0: (+1)
   \   0000000E   0x2700             MOVS     R7,#+0
   1155              {
   1156                power = 0x01;
   \                     ??I2C_Init_1: (+1)
   \   00000010   0x.... 0x....      BL       ?Subroutine4
   1157                for (idx=1; idx <= expvalue; idx++)
   1158                {
   1159                  power*=2;
   1160                }
   1161                tempclockrate = power * (uint32_t)(lin + 1);
   1162                
   1163                if (tempclockrate == ((uint32_t)((uint32_t)CLK_GetClocksFreq()/(uint32_t)(2*(I2C_InitStruct->I2C_ClockRate)))))
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000001C   0x4582             CMP      R10,R0
   \   0000001E   0xD104             BNE.N    ??I2C_Init_2
   1164                {
   1165                  SCx_I2C->CRR1 = (uint32_t)lin;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x6246             STR      R6,[R0, #+36]
   1166                  SCx_I2C->CRR2 = (uint32_t)expvalue;
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x6287             STR      R7,[R0, #+40]
   \   00000028   0xE023             B.N      ??CrossCallReturnLabel_15
   1167                }
   1168                else
   1169                {
   1170                  /* Check the clock rate error and write to CRRx */
   1171                  if((ABS((int32_t)tempclockrate - (int32_t)(CLK_GetClocksFreq()/(2*(I2C_InitStruct->I2C_ClockRate))))) < (ABS((int32_t)clockrate - (int32_t)(CLK_GetClocksFreq()/(2*(I2C_InitStruct->I2C_ClockRate))))))
   \                     ??I2C_Init_2: (+1)
   \   0000002A   0x.... 0x....      BL       CLK_GetClocksFreq
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x.... 0x....      BL       ?Subroutine5
   1172                  {
   1173                    clockrate = tempclockrate;
   1174                    tmplin = lin;
   1175                    tmpexp = expvalue;
   1176                  }
   1177                }
   1178              }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000034   0xDB05             BLT.N    ??I2C_Init_3
   \   00000036   0x.... 0x....      BL       CLK_GetClocksFreq
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000040   0xE004             B.N      ??CrossCallReturnLabel_9
   \                     ??I2C_Init_3: (+1)
   \   00000042   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000004C   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000056   0xDB05             BLT.N    ??I2C_Init_4
   \   00000058   0x.... 0x....      BL       CLK_GetClocksFreq
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000062   0xE004             B.N      ??CrossCallReturnLabel_13
   \                     ??I2C_Init_4: (+1)
   \   00000064   0x.... 0x....      BL       CLK_GetClocksFreq
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000006E   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000072   0x1C7F             ADDS     R7,R7,#+1
   \   00000074   0x2F10             CMP      R7,#+16
   \   00000076   0xDBCB             BLT.N    ??I2C_Init_1
   1179            }
   \   00000078   0x1C76             ADDS     R6,R6,#+1
   \   0000007A   0x2E10             CMP      R6,#+16
   \   0000007C   0xDBC7             BLT.N    ??I2C_Init_0
   1180            
   1181            SCx_I2C->CRR1 = (uint32_t)tmplin;
   \   0000007E                      REQUIRE ?Subroutine3
   \   0000007E                      ;; // Fall through to label ?Subroutine3
   1182            SCx_I2C->CRR2 = (uint32_t)tmpexp;
   1183          }
   1184          
   1185          /**
   1186            * @brief  Fills each I2C_InitStruct member with its default value.
   1187            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure which will be initialized.
   1188            * @retval None
   1189            */

   \                                 In section .text, align 2, keep-with-next
   1190          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
   1191          {
   1192            /*--------------- Reset I2C init structure parameters values ---------------*/
   1193            
   1194            /* Initialize the I2C_ClockRate member */
   1195            I2C_InitStruct->I2C_ClockRate = 400000;
   \                     I2C_StructInit: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable1_1  ;; 0x61a80
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1196          }
   \   00000004   0x4770             BX       LR               ;; return
   1197          
   1198          /**
   1199            * @brief  Generates SCx_I2C communication START condition.
   1200            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1201            * @retval None
   1202            */

   \                                 In section .text, align 2, keep-with-next
   1203          void I2C_GenerateSTART(SC_I2C_TypeDef* SCx_I2C)
   1204          {
   1205            /* Check the parameters */
   1206            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1207            
   1208            /* Generate a START condition */
   1209            SCx_I2C->I2CCR1 |= SC_I2CCR1_START;
   \                     I2C_GenerateSTART: (+1)
   \   00000000   0x6901             LDR      R1,[R0, #+16]
   \   00000002   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000006   0x6101             STR      R1,[R0, #+16]
   1210          }  
   \   00000008   0x4770             BX       LR               ;; return
   1211          
   1212          /**
   1213            * @brief  Generates SCx_I2C communication STOP condition.
   1214            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1215            * @retval None
   1216            */

   \                                 In section .text, align 2, keep-with-next
   1217          void I2C_GenerateSTOP(SC_I2C_TypeDef* SCx_I2C)
   1218          {
   1219            /* Check the parameters */
   1220            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1221            
   1222            /* Generate a STOP condition */
   1223            SCx_I2C->I2CCR1 |= SC_I2CCR1_STOP;
   \                     I2C_GenerateSTOP: (+1)
   \   00000000   0x6901             LDR      R1,[R0, #+16]
   \   00000002   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000006   0x6101             STR      R1,[R0, #+16]
   1224          } 
   \   00000008   0x4770             BX       LR               ;; return
   1225          
   1226          /**
   1227            * @brief  Generates SCx_I2C communication Acknowledge.
   1228            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1229            * @param  NewState: new state of the Acknowledge.
   1230            *   This parameter can be: ENABLE or DISABLE.  
   1231            * @retval None
   1232            */

   \                                 In section .text, align 2, keep-with-next
   1233          void I2C_AcknowledgeConfig(SC_I2C_TypeDef* SCx_I2C, FunctionalState NewState)
   1234          {
   1235            /* Check the parameters */
   1236            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1237            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1238            
   1239            if (NewState != DISABLE)
   \                     I2C_AcknowledgeConfig: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6941             LDR      R1,[R0, #+20]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0x0849             LSREQ    R1,R1,#+1
   \   0000000C   0x0049             LSLEQ    R1,R1,#+1
   1240            {
   1241              /* Enable ACK generation */
   1242              SCx_I2C->I2CCR2 |= SC_I2CCR2_ACK; 
   1243            }
   1244            else
   1245            {
   1246              /* Enable NACK generation */
   1247              SCx_I2C->I2CCR2 &= (uint32_t)~((uint32_t)SC_I2CCR2_ACK);
   \   0000000E   0x6141             STR      R1,[R0, #+20]
   1248            }
   1249          }
   \   00000010   0x4770             BX       LR               ;; return
   1250          
   1251          /**
   1252            * @brief  Transmits the address byte to select the slave device.
   1253            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1254            * @param  Address: specifies the slave address which will be transmitted
   1255            * @param  I2C_Direction: specifies whether the SCx_I2C device will be a
   1256            *   Transmitter or a Receiver. This parameter can be one of the following values
   1257            *     @arg I2C_Direction_Transmitter: Transmitter mode
   1258            *     @arg I2C_Direction_Receiver: Receiver mode
   1259            * @retval None.
   1260            */

   \                                 In section .text, align 2, keep-with-next
   1261          void I2C_Send7bitAddress(SC_I2C_TypeDef* SCx_I2C, uint8_t Address, uint8_t I2C_Direction)
   1262          {
   1263            uint32_t scxbase = 0x00;
   1264            /* Check the parameters */
   1265            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1266            assert_param(IS_I2C_DIRECTION(I2C_Direction));
   1267            /* Test on the direction to set/reset the read/write bit */
   1268            if (I2C_Direction != I2C_Direction_Transmitter)
   \                     I2C_Send7bitAddress: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0xBF14             ITE      NE 
   \   00000004   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   00000008   0xF001 0x01FE      ANDEQ    R1,R1,#0xFE
   1269            {
   1270              /* Set the address bit0 for read */
   1271              Address |= OAR1_ADD0_Set;
   1272            }
   1273            else
   1274            {
   1275              /* Reset the address bit0 for write */
   1276              Address &= OAR1_ADD0_Reset;
   1277            }
   1278            
   1279            scxbase = (uint32_t)SCx_I2C; 
   1280            /* Send the address */
   1281            *(__IO uint32_t *) scxbase = Address;
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1282            
   1283            /* Enable the byte Send */
   1284            SCx_I2C->I2CCR1 |= SC_I2CCR1_BTE;
   \   0000000E   0x6901             LDR      R1,[R0, #+16]
   \   00000010   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000014   0x6101             STR      R1,[R0, #+16]
   1285            
   1286            while ((SCx_I2C->I2CCR1 & SC_I2CCR1_BTE) != 0x00)
   \                     ??I2C_Send7bitAddress_0: (+1)
   \   00000016   0x6901             LDR      R1,[R0, #+16]
   \   00000018   0x0789             LSLS     R1,R1,#+30
   \   0000001A   0xD4FC             BMI.N    ??I2C_Send7bitAddress_0
   1287            {}
   1288          }
   \   0000001C   0x4770             BX       LR               ;; return
   1289          
   1290          
   1291          #define SC_MAX_FLAG_WAIT	200
   1292          
   1293          #define SC_OK	0
   1294          #define SC_ERROR_BTE_FAILED	1
   1295          #define SC_ERROR_BTF_FAILED 2
   1296          
   1297          /**
   1298            * @brief  Transmits a Data through the SCx_I2C peripheral.
   1299            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1300            * @param  Data: Data to be transmitted.
   1301            * @retval SC_OK if successful or SC_ERROR_xxx for "xxx" error
   1302            */

   \                                 In section .text, align 2, keep-with-next
   1303          uint8_t I2C_SendData(SC_I2C_TypeDef* SCx_I2C, uint8_t Data)
   1304          {
   1305            uint32_t scxbase = 0x00;
   1306          
   1307            /* Check the parameters */
   1308            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1309          
   1310            scxbase = (uint32_t)SCx_I2C; 
   1311            
   1312            *(__IO uint32_t *) scxbase = Data;
   \                     I2C_SendData: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   1313            
   1314            /* Enable the byte Send */
   1315            SCx_I2C->I2CCR1 |= SC_I2CCR1_BTE;
   \   00000002   0x6901             LDR      R1,[R0, #+16]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x6101             STR      R1,[R0, #+16]
   1316            
   1317            int i=SC_MAX_FLAG_WAIT;
   \   0000000A   0x21C8             MOVS     R1,#+200
   1318            while ((SCx_I2C->I2CCR1 & SC_I2CCR1_BTE) != 0x00)
   \                     ??I2C_SendData_0: (+1)
   \   0000000C   0x6902             LDR      R2,[R0, #+16]
   \   0000000E   0x0792             LSLS     R2,R2,#+30
   \   00000010   0xD505             BPL.N    ??I2C_SendData_1
   1319            {if (0==i--) return SC_ERROR_BTE_FAILED;}
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0x1E51             SUBS     R1,R2,#+1
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1F8             BNE.N    ??I2C_SendData_0
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR
   1320            i=SC_MAX_FLAG_WAIT;
   \                     ??I2C_SendData_1: (+1)
   \   0000001E   0x21C8             MOVS     R1,#+200
   1321            while ((SCx_I2C->I2CSR & SC_I2CSR_BTF) == 0x00)
   \                     ??I2C_SendData_2: (+1)
   \   00000020   0x6882             LDR      R2,[R0, #+8]
   \   00000022   0x0792             LSLS     R2,R2,#+30
   \   00000024   0xD404             BMI.N    ??I2C_SendData_3
   1322            {if (0==i--) return SC_ERROR_BTF_FAILED;}
   \   00000026   0x460A             MOV      R2,R1
   \   00000028   0x1E51             SUBS     R1,R2,#+1
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD1F8             BNE.N    ??I2C_SendData_2
   \   0000002E   0x2002             MOVS     R0,#+2
   1323          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "I2C_SendData"
   \                     ??I2C_SendData_3: (+1)
   \   00000030   0x4770             BX       LR               ;; return
   1324          
   1325          /**
   1326            * @brief  Returns the most recent received data by the SCx_I2C peripheral. 
   1327            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1328            * @retval The value of the received data.
   1329            */

   \                                 In section .text, align 2, keep-with-next
   1330          uint8_t I2C_ReceiveData(SC_I2C_TypeDef* SCx_I2C)
   1331          {
   1332            uint32_t scxbase = 0x00;
   1333            
   1334            /* Check the parameters */
   1335            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1336            
   1337            scxbase = (uint32_t)SCx_I2C; 
   1338          
   1339            /* Enable the byte Receive */
   1340            SCx_I2C->I2CCR1 |= SC_I2CCR1_BRE;
   \                     I2C_ReceiveData: (+1)
   \   00000000   0x6902             LDR      R2,[R0, #+16]
   \   00000002   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000006   0x6102             STR      R2,[R0, #+16]
   1341            
   1342            while ((SCx_I2C->I2CCR1 & SC_I2CCR1_BRE) != 0x00)
   \                     ??I2C_ReceiveData_0: (+1)
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x07D2             LSLS     R2,R2,#+31
   \   0000000C   0xD4FC             BMI.N    ??I2C_ReceiveData_0
   1343            {}
   1344            while ((SCx_I2C->I2CSR & SC_I2CSR_BRF) == 0x00)
   \                     ??I2C_ReceiveData_1: (+1)
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0x0752             LSLS     R2,R2,#+29
   \   00000012   0xD5FC             BPL.N    ??I2C_ReceiveData_1
   1345            {}
   1346          
   1347            return *(__IO uint32_t *) scxbase;
   \   00000014   0x....             B.N      ?Subroutine1
   1348          }
   1349          
   1350          /**
   1351            * @brief  Enables or disables the specified SCx_I2C peripheral.
   1352            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1353            * @param  NewState: new state of the SCx_I2C peripheral.
   1354            *         This parameter can be: ENABLE or DISABLE.
   1355            * @retval None
   1356            */

   \                                 In section .text, align 2, keep-with-next
   1357          void I2C_Cmd(SC_I2C_TypeDef* SCx_I2C, FunctionalState NewState)
   1358          {
   1359            /* Check the parameters */
   1360            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1361            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1362            
   1363            if (NewState != DISABLE)
   \                     I2C_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6981             LDR      R1,[R0, #+24]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0103      ORRNE    R1,R1,#0x3
   \   0000000A   0xF64F 0x72FC      MOVWEQ   R2,#+65532
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   1364            {
   1365              /* Enable the selected I2C by setting the MODE bits in the CR register */
   1366              SCx_I2C->CR |= SC_CR_MODE;
   1367            }
   1368            else
   1369            {
   1370              /* Disable the selected I2C by clearing the MODE bits in the CR register */
   1371              SCx_I2C->CR &= (uint16_t)~((uint16_t)SC_CR_MODE);
   \   00000010   0x6181             STR      R1,[R0, #+24]
   1372            }
   1373          }
   \   00000012   0x4770             BX       LR               ;; return
   1374          
   1375          /**
   1376            * @brief  Enables or disables the specified SCx_I2C interrupts.
   1377            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
   1378            * @param  I2C_IT: specifies the SCx_I2C interrupt source to be enabled or disabled. 
   1379            *   This parameter can be one of the following values:
   1380            *     @arg I2C_IT_NACK: Not acknowledge interrupt mask
   1381            *     @arg I2C_IT_CMDFIN: Command finished interrupt mask
   1382            *     @arg I2C_IT_BTF: Byte transfer finished interrupt mask
   1383            *     @arg I2C_IT_BRF: Byte receive finished interrupt mask
   1384            * @param  NewState: new state of the specified SCx_I2C interrupt source.
   1385            *   This parameter can be: ENABLE or DISABLE.
   1386            * @retval None
   1387            */

   \                                 In section .text, align 2, keep-with-next
   1388          void I2C_ITConfig(SC_IT_TypeDef* SCx_IT, uint32_t I2C_IT, FunctionalState NewState)
   1389          {
   1390            /* Check the parameters */
   1391            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
   1392            assert_param(IS_I2C_IT(I2C_IT));
   1393            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1394            
   1395            if (NewState != DISABLE)
   \                     I2C_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6C02             LDR      R2,[R0, #+64]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
   1396            {
   1397              /* Enable the selected I2C interrupt */
   1398              SCx_IT->IER |= I2C_IT;
   1399            }
   1400            else
   1401            {
   1402              /* Disable the selected I2C interrupt */
   1403              SCx_IT->IER &= (uint16_t)~((uint16_t)I2C_IT);
   \   0000000E   0x6401             STR      R1,[R0, #+64]
   1404            }
   1405          }
   \   00000010   0x4770             BX       LR               ;; return
   1406          
   1407          /**
   1408            * @brief  Checks whether the specified I2C flag is set or not.
   1409            * @param  SCx_I2C: where x can be 1 or 2 to select the Serial controller peripheral.
   1410            * @param  I2C_FLAG: specifies the SCx_I2C flag to check.
   1411            *   This parameter can be one of the following values:
   1412            *     @arg I2C_FLAG_NACK: Not acknowledge flag
   1413            *     @arg I2C_FLAG_BTF: Byte transfer finished flag
   1414            *     @arg I2C_FLAG_BRF: Byte receive finished flag
   1415            *     @arg I2C_FLAG_CMDFIN: Command finished flag
   1416            * @retval The new state of I2C_FLAG (SET or RESET).
   1417            */

   \                                 In section .text, align 2, keep-with-next
   1418          FlagStatus I2C_GetFlagStatus(SC_I2C_TypeDef* SCx_I2C, uint32_t I2C_FLAG)
   1419          {
   1420            FlagStatus bitstatus = RESET;
   1421            
   1422            /* Check the parameters */
   1423            assert_param(IS_I2C_PERIPH(SCx_I2C));
   1424            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1425            
   1426            if ((SCx_I2C->I2CSR & I2C_FLAG) != (uint32_t)RESET)
   \                     I2C_GetFlagStatus: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
   1427            {
   1428              bitstatus = SET;
   1429            }
   1430            else
   1431            {
   1432              bitstatus = RESET;
   1433            }
   1434            return bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
   1435          }
   1436          
   1437          /**
   1438            * @brief  Checks whether the specified SCx_I2C pending interrupt is set or not.
   1439            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
   1440            * @param  I2C_IT: specifies the SCx_I2C interrupt pending to check.
   1441            *   This parameter can be one of the following values:
   1442            *     @arg I2C_IT_NACK: Not acknowledge interrupt pending
   1443            *     @arg I2C_IT_CMDFIN: Command finished interrupt pending
   1444            *     @arg I2C_IT_BTF: Byte transfer finished interrupt pending
   1445            *     @arg I2C_IT_BRF: Byte receive finished interrupt pending
   1446            * @retval The new state of I2C_IT (SET or RESET).
   1447            */

   \                                 In section .text, align 2, keep-with-next
   1448          ITStatus I2C_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t I2C_IT)
   1449          {
   1450            ITStatus bitstatus = RESET;
   1451            uint32_t enablestatus = 0;
   1452            
   1453            /* Check the parameters */
   1454            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
   1455            assert_param(IS_I2C_IT(I2C_IT));
   1456            
   1457            enablestatus = (uint32_t)(SCx_IT->IER & I2C_IT);
   \                     I2C_GetITStatus: (+1)
   \   00000000   0x6C03             LDR      R3,[R0, #+64]
   1458            if (((SCx_IT->ISR & I2C_IT) != (uint32_t)RESET) && enablestatus)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x400B             ANDS     R3,R1,R3
   \   00000008   0x4208             TST      R0,R1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x2B00             CMPNE    R3,#+0
   \   0000000E   0x2201             MOVNE    R2,#+1
   1459            {
   1460              bitstatus = SET;
   1461            }
   1462            else
   1463            {
   1464              bitstatus = RESET;
   1465            }
   1466            return bitstatus;
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR               ;; return
   1467          }
   1468          
   1469          /**
   1470            * @brief  Clears the SCx_I2C interrupt pending bits.
   1471            * @param  SCx_IT: where x can be 1 to select the Serial controller peripheral.
   1472            * @param  I2C_IT: specifies the SCx_I2C interrupt pending to check.
   1473            *   This parameter can be one of the following values:
   1474            *     @arg I2C_IT_NACK: Not acknowledge interrupt pending
   1475            *     @arg I2C_IT_CMDFIN: Command finished interrupt pending
   1476            *     @arg I2C_IT_BTF: Byte transfer finished interrupt pending
   1477            *     @arg I2C_IT_BRF: Byte receive finished interrupt pending
   1478            * @retval None
   1479            */

   \                                 In section .text, align 2, keep-with-next
   1480          void I2C_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t I2C_IT)
   1481          {
   1482            /* Check the parameters */
   1483            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
   1484            assert_param(IS_I2C_IT(I2C_IT));
   1485            
   1486            SCx_IT->ISR = I2C_IT;
   \                     I2C_ClearITPendingBit: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   1487          }
   \   00000002   0x4770             BX       LR               ;; return
   1488          
   1489          /**
   1490            * @}
   1491            */
   1492          
   1493          /** @defgroup SC_Group4 DMA transfers management
   1494           *  @brief   DMA transfers management functions 
   1495           *
   1496          @verbatim   
   1497           ===============================================================================
   1498                           ##### DMA transfers management functions #####
   1499           ===============================================================================
   1500              [..] This section provides a set of functions that can be used only in DMA mode.
   1501             
   1502              (@) The SC1 and SC2 include a DMA controller that can be used to manage the UART
   1503                  and SPI communications.
   1504          
   1505          *** Initialization and Configuration ***
   1506           =======================================
   1507              [..] For the DMA mode these parameters can be configured: 
   1508                   (+) Begin address buffer A.
   1509                   (+) End address buffer A.
   1510                   (+) Begin address buffer B.
   1511                   (+) End address buffer B.
   1512          
   1513              [..] The DMA_Init() function follows the DMA configuration procedure.
   1514          
   1515          *** Data transfers ***
   1516           =====================
   1517              [..] In DMA Mode, the UART and SPI communications can be managed by 4 DMA Channel 
   1518                   requests:
   1519                   (#) DMA_ChannelLoad_BTx: specifies the DMA transmit channel buffer B transfer request.
   1520                   (#) DMA_ChannelLoad_ATx: specifies the DMA transmit channel buffer A transfer request.
   1521                   (#) DMA_ChannelLoad_BRx: specifies the DMA receive channel buffer B transfer request.
   1522                   (#) DMA_ChannelLoad_ARx: specifies the DMA receive channel buffer A transfer request.
   1523              [..] In this Mode it is advised to use the following function to load and enables the specified DMA channel:
   1524                  (+) void SC_DMA_ChannelLoadEnable(SC_DMA_TypeDef* SCx_DMA, uint32_t Channelxy).
   1525          
   1526          *** Interrupts and flags management ***
   1527           =======================================
   1528              [..] This subsection provides also a set of functions allowing to configure the 
   1529                   DMA Interrupts sources, Requests and check or clear the flags or pending bits status. 
   1530                   The user should identify which mode will be used in his application to 
   1531                   manage the communication: Polling mode, Interrupt mode.
   1532          
   1533              [..] In Polling Mode, the DMA communication can be managed by 4 flags:
   1534                  (#) DMA_FLAG_RXAACK: to indicate the status of the DMA receive buffer A acknowledge flag.
   1535                  (#) DMA_FLAG_RXBACK: to indicate the status of the DMA receive buffer B acknowledge flag.
   1536                  (#) DMA_FLAG_TXAACK: to indicate the status of the DMA transmit buffer A acknowledge flag.
   1537                  (#) DMA_FLAG_TXBACK: to indicate the status of the DMA transmit buffer B acknowledge flag.
   1538                  (#) DMA_FLAG_OVRA: to indicate the status of the DMA buffer B overrun flag.
   1539                  (#) DMA_FLAG_OVRB: to indicate the status of the DMA buffer B overrun flag.
   1540                  (#) DMA_FLAG_PEA: to indicate the status of the DMA Parity error A flag.
   1541                  (#) DMA_FLAG_PEB: to indicate the status of the DMA Parity error B flag.
   1542                  (#) DMA_FLAG_FEA: to indicate the status of the DMA Frame error A flag.
   1543                  (#) DMA_FLAG_FEB: to indicate the status of the DMA Frame error B flag.
   1544                  (#) DMA_FLAG_NSSS: to indicate the status of the status of the receive count flag.
   1545              [..] In this Mode it is advised to use the following functions:
   1546                  (+) FlagStatus SC_DMA_GetFlagStatus(SC_DMA_TypeDef* SCx_DMA, uint32_t DMA_FLAG).
   1547              [..] In this mode all the DMA flags are cleared by hardware.
   1548          
   1549            *** Interrupt Mode ***
   1550            ======================
   1551              [..] In Interrupt Mode, the DMA communication can be managed by 4 interrupt sources
   1552                   and 4 pending bits:
   1553          
   1554              [..] Interrupt Source:
   1555                  (#) DMA_IT_TXULODB: specifies the interrupt source for the transmit buffer B unloaded interrupt.
   1556                  (#) DMA_IT_TXULODA: specifies the interrupt source for the transmit buffer A unloaded interrupt.
   1557                  (#) DMA_IT_RXULODB: specifies the interrupt source for the receive buffer B unloaded interrupt.
   1558                  (#) DMA_IT_RXULODA: specifies the interrupt source for the receive buffer A unloaded interrupt.
   1559                  
   1560              [..] Pending Bits:
   1561                  (#) DMA_IT_TXULODB: to indicate the status of transmit buffer B unloaded pending interrupt.
   1562                  (#) DMA_IT_TXULODA: to indicate the status of transmit buffer A unloaded pending interrupt.
   1563                  (#) DMA_IT_RXULODB: to indicate the status of receive buffer B unloaded pending interrupt.
   1564                  (#) DMA_IT_RXULODA: to indicate the status of receive buffer A unloaded pending interrupt.
   1565                  
   1566              [..] In this Mode it is advised to use the following functions:
   1567                  (+) ITStatus SC_DMA_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t DMA_IT).
   1568                  (+) SC_DMA_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t DMA_IT).
   1569          
   1570          @endverbatim
   1571            * @{
   1572            */
   1573          
   1574          /**
   1575            * @brief  Reset the specified SCx_DMA Channely buffer addresses.
   1576            * @param  SCx_DMA: where x can be 1 or 2 to select the Serial controller peripheral.
   1577            * @param  Channely: specifies the SCx_DMA channel to be enabled. 
   1578            *   This parameter can be one of the following values:
   1579            *     @arg DMA_ChannelReset_Tx: DMA reset transmit channels mask
   1580            *     @arg DMA_ChannelReset_Rx: DMA reset receive channels mask
   1581            * @retval None
   1582            */

   \                                 In section .text, align 2, keep-with-next
   1583          void SC_DMA_ChannelReset(SC_DMA_TypeDef* SCx_DMA, uint32_t Channely)
   1584          {
   1585            /* Check the parameters */
   1586            assert_param(IS_DMA_PERIPH(SCx_DMA));
   1587            assert_param(IS_DMA_CHANNEL_RESET(Channely));
   1588            
   1589            /* Reset the selected SCx_DMA Channelx */
   1590            SCx_DMA->DMACR |= Channely;
   \                     SC_DMA_ChannelReset: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
   1591          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6902             LDR      R2,[R0, #+16]
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x6101             STR      R1,[R0, #+16]
   \   00000006   0x4770             BX       LR               ;; return
   1592          
   1593          /**
   1594            * @brief  Initializes the SCx_DMA Channely according to the specified
   1595            *         parameters in the DMA_InitStruct.
   1596            * @param  SCx_DMA_Channely: where x can be 1 or 2 to select the SCx_DMA and
   1597            *   y can be Tx or Rx to select the SCx_DMA Channel.
   1598            * @param  SC_DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
   1599            *         contains the configuration information for the specified DMA Channel.
   1600            * @retval None
   1601            */

   \                                 In section .text, align 2, keep-with-next
   1602          void SC_DMA_Init(SC_DMA_Channel_TypeDef* SCx_DMA_Channely, SC_DMA_InitTypeDef* SC_DMA_InitStruct)
   1603          {
   1604            /* Check the parameters */
   1605            assert_param(IS_DMA_CHANNEL_PERIPH(SCx_DMA_Channely));
   1606            assert_param(IS_DMA_VALID_ADDRESS(SC_DMA_InitStruct->DMA_BeginAddrA));
   1607            assert_param(IS_DMA_VALID_ADDRESS(SC_DMA_InitStruct->DMA_EndAddrA));
   1608            assert_param(IS_DMA_VALID_ADDRESS(SC_DMA_InitStruct->DMA_BeginAddrB));
   1609            assert_param(IS_DMA_VALID_ADDRESS(SC_DMA_InitStruct->DMA_EndAddrB));
   1610            
   1611          /*---------------------- SCx_DMA Channely DMABEGADDAR Configuration ----------*/
   1612            /* Write to SCx_DMA Channely Begin address A register */
   1613            SCx_DMA_Channely->DMABEGADDAR = SC_DMA_InitStruct->DMA_BeginAddrA;
   \                     SC_DMA_Init: (+1)
   \   00000000   0x680A             LDR      R2,[R1, #+0]
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1614            
   1615            /*---------------------- SCx_DMA Channely DMAENDADDAR Configuration --------*/
   1616            /* Write to SCx_DMA Channely end address A register */
   1617            SCx_DMA_Channely->DMAENDADDAR = SC_DMA_InitStruct->DMA_EndAddrA;
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0x6042             STR      R2,[R0, #+4]
   1618            
   1619            /*---------------------- SCx_DMA Channely DMABEGADDBR Configuration --------*/
   1620            /* Write to SCx_DMA Channely Begin address B register */
   1621            SCx_DMA_Channely->DMABEGADDBR = SC_DMA_InitStruct->DMA_BeginAddrB;
   \   00000008   0x688A             LDR      R2,[R1, #+8]
   \   0000000A   0x6082             STR      R2,[R0, #+8]
   1622            
   1623            /*---------------------- SCx_DMA Channely DMAENDADDBR Configuration --------*/
   1624            /* Write to SCx_DMA Channely end address B register */
   1625            SCx_DMA_Channely->DMAENDADDBR = SC_DMA_InitStruct->DMA_EndAddrB;
   \   0000000C   0x68C9             LDR      R1,[R1, #+12]
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
   1626          }
   \   00000010   0x4770             BX       LR               ;; return
   1627          
   1628          /**
   1629            * @brief  Fills each DMA_InitStruct member with its default value.
   1630            * @param  SC_DMA_InitStruct: pointer to a DMA_InitTypeDef structure which will be initialized.
   1631            * @retval None
   1632            */

   \                                 In section .text, align 2, keep-with-next
   1633          void SC_DMA_StructInit(SC_DMA_InitTypeDef* SC_DMA_InitStruct)
   1634          {
   1635            /*--------------- Reset DMA init structure parameters values ---------------*/
   1636            /* Initialize the SCx_DMA_Channely begin address A member */
   1637            SC_DMA_InitStruct->DMA_BeginAddrA = 0x20000000;
   \                     SC_DMA_StructInit: (+1)
   \   00000000   0xF04F 0x5100      MOV      R1,#+536870912
   \   00000004   0x6001             STR      R1,[R0, #+0]
   1638            /* Initialize the SCx_DMA_Channely end address A member */
   1639            SC_DMA_InitStruct->DMA_EndAddrA = 0x20000000;
   \   00000006   0x6041             STR      R1,[R0, #+4]
   1640            /* Initialize the SCx_DMA_Channely begin address B member */
   1641            SC_DMA_InitStruct->DMA_BeginAddrB = 0x20000000;
   \   00000008   0x6081             STR      R1,[R0, #+8]
   1642            /* Initialize the SCx_DMA_Channely end address B member */
   1643            SC_DMA_InitStruct->DMA_EndAddrB = 0x20000000;
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
   1644          }
   \   0000000C   0x4770             BX       LR               ;; return
   1645          
   1646          /**
   1647            * @brief  Enables or disables the specified SCx_DMA interrupts.
   1648            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
   1649            * @param  DMA_IT: specifies the SCx_DMA interrupt source to be enabled or disabled. 
   1650            *   This parameter can be one of the following values:
   1651            *     @arg DMA_IT_TXULODB: DMA transmit buffer B unloaded interrupt mask
   1652            *     @arg DMA_IT_TXULODA: DMA transmit buffer A unloaded interrupt mask
   1653            *     @arg DMA_IT_RXULODB: DMA receive buffer B unloaded interrupt mask
   1654            *     @arg DMA_IT_RXULODA: DMA receive buffer A unloaded interrupt mask
   1655            * @param  NewState: new state of the specified SCx_DMA interrupt source.
   1656            *   This parameter can be: ENABLE or DISABLE.
   1657            * @retval None
   1658            */

   \                                 In section .text, align 2, keep-with-next
   1659          void SC_DMA_ITConfig(SC_IT_TypeDef* SCx_IT, uint32_t DMA_IT, FunctionalState NewState)
   1660          {
   1661            /* Check the parameters */
   1662            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
   1663            assert_param(IS_DMA_IT(DMA_IT));
   1664            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1665            
   1666            if (NewState != DISABLE)
   \                     SC_DMA_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6C02             LDR      R2,[R0, #+64]
   \   00000004   0xBF11             ITEEE    NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0x43C9             MVNEQ    R1,R1
   \   0000000A   0xB289             UXTHEQ   R1,R1
   \   0000000C   0x4011             ANDEQ    R1,R1,R2
   1667            {
   1668              /* Enable the selected DMA interrupt */
   1669              SCx_IT->IER |= DMA_IT;
   1670            }
   1671            else
   1672            {
   1673              /* Disable the selected DMA interrupt */
   1674              SCx_IT->IER &= (uint16_t)~((uint16_t)DMA_IT);
   \   0000000E   0x6401             STR      R1,[R0, #+64]
   1675            }
   1676          }
   \   00000010   0x4770             BX       LR               ;; return
   1677          
   1678          /**
   1679            * @brief  Load and Enables the specified SCx_DMA Channelxy buffers addresses.
   1680            * @param  SCx_DMA: where x can be 1 or 2 to select the Serial controller peripheral.
   1681            * @param  Channelxy: specifies the SCx_DMA channel to be enabled. 
   1682            *   This parameter can be one of the following values:
   1683            *     @arg DMA_ChannelLoad_BTx: DMA transmit channel buffer B mask
   1684            *     @arg DMA_ChannelLoad_ATx: DMA transmit channel buffer A mask
   1685            *     @arg DMA_ChannelLoad_BRx: DMA receive channel buffer B mask
   1686            *     @arg DMA_ChannelLoad_ARx: DMA receive channel buffer A mask
   1687            * @retval None
   1688            */

   \                                 In section .text, align 2, keep-with-next
   1689          void SC_DMA_ChannelLoadEnable(SC_DMA_TypeDef* SCx_DMA, uint32_t Channelxy)
   \                     SC_DMA_ChannelLoadEnable: (+1)
   \   00000000   0xBF00             Nop      
   1690          {
   1691            /* Check the parameters */
   1692            assert_param(IS_DMA_PERIPH(SCx_DMA));
   1693            assert_param(IS_DMA_CHANNEL_LOAD(Channelxy));
   1694            
   1695            /* Load the selected SCx_DMA Channelxy buffer addresses and allow the DMA controller
   1696               to start processing */
   1697            SCx_DMA->DMACR |= Channelxy;
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
   1698          }
   1699          
   1700          /**
   1701            * @brief  Returns the most recent value for the specific SCx_DMA counter register.
   1702            * @param  SCx_DMA: where x can be 1 or 2 to select the Serial controller peripheral.
   1703            * @param  Counter: specifies the SCx_DMA counter register to be read. 
   1704            *   This parameter can be one of the following values:
   1705            *     @arg DMA_Counter_RXCNTA: DMA receive counter A register
   1706            *     @arg DMA_Counter_RXCNTB: DMA receive counter B register
   1707            *     @arg DMA_Counter_TXCNT: DMA transmit counter register
   1708            *     @arg DMA_Counter_RXCNTSAVED: DMA receive counter saved register
   1709            * @retval The DMA register counter value.
   1710            */

   \                                 In section .text, align 2, keep-with-next
   1711          uint32_t SC_DMA_GetCounter(SC_DMA_TypeDef* SCx_DMA, uint32_t Counter)
   1712          {
   1713            uint32_t scxbase = 0x00;
   1714            
   1715            /* Check the parameters */
   1716            assert_param(IS_DMA_PERIPH(SCx_DMA));
   1717            assert_param(IS_DMA_COUNTER(Counter));
   1718            
   1719            scxbase = (uint32_t)SCx_DMA; 
   1720            scxbase += Counter;
   1721          
   1722            return *(__IO uint32_t *) scxbase;
   \                     SC_DMA_GetCounter: (+1)
   \   00000000   0x5808             LDR      R0,[R1, R0]
   \   00000002   0x4770             BX       LR               ;; return
   1723          }
   1724          
   1725          /**
   1726            * @brief  Returns the specified SCx_DMA receive error register.
   1727            * @param  SCx_DMA: where x can be 1 or 2 to select the Serial controller peripheral.
   1728            * @param  RegisterError: specifies the SCx_DMA receiver error register to be read. 
   1729            *   This parameter can be one of the following values:
   1730            *     @arg DMA_ReceiverError_CNTA: DMA receive error register A
   1731            *     @arg DMA_ReceiverError_CNTB: DMA receive error register B
   1732            * @retval The DMA receive error register value.
   1733            */

   \                                 In section .text, align 2, keep-with-next
   1734          uint32_t SC_DMA_GetReceiverErrorOffset(SC_DMA_TypeDef* SCx_DMA, uint32_t RegisterError)
   1735          {
   1736            uint32_t scxbase = 0x00;
   1737            
   1738            /* Check the parameters */
   1739            assert_param(IS_DMA_PERIPH(SCx_DMA));
   1740            assert_param(IS_DMA_RECEIVER_ERROR(RegisterError));
   1741            
   1742            scxbase = (uint32_t)SCx_DMA; 
   1743            scxbase += RegisterError;
   1744          
   1745            return *(__IO uint32_t *) scxbase;
   \                     SC_DMA_GetReceiverErrorOffset: (+1)
   \   00000000   0x5808             LDR      R0,[R1, R0]
   \   00000002   0x4770             BX       LR               ;; return
   1746          }
   1747          
   1748          /**
   1749            * @brief  Checks whether the specified DMA flag is set or not.
   1750            * @param  SCx_DMA: where x can be 1 or 2 to select the Serial controller peripheral.
   1751            * @param  DMA_FLAG: specifies the SCx_DMA flag to check.
   1752            *   This parameter can be one of the following values:
   1753            *     @arg DMA_FLAG_RXAACK: DMA receive buffer A acknowledge flag
   1754            *     @arg DMA_FLAG_RXBACK: DMA receive buffer B acknowledge flag
   1755            *     @arg DMA_FLAG_TXAACK: DMA transmit buffer A acknowledge flag
   1756            *     @arg DMA_FLAG_TXBACK: DMA transmit buffer B acknowledge flag
   1757            *     @arg DMA_FLAG_OVRA: DMA buffer B overrun flag
   1758            *     @arg DMA_FLAG_OVRB: DMA buffer B overrun flag
   1759            *     @arg DMA_FLAG_PEA: DMA Parity error A flag
   1760            *     @arg DMA_FLAG_PEB: DMA Parity error B flag
   1761            *     @arg DMA_FLAG_FEA: DMA Frame error A flag
   1762            *     @arg DMA_FLAG_FEB: DMA Frame error B flag
   1763            *     @arg DMA_FLAG_NSSS: DMA Status of the receive count flag
   1764            * @retval The new state of DMA_FLAG (SET or RESET).
   1765            */

   \                                 In section .text, align 2, keep-with-next
   1766          FlagStatus SC_DMA_GetFlagStatus(SC_DMA_TypeDef* SCx_DMA, uint32_t DMA_FLAG)
   1767          {
   1768            FlagStatus bitstatus = RESET;
   1769            
   1770            /* Check the parameters */
   1771            assert_param(IS_DMA_PERIPH(SCx_DMA));
   1772            assert_param(IS_DMA_FLAG(DMA_FLAG));
   1773            
   1774            if ((SCx_DMA->DMASR & DMA_FLAG) != (uint32_t)RESET)
   \                     SC_DMA_GetFlagStatus: (+1)
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
   1775            {
   1776              bitstatus = SET;
   1777            }
   1778            else
   1779            {
   1780              bitstatus = RESET;
   1781            }
   1782            return bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
   1783          }
   1784          
   1785          /**
   1786            * @brief  Checks whether the specified SCx_DMA pending interrupt is set or not.
   1787            * @param  SCx_IT: where x can be 1 or 2 to select the Serial controller peripheral.
   1788            * @param  DMA_IT: specifies the SCx_DMA interrupt pending to check.
   1789            *   This parameter can be one of the following values:
   1790            *     @arg DMA_IT_TXULODB: DMA transmit buffer B unloaded interrupt pending
   1791            *     @arg DMA_IT_TXULODA: DMA transmit buffer A unloaded interrupt pending
   1792            *     @arg DMA_IT_RXULODB: DMA receive buffer B unloaded interrupt pending
   1793            *     @arg DMA_IT_RXULODA: DMA receive buffer A unloaded interrupt pending
   1794            * @retval The new state of DMA_IT (SET or RESET).
   1795            */

   \                                 In section .text, align 2, keep-with-next
   1796          ITStatus SC_DMA_GetITStatus(SC_IT_TypeDef* SCx_IT, uint32_t DMA_IT)
   1797          {
   1798            ITStatus bitstatus = RESET;
   1799            uint32_t enablestatus = 0;
   1800            
   1801            /* Check the parameters */
   1802            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
   1803            assert_param(IS_DMA_IT(DMA_IT));
   1804            
   1805            enablestatus = (uint32_t)(SCx_IT->IER & DMA_IT);
   \                     SC_DMA_GetITStatus: (+1)
   \   00000000   0x6C03             LDR      R3,[R0, #+64]
   1806            if (((SCx_IT->ISR & DMA_IT) != (uint32_t)RESET) && enablestatus)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x400B             ANDS     R3,R1,R3
   \   00000008   0x4208             TST      R0,R1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x2B00             CMPNE    R3,#+0
   \   0000000E   0x2201             MOVNE    R2,#+1
   1807            {
   1808              bitstatus = SET;
   1809            }
   1810            else
   1811            {
   1812              bitstatus = RESET;
   1813            }
   1814            return bitstatus;
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR               ;; return
   1815          }
   1816          
   1817          /**
   1818            * @brief  Clears the SCx_DMA interrupt pending bits.
   1819            * @param  SCx_IT: where x can be 1 to select the Serial controller peripheral.
   1820            * @param  DMA_IT: specifies the SCx_DMA interrupt pending to check.
   1821            *   This parameter can be one of the following values:
   1822            *     @arg DMA_IT_TXULODB: DMA transmit buffer B unloaded interrupt pending
   1823            *     @arg DMA_IT_TXULODA: DMA transmit buffer A unloaded interrupt pending
   1824            *     @arg DMA_IT_RXULODB: DMA receive buffer B unloaded interrupt pending
   1825            *     @arg DMA_IT_RXULODA: DMA receive buffer A unloaded interrupt pending
   1826            * @retval None
   1827            */

   \                                 In section .text, align 2, keep-with-next
   1828          void SC_DMA_ClearITPendingBit(SC_IT_TypeDef* SCx_IT, uint32_t DMA_IT)
   1829          {
   1830            /* Check the parameters */
   1831            assert_param(IS_I2C_SPI_DMA_IT_PERIPH(SCx_IT));
   1832            assert_param(IS_DMA_IT(DMA_IT));
   1833            
   1834            SCx_IT->ISR = DMA_IT;
   \                     SC_DMA_ClearITPendingBit: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   1835          }
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x00061A80         DC32     0x61a80
   1836          
   1837          /**
   1838            * @}
   1839            */
   1840            
   1841          /**
   1842            * @}
   1843            */
   1844          
   1845          /**
   1846            * @}
   1847            */ 
   1848          
   1849          /**
   1850            * @}
   1851            */
   1852          
   1853          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2C_AcknowledgeConfig
       0   I2C_ClearITPendingBit
       0   I2C_Cmd
       0   I2C_DeInit
       0   I2C_GenerateSTART
       0   I2C_GenerateSTOP
       0   I2C_GetFlagStatus
       0   I2C_GetITStatus
       0   I2C_ITConfig
      40   I2C_Init
        40   -> CLK_GetClocksFreq
       0   I2C_ReceiveData
       0   I2C_Send7bitAddress
       0   I2C_SendData
       0   I2C_StructInit
       0   SC_DMA_ChannelLoadEnable
       0   SC_DMA_ChannelReset
       0   SC_DMA_ClearITPendingBit
       0   SC_DMA_GetCounter
       0   SC_DMA_GetFlagStatus
       0   SC_DMA_GetITStatus
       0   SC_DMA_GetReceiverErrorOffset
       0   SC_DMA_ITConfig
       0   SC_DMA_Init
       0   SC_DMA_StructInit
       0   SPI_ClearITPendingBit
       0   SPI_Cmd
       0   SPI_DeInit
       0   SPI_GetFlagStatus
       0   SPI_GetITStatus
       0   SPI_ITConfig
      40   SPI_Init
        40   -> CLK_GetClocksFreq
       0   SPI_LastByteRepeatCmd
       0   SPI_ReceiveData
       0   SPI_ReceiverModeConfig
       0   SPI_SendData
       0   SPI_StructInit
       0   SPI_TriggerEventConfig
       0   UART_ClearITPendingBit
       0   UART_Cmd
       0   UART_DeInit
       0   UART_GetFlagStatus
       0   UART_GetITStatus
       0   UART_ITConfig
      16   UART_Init
        16   -> CLK_GetClocksFreq
       0   UART_RTSAssertionCmd
       0   UART_ReceiveData
       0   UART_SendData
       0   UART_StructInit
       0   UART_TriggerEventConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       8  ?Subroutine0
       6  ?Subroutine1
      12  ?Subroutine10
      12  ?Subroutine11
       6  ?Subroutine2
      18  ?Subroutine3
      26  ?Subroutine4
      14  ?Subroutine5
      14  ?Subroutine6
      12  ?Subroutine7
      12  ?Subroutine8
      12  ?Subroutine9
      18  I2C_AcknowledgeConfig
       4  I2C_ClearITPendingBit
      20  I2C_Cmd
       8  I2C_DeInit
      10  I2C_GenerateSTART
      10  I2C_GenerateSTOP
      14  I2C_GetFlagStatus
      20  I2C_GetITStatus
      18  I2C_ITConfig
     126  I2C_Init
      22  I2C_ReceiveData
      30  I2C_Send7bitAddress
      50  I2C_SendData
       6  I2C_StructInit
       2  SC_DMA_ChannelLoadEnable
       2  SC_DMA_ChannelReset
       4  SC_DMA_ClearITPendingBit
       4  SC_DMA_GetCounter
      14  SC_DMA_GetFlagStatus
      20  SC_DMA_GetITStatus
       4  SC_DMA_GetReceiverErrorOffset
      18  SC_DMA_ITConfig
      18  SC_DMA_Init
      14  SC_DMA_StructInit
       4  SPI_ClearITPendingBit
      28  SPI_Cmd
       8  SPI_DeInit
      14  SPI_GetFlagStatus
      20  SPI_GetITStatus
      18  SPI_ITConfig
     154  SPI_Init
      20  SPI_LastByteRepeatCmd
       2  SPI_ReceiveData
      18  SPI_ReceiverModeConfig
       4  SPI_SendData
      18  SPI_StructInit
      18  SPI_TriggerEventConfig
       4  UART_ClearITPendingBit
      28  UART_Cmd
      12  UART_DeInit
      14  UART_GetFlagStatus
      20  UART_GetITStatus
      18  UART_ITConfig
     104  UART_Init
      20  UART_RTSAssertionCmd
       2  UART_ReceiveData
       4  UART_SendData
      20  UART_StructInit
      18  UART_TriggerEventConfig

 
 1 206 bytes in section .text
 
 1 206 bytes of CODE memory

Errors: none
Warnings: 1
