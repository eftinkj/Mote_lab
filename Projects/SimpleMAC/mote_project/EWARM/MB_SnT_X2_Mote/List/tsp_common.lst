###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        21/Feb/2015  16:30:59
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\tsp_common.c
#    Command line =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\tsp_common.c
#        -D USE_STDPERIPH_DRIVER -D USE_MB_SNT_X2 -D STM32W108CB -D
#        "PLATFORM_HEADER=\"Utilities\STM32W108xx_HAL_Driver/micro/cortexm3/compiler/iar.h\""
#        -D CORTEXM3 -D CORTEXM3_STM32W108 -D CORTEXM3_STM32W108xB -D
#        DISABLE_WATCHDOG -D "__SOURCEFILE__=\"tsp_common.c\"" -lC
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\
#        --diag_suppress Pa050 -o
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\stm32w108\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\generic\compiler\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32W108xx_HAL_Driver\micro\cortexm3\bootloader\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\Shared\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\STM32W108xx_StdPeriph_Driver\inc\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32W108xx\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Libraries\SimpleMAC\Include\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\..\..\Utilities\STM32_EVAL\MB851\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\
#        -I
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\..\..\arm_mote\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\List\tsp_common.lst
#    Object file  =  
#        C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\mote_project\EWARM\MB_SnT_X2_Mote\Obj\tsp_common.o
#
###############################################################################

C:\Users\Jon\Documents\MO_S_and_T\CpE5170_RT_Systems\Labs\cpe-5170-mote-code\Projects\SimpleMAC\arm_mote\FEAT_Networking\tsp_common.c
      1          
      2          #include "tsp_common_prv.h"
      3          #include "tsp_common_pub.h"
      4          
      5          #include "packet.h"
      6          #include "FEAT_Queuing/Queuing.h"
      7          #include "sys_func.h"
      8          
      9          #ifdef _ENABLE_ROBOTICS_01_
     10          	#include "PRJ_Robotics_01/truck_basic_control_pub.h"
     11          #endif // _ENABLE_ROBOTICS_01_
     12          
     13          #ifdef _ENABLE_ROBOTICS_02_
     14          	#include "PRJ_Robotics_02/bot_basic_control_pub.h"
     15          #endif // _ENABLE_ROBOTICS_02_
     16          
     17          
     18          #ifdef _ENABLE_ROBOTICS_03_
     19          #include "PRJ_Robotics_03/qrhelo_basic_control_pub.h"
     20          #endif // _ENABLE_ROBOTICS_03_
     21          
     22          
     23          #ifdef _ENABLE_ROBOTICS_04_
     24          #include "PRJ_Robotics_04/vex_tank_basic_control_pub.h"
     25          #endif // _ENABLE_ROBOTICS_04_
     26          
     27          
     28          #ifdef _ENABLE_NEM_UTILITIES_01_
     29          	#include "PRJ_NEM_Utilities_01/mon_power_basic_pub.h"
     30          #endif // _ENABLE_NEM_UTILITIES_01_
     31          
     32          
     33          #ifdef _ENABLE_LOGISTICS_01_
     34          	#include "FEAT_LGS_01/lgs_basic_pub.h"
     35          #endif // _ENABLE_LOGISTICS_01_
     36          
     37          
     38          #if defined(_ENABLE_CAMT_HEADSET_01_) || defined(_ENABLE_CAMT_HEADSET_02_)
     39          	#include "PRJ_CAMT_Headset_01/hset_basic_pub.h"
     40          	#include "FEAT_XBee_API/API_frames.h"
     41          #endif // _ENABLE_CAMT_HEADSET_01_
     42          
     43          
     44          #ifdef _ENABLE_FLA_BASIC_
     45          	#include "FEAT_Flash_Access/fla_basic_pub.h"
     46          #endif // _ENABLE_FLA_BASIC_
     47          
     48          #ifdef _ENABLE_SSN_BASIC_
     49          	#include "FEAT_SigProc/ssn_basic_pub.h"
     50          #endif // _ENABLE_SSN_BASIC_
     51          
     52          #include "FEAT_Queuing/Queuing.h"
     53          
     54          #include "FEAT_STM32W/STM32W_Radio.h"
     55          
     56          #include "Application.h"
     57          //#include "HW_LIB/adc_0.h"
     58          /****************************************************************************
     59          **	Constants, definies and typedefs  (PRIVATE)
     60          ****************************************************************************/
     61          
     62          #define MAX_PORTS	10
     63          
     64          
     65          /****************************************************************************
     66          **	Constants, definies and typedefs  (PUBLIC)
     67          ****************************************************************************/
     68          
     69          /****************************************************************************
     70          **	Variables definition (PRIVATE)
     71          ****************************************************************************/

   \                                 In section .bss, align 4
     72          uint8_t		tsp_callback_port[MAX_PORTS];
     73          tsp_cb_func_t	tsp_callback_funcs[MAX_PORTS];
     74          uint8_t		tsp_cb_count = 0;
   \                     tsp_cb_count:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     tsp_callback_port:
   \   00000004                      DS8 12
   \                     tsp_callback_funcs:
   \   00000010                      DS8 40
     75          
     76          /****************************************************************************
     77          **	Variables definition (PUBLIC)
     78          ****************************************************************************/
     79          
     80          /****************************************************************************
     81          **	Functions declarations / prototypes (PRIVATE)
     82          ****************************************************************************/
     83          
     84          /****************************************************************************
     85          **	Functions declarations / prototypes (PUBLIC)
     86          ****************************************************************************/
     87          
     88          
     89          /****************************************************************************
     90          **	Functions implementation (PRIVATE)
     91          ****************************************************************************/
     92          
     93          
     94          /**
     95           * tsp_register_port( port, callback_func) - sets a new listening port
     96           *			when a message comes, the (callback_func) is executed
     97           *	RETURNS:
     98           */

   \                                 In section .text, align 2, keep-with-next
     99          uint8_t tsp_register_port( uint8_t port, tsp_cb_func_t callback_func)
    100          {
   \                     tsp_register_port: (+1)
   \   00000000   0xB520             PUSH     {R5,LR}
    101          	if (tsp_cb_count < MAX_PORTS) {
   \   00000002   0x....             LDR.N    R2,??DataTable5
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B0A             CMP      R3,#+10
   \   00000008   0xDA08             BGE.N    ??tsp_register_port_0
    102          		tsp_callback_port[tsp_cb_count] = port;
   \   0000000A   0x189D             ADDS     R5,R3,R2
   \   0000000C   0x7128             STRB     R0,[R5, #+4]
    103          		tsp_callback_funcs[tsp_cb_count] = callback_func;
   \   0000000E   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   00000012   0x6101             STR      R1,[R0, #+16]
    104          		tsp_cb_count++;
   \   00000014   0x1C58             ADDS     R0,R3,#+1
   \   00000016   0x7010             STRB     R0,[R2, #+0]
    105          		return tsp_cb_count-1;
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0xBD20             POP      {R5,PC}
    106          	} else {
    107          		return 0xFF; // failed
   \                     ??tsp_register_port_0: (+1)
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xBD20             POP      {R5,PC}          ;; return
    108          	}
    109          }
    110          
    111          /****************************************************************************
    112          **	Functions implementation (PUBLIC)
    113          ****************************************************************************/
    114          
    115          /**
    116            * tsp_init() - sets up MOD module
    117            */

   \                                 In section .text, align 2, keep-with-next
    118          void tsp_init ( void )
    119          {
    120          	tsp_cb_count = 0;
   \                     tsp_init: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    121          	// DO NOTHING ???
    122          }
   \   00000006   0x4770             BX       LR               ;; return
    123          
    124          
    125          /**
    126            * tsp_receive(p) - handle reception of packet "p"
    127            */

   \                                 In section .text, align 2, keep-with-next
    128          uint8_t tsp_receive( uint8_t XDATA *p, uint8_t rssi )
    129          {
   \                     tsp_receive: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    130          	pkt_t XDATA *pkt = ( pkt_t XDATA * ) p;
    131          	switch (pkt->flags)
   \   00000002   0x7842             LDRB     R2,[R0, #+1]
   \   00000004   0x3A74             SUBS     R2,R2,#+116
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD803             BHI.N    ??tsp_receive_0
    132          	{
    133          		case FLAG_DATA:
    134          			break;
    135          		case FLAG_DATA_TEST:
    136          			break;
    137          		case FLAG_DATA_ARB:
    138          			break;
    139          		case FLAG_DATA_TEST_V2:		
    140          		case FLAG_DATA_MODULAR:
    141          			tsp_distribute_modules( p, rssi );
   \   0000000A   0x.... 0x....      BL       tsp_distribute_modules
    142          			return TSP_HANDLED_PACKET;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xBD02             POP      {R1,PC}
    143          
    144          			//break;
    145          		default:
    146          			// Drop the packet and forget
    147          			break;
    148          	}
    149          	return TSP_NOT_HANDLED_PACKET;
   \                     ??tsp_receive_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    150          }
    151          
    152          
    153          
    154          /**
    155            * tsp_distribute_modules(p) - handle distribution of modules from packet "p"
    156            *			to the applications
    157            *			where the data in "p" is in new MODULAR format
    158            *		TODO: Make the distribution flexible (configured online via functions)
    159            */

   \                                 In section .text, align 2, keep-with-next
    160          void tsp_distribute_modules(uint8_t XDATA *p, uint8_t rssi )
    161          {
   \                     tsp_distribute_modules: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x4688             MOV      R8,R1
    162          	pkt_v2_t XDATA *pkt = ( pkt_v2_t XDATA * )p ;
    163          
    164          	// NOTE: Initially only handling of the first module is suported
    165          	// TODO: Enable multiple modules in one packet
    166          	uint8_t offset = PKT_V2_MODULES_OFFSET;
    167          	uint8_t len = pkt->length + PKT_HEADER_LENGTH;
   \   00000008   0x79B0             LDRB     R0,[R6, #+6]
    168          	pkt_mod_header_t XDATA *mod = (pkt_mod_header_t XDATA*) &(p[offset]);
    169          	uint8_t src_id = pkt->src_id;
   \   0000000A   0xF896 0x9008      LDRB     R9,[R6, #+8]
   \   0000000E   0x1DC7             ADDS     R7,R0,#+7
   \   00000010   0x2409             MOVS     R4,#+9
   \   00000012   0xB2FF             UXTB     R7,R7
   \   00000014   0xE006             B.N      ??tsp_distribute_modules_0
    170          //	while ( (offset < (pkt->length + PKT_HEADER_LENGTH)) && (offset < MAX_PKT_SIZE) )
    171          	while ( (offset < len) && (offset < MAX_PKT_SIZE) )
    172          	{
    173          		mod = (pkt_mod_header_t XDATA *) &(p[offset]);
    174          //		switch (pkt->data_modules)
    175          		switch (mod->module_type)
    176          		{
    177          			case PKT_MODULE_TYPE_ADFS:
    178          				break;
    179          			case PKT_MODULE_TYPE_PONG:
    180          				break;
    181          			case PKT_MODULE_TYPE_HOPLIST:
    182          				break;
    183          			case PKT_MODULE_TYPE_PCC_UPSTREAM:
    184          				break;
    185          			//case PKT_MODULE_TYPE_CS_V1:
    186          			//	break;
    187          			case PKT_MODULE_TYPE_RAW_CHANNEL:
    188          				break;
    189          			case PKT_MODULE_TYPE_RAW_CHANNEL_V1:
    190          				break;
    191          			case PKT_MODULE_TYPE_RAW_CHANNEL_V2:
    192          				break;
    193          			case PKT_MODULE_TYPE_RAW_CHANNEL_V3:
    194          				break;
    195          #ifdef _ENABLE_ROBOTICS_01_
    196          			case PKT_MODULE_TYPE_TRUCK_CMD_V1:
    197          				truck_execute_command( mod );
    198          				break;
    199          #endif // _ENABLE_ROBOTICS_01_
    200          
    201          #ifdef _ENABLE_ROBOTICS_02_
    202          			case PKT_MODULE_TYPE_BOT_CMD_V1:
    203          				bot_execute_command( mod );
    204          				break;
    205          #endif // _ENABLE_ROBOTICS_02_
    206          
    207          #ifdef _ENABLE_ROBOTICS_03_
    208          			case PKT_MODULE_TYPE_QRHELO_CMD_V1:
    209          				qrhelo_execute_command( mod );
    210          				break;
    211          #endif // _ENABLE_ROBOTICS_03_
    212          
    213          
    214          #ifdef _ENABLE_ROBOTICS_04_
    215          			case PKT_MODULE_TYPE_VEX_TANK_CMD_V1:
    216          				vex_tank_execute_command( mod );
    217          				break;
    218          #endif // _ENABLE_ROBOTICS_04_
    219          
    220          
    221          #ifdef _ENABLE_NEM_UTILITIES_01_
    222          			case PKT_MODULE_TYPE_MON_POWER_CMD_V1:
    223          			case PKT_MODULE_TYPE_MON_POWER_REPORT_V1:
    224          				mon_power_execute_command( mod );
    225          				break;
    226          #endif // _ENABLE_NEM_UTILITIES_01_
    227          
    228          #ifdef _ENABLE_LOGISTICS_01_
    229          			case PKT_MODULE_TYPE_LGS_MOTE_REPORT:
    230          				lgs_recv_command( mod, rssi );
    231          				break;
    232          	#ifdef _ENABLE_RFID_READER_DETECTION_
    233          			case PKT_MODULE_TYPE_RFID_READER_V1:
    234          				logistics_rfid_read( mod, rssi );
    235          				break;
    236          	#endif //_ENABLE_RFID_READER_DETECTION_
    237          
    238          	#ifdef _ENABLE_DLS_TRUCK_MOTE_
    239          			case PKT_MODULE_TYPE_LGS_GATEMOTE_BEACON:
    240          //				logistics_gate_read( mod, rssi );
    241          				break;
    242          	#endif // _ENABLE_DLS_TRUCK_MOTE_
    243          
    244          
    245          	#ifdef _ENABLE_DLS_GATE_MOTE_
    246          			case PKT_MODULE_TYPE_RFID_READER_V1:
    247          //				logistics_recv_gatemote(mod, rssi );
    248          				break;
    249          	#endif // _ENABLE_DLS_GATE_MOTE_
    250          
    251          //PKT_MODULE_TYPE_LGS_RFIDR_DETECT_REPORT
    252          // PKT_MODULE_TYPE_LGS_INVENTORY_REPORT
    253          //			case PKT_MODULE_TYPE_LGS_MOTE_REPORT:
    254          //				break;
    255          
    256          			case PKT_MODULE_TYPE_LGS_MOTE_BEACON:
    257          //	#ifdef _ENABLE_RFID_READER_DETECTION_
    258          				lgs_recv_mote_beacon( mod, rssi);
    259          //	#endif // _ENABLE_RFID_READER_DETECTION_
    260          				break;
    261          			case PKT_MODULE_TYPE_LGS_MOTE_ASSOC_REQ:
    262          				lgs_recv_assoc_req(mod, rssi);
    263          				break;
    264          			case PKT_MODULE_TYPE_LGS_MOTE_QUERY:
    265          				break;
    266          
    267          #endif // _ENABLE_LOGISTICS_01_
    268          
    269          #ifdef _ENABLE_FLA_BASIC_
    270          //#ifdef _ENABLE_RFID_READER_DETECTION_
    271          			case PKT_MODULE_TYPE_FLA_BASIC:
    272          				fla_recv_cmd( mod, rssi );
    273          				break;
    274          #endif // _ENABLE_FLA_BASIC_
    275          
    276          #ifdef _ENABLE_SSN_BASIC_
    277          			case PKT_MODULE_TYPE_SSN_V1:
    278          				ssn_execute_command ( (uint8_t XDATA *)mod );
    279          				break;
    280          #endif // _ENABLE_SSN_BASIC_
    281          
    282          #ifdef FEAT_ENABLE_CH_SWITCHING
    283          			case PKT_MODULE_TYPE_CS_V1:
    284          				cs_recv_switching_request( (char *)mod );
                 				^
Warning[Pe223]: function "cs_recv_switching_request" declared implicitly
   \                     ??tsp_distribute_modules_1: (+1)
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       cs_recv_switching_request
    285          				break;
    286          #endif // FEAT_ENABLE_CH_SWITCHING
    287          				
    288          #if defined(_ENABLE_CAMT_HEADSET_01_) || defined(_ENABLE_CAMT_HEADSET_02_)
    289          			case PKT_MODULE_TYPE_HSET_REPORT_V1:
    290          			case PKT_MODULE_TYPE_HSET_SAMPLES_V1:
    291          				hset_execute_command(&(pkt->data_modules));
    292          				break;
    293          #endif // _ENABLE_CAMT_HEADSET_01_
    294          
    295          #if defined(_ENABLE_RSSI_SENSOR_)
    296          		  	case PKT_MODULE_TYPE_RS_RSSI_REPORT:
    297          				rs_receive_report((uint8_t XDATA *)mod );
    298          			 	break;
    299          #endif // #if defined(_ENABLE_RSSI_SENSOR_)
    300          			case PKT_MODULE_TYPE_END:
    301          			case PKT_MODULE_TYPE_DUMMY:
    302          			default:
    303          				//TODO: Add dynamic port assignment/handling
    304          			{
    305          				uint8_t i;
    306          				for(i=0; i<tsp_cb_count; i++)
    307          				{
    308          					if (tsp_callback_port[i] == mod->module_type)
    309          					{
    310          						(tsp_callback_funcs[i])(src_id, mod, rssi) ;
    311          					}
    312          				}
    313          			}
    314          				return;
    315          				//break;
    316          		}
    317          		offset += (mod->module_length + 2);
   \                     ??tsp_distribute_modules_2: (+1)
   \   0000001C   0x7868             LDRB     R0,[R5, #+1]
   \   0000001E   0x1900             ADDS     R0,R0,R4
   \   00000020   0x1C80             ADDS     R0,R0,#+2
   \   00000022   0xB2C4             UXTB     R4,R0
   \                     ??tsp_distribute_modules_0: (+1)
   \   00000024   0x42BC             CMP      R4,R7
   \   00000026   0xBFB8             IT       LT 
   \   00000028   0x2C63             CMPLT    R4,#+99
   \   0000002A   0xDA21             BGE.N    ??tsp_distribute_modules_3
   \   0000002C   0x19A5             ADDS     R5,R4,R6
   \   0000002E   0x7828             LDRB     R0,[R5, #+0]
   \   00000030   0x3810             SUBS     R0,R0,#+16
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD9F2             BLS.N    ??tsp_distribute_modules_2
   \   00000036   0x3810             SUBS     R0,R0,#+16
   \   00000038   0xD0F0             BEQ.N    ??tsp_distribute_modules_2
   \   0000003A   0x3810             SUBS     R0,R0,#+16
   \   0000003C   0xD0EE             BEQ.N    ??tsp_distribute_modules_2
   \   0000003E   0x3820             SUBS     R0,R0,#+32
   \   00000040   0xD0E9             BEQ.N    ??tsp_distribute_modules_1
   \   00000042   0x3810             SUBS     R0,R0,#+16
   \   00000044   0x2803             CMP      R0,#+3
   \   00000046   0xD9E9             BLS.N    ??tsp_distribute_modules_2
   \   00000048   0x2600             MOVS     R6,#+0
   \   0000004A   0x....             LDR.N    R7,??DataTable5
   \   0000004C   0xE00D             B.N      ??tsp_distribute_modules_4
   \                     ??tsp_distribute_modules_5: (+1)
   \   0000004E   0x19F0             ADDS     R0,R6,R7
   \   00000050   0x7829             LDRB     R1,[R5, #+0]
   \   00000052   0x7900             LDRB     R0,[R0, #+4]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD106             BNE.N    ??tsp_distribute_modules_6
   \   00000058   0xEB07 0x0386      ADD      R3,R7,R6, LSL #+2
   \   0000005C   0x4642             MOV      R2,R8
   \   0000005E   0x691B             LDR      R3,[R3, #+16]
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x4648             MOV      R0,R9
   \   00000064   0x4798             BLX      R3
   \                     ??tsp_distribute_modules_6: (+1)
   \   00000066   0x1C76             ADDS     R6,R6,#+1
   \   00000068   0xB2F6             UXTB     R6,R6
   \                     ??tsp_distribute_modules_4: (+1)
   \   0000006A   0x7838             LDRB     R0,[R7, #+0]
   \   0000006C   0x4286             CMP      R6,R0
   \   0000006E   0xDBEE             BLT.N    ??tsp_distribute_modules_5
    318          	} // while end
    319          }
   \                     ??tsp_distribute_modules_3: (+1)
   \   00000070   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    320          
    321          
    322          /**
    323           * tsp_release_packet(pkt_id) - releases the packet buffer (in queue)
    324           *			this should be used when the packet was reserved
    325           *			and will not be sent out nor used anymore
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          void tsp_release_packet(uint8_t pkt_id)
    328          {
    329          	que_make_empty_buffer ( pkt_id );
   \                     tsp_release_packet: (+1)
   \   00000000   0x.... 0x....      B.W      que_make_empty_buffer
    330          }
    331          
    332          
    333          
    334          /**
    335            * tsp_send_from_modules(pkt_id) - handle transmission of the new packet
    336            *			from the applications (actually enquing the packet)
    337            *			where the data in "p" is in new MODULAR format
    338            *		RETURNs: 1 - when succesful, 0 - when failed (queue full)
    339            */

   \                                 In section .text, align 2, keep-with-next
    340          uint8_t tsp_send_from_modules(uint8_t pkt_id)
    341          {
   \                     tsp_send_from_modules: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    342          	// Enqueue packet
    343          	if ( 0 == que_enQpacket ( pkt_id ) )
   \   00000004   0x.... 0x....      BL       que_enQpacket
   \   00000008   0xB950             CBNZ.N   R0,??tsp_send_from_modules_0
    344          	{
    345          		// Failed -> free the packet
    346          		app_drop_pkt ( pkt_id, MODULE_APP, REASON_QUEUE_FULL, EVENT_DGEN );
   \   0000000A   0x2302             MOVS     R3,#+2
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x2104             MOVS     R1,#+4
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       app_drop_pkt
    347          		que_make_empty_buffer ( pkt_id );
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       que_make_empty_buffer
    348          		return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}
    349          		// Handle the lack of space in queue
    350          	}
    351          	return 1;
   \                     ??tsp_send_from_modules_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    352          }
    353          
    354          
    355          
    356          /**
    357            * tsp_reserve_packet ( data_size, *pkt_base, dest_id ) - reserves a new packet
    358            *			and fills out the main fields and modules
    359            *			The reserved space for user/app module is marked as DUMMY module
    360            *		RETURNs: total length of the packet OR ZERO (0) if failed
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          uint8_t tsp_reserve_packet ( uint8_t data_size, uint8_t *pkt_id, uint8_t dst_id )
    363          {
   \                     tsp_reserve_packet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    364          
    365          	int16_t len = PKT_HEADER_LENGTH; // size of the packet header (start + flag + dst(2) + src(2) + len)
    366          	int16_t msg_i;
    367          	uint16_t	pkt_base;
    368          	// SDCC:
    369          	pkt_v2_t * XDATA pkt = NULL;
    370          	uint8_t * XDATA msg;
    371          	int i;
    372          
    373          	{
    374          		// reserve packet
    375          		(*pkt_id) = que_get_empty_buffer_location();
   \   00000008   0x.... 0x....      BL       que_get_empty_buffer_location
   \   0000000C   0x4601             MOV      R1,R0
    376          		if ( 0xFF == (*pkt_id) )
   \   0000000E   0x29FF             CMP      R1,#+255
   \   00000010   0x7031             STRB     R1,[R6, #+0]
   \   00000012   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000016   0xD106             BNE.N    ??tsp_reserve_packet_0
    377          		{
    378          			// Error with packet buffer allocation!!
    379          			// TODO: Handle the lack of space for new packet
    380          			app_drop_pkt ( 0xFFFF, MODULE_APP, REASON_MEMORY_FULL, EVENT_DGEN );
   \   00000018   0x2302             MOVS     R3,#+2
   \   0000001A   0x2205             MOVS     R2,#+5
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x.... 0x....      BL       app_drop_pkt
    381          			return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}
    382          		}
    383          	}
    384          	pkt_base = ( uint16_t ) QBUFF_BASE ( (*pkt_id) );
    385          	pkt = ( pkt_v2_t* ) ( & ( buffer0[pkt_base] ) ); //&(QBUFF_ACCESS(base,0));
   \                     ??tsp_reserve_packet_0: (+1)
   \   00000026   0x2364             MOVS     R3,#+100
   \   00000028   0x....             LDR.N    R2,??DataTable5_1
   \   0000002A   0x4359             MULS     R1,R3,R1
   \   0000002C   0x1889             ADDS     R1,R1,R2
    386          
    387          	pkt->start = START_BYTE;
   \   0000002E   0x2242             MOVS     R2,#+66
   \   00000030   0x700A             STRB     R2,[R1, #+0]
    388          	pkt->flag = FLAG_DATA_TEST_V2;
    389          
    390          	pkt->mac_dst = SWAP16((uint16_t)(0xFF==dst_id?0xFFFF:dst_id));//0xFFFF);
    391          	pkt->mac_src = SWAP16(MY_ADDR);
    392          
    393          	msg = & ( pkt->dst_id );
    394          
    395          	msg_i = 0;
    396          
    397          	// FILL END-TO-END ADDRESSING
    398          	msg[msg_i] = dst_id; // BS_ADDR;
    399          	msg[msg_i+1] = MY_ADDR;
    400          
    401          	len = len + 2;
    402          	msg_i = msg_i + 2;
    403          
    404          #ifdef FEAT_ENABLE_SFQ
    405          	{
    406          		pkt_mod_header_t *ph = ( pkt_mod_header_t * ) ( & ( msg[msg_i] ) );
    407          		pkt_mod_adfs_t *p_adfs = ( pkt_mod_adfs_t* ) ( &msg[msg_i + PKT_MODULE_LEN_HEADER] );
    408          
    409          		ph->module_type = PKT_MODULE_TYPE_ADFS;
    410          		ph->module_length = PKT_MODULE_LEN_ADFS;
    411          
    412          		p_adfs->weight = my_source_weight_;
    413          		p_adfs ->ticker = rtc_get_rticks();
    414          
    415          		len = len + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_ADFS;
    416          		msg_i = msg_i + PKT_MODULE_LEN_HEADER + PKT_MODULE_LEN_ADFS;
    417          	}
    418          #endif // FEAT_ENABLE_SFQ
    419          
    420          
    421          	{
    422          		pkt_mod_header_t *ph = ( pkt_mod_header_t * ) ( & ( msg[msg_i] ) );
    423          		ph->module_type = PKT_MODULE_TYPE_DUMMY; // Data portion type
    424          
    425          		len += PKT_MODULE_LEN_HEADER;
    426          		msg_i += PKT_MODULE_LEN_HEADER;
    427          
    428          		// FILL THE REST OF 100byte packet (90 bytes of samples)
    429          		// MZ: 2011/08/05 - does not belong here:
    430          		//		if ( SAMPLES_PER_PACKET < data_size )
    431          		//			data_size = SAMPLES_PER_PACKET;
    432          		if ( MAX_PKT_SIZE < len + data_size )
   \   00000032   0xF104 0x060B      ADD      R6,R4,#+11
   \   00000036   0x2275             MOVS     R2,#+117
   \   00000038   0x704A             STRB     R2,[R1, #+1]
   \   0000003A   0x2DFF             CMP      R5,#+255
   \   0000003C   0xBF0E             ITEE     EQ 
   \   0000003E   0x4602             MOVEQ    R2,R0
   \   00000040   0x462A             MOVNE    R2,R5
   \   00000042   0x4628             MOVNE    R0,R5
   \   00000044   0x0200             LSLS     R0,R0,#+8
   \   00000046   0xEA40 0x2012      ORR      R0,R0,R2, LSR #+8
   \   0000004A   0x8048             STRH     R0,[R1, #+2]
   \   0000004C   0x23F0             MOVS     R3,#+240
   \   0000004E   0x....             LDR.N    R2,??DataTable5_2
   \   00000050   0x7810             LDRB     R0,[R2, #+0]
   \   00000052   0x0200             LSLS     R0,R0,#+8
   \   00000054   0x8088             STRH     R0,[R1, #+4]
   \   00000056   0x1DC8             ADDS     R0,R1,#+7
   \   00000058   0x7005             STRB     R5,[R0, #+0]
   \   0000005A   0x2504             MOVS     R5,#+4
   \   0000005C   0x7812             LDRB     R2,[R2, #+0]
   \   0000005E   0x7042             STRB     R2,[R0, #+1]
   \   00000060   0x1C82             ADDS     R2,R0,#+2
   \   00000062   0x7013             STRB     R3,[R2, #+0]
   \   00000064   0x230B             MOVS     R3,#+11
   \   00000066   0x2E64             CMP      R6,#+100
   \   00000068   0xBFA8             IT       GE 
   \   0000006A   0x2458             MOVGE    R4,#+88
    433          			data_size = MAX_PKT_SIZE - len;
    434          
    435          		ph->module_length = data_size; // Data portion length
   \   0000006C   0x7054             STRB     R4,[R2, #+1]
    436          
    437          		for ( i = 0; i < data_size; i++ )
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x....             LDR.N    R6,??DataTable5_3
   \   00000072   0xE003             B.N      ??tsp_reserve_packet_1
    438          		{
    439          			msg[msg_i] = sequence_no_;
   \                     ??tsp_reserve_packet_2: (+1)
   \   00000074   0x542F             STRB     R7,[R5, R0]
    440          			msg_i++;
   \   00000076   0x1C6D             ADDS     R5,R5,#+1
    441          			len++;
   \   00000078   0x1C5B             ADDS     R3,R3,#+1
    442          		}
   \   0000007A   0x1C52             ADDS     R2,R2,#+1
   \                     ??tsp_reserve_packet_1: (+1)
   \   0000007C   0x7837             LDRB     R7,[R6, #+0]
   \   0000007E   0x42A2             CMP      R2,R4
   \   00000080   0xB22D             SXTH     R5,R5
   \   00000082   0xDBF7             BLT.N    ??tsp_reserve_packet_2
    443          		sequence_no_++;	// increase for next packet
   \   00000084   0x1C7A             ADDS     R2,R7,#+1
   \   00000086   0x7032             STRB     R2,[R6, #+0]
    444          	}
    445          
    446          	msg[msg_i] = PKT_MODULE_TYPE_END; // End of modules
   \   00000088   0x2241             MOVS     R2,#+65
   \   0000008A   0x542A             STRB     R2,[R5, R0]
    447          
    448          	len++;
    449          	msg_i++;
    450          
    451          	pkt->length = msg_i; // of the packet'd data
   \   0000008C   0x1C68             ADDS     R0,R5,#+1
   \   0000008E   0x7188             STRB     R0,[R1, #+6]
    452          
    453          	return len;
   \   00000090   0x1C58             ADDS     R0,R3,#+1
   \   00000092   0xB2C0             UXTB     R0,R0
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    454          }
    455          
    456          /**
    457          *	tsp_get_dummy(pkt_base) - finds the DUMMY module in the given packet
    458          *		RETURNS: pointer (*) to the DUMMY module OR NULL value if failed
    459          */

   \                                 In section .text, align 2, keep-with-next
    460          uint8_t XDATA *tsp_get_dummy(uint8_t pkt_id)
    461          {
   \                     tsp_get_dummy: (+1)
   \   00000000   0x4601             MOV      R1,R0
    462          	uint16_t pkt_base = ( uint16_t ) QBUFF_BASE ( pkt_id );
    463          	pkt_v2_t *pkt_v2  = ( pkt_v2_t* ) ( & ( buffer0[pkt_base] ) );
    464          	pkt_mod_header_t *ph = ( pkt_mod_header_t * ) ( & ( pkt_v2->data_modules ) );
   \   00000002   0x2264             MOVS     R2,#+100
   \   00000004   0x....             LDR.N    R0,??DataTable5_1
   \   00000006   0x434A             MULS     R2,R2,R1
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x3009             ADDS     R0,R0,#+9
    465          	uint8_t mod_len = 0;
    466          	uint8_t pkt_len = PKT_HEADER_LENGTH + 2;
    467          	if (pkt_id >= NUMQBUFFS)
   \   0000000E   0x2908             CMP      R1,#+8
   \   00000010   0xDB06             BLT.N    ??tsp_get_dummy_0
    468          	{
    469          		sys_error(SYS_ERROR_TSP_WRONG_PKT_IDX);
   \   00000012   0x201A             MOVS     R0,#+26
   \   00000014   0x.... 0x....      BL       sys_error
    470          		return NULL;
   \   00000018   0xE009             B.N      ??tsp_get_dummy_1
    471          	}
    472          
    473          	while (( PKT_MODULE_TYPE_END != ph->module_type ) && ( PKT_MODULE_TYPE_DUMMY != ph->module_type ))
    474          	{
    475          		if (MAX_PKT_SIZE < pkt_len + PKT_MODULE_LEN_HEADER )
    476          		{
    477          			return NULL;
    478          		}
    479          		mod_len = ph->module_length;
    480          		ph = ( ( pkt_mod_header_t * ) ( ( ( char* ) ( ph ) ) + mod_len + PKT_MODULE_LEN_HEADER ) );
   \                     ??tsp_get_dummy_2: (+1)
   \   0000001A   0x7841             LDRB     R1,[R0, #+1]
   \   0000001C   0x1808             ADDS     R0,R1,R0
   \   0000001E   0x1C80             ADDS     R0,R0,#+2
    481          	} //while
   \                     ??tsp_get_dummy_0: (+1)
   \   00000020   0x7801             LDRB     R1,[R0, #+0]
   \   00000022   0x2941             CMP      R1,#+65
   \   00000024   0xBF18             IT       NE 
   \   00000026   0x29F0             CMPNE    R1,#+240
   \   00000028   0xD1F7             BNE.N    ??tsp_get_dummy_2
    482          	if (PKT_MODULE_TYPE_DUMMY == ph->module_type )
   \   0000002A   0x29F0             CMP      R1,#+240
   \   0000002C   0xD000             BEQ.N    ??tsp_get_dummy_3
    483          		return (uint8_t XDATA*)ph;
    484          	else
    485          		return NULL;
   \                     ??tsp_get_dummy_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??tsp_get_dummy_3: (+1)
   \   00000030   0xBD02             POP      {R1,PC}          ;; return
    486          }
    487          
    488          /**
    489          * tsp_new_module( module_type, module_size, *pkt_id, dst_addr)
    490          * DESC:		Reserves packet and fills main fields
    491          * PARAMS:	module_type - Uniques module/socket ID
    492          *			module_size - Size of the module content
    493          *			pkt_id		- pointer to the reference ID of the entire packet
    494          *			dst_addr	- intended final destination address for the packet/module
    495          * RETURN:	0 (NULL) when not successful, pointer to the module content otherwise
    496          */

   \                                 In section .text, align 2, keep-with-next
    497          uint8_t *tsp_new_module( uint8_t module_type, uint8_t module_size, uint8_t* ptr_pkt_id, uint16_t dst_addr)
    498          {
   \                     tsp_new_module: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    499          	if (0 == tsp_reserve_packet( module_size, ptr_pkt_id, dst_addr ))
   \   00000008   0xB2DA             UXTB     R2,R3
   \   0000000A   0x4631             MOV      R1,R6
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       tsp_reserve_packet
   \   00000012   0xB920             CBNZ.N   R0,??tsp_new_module_0
    500          	{
    501          		sys_error(11);
   \   00000014   0x200B             MOVS     R0,#+11
   \   00000016   0x.... 0x....      BL       sys_error
    502          		return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD70             POP      {R4-R6,PC}
    503          	}
    504          	{
    505          		uint8_t *mod = (uint8_t *)tsp_get_dummy(*ptr_pkt_id);
   \                     ??tsp_new_module_0: (+1)
   \   0000001E   0x7830             LDRB     R0,[R6, #+0]
   \   00000020   0x.... 0x....      BL       tsp_get_dummy
    506          		pkt_mod_header_t *ph = ( pkt_mod_header_t * )mod ;
    507          		ph->module_type = module_type;
   \   00000024   0x7004             STRB     R4,[R0, #+0]
    508          		ph->module_length = module_size;
   \   00000026   0x7045             STRB     R5,[R0, #+1]
    509          		return &(ph->content);
   \   00000028   0x1C80             ADDS     R0,R0,#+2
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    510          	}
    511          }
    512          
    513          
    514          
    515          /**
    516          *	tsp_get_module(pkt_base, mod_type) - finds the "mod_type" module in the given packet
    517          *		RETURNS: pointer (*) to the DUMMY module OR NULL value if failed
    518          */

   \                                 In section .text, align 2, keep-with-next
    519          uint8_t *tsp_get_module(uint8_t pkt_id, uint8_t mod_type)
    520          {
    521          	uint16_t pkt_base = ( uint16_t ) QBUFF_BASE ( pkt_id );
    522          	pkt_v2_t *pkt_v2  = ( pkt_v2_t* ) ( & ( buffer0[pkt_base] ) );
    523          	pkt_mod_header_t *ph = ( pkt_mod_header_t * ) ( & ( pkt_v2->data_modules ) );
   \                     tsp_get_module: (+1)
   \   00000000   0x2364             MOVS     R3,#+100
   \   00000002   0x....             LDR.N    R2,??DataTable5_1
   \   00000004   0x4358             MULS     R0,R3,R0
   \   00000006   0x1880             ADDS     R0,R0,R2
   \   00000008   0x3009             ADDS     R0,R0,#+9
    524          	uint8_t mod_len = 0;
    525          	uint8_t pkt_len = PKT_HEADER_LENGTH + 2;
   \   0000000A   0xE002             B.N      ??tsp_get_module_0
    526          
    527          	while (( PKT_MODULE_TYPE_END != ph->module_type ) && ( mod_type != ph->module_type ))
    528          	{
    529          		if (MAX_PKT_SIZE < pkt_len + PKT_MODULE_LEN_HEADER )
    530          		{
    531          			return NULL;
    532          		}
    533          		mod_len = ph->module_length;
    534          		ph = ( ( pkt_mod_header_t * ) ( ( ( char* ) ( ph ) ) + mod_len + PKT_MODULE_LEN_HEADER ) );
   \                     ??tsp_get_module_1: (+1)
   \   0000000C   0x7842             LDRB     R2,[R0, #+1]
   \   0000000E   0x1810             ADDS     R0,R2,R0
   \   00000010   0x1C80             ADDS     R0,R0,#+2
    535          	} //while
   \                     ??tsp_get_module_0: (+1)
   \   00000012   0x7802             LDRB     R2,[R0, #+0]
   \   00000014   0x2A41             CMP      R2,#+65
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x4291             CMPNE    R1,R2
   \   0000001A   0xD1F7             BNE.N    ??tsp_get_module_1
    536          	if (mod_type == ph->module_type )
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0x2000             MOVNE    R0,#+0
    537          		return (uint8_t*)ph;
    538          	else
    539          		return NULL;
   \   00000022   0x4770             BX       LR               ;; return
    540          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     tsp_cb_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     buffer0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     my_addr8_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     sequence_no_
    541          // ############################################################################
    542          // ############################################################################
    543          // Spacers
    544          // ############################################################################
    545          // ############################################################################
    546          
    547          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   tsp_distribute_modules
        32   -- Indirect call
        32   -> cs_recv_switching_request
       8   tsp_get_dummy
         8   -> sys_error
       0   tsp_get_module
       0   tsp_init
      16   tsp_new_module
        16   -> sys_error
        16   -> tsp_get_dummy
        16   -> tsp_reserve_packet
       8   tsp_receive
         8   -> tsp_distribute_modules
       8   tsp_register_port
       0   tsp_release_packet
         0   -> que_make_empty_buffer
      24   tsp_reserve_packet
        24   -> app_drop_pkt
        24   -> que_get_empty_buffer_location
       8   tsp_send_from_modules
         8   -> app_drop_pkt
         8   -> que_enQpacket
         8   -> que_make_empty_buffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
      56  tsp_cb_count
          tsp_callback_port
          tsp_callback_funcs
     116  tsp_distribute_modules
      50  tsp_get_dummy
      36  tsp_get_module
       8  tsp_init
      44  tsp_new_module
      22  tsp_receive
      32  tsp_register_port
       4  tsp_release_packet
     150  tsp_reserve_packet
      36  tsp_send_from_modules

 
  56 bytes in section .bss
 514 bytes in section .text
 
 514 bytes of CODE memory
  56 bytes of DATA memory

Errors: none
Warnings: 1
